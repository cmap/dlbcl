!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;r>e;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var i,u=n[e],o=0,a=u.length;a>o;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro="onselectstart"in e?!1:x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(0>Po){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:-1>n?Fo:Math.acos(n)}function tn(n){return n>1?Io:-1>n?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?u+(o-u)*n/60:180>n?o:240>n?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=.5>l?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&1>l?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&300>t||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>g){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=m?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=f>S?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return r-t>t-e?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;r>o;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;l>a;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=0>n?"-":"",i=(r?-n:n)+"",u=i.length;return r+(e>u?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;t>a;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,!0),c=new Tt(e,null,l,!1);l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,!1),c=new Tt(r,null,l,!0),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;c>a;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;c>a;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;l>a;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(-Uo>u||Uo>u&&-Uo>ka)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(0>s?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(0>M)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];w>S&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||Uo>E;if(!A&&k>N&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return-r>t?i|=1:t>r&&(i|=2),-r>e?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,0>g){if(h>u)return;p>u&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(0>u)){if(u/=g,0>g){if(u>p)return;u>h&&(h=u)}else if(g>0){if(h>u)return;p>u&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,0>v){if(h>u)return;p>u&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(0>u)){if(u/=v,0>v){if(u>p)return;u>h&&(h=u)}else if(v>0){if(h>u)return;p>u&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),1>p&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;e>i;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];l>o;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return i>=n&&e>=i&&u>=t&&r>=u}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){Ya>n&&(Ya=n),n>Va&&(Va=n),Za>t&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function l(){
r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||o>a*p+l*g+c*v)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:-Fo>n?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:-Fo>t?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?u>i:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:u>f;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?-Io+Uo>t&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;t>i;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;s>f;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;l>o;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(o>d||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,-1>r||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(v>p){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||r>h||i>p)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(l>y){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;t>r;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(Mr(n[e],t[e]));for(;u>e;++e)i[e]=n[e];for(;o>e;++e)i[e]=t[e];return function(n){for(e=0;a>e;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;u>e;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;c>o;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(d>v||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;c>o;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return 0>i&&(e+=i/2,i=0),0>u&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return u>o&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return.15>=u?i*=10:.35>=u?i*=5:.75>=u&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;f>c;c++)for(var h=1;s>h;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return t-.5>o*t&&(o*=t),r>=o?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){return e>=e?t[ao.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(0>y?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,n>=t?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(r>+o){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);return u>=1?(v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1):void 0}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),r>i&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),r>i&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;return l?u/l:void 0},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);return o.length?ao.quantile(o.sort(e),.5):void 0},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));return f>1?l/(f-1):void 0},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,2>u&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(0>r?0:r);r>e;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,0>e)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\x00";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>i){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;s>r;++r)g[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,i=e.length;i>r;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;u>i;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(jo>h)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;u>i;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(500>c-M){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;l>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&i>t&&(t=i),e&&i>e&&(e=i),r&&i>r&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("	","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(0>n&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=0>n?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),s>t&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(v>c*g&&c*t>v)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(v>c*g&&c*t>v)){var m=-o[1]*Zo;s>m&&(s=m)}else s>e&&(s=e),e>p&&(p=e);d?g>t?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(f>t&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>ka?(f=-(h=180),s=-(p=90)):m>Uo?p=90:-Uo>m&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];t>r;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];t>=r;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return jo>i&&(t=qa,e=Ta,r=Ra,Uo>Aa&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,jo>i)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&.234>i&&r>=-.425&&-.214>r?o:i>=.166&&.234>i&&r>=-.214&&-.115>r?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;o>t;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;o>t;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;g>p;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;g>p;++p){var b=+M(f=n[p],p),_=+x(f,p);v>b&&(v=b),d>_&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(l>a*a/y){if(v>l){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&v>l){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;w>r;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;i>l;++l)e[l]=[];for(l=0;c>l;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;i>t;++t)(r=M[t]).index=t,r.weight=0;for(t=0;c>t;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;i>t;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;c>t;++t)u[t]=+h.call(this,x[t],t);else for(t=0;c>t;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;c>t;++t)o[t]=+p.call(this,x[t],t);else for(t=0;c>t;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;i>t;++t)a[t]=+g.call(this,M[t],t);else for(t=0;i>t;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(0>s?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;y>g;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;h>p;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;r>t;++t)e=o[t],l>a?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;u>e;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;h>e;++e){for(t=0,i=0;f>t;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];f>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,c>l&&(c=l)}for(e=0;h>e;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];if(r)for(t=0;i>t;t++)n[t][e][1]/=r;else for(t=0;i>t;t++)n[t][e][1]=o}for(e=0;u>e;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;a>o;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(u>e&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(n>c&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=c>n^p?0:1;var T=g,R=g;if(Fo>h){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;c>l;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;s>f;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];return C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),r>f?(i=r,r=f):i=f),v[0]!=r||v[1]!=i?(e?a=null:o=null,v[0]=r,v[1]=i,!0):void 0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),i>u&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),i>u&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();
/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m="2.2.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isPlainObject:function(a){var b;if("object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;if(a.constructor&&!k.call(a,"constructor")&&!k.call(a.constructor.prototype||{},"isPrototypeOf"))return!1;for(b in a);return void 0===b||k.call(a,b)},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?i[j.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=d.createElement("script"),b.text=a,d.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:h.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(d=e.call(arguments,2),f=function(){return a.apply(b||this,d.concat(e.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:l}),"function"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){i["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=!!a&&"length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+M+"))|)"+L+"*\\]",O=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+N+")*)|.*)\\)|)",P=new RegExp(L+"+","g"),Q=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),R=new RegExp("^"+L+"*,"+L+"*"),S=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),T=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),U=new RegExp(O),V=new RegExp("^"+M+"$"),W={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M+"|[*])"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},X=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,$=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,_=/[+~]/,aa=/'|\\/g,ba=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),ca=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},da=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(ea){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fa(a,b,d,e){var f,h,j,k,l,o,r,s,w=b&&b.ownerDocument,x=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==x&&9!==x&&11!==x)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==x&&(o=$.exec(a)))if(f=o[1]){if(9===x){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(w&&(j=w.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(o[2])return H.apply(d,b.getElementsByTagName(a)),d;if((f=o[3])&&c.getElementsByClassName&&b.getElementsByClassName)return H.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==x)w=b,s=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(aa,"\\$&"):b.setAttribute("id",k=u),r=g(a),h=r.length,l=V.test(k)?"#"+k:"[id='"+k+"']";while(h--)r[h]=l+" "+qa(r[h]);s=r.join(","),w=_.test(a)&&oa(b.parentNode)||b}if(s)try{return H.apply(d,w.querySelectorAll(s)),d}catch(y){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(Q,"$1"),b,d,e)}function ga(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ha(a){return a[u]=!0,a}function ia(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ja(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function ka(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function la(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function na(a){return ha(function(b){return b=+b,ha(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function oa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=fa.support={},f=fa.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fa.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ia(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ia(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Z.test(n.getElementsByClassName),c.getById=ia(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return"undefined"!=typeof b.getElementsByClassName&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=Z.test(n.querySelectorAll))&&(ia(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ia(function(a){var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Z.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ia(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",O)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Z.test(o.compareDocumentPosition),t=b||Z.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return ka(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?ka(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},fa.matches=function(a,b){return fa(a,null,null,b)},fa.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(T,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fa(b,n,null,[a]).length>0},fa.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fa.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fa.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fa.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fa.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fa.selectors={cacheLength:50,createPseudo:ha,match:W,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ba,ca),a[3]=(a[3]||a[4]||a[5]||"").replace(ba,ca),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fa.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fa.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return W.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&U.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ba,ca).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fa.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(P," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fa.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ha(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ha(function(a){var b=[],c=[],d=h(a.replace(Q,"$1"));return d[u]?ha(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ha(function(a){return function(b){return fa(a,b).length>0}}),contains:ha(function(a){return a=a.replace(ba,ca),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ha(function(a){return V.test(a||"")||fa.error("unsupported lang: "+a),a=a.replace(ba,ca).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Y.test(a.nodeName)},input:function(a){return X.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:na(function(){return[0]}),last:na(function(a,b){return[b-1]}),eq:na(function(a,b,c){return[0>c?c+b:c]}),even:na(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:na(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:na(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:na(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=la(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=ma(b);function pa(){}pa.prototype=d.filters=d.pseudos,d.setFilters=new pa,g=fa.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=R.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=S.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(Q," ")}),h=h.slice(c.length));for(g in d.filter)!(e=W[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fa.error(a):z(a,i).slice(0)};function qa(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function ra(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j,k=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(j=b[u]||(b[u]={}),i=j[b.uniqueID]||(j[b.uniqueID]={}),(h=i[d])&&h[0]===w&&h[1]===f)return k[2]=h[2];if(i[d]=k,k[2]=a(b,c,g))return!0}}}function sa(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ta(a,b,c){for(var d=0,e=b.length;e>d;d++)fa(a,b[d],c);return c}function ua(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function va(a,b,c,d,e,f){return d&&!d[u]&&(d=va(d)),e&&!e[u]&&(e=va(e,f)),ha(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ta(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ua(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ua(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ua(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function wa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ra(function(a){return a===b},h,!0),l=ra(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[ra(sa(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return va(i>1&&sa(m),i>1&&qa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(Q,"$1"),c,e>i&&wa(a.slice(i,e)),f>e&&wa(a=a.slice(e)),f>e&&qa(a))}m.push(c)}return sa(m)}function xa(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=F.call(i));u=ua(u)}H.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&fa.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ha(f):f}return h=fa.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xa(e,d)),f.selector=a}return f},i=fa.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ba,ca),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=W.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ba,ca),_.test(j[0].type)&&oa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qa(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,!b||_.test(a)&&oa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ia(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ia(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ja("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ia(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ja("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ia(function(a){return null==a.getAttribute("disabled")})||ja(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fa}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.uniqueSort=n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},v=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},w=n.expr.match.needsContext,x=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,y=/^.[^:#\[\.,]*$/;function z(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(y.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return h.call(b,a)>-1!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(z(this,a||[],!1))},not:function(a){return this.pushStack(z(this,a||[],!0))},is:function(a){return!!z(this,"string"==typeof a&&w.test(a)?n(a):a||[],!1).length}});var A,B=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=n.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||A,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:B.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),x.test(e[1])&&n.isPlainObject(b))for(e in b)n.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&f.parentNode&&(this.length=1,this[0]=f),this.context=d,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?void 0!==c.ready?c.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};C.prototype=n.fn,A=n(d);var D=/^(?:parents|prev(?:Until|All))/,E={children:!0,contents:!0,next:!0,prev:!0};n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=w.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?h.call(n(a),this[0]):h.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.uniqueSort(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function F(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return u(a,"parentNode")},parentsUntil:function(a,b,c){return u(a,"parentNode",c)},next:function(a){return F(a,"nextSibling")},prev:function(a){return F(a,"previousSibling")},nextAll:function(a){return u(a,"nextSibling")},prevAll:function(a){return u(a,"previousSibling")},nextUntil:function(a,b,c){return u(a,"nextSibling",c)},prevUntil:function(a,b,c){return u(a,"previousSibling",c)},siblings:function(a){return v((a.parentNode||{}).firstChild,a)},children:function(a){return v(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(E[a]||n.uniqueSort(e),D.test(a)&&e.reverse()),this.pushStack(e)}});var G=/\S+/g;function H(a){var b={};return n.each(a.match(G)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?H(a):n.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){n.each(b,function(b,c){n.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==n.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return n.each(arguments,function(a,b){var c;while((c=n.inArray(b,f,c))>-1)f.splice(c,1),h>=c&&h--}),this},has:function(a){return a?n.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().progress(c.notify).done(c.resolve).fail(c.reject):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=e.call(arguments),d=c.length,f=1!==d||a&&n.isFunction(a.promise)?d:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?e.call(arguments):d,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(d>1)for(i=new Array(d),j=new Array(d),k=new Array(d);d>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().progress(h(b,j,i)).done(h(b,k,c)).fail(g.reject):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(d,[n]),n.fn.triggerHandler&&(n(d).triggerHandler("ready"),n(d).off("ready"))))}});function J(){d.removeEventListener("DOMContentLoaded",J),a.removeEventListener("load",J),n.ready()}n.ready.promise=function(b){return I||(I=n.Deferred(),"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(n.ready):(d.addEventListener("DOMContentLoaded",J),a.addEventListener("load",J))),I.promise(b)},n.ready.promise();var K=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)K(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},L=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function M(){this.expando=n.expando+M.uid++}M.uid=1,M.prototype={register:function(a,b){var c=b||{};return a.nodeType?a[this.expando]=c:Object.defineProperty(a,this.expando,{value:c,writable:!0,configurable:!0}),a[this.expando]},cache:function(a){if(!L(a))return{};var b=a[this.expando];return b||(b={},L(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[b]=c;else for(d in b)e[d]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=a[this.expando];if(void 0!==f){if(void 0===b)this.register(a);else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in f?d=[b,e]:(d=e,d=d in f?[d]:d.match(G)||[])),c=d.length;while(c--)delete f[d[c]]}(void 0===b||n.isEmptyObject(f))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!n.isEmptyObject(b)}};var N=new M,O=new M,P=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Q=/[A-Z]/g;function R(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Q,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:P.test(c)?n.parseJSON(c):c;
}catch(e){}O.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return O.hasData(a)||N.hasData(a)},data:function(a,b,c){return O.access(a,b,c)},removeData:function(a,b){O.remove(a,b)},_data:function(a,b,c){return N.access(a,b,c)},_removeData:function(a,b){N.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=O.get(f),1===f.nodeType&&!N.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),R(f,d,e[d])));N.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){O.set(this,a)}):K(this,function(b){var c,d;if(f&&void 0===b){if(c=O.get(f,a)||O.get(f,a.replace(Q,"-$&").toLowerCase()),void 0!==c)return c;if(d=n.camelCase(a),c=O.get(f,d),void 0!==c)return c;if(c=R(f,d,void 0),void 0!==c)return c}else d=n.camelCase(a),this.each(function(){var c=O.get(this,d);O.set(this,d,b),a.indexOf("-")>-1&&void 0!==c&&O.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){O.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=N.get(a,b),c&&(!d||n.isArray(c)?d=N.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return N.get(a,c)||N.access(a,c,{empty:n.Callbacks("once memory").add(function(){N.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=N.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),U=["Top","Right","Bottom","Left"],V=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)};function W(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return n.css(a,b,"")},i=h(),j=c&&c[3]||(n.cssNumber[b]?"":"px"),k=(n.cssNumber[b]||"px"!==j&&+i)&&T.exec(n.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,n.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var X=/^(?:checkbox|radio)$/i,Y=/<([\w:-]+)/,Z=/^$|\/(?:java|ecma)script/i,$={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};$.optgroup=$.option,$.tbody=$.tfoot=$.colgroup=$.caption=$.thead,$.th=$.td;function _(a,b){var c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function aa(a,b){for(var c=0,d=a.length;d>c;c++)N.set(a[c],"globalEval",!b||N.get(b[c],"globalEval"))}var ba=/<|&#?\w+;/;function ca(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],o=0,p=a.length;p>o;o++)if(f=a[o],f||0===f)if("object"===n.type(f))n.merge(m,f.nodeType?[f]:f);else if(ba.test(f)){g=g||l.appendChild(b.createElement("div")),h=(Y.exec(f)||["",""])[1].toLowerCase(),i=$[h]||$._default,g.innerHTML=i[1]+n.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;n.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",o=0;while(f=m[o++])if(d&&n.inArray(f,d)>-1)e&&e.push(f);else if(j=n.contains(f.ownerDocument,f),g=_(l.appendChild(f),"script"),j&&aa(g),c){k=0;while(f=g[k++])Z.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),l.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var da=/^key/,ea=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,fa=/^([^.]*)(?:\.(.+)|)/;function ga(){return!0}function ha(){return!1}function ia(){try{return d.activeElement}catch(a){}}function ja(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ja(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=ha;else if(!e)return a;return 1===f&&(g=e,e=function(a){return n().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=n.guid++)),a.each(function(){n.event.add(this,b,e,d,c)})}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=N.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return"undefined"!=typeof n&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(G)||[""],j=b.length;while(j--)h=fa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=N.hasData(a)&&N.get(a);if(r&&(i=r.events)){b=(b||"").match(G)||[""],j=b.length;while(j--)if(h=fa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&N.remove(a,"handle events")}},dispatch:function(a){a=n.event.fix(a);var b,c,d,f,g,h=[],i=e.call(arguments),j=(N.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())a.rnamespace&&!a.rnamespace.test(g.namespace)||(a.handleObj=g,a.data=g.data,d=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==d&&(a.result=d)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&("click"!==a.type||isNaN(a.button)||a.button<1))for(;i!==this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>-1:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,e,f,g=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||d,e=c.documentElement,f=c.body,a.pageX=b.clientX+(e&&e.scrollLeft||f&&f.scrollLeft||0)-(e&&e.clientLeft||f&&f.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||f&&f.scrollTop||0)-(e&&e.clientTop||f&&f.clientTop||0)),a.which||void 0===g||(a.which=1&g?1:2&g?3:4&g?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,e,f=a.type,g=a,h=this.fixHooks[f];h||(this.fixHooks[f]=h=ea.test(f)?this.mouseHooks:da.test(f)?this.keyHooks:{}),e=h.props?this.props.concat(h.props):this.props,a=new n.Event(g),b=e.length;while(b--)c=e[b],a[c]=g[c];return a.target||(a.target=d),3===a.target.nodeType&&(a.target=a.target.parentNode),h.filter?h.filter(a,g):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==ia()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===ia()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ga:ha):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={constructor:n.Event,isDefaultPrevented:ha,isPropagationStopped:ha,isImmediatePropagationStopped:ha,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ga,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ga,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ga,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||n.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),n.fn.extend({on:function(a,b,c,d){return ja(this,a,b,c,d)},one:function(a,b,c,d){return ja(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=ha),this.each(function(){n.event.remove(this,a,c,b)})}});var ka=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,la=/<script|<style|<link/i,ma=/checked\s*(?:[^=]|=\s*.checked.)/i,na=/^true\/(.*)/,oa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function pa(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function qa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function ra(a){var b=na.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function sa(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(N.hasData(a)&&(f=N.access(a),g=N.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}O.hasData(a)&&(h=O.access(a),i=n.extend({},h),O.set(b,i))}}function ta(a,b){var c=b.nodeName.toLowerCase();"input"===c&&X.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function ua(a,b,c,d){b=f.apply([],b);var e,g,h,i,j,k,m=0,o=a.length,p=o-1,q=b[0],r=n.isFunction(q);if(r||o>1&&"string"==typeof q&&!l.checkClone&&ma.test(q))return a.each(function(e){var f=a.eq(e);r&&(b[0]=q.call(this,e,f.html())),ua(f,b,c,d)});if(o&&(e=ca(b,a[0].ownerDocument,!1,a,d),g=e.firstChild,1===e.childNodes.length&&(e=g),g||d)){for(h=n.map(_(e,"script"),qa),i=h.length;o>m;m++)j=e,m!==p&&(j=n.clone(j,!0,!0),i&&n.merge(h,_(j,"script"))),c.call(a[m],j,m);if(i)for(k=h[h.length-1].ownerDocument,n.map(h,ra),m=0;i>m;m++)j=h[m],Z.test(j.type||"")&&!N.access(j,"globalEval")&&n.contains(k,j)&&(j.src?n._evalUrl&&n._evalUrl(j.src):n.globalEval(j.textContent.replace(oa,"")))}return a}function va(a,b,c){for(var d,e=b?n.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||n.cleanData(_(d)),d.parentNode&&(c&&n.contains(d.ownerDocument,d)&&aa(_(d,"script")),d.parentNode.removeChild(d));return a}n.extend({htmlPrefilter:function(a){return a.replace(ka,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=_(h),f=_(a),d=0,e=f.length;e>d;d++)ta(f[d],g[d]);if(b)if(c)for(f=f||_(a),g=g||_(h),d=0,e=f.length;e>d;d++)sa(f[d],g[d]);else sa(a,h);return g=_(h,"script"),g.length>0&&aa(g,!i&&_(a,"script")),h},cleanData:function(a){for(var b,c,d,e=n.event.special,f=0;void 0!==(c=a[f]);f++)if(L(c)){if(b=c[N.expando]){if(b.events)for(d in b.events)e[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);c[N.expando]=void 0}c[O.expando]&&(c[O.expando]=void 0)}}}),n.fn.extend({domManip:ua,detach:function(a){return va(this,a,!0)},remove:function(a){return va(this,a)},text:function(a){return K(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return ua(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=pa(this,a);b.appendChild(a)}})},prepend:function(){return ua(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=pa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return ua(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return ua(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(_(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return K(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!la.test(a)&&!$[(Y.exec(a)||["",""])[1].toLowerCase()]){a=n.htmlPrefilter(a);try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(_(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return ua(this,arguments,function(b){var c=this.parentNode;n.inArray(this,a)<0&&(n.cleanData(_(this)),c&&c.replaceChild(b,this))},a)}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),f=e.length-1,h=0;f>=h;h++)c=h===f?this:this.clone(!0),n(e[h])[b](c),g.apply(d,c.get());return this.pushStack(d)}});var wa,xa={HTML:"block",BODY:"block"};function ya(a,b){var c=n(b.createElement(a)).appendTo(b.body),d=n.css(c[0],"display");return c.detach(),d}function za(a){var b=d,c=xa[a];return c||(c=ya(a,b),"none"!==c&&c||(wa=(wa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=wa[0].contentDocument,b.write(),b.close(),c=ya(a,b),wa.detach()),xa[a]=c),c}var Aa=/^margin/,Ba=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ca=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)},Da=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e},Ea=d.documentElement;!function(){var b,c,e,f,g=d.createElement("div"),h=d.createElement("div");if(h.style){h.style.backgroundClip="content-box",h.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===h.style.backgroundClip,g.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",g.appendChild(h);function i(){h.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",h.innerHTML="",Ea.appendChild(g);var d=a.getComputedStyle(h);b="1%"!==d.top,f="2px"===d.marginLeft,c="4px"===d.width,h.style.marginRight="50%",e="4px"===d.marginRight,Ea.removeChild(g)}n.extend(l,{pixelPosition:function(){return i(),b},boxSizingReliable:function(){return null==c&&i(),c},pixelMarginRight:function(){return null==c&&i(),e},reliableMarginLeft:function(){return null==c&&i(),f},reliableMarginRight:function(){var b,c=h.appendChild(d.createElement("div"));return c.style.cssText=h.style.cssText="-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",h.style.width="1px",Ea.appendChild(g),b=!parseFloat(a.getComputedStyle(c).marginRight),Ea.removeChild(g),h.removeChild(c),b}})}}();function Fa(a,b,c){var d,e,f,g,h=a.style;return c=c||Ca(a),g=c?c.getPropertyValue(b)||c[b]:void 0,""!==g&&void 0!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),c&&!l.pixelMarginRight()&&Ba.test(g)&&Aa.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f),void 0!==g?g+"":g}function Ga(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Ha=/^(none|table(?!-c[ea]).+)/,Ia={position:"absolute",visibility:"hidden",display:"block"},Ja={letterSpacing:"0",fontWeight:"400"},Ka=["Webkit","O","Moz","ms"],La=d.createElement("div").style;function Ma(a){if(a in La)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ka.length;while(c--)if(a=Ka[c]+b,a in La)return a}function Na(a,b,c){var d=T.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Oa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+U[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+U[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+U[f]+"Width",!0,e))):(g+=n.css(a,"padding"+U[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+U[f]+"Width",!0,e)));return g}function Pa(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ca(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Fa(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ba.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Oa(a,b,c||(g?"border":"content"),d,f)+"px"}function Qa(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=N.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&V(d)&&(f[g]=N.access(d,"olddisplay",za(d.nodeName)))):(e=V(d),"none"===c&&e||N.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Fa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Ma(h)||h),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=T.exec(c))&&e[1]&&(c=W(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(n.cssNumber[h]?"":"px")),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Ma(h)||h),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Fa(a,b,d)),"normal"===e&&b in Ja&&(e=Ja[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?Ha.test(n.css(a,"display"))&&0===a.offsetWidth?Da(a,Ia,function(){return Pa(a,b,d)}):Pa(a,b,d):void 0},set:function(a,c,d){var e,f=d&&Ca(a),g=d&&Oa(a,b,d,"border-box"===n.css(a,"boxSizing",!1,f),f);return g&&(e=T.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=n.css(a,b)),Na(a,c,g)}}}),n.cssHooks.marginLeft=Ga(l.reliableMarginLeft,function(a,b){return b?(parseFloat(Fa(a,"marginLeft"))||a.getBoundingClientRect().left-Da(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px":void 0}),n.cssHooks.marginRight=Ga(l.reliableMarginRight,function(a,b){return b?Da(a,{display:"inline-block"},Fa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+U[d]+b]=f[d]||f[d-2]||f[0];return e}},Aa.test(a)||(n.cssHooks[a+b].set=Na)}),n.fn.extend({css:function(a,b){return K(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Ca(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Qa(this,!0)},hide:function(){return Qa(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){V(this)?n(this).show():n(this).hide()})}});function Ra(a,b,c,d,e){return new Ra.prototype.init(a,b,c,d,e)}n.Tween=Ra,Ra.prototype={constructor:Ra,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||n.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ra.propHooks[this.prop];return a&&a.get?a.get(this):Ra.propHooks._default.get(this)},run:function(a){var b,c=Ra.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ra.propHooks._default.set(this),this}},Ra.prototype.init.prototype=Ra.prototype,Ra.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[n.cssProps[a.prop]]&&!n.cssHooks[a.prop]?a.elem[a.prop]=a.now:n.style(a.elem,a.prop,a.now+a.unit)}}},Ra.propHooks.scrollTop=Ra.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},n.fx=Ra.prototype.init,n.fx.step={};var Sa,Ta,Ua=/^(?:toggle|show|hide)$/,Va=/queueHooks$/;function Wa(){return a.setTimeout(function(){Sa=void 0}),Sa=n.now()}function Xa(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=U[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ya(a,b,c){for(var d,e=(_a.tweeners[b]||[]).concat(_a.tweeners["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Za(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&V(a),q=N.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?N.get(a,"olddisplay")||za(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Ua.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?za(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=N.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;N.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ya(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function $a(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function _a(a,b,c){var d,e,f=0,g=_a.prefilters.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Sa||Wa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{},easing:n.easing._default},c),originalProperties:b,originalOptions:c,startTime:Sa||Wa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for($a(k,j.opts.specialEasing);g>f;f++)if(d=_a.prefilters[f].call(j,a,k,j.opts))return n.isFunction(d.stop)&&(n._queueHooks(j.elem,j.opts.queue).stop=n.proxy(d.stop,d)),d;return n.map(k,Ya,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(_a,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return W(c.elem,a,T.exec(b),c),c}]},tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.match(G);for(var c,d=0,e=a.length;e>d;d++)c=a[d],_a.tweeners[c]=_a.tweeners[c]||[],_a.tweeners[c].unshift(b)},prefilters:[Za],prefilter:function(a,b){b?_a.prefilters.unshift(a):_a.prefilters.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(V).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=_a(this,n.extend({},a),f);(e||N.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=N.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Va.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=N.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Xa(b,!0),a,d,e)}}),n.each({slideDown:Xa("show"),slideUp:Xa("hide"),slideToggle:Xa("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Sa=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Sa=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ta||(Ta=a.setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){a.clearInterval(Ta),Ta=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(b,c){return b=n.fx?n.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",l.checkOn=""!==a.value,l.optSelected=c.selected,b.disabled=!0,l.optDisabled=!c.disabled,a=d.createElement("input"),a.value="t",a.type="radio",l.radioValue="t"===a.value}();var ab,bb=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return K(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),e=n.attrHooks[b]||(n.expr.match.bool.test(b)?ab:void 0)),void 0!==c?null===c?void n.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=n.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(G);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)}}),ab={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=bb[b]||n.find.attr;bb[b]=function(a,b,d){var e,f;return d||(f=bb[b],bb[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,bb[b]=f),e}});var cb=/^(?:input|select|textarea|button)$/i,db=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return K(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&n.isXMLDoc(a)||(b=n.propFix[b]||b,e=n.propHooks[b]),
void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):cb.test(a.nodeName)||db.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var eb=/[\t\r\n\f]/g;function fb(a){return a.getAttribute&&a.getAttribute("class")||""}n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,fb(this)))});if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=fb(c),d=1===c.nodeType&&(" "+e+" ").replace(eb," ")){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=n.trim(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,fb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=fb(c),d=1===c.nodeType&&(" "+e+" ").replace(eb," ")){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=n.trim(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):n.isFunction(a)?this.each(function(c){n(this).toggleClass(a.call(this,c,fb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=n(this),f=a.match(G)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=fb(this),b&&N.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":N.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+fb(c)+" ").replace(eb," ").indexOf(b)>-1)return!0;return!1}});var gb=/\r/g,hb=/[\x20\t\r\n\f]+/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(gb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a)).replace(hb," ")}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],(c.selected||i===e)&&(l.optDisabled?!c.disabled:null===c.getAttribute("disabled"))&&(!c.parentNode.disabled||!n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(n.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>-1:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var ib=/^(?:focusinfocus|focusoutblur)$/;n.extend(n.event,{trigger:function(b,c,e,f){var g,h,i,j,l,m,o,p=[e||d],q=k.call(b,"type")?b.type:b,r=k.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!ib.test(q+n.event.triggered)&&(q.indexOf(".")>-1&&(r=q.split("."),q=r.shift(),r.sort()),l=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=r.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},f||!o.trigger||o.trigger.apply(e,c)!==!1)){if(!f&&!o.noBubble&&!n.isWindow(e)){for(j=o.delegateType||q,ib.test(j+q)||(h=h.parentNode);h;h=h.parentNode)p.push(h),i=h;i===(e.ownerDocument||d)&&p.push(i.defaultView||i.parentWindow||a)}g=0;while((h=p[g++])&&!b.isPropagationStopped())b.type=g>1?j:o.bindType||q,m=(N.get(h,"events")||{})[b.type]&&N.get(h,"handle"),m&&m.apply(h,c),m=l&&h[l],m&&m.apply&&L(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=q,f||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!L(e)||l&&n.isFunction(e[q])&&!n.isWindow(e)&&(i=e[l],i&&(e[l]=null),n.event.triggered=q,e[q](),n.event.triggered=void 0,i&&(e[l]=i)),b.result}},simulate:function(a,b,c){var d=n.extend(new n.Event,c,{type:a,isSimulated:!0});n.event.trigger(d,null,b)}}),n.fn.extend({trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),l.focusin="onfocusin"in a,l.focusin||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a))};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=N.access(d,b);e||d.addEventListener(a,c,!0),N.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=N.access(d,b)-1;e?N.access(d,b,e):(d.removeEventListener(a,c,!0),N.remove(d,b))}}});var jb=a.location,kb=n.now(),lb=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var mb=/#.*$/,nb=/([?&])_=[^&]*/,ob=/^(.*?):[ \t]*([^\r\n]*)$/gm,pb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,qb=/^(?:GET|HEAD)$/,rb=/^\/\//,sb={},tb={},ub="*/".concat("*"),vb=d.createElement("a");vb.href=jb.href;function wb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(G)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function xb(a,b,c,d){var e={},f=a===tb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function yb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function zb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Ab(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:jb.href,type:"GET",isLocal:pb.test(jb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":ub,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?yb(yb(a,n.ajaxSettings),b):yb(n.ajaxSettings,a)},ajaxPrefilter:wb(sb),ajaxTransport:wb(tb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m=n.ajaxSetup({},c),o=m.context||m,p=m.context&&(o.nodeType||o.jquery)?n(o):n.event,q=n.Deferred(),r=n.Callbacks("once memory"),s=m.statusCode||{},t={},u={},v=0,w="canceled",x={readyState:0,getResponseHeader:function(a){var b;if(2===v){if(!h){h={};while(b=ob.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===v?g:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return v||(a=u[c]=u[c]||a,t[a]=b),this},overrideMimeType:function(a){return v||(m.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>v)for(b in a)s[b]=[s[b],a[b]];else x.always(a[x.status]);return this},abort:function(a){var b=a||w;return e&&e.abort(b),z(0,b),this}};if(q.promise(x).complete=r.add,x.success=x.done,x.error=x.fail,m.url=((b||m.url||jb.href)+"").replace(mb,"").replace(rb,jb.protocol+"//"),m.type=c.method||c.type||m.method||m.type,m.dataTypes=n.trim(m.dataType||"*").toLowerCase().match(G)||[""],null==m.crossDomain){j=d.createElement("a");try{j.href=m.url,j.href=j.href,m.crossDomain=vb.protocol+"//"+vb.host!=j.protocol+"//"+j.host}catch(y){m.crossDomain=!0}}if(m.data&&m.processData&&"string"!=typeof m.data&&(m.data=n.param(m.data,m.traditional)),xb(sb,m,c,x),2===v)return x;k=n.event&&m.global,k&&0===n.active++&&n.event.trigger("ajaxStart"),m.type=m.type.toUpperCase(),m.hasContent=!qb.test(m.type),f=m.url,m.hasContent||(m.data&&(f=m.url+=(lb.test(f)?"&":"?")+m.data,delete m.data),m.cache===!1&&(m.url=nb.test(f)?f.replace(nb,"$1_="+kb++):f+(lb.test(f)?"&":"?")+"_="+kb++)),m.ifModified&&(n.lastModified[f]&&x.setRequestHeader("If-Modified-Since",n.lastModified[f]),n.etag[f]&&x.setRequestHeader("If-None-Match",n.etag[f])),(m.data&&m.hasContent&&m.contentType!==!1||c.contentType)&&x.setRequestHeader("Content-Type",m.contentType),x.setRequestHeader("Accept",m.dataTypes[0]&&m.accepts[m.dataTypes[0]]?m.accepts[m.dataTypes[0]]+("*"!==m.dataTypes[0]?", "+ub+"; q=0.01":""):m.accepts["*"]);for(l in m.headers)x.setRequestHeader(l,m.headers[l]);if(m.beforeSend&&(m.beforeSend.call(o,x,m)===!1||2===v))return x.abort();w="abort";for(l in{success:1,error:1,complete:1})x[l](m[l]);if(e=xb(tb,m,c,x)){if(x.readyState=1,k&&p.trigger("ajaxSend",[x,m]),2===v)return x;m.async&&m.timeout>0&&(i=a.setTimeout(function(){x.abort("timeout")},m.timeout));try{v=1,e.send(t,z)}catch(y){if(!(2>v))throw y;z(-1,y)}}else z(-1,"No Transport");function z(b,c,d,h){var j,l,t,u,w,y=c;2!==v&&(v=2,i&&a.clearTimeout(i),e=void 0,g=h||"",x.readyState=b>0?4:0,j=b>=200&&300>b||304===b,d&&(u=zb(m,x,d)),u=Ab(m,u,x,j),j?(m.ifModified&&(w=x.getResponseHeader("Last-Modified"),w&&(n.lastModified[f]=w),w=x.getResponseHeader("etag"),w&&(n.etag[f]=w)),204===b||"HEAD"===m.type?y="nocontent":304===b?y="notmodified":(y=u.state,l=u.data,t=u.error,j=!t)):(t=y,!b&&y||(y="error",0>b&&(b=0))),x.status=b,x.statusText=(c||y)+"",j?q.resolveWith(o,[l,y,x]):q.rejectWith(o,[x,y,t]),x.statusCode(s),s=void 0,k&&p.trigger(j?"ajaxSuccess":"ajaxError",[x,m,j?l:t]),r.fireWith(o,[x,y]),k&&(p.trigger("ajaxComplete",[x,m]),--n.active||n.event.trigger("ajaxStop")))}return x},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax(n.extend({url:a,type:b,dataType:e,data:c,success:d},n.isPlainObject(a)&&a))}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return n.isFunction(a)?this.each(function(b){n(this).wrapInner(a.call(this,b))}):this.each(function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return!n.expr.filters.visible(a)},n.expr.filters.visible=function(a){return a.offsetWidth>0||a.offsetHeight>0||a.getClientRects().length>0};var Bb=/%20/g,Cb=/\[\]$/,Db=/\r?\n/g,Eb=/^(?:submit|button|image|reset|file)$/i,Fb=/^(?:input|select|textarea|keygen)/i;function Gb(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||Cb.test(a)?d(a,e):Gb(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Gb(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Gb(c,a[c],b,e);return d.join("&").replace(Bb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Fb.test(this.nodeName)&&!Eb.test(a)&&(this.checked||!X.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(Db,"\r\n")}}):{name:b.name,value:c.replace(Db,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Hb={0:200,1223:204},Ib=n.ajaxSettings.xhr();l.cors=!!Ib&&"withCredentials"in Ib,l.ajax=Ib=!!Ib,n.ajaxTransport(function(b){var c,d;return l.cors||Ib&&!b.crossDomain?{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Hb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=n("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Jb=[],Kb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Jb.pop()||n.expando+"_"+kb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Kb.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Kb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Kb,"$1"+e):b.jsonp!==!1&&(b.url+=(lb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?n(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Jb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||d;var e=x.exec(a),f=!c&&[];return e?[b.createElement(e[1])]:(e=ca([a],b,f),f&&f.length&&n(f).remove(),n.merge([],e.childNodes))};var Lb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Lb)return Lb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};function Mb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,n.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(e=d.getBoundingClientRect(),c=Mb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ea})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;n.fn[a]=function(d){return K(this,function(a,d,e){var f=Mb(a);return void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=Ga(l.pixelPosition,function(a,c){return c?(c=Fa(a,b),Ba.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return K(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)},size:function(){return this.length}}),n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Nb=a.jQuery,Ob=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Ob),b&&a.jQuery===n&&(a.jQuery=Nb),n},b||(a.jQuery=a.$=n),n});

/*! jQuery UI - v1.12.1 - 2017-03-02
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, focusable.js, form-reset-mixin.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/draggable.js, widgets/resizable.js, widgets/selectable.js, widgets/sortable.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/dialog.js, widgets/menu.js, widgets/mouse.js, effect.js, effects/effect-scale.js, effects/effect-size.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}t.ui=t.ui||{},t.ui.version="1.12.1";var i=0,s=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},l=e.split(".")[0];e=e.split(".")[1];var h=l+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][h.toLowerCase()]=function(e){return!!t.data(e,h)},t[l]=t[l]||{},n=t[l][e],o=t[l][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:l,widgetName:e,widgetFullName:h}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,n,o=s.call(arguments,1),a=0,r=o.length;r>a;a++)for(i in o[a])n=o[a][i],o[a].hasOwnProperty(i)&&void 0!==n&&(e[i]=t.isPlainObject(n)?t.isPlainObject(e[i])?t.widget.extend({},e[i],n):t.widget.extend({},n):n);return e},t.widget.bridge=function(e,i){var n=i.prototype.widgetFullName||e;t.fn[e]=function(o){var a="string"==typeof o,r=s.call(arguments,1),l=this;return a?this.length||"instance"!==o?this.each(function(){var i,s=t.data(this,n);return"instance"===o?(l=s,!1):s?t.isFunction(s[o])&&"_"!==o.charAt(0)?(i=s[o].apply(s,r),i!==s&&void 0!==i?(l=i&&i.jquery?l.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+o+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+o+"'")}):l=void 0:(r.length&&(o=t.widget.extend.apply(null,[o].concat(r))),this.each(function(){var e=t.data(this,n);e?(e.option(o||{}),e._init&&e._init()):t.data(this,n,new i(o,this))})),l}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var l=s.match(/^([\w:-]*)\s*(.*)$/),h=l[1]+o.eventNamespace,c=l[2];c?n.on(h,c,r):i.on(h,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,l=/top|center|bottom/,h=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):l.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=l.test(i[1])?i[1]:"center",t=h.exec(i[0]),e=h.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,l=t(this),h=l.outerWidth(),c=l.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=h+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),T=e(k.my,l.outerWidth(),l.outerHeight());"right"===n.my[0]?D.left-=h:"center"===n.my[0]&&(D.left-=h/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=T[0],D.top+=T[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:h,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+T[0],u[1]+T[1]],my:n.my,at:n.at,within:b,elem:l})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-h,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:l,left:D.left,top:D.top,width:h,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};h>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),l.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,l=n-r,h=r+e.collisionWidth-a-n;e.collisionWidth>a?l>0&&0>=h?(i=t.left+l+e.collisionWidth-a-n,t.left+=l-i):t.left=h>0&&0>=l?n:l>h?n+a-e.collisionWidth:n:l>0?t.left+=l:h>0?t.left-=h:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,l=n-r,h=r+e.collisionHeight-a-n;e.collisionHeight>a?l>0&&0>=h?(i=t.top+l+e.collisionHeight-a-n,t.top+=l-i):t.top=h>0&&0>=l?n:l>h?n+a-e.collisionHeight:n:l>0?t.top+=l:h>0?t.top-=h:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,l=n.isWindow?n.scrollLeft:n.offset.left,h=t.left-e.collisionPosition.marginLeft,c=h-l,u=h+e.collisionWidth-r-l,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-l,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,l=n.isWindow?n.scrollTop:n.offset.top,h=t.top-e.collisionPosition.marginTop,c=h-l,u=h+e.collisionHeight-r-l,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-l,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}}),t.ui.focusable=function(i,s){var n,o,a,r,l,h=i.nodeName.toLowerCase();return"area"===h?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(h)?(r=!i.disabled,r&&(l=t(i).closest("fieldset")[0],l&&(r=!l.disabled))):r="a"===h?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var n=!1;t(document).on("mouseup",function(){n=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!n){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,o="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!o&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),n=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,n=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),l=t.pageX,h=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(l=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(h=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(l=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(h=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((h-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,h=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((l-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,l=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(l=this.originalPageX),"x"===a.axis&&(h=this.originalPageY)),{top:h-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:l-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");
i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,l,h,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)l=s.snapElements[d].left-s.margins.left,h=l+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,l-g>_||m>h+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(l-_),r=g>=Math.abs(h-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(l-m),r=g>=Math.abs(h-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,l=this._change[o];return this._updatePrevProperties(),l?(i=l.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,l,h=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,l=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,h.animate||this.element.css(t.extend(a,{top:l,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!h.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,l=this.originalPosition.top+this.originalSize.height,h=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&h&&(t.left=r-e.minWidth),s&&h&&(t.left=r-e.maxWidth),a&&c&&(t.top=l-e.minHeight),n&&c&&(t.top=l-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,l={width:i.size.width-r,height:i.size.height-a},h=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(l,c&&h?{top:c,left:h}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,l=t(this).resizable("instance"),h=l.options,c=l.element,u=h.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(l.containerElement=t(d),/document/.test(u)||u===document?(l.containerOffset={left:0,top:0},l.containerPosition={left:0,top:0},l.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=l._num(e.css("padding"+s))}),l.containerOffset=e.offset(),l.containerPosition=e.position(),l.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=l.containerOffset,n=l.containerSize.height,o=l.containerSize.width,a=l._hasScroll(d,"left")?d.scrollWidth:o,r=l._hasScroll(d)?d.scrollHeight:n,l.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,l=a.containerOffset,h=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=l),h.left<(a._helper?l.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-l.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?l.left:0),h.top<(a._helper?l.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-l.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?l.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-l.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-l.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),l=a.outerWidth()-e.sizeDiff.width,h=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:l,height:h}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:l,height:h})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,l="number"==typeof s.grid?[s.grid,s.grid]:s.grid,h=l[0]||1,c=l[1]||1,u=Math.round((n.width-o.width)/h)*h,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=l,_&&(p+=h),v&&(f+=c),g&&(p-=h),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-h)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-h>0?(i.size.width=p,i.position.left=a.left-u):(p=h-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,l=e.pageY;return o>r&&(i=r,r=o,o=i),a>l&&(i=l,l=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:l-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),h=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?h=!(c.left>r||o>c.right||c.top>l||a>c.bottom):"fit"===n.tolerance&&(h=c.left>o&&r>c.right&&c.top>a&&l>c.bottom),h?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));
return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,l=r+t.height,h=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+h>r&&l>s+h,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&l>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],l=[],h=this._connectWith();if(h&&e)for(s=h.length-1;s>=0;s--)for(o=t(h[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&l.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(l.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=l.length-1;s>=0;s--)l[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,l,h,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,h=r.length;h>s;s++)l=t(r[s]),l.data(this.widgetName+"-item",a),c.push({item:l,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,l,h,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(l=this.items[s].item.offset()[a],h=!1,e[u]-l>this.items[s][r]/2&&(h=!0),n>Math.abs(e[u]-l)&&(n=Math.abs(e[u]-l),o=this.items[s],this.direction=h?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,l=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():l?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():l?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,l=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=l.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=l.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)
}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var o=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var l=n[s]("widget");t.data(l[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(l[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var a=i.options.classes[n]||"";a=t.trim(a.replace(o,"")),s[n]=(a+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),l=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(l>=0?"+":"")+l,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null
}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog;var a="ui-effects-",r="ui-effects-style",l="ui-effects-animated",h=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=h(),n=s._rgba=[];return i=i.toLowerCase(),f(l,function(t,o){var a,r=o.re.exec(i),l=r&&o.parse(r),h=o.space||"rgba";return l?(a=s[h](l),s[c[h].cache]=a[c[h].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,l=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],h=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=h.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),h.fn=t.extend(h.prototype,{parse:function(n,a,r,l){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,l],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof h?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=h(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=h(t),n=s._space(),o=c[n],a=0===this.alpha()?h("transparent"):this,r=a[o.cache]||o.to(a._rgba),l=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],h=s[o],c=u[n.type]||{};null!==h&&(null===a?l[o]=h:(c.mod&&(h-a>c.mod/2?a+=c.mod:a-h>c.mod/2&&(a-=c.mod)),l[o]=i((h-a)*e+a,n)))}),this[n](l)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=h(e)._rgba;return h(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),h.fn.parse.prototype=h.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),l=Math.min(s,n,o),h=r-l,c=r+l,u=.5*c;return e=l===r?0:s===r?60*(n-o)/h+360:n===r?60*(o-s)/h+120:60*(s-n)/h+240,i=0===h?0:.5>=u?h/c:h/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,l=n.to,c=n.from;h.fn[s]=function(s){if(l&&!this[a]&&(this[a]=l(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=h(c(d)),n[a]=d,n):h(d)},f(o,function(e,i){h.fn[e]||(h.fn[e]=function(n){var o,a=t.type(n),l="alpha"===e?this._hsla?"hsla":"rgba":s,h=this[l](),c=h[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),h[i.idx]=n,this[l](h)))})})}),h.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=h(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(l){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(l){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=h(e.elem,i),e.end=h(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},h.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(h),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(h.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var l=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",h=l.children?a.find("*").addBack():a;h=h.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),h=h.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),h=h.map(function(){var e=this,i=t.Deferred(),s=t.extend({},l,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,h.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),l.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(l)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(a+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(a+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(r,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(r)||"",t.removeData(r)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(a+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=a+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(l),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=u.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[c](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===c:"show"===c)?(r[c](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,c=s.mode,u=[],d=function(e){var i=t(this),s=t.effects.mode(i,c)||o;i.data(l,!0),u.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?c?this[c](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(d).each(i):this.queue(r,d).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)}}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,l=o?a.scrollLeft():0,h=n.offset(),c={top:h.top-r,left:h.left-l,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-l,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}(),t.effects,t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],l=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],h=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,l,n.from.y,_),v=t.effects.setTransition(a,l,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,h,n.from.x,_),v=t.effects.setTransition(a,h,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(l=l.concat(["marginTop","marginBottom"]).concat(r),h=h.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,l,n.from.y,o),a=t.effects.setTransition(i,l,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,h,n.from.x,o),a=t.effects.setTransition(i,h,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)})});
/*!
 * Bootstrap v3.3.6 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1||b[0]>2)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.6",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.6",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is('input[type="radio"]')||a(c.target).is('input[type="checkbox"]')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.6",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger(a.Event("hidden.bs.dropdown",f)))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.6",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger(a.Event("shown.bs.dropdown",h))}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.6",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.6",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");
    d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.6",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function(){function n(n){function t(t,r,e,u,i,o){for(;i>=0&&o>i;i+=n){var a=u?u[i]:i;e=r(e,t[a],a,t)}return e}return function(r,e,u,i){e=b(e,i,4);var o=!k(r)&&m.keys(r),a=(o||r).length,c=n>0?0:a-1;return arguments.length<3&&(u=r[o?o[c]:c],c+=n),t(r,e,u,o,c,a)}}function t(n){return function(t,r,e){r=x(r,e);for(var u=O(t),i=n>0?0:u-1;i>=0&&u>i;i+=n)if(r(t[i],i,t))return i;return-1}}function r(n,t,r){return function(e,u,i){var o=0,a=O(e);if("number"==typeof i)n>0?o=i>=0?i:Math.max(i+a,o):a=i>=0?Math.min(i+1,a):i+a+1;else if(r&&i&&a)return i=r(e,u),e[i]===u?i:-1;if(u!==u)return i=t(l.call(e,o,a),m.isNaN),i>=0?i+o:-1;for(i=n>0?o:a-1;i>=0&&a>i;i+=n)if(e[i]===u)return i;return-1}}function e(n,t){var r=I.length,e=n.constructor,u=m.isFunction(e)&&e.prototype||a,i="constructor";for(m.has(n,i)&&!m.contains(t,i)&&t.push(i);r--;)i=I[r],i in n&&n[i]!==u[i]&&!m.contains(t,i)&&t.push(i)}var u=this,i=u._,o=Array.prototype,a=Object.prototype,c=Function.prototype,f=o.push,l=o.slice,s=a.toString,p=a.hasOwnProperty,h=Array.isArray,v=Object.keys,g=c.bind,y=Object.create,d=function(){},m=function(n){return n instanceof m?n:this instanceof m?void(this._wrapped=n):new m(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=m),exports._=m):u._=m,m.VERSION="1.8.3";var b=function(n,t,r){if(t===void 0)return n;switch(null==r?3:r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)}}return function(){return n.apply(t,arguments)}},x=function(n,t,r){return null==n?m.identity:m.isFunction(n)?b(n,t,r):m.isObject(n)?m.matcher(n):m.property(n)};m.iteratee=function(n,t){return x(n,t,1/0)};var _=function(n,t){return function(r){var e=arguments.length;if(2>e||null==r)return r;for(var u=1;e>u;u++)for(var i=arguments[u],o=n(i),a=o.length,c=0;a>c;c++){var f=o[c];t&&r[f]!==void 0||(r[f]=i[f])}return r}},j=function(n){if(!m.isObject(n))return{};if(y)return y(n);d.prototype=n;var t=new d;return d.prototype=null,t},w=function(n){return function(t){return null==t?void 0:t[n]}},A=Math.pow(2,53)-1,O=w("length"),k=function(n){var t=O(n);return"number"==typeof t&&t>=0&&A>=t};m.each=m.forEach=function(n,t,r){t=b(t,r);var e,u;if(k(n))for(e=0,u=n.length;u>e;e++)t(n[e],e,n);else{var i=m.keys(n);for(e=0,u=i.length;u>e;e++)t(n[i[e]],i[e],n)}return n},m.map=m.collect=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=Array(u),o=0;u>o;o++){var a=e?e[o]:o;i[o]=t(n[a],a,n)}return i},m.reduce=m.foldl=m.inject=n(1),m.reduceRight=m.foldr=n(-1),m.find=m.detect=function(n,t,r){var e;return e=k(n)?m.findIndex(n,t,r):m.findKey(n,t,r),e!==void 0&&e!==-1?n[e]:void 0},m.filter=m.select=function(n,t,r){var e=[];return t=x(t,r),m.each(n,function(n,r,u){t(n,r,u)&&e.push(n)}),e},m.reject=function(n,t,r){return m.filter(n,m.negate(x(t)),r)},m.every=m.all=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(!t(n[o],o,n))return!1}return!0},m.some=m.any=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(t(n[o],o,n))return!0}return!1},m.contains=m.includes=m.include=function(n,t,r,e){return k(n)||(n=m.values(n)),("number"!=typeof r||e)&&(r=0),m.indexOf(n,t,r)>=0},m.invoke=function(n,t){var r=l.call(arguments,2),e=m.isFunction(t);return m.map(n,function(n){var u=e?t:n[t];return null==u?u:u.apply(n,r)})},m.pluck=function(n,t){return m.map(n,m.property(t))},m.where=function(n,t){return m.filter(n,m.matcher(t))},m.findWhere=function(n,t){return m.find(n,m.matcher(t))},m.max=function(n,t,r){var e,u,i=-1/0,o=-1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],e>i&&(i=e)}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(u>o||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},m.min=function(n,t,r){var e,u,i=1/0,o=1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],i>e&&(i=e)}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(o>u||1/0===u&&1/0===i)&&(i=n,o=u)});return i},m.shuffle=function(n){for(var t,r=k(n)?n:m.values(n),e=r.length,u=Array(e),i=0;e>i;i++)t=m.random(0,i),t!==i&&(u[i]=u[t]),u[t]=r[i];return u},m.sample=function(n,t,r){return null==t||r?(k(n)||(n=m.values(n)),n[m.random(n.length-1)]):m.shuffle(n).slice(0,Math.max(0,t))},m.sortBy=function(n,t,r){return t=x(t,r),m.pluck(m.map(n,function(n,r,e){return{value:n,index:r,criteria:t(n,r,e)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={};return r=x(r,e),m.each(t,function(e,i){var o=r(e,i,t);n(u,e,o)}),u}};m.groupBy=F(function(n,t,r){m.has(n,r)?n[r].push(t):n[r]=[t]}),m.indexBy=F(function(n,t,r){n[r]=t}),m.countBy=F(function(n,t,r){m.has(n,r)?n[r]++:n[r]=1}),m.toArray=function(n){return n?m.isArray(n)?l.call(n):k(n)?m.map(n,m.identity):m.values(n):[]},m.size=function(n){return null==n?0:k(n)?n.length:m.keys(n).length},m.partition=function(n,t,r){t=x(t,r);var e=[],u=[];return m.each(n,function(n,r,i){(t(n,r,i)?e:u).push(n)}),[e,u]},m.first=m.head=m.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:m.initial(n,n.length-t)},m.initial=function(n,t,r){return l.call(n,0,Math.max(0,n.length-(null==t||r?1:t)))},m.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:m.rest(n,Math.max(0,n.length-t))},m.rest=m.tail=m.drop=function(n,t,r){return l.call(n,null==t||r?1:t)},m.compact=function(n){return m.filter(n,m.identity)};var S=function(n,t,r,e){for(var u=[],i=0,o=e||0,a=O(n);a>o;o++){var c=n[o];if(k(c)&&(m.isArray(c)||m.isArguments(c))){t||(c=S(c,t,r));var f=0,l=c.length;for(u.length+=l;l>f;)u[i++]=c[f++]}else r||(u[i++]=c)}return u};m.flatten=function(n,t){return S(n,t,!1)},m.without=function(n){return m.difference(n,l.call(arguments,1))},m.uniq=m.unique=function(n,t,r,e){m.isBoolean(t)||(e=r,r=t,t=!1),null!=r&&(r=x(r,e));for(var u=[],i=[],o=0,a=O(n);a>o;o++){var c=n[o],f=r?r(c,o,n):c;t?(o&&i===f||u.push(c),i=f):r?m.contains(i,f)||(i.push(f),u.push(c)):m.contains(u,c)||u.push(c)}return u},m.union=function(){return m.uniq(S(arguments,!0,!0))},m.intersection=function(n){for(var t=[],r=arguments.length,e=0,u=O(n);u>e;e++){var i=n[e];if(!m.contains(t,i)){for(var o=1;r>o&&m.contains(arguments[o],i);o++);o===r&&t.push(i)}}return t},m.difference=function(n){var t=S(arguments,!0,!0,1);return m.filter(n,function(n){return!m.contains(t,n)})},m.zip=function(){return m.unzip(arguments)},m.unzip=function(n){for(var t=n&&m.max(n,O).length||0,r=Array(t),e=0;t>e;e++)r[e]=m.pluck(n,e);return r},m.object=function(n,t){for(var r={},e=0,u=O(n);u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},m.findIndex=t(1),m.findLastIndex=t(-1),m.sortedIndex=function(n,t,r,e){r=x(r,e,1);for(var u=r(t),i=0,o=O(n);o>i;){var a=Math.floor((i+o)/2);r(n[a])<u?i=a+1:o=a}return i},m.indexOf=r(1,m.findIndex,m.sortedIndex),m.lastIndexOf=r(-1,m.findLastIndex),m.range=function(n,t,r){null==t&&(t=n||0,n=0),r=r||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=Array(e),i=0;e>i;i++,n+=r)u[i]=n;return u};var E=function(n,t,r,e,u){if(!(e instanceof t))return n.apply(r,u);var i=j(n.prototype),o=n.apply(i,u);return m.isObject(o)?o:i};m.bind=function(n,t){if(g&&n.bind===g)return g.apply(n,l.call(arguments,1));if(!m.isFunction(n))throw new TypeError("Bind must be called on a function");var r=l.call(arguments,2),e=function(){return E(n,e,t,this,r.concat(l.call(arguments)))};return e},m.partial=function(n){var t=l.call(arguments,1),r=function(){for(var e=0,u=t.length,i=Array(u),o=0;u>o;o++)i[o]=t[o]===m?arguments[e++]:t[o];for(;e<arguments.length;)i.push(arguments[e++]);return E(n,r,this,this,i)};return r},m.bindAll=function(n){var t,r,e=arguments.length;if(1>=e)throw new Error("bindAll must be passed function names");for(t=1;e>t;t++)r=arguments[t],n[r]=m.bind(n[r],n);return n},m.memoize=function(n,t){var r=function(e){var u=r.cache,i=""+(t?t.apply(this,arguments):e);return m.has(u,i)||(u[i]=n.apply(this,arguments)),u[i]};return r.cache={},r},m.delay=function(n,t){var r=l.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},m.defer=m.partial(m.delay,m,1),m.throttle=function(n,t,r){var e,u,i,o=null,a=0;r||(r={});var c=function(){a=r.leading===!1?0:m.now(),o=null,i=n.apply(e,u),o||(e=u=null)};return function(){var f=m.now();a||r.leading!==!1||(a=f);var l=t-(f-a);return e=this,u=arguments,0>=l||l>t?(o&&(clearTimeout(o),o=null),a=f,i=n.apply(e,u),o||(e=u=null)):o||r.trailing===!1||(o=setTimeout(c,l)),i}},m.debounce=function(n,t,r){var e,u,i,o,a,c=function(){var f=m.now()-o;t>f&&f>=0?e=setTimeout(c,t-f):(e=null,r||(a=n.apply(i,u),e||(i=u=null)))};return function(){i=this,u=arguments,o=m.now();var f=r&&!e;return e||(e=setTimeout(c,t)),f&&(a=n.apply(i,u),i=u=null),a}},m.wrap=function(n,t){return m.partial(t,n)},m.negate=function(n){return function(){return!n.apply(this,arguments)}},m.compose=function(){var n=arguments,t=n.length-1;return function(){for(var r=t,e=n[t].apply(this,arguments);r--;)e=n[r].call(this,e);return e}},m.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},m.before=function(n,t){var r;return function(){return--n>0&&(r=t.apply(this,arguments)),1>=n&&(t=null),r}},m.once=m.partial(m.before,2);var M=!{toString:null}.propertyIsEnumerable("toString"),I=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"];m.keys=function(n){if(!m.isObject(n))return[];if(v)return v(n);var t=[];for(var r in n)m.has(n,r)&&t.push(r);return M&&e(n,t),t},m.allKeys=function(n){if(!m.isObject(n))return[];var t=[];for(var r in n)t.push(r);return M&&e(n,t),t},m.values=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},m.mapObject=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=u.length,o={},a=0;i>a;a++)e=u[a],o[e]=t(n[e],e,n);return o},m.pairs=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},m.invert=function(n){for(var t={},r=m.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},m.functions=m.methods=function(n){var t=[];for(var r in n)m.isFunction(n[r])&&t.push(r);return t.sort()},m.extend=_(m.allKeys),m.extendOwn=m.assign=_(m.keys),m.findKey=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=0,o=u.length;o>i;i++)if(e=u[i],t(n[e],e,n))return e},m.pick=function(n,t,r){var e,u,i={},o=n;if(null==o)return i;m.isFunction(t)?(u=m.allKeys(o),e=b(t,r)):(u=S(arguments,!1,!1,1),e=function(n,t,r){return t in r},o=Object(o));for(var a=0,c=u.length;c>a;a++){var f=u[a],l=o[f];e(l,f,o)&&(i[f]=l)}return i},m.omit=function(n,t,r){if(m.isFunction(t))t=m.negate(t);else{var e=m.map(S(arguments,!1,!1,1),String);t=function(n,t){return!m.contains(e,t)}}return m.pick(n,t,r)},m.defaults=_(m.allKeys,!0),m.create=function(n,t){var r=j(n);return t&&m.extendOwn(r,t),r},m.clone=function(n){return m.isObject(n)?m.isArray(n)?n.slice():m.extend({},n):n},m.tap=function(n,t){return t(n),n},m.isMatch=function(n,t){var r=m.keys(t),e=r.length;if(null==n)return!e;for(var u=Object(n),i=0;e>i;i++){var o=r[i];if(t[o]!==u[o]||!(o in u))return!1}return!0};var N=function(n,t,r,e){if(n===t)return 0!==n||1/n===1/t;if(null==n||null==t)return n===t;n instanceof m&&(n=n._wrapped),t instanceof m&&(t=t._wrapped);var u=s.call(n);if(u!==s.call(t))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+t;case"[object Number]":return+n!==+n?+t!==+t:0===+n?1/+n===1/t:+n===+t;case"[object Date]":case"[object Boolean]":return+n===+t}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof t)return!1;var o=n.constructor,a=t.constructor;if(o!==a&&!(m.isFunction(o)&&o instanceof o&&m.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in t)return!1}r=r||[],e=e||[];for(var c=r.length;c--;)if(r[c]===n)return e[c]===t;if(r.push(n),e.push(t),i){if(c=n.length,c!==t.length)return!1;for(;c--;)if(!N(n[c],t[c],r,e))return!1}else{var f,l=m.keys(n);if(c=l.length,m.keys(t).length!==c)return!1;for(;c--;)if(f=l[c],!m.has(t,f)||!N(n[f],t[f],r,e))return!1}return r.pop(),e.pop(),!0};m.isEqual=function(n,t){return N(n,t)},m.isEmpty=function(n){return null==n?!0:k(n)&&(m.isArray(n)||m.isString(n)||m.isArguments(n))?0===n.length:0===m.keys(n).length},m.isElement=function(n){return!(!n||1!==n.nodeType)},m.isArray=h||function(n){return"[object Array]"===s.call(n)},m.isObject=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},m.each(["Arguments","Function","String","Number","Date","RegExp","Error"],function(n){m["is"+n]=function(t){return s.call(t)==="[object "+n+"]"}}),m.isArguments(arguments)||(m.isArguments=function(n){return m.has(n,"callee")}),"function"!=typeof/./&&"object"!=typeof Int8Array&&(m.isFunction=function(n){return"function"==typeof n||!1}),m.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},m.isNaN=function(n){return m.isNumber(n)&&n!==+n},m.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"===s.call(n)},m.isNull=function(n){return null===n},m.isUndefined=function(n){return n===void 0},m.has=function(n,t){return null!=n&&p.call(n,t)},m.noConflict=function(){return u._=i,this},m.identity=function(n){return n},m.constant=function(n){return function(){return n}},m.noop=function(){},m.property=w,m.propertyOf=function(n){return null==n?function(){}:function(t){return n[t]}},m.matcher=m.matches=function(n){return n=m.extendOwn({},n),function(t){return m.isMatch(t,n)}},m.times=function(n,t,r){var e=Array(Math.max(0,n));t=b(t,r,1);for(var u=0;n>u;u++)e[u]=t(u);return e},m.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},m.now=Date.now||function(){return(new Date).getTime()};var B={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},T=m.invert(B),R=function(n){var t=function(t){return n[t]},r="(?:"+m.keys(n).join("|")+")",e=RegExp(r),u=RegExp(r,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};m.escape=R(B),m.unescape=R(T),m.result=function(n,t,r){var e=null==n?void 0:n[t];return e===void 0&&(e=r),m.isFunction(e)?e.call(n):e};var q=0;m.uniqueId=function(n){var t=++q+"";return n?n+t:t},m.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var K=/(.)^/,z={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\u2028|\u2029/g,L=function(n){return"\\"+z[n]};m.template=function(n,t,r){!t&&r&&(t=r),t=m.defaults({},t,m.templateSettings);var e=RegExp([(t.escape||K).source,(t.interpolate||K).source,(t.evaluate||K).source].join("|")+"|$","g"),u=0,i="__p+='";n.replace(e,function(t,r,e,o,a){return i+=n.slice(u,a).replace(D,L),u=a+t.length,r?i+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":e?i+="'+\n((__t=("+e+"))==null?'':__t)+\n'":o&&(i+="';\n"+o+"\n__p+='"),t}),i+="';\n",t.variable||(i="with(obj||{}){\n"+i+"}\n"),i="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+i+"return __p;\n";try{var o=new Function(t.variable||"obj","_",i)}catch(a){throw a.source=i,a}var c=function(n){return o.call(this,n,m)},f=t.variable||"obj";return c.source="function("+f+"){\n"+i+"}",c},m.chain=function(n){var t=m(n);return t._chain=!0,t};var P=function(n,t){return n._chain?m(t).chain():t};m.mixin=function(n){m.each(m.functions(n),function(t){var r=m[t]=n[t];m.prototype[t]=function(){var n=[this._wrapped];return f.apply(n,arguments),P(this,r.apply(m,n))}})},m.mixin(m),m.each(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=o[n];m.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!==n&&"splice"!==n||0!==r.length||delete r[0],P(this,r)}}),m.each(["concat","join","slice"],function(n){var t=o[n];m.prototype[n]=function(){return P(this,t.apply(this._wrapped,arguments))}}),m.prototype.value=function(){return this._wrapped},m.prototype.valueOf=m.prototype.toJSON=m.prototype.value,m.prototype.toString=function(){return""+this._wrapped},"function"==typeof define&&define.amd&&define("underscore",[],function(){return m})}).call(this);
//# sourceMappingURL=underscore-min.map
/*!
 * Bootstrap-select v1.12.2 (http://silviomoreto.github.io/bootstrap-select)
 *
 * Copyright 2013-2017 bootstrap-select
 * Licensed under MIT (https://github.com/silviomoreto/bootstrap-select/blob/master/LICENSE)
 */
!function(a,b){"function"==typeof define&&define.amd?define(["jquery"],function(a){return b(a)}):"object"==typeof module&&module.exports?module.exports=b(require("jquery")):b(a.jQuery)}(this,function(a){!function(a){"use strict";function b(b){var c=[{re:/[\xC0-\xC6]/g,ch:"A"},{re:/[\xE0-\xE6]/g,ch:"a"},{re:/[\xC8-\xCB]/g,ch:"E"},{re:/[\xE8-\xEB]/g,ch:"e"},{re:/[\xCC-\xCF]/g,ch:"I"},{re:/[\xEC-\xEF]/g,ch:"i"},{re:/[\xD2-\xD6]/g,ch:"O"},{re:/[\xF2-\xF6]/g,ch:"o"},{re:/[\xD9-\xDC]/g,ch:"U"},{re:/[\xF9-\xFC]/g,ch:"u"},{re:/[\xC7-\xE7]/g,ch:"c"},{re:/[\xD1]/g,ch:"N"},{re:/[\xF1]/g,ch:"n"}];return a.each(c,function(){b=b?b.replace(this.re,this.ch):""}),b}function c(b){var c=arguments,d=b;[].shift.apply(c);var e,f=this.each(function(){var b=a(this);if(b.is("select")){var f=b.data("selectpicker"),g="object"==typeof d&&d;if(f){if(g)for(var h in g)g.hasOwnProperty(h)&&(f.options[h]=g[h])}else{var i=a.extend({},k.DEFAULTS,a.fn.selectpicker.defaults||{},b.data(),g);i.template=a.extend({},k.DEFAULTS.template,a.fn.selectpicker.defaults?a.fn.selectpicker.defaults.template:{},b.data().template,g.template),b.data("selectpicker",f=new k(this,i))}"string"==typeof d&&(e=f[d]instanceof Function?f[d].apply(f,c):f.options[d])}});return"undefined"!=typeof e?e:f}String.prototype.includes||!function(){var a={}.toString,b=function(){try{var a={},b=Object.defineProperty,c=b(a,a,a)&&b}catch(a){}return c}(),c="".indexOf,d=function(b){if(null==this)throw new TypeError;var d=String(this);if(b&&"[object RegExp]"==a.call(b))throw new TypeError;var e=d.length,f=String(b),g=f.length,h=arguments.length>1?arguments[1]:void 0,i=h?Number(h):0;i!=i&&(i=0);var j=Math.min(Math.max(i,0),e);return!(g+j>e)&&c.call(d,f,i)!=-1};b?b(String.prototype,"includes",{value:d,configurable:!0,writable:!0}):String.prototype.includes=d}(),String.prototype.startsWith||!function(){var a=function(){try{var a={},b=Object.defineProperty,c=b(a,a,a)&&b}catch(a){}return c}(),b={}.toString,c=function(a){if(null==this)throw new TypeError;var c=String(this);if(a&&"[object RegExp]"==b.call(a))throw new TypeError;var d=c.length,e=String(a),f=e.length,g=arguments.length>1?arguments[1]:void 0,h=g?Number(g):0;h!=h&&(h=0);var i=Math.min(Math.max(h,0),d);if(f+i>d)return!1;for(var j=-1;++j<f;)if(c.charCodeAt(i+j)!=e.charCodeAt(j))return!1;return!0};a?a(String.prototype,"startsWith",{value:c,configurable:!0,writable:!0}):String.prototype.startsWith=c}(),Object.keys||(Object.keys=function(a,b,c){c=[];for(b in a)c.hasOwnProperty.call(a,b)&&c.push(b);return c});var d={useDefault:!1,_set:a.valHooks.select.set};a.valHooks.select.set=function(b,c){return c&&!d.useDefault&&a(b).data("selected",!0),d._set.apply(this,arguments)};var e=null;a.fn.triggerNative=function(a){var b,c=this[0];c.dispatchEvent?("function"==typeof Event?b=new Event(a,{bubbles:!0}):(b=document.createEvent("Event"),b.initEvent(a,!0,!1)),c.dispatchEvent(b)):c.fireEvent?(b=document.createEventObject(),b.eventType=a,c.fireEvent("on"+a,b)):this.trigger(a)},a.expr.pseudos.icontains=function(b,c,d){var e=a(b),f=(e.data("tokens")||e.text()).toString().toUpperCase();return f.includes(d[3].toUpperCase())},a.expr.pseudos.ibegins=function(b,c,d){var e=a(b),f=(e.data("tokens")||e.text()).toString().toUpperCase();return f.startsWith(d[3].toUpperCase())},a.expr.pseudos.aicontains=function(b,c,d){var e=a(b),f=(e.data("tokens")||e.data("normalizedText")||e.text()).toString().toUpperCase();return f.includes(d[3].toUpperCase())},a.expr.pseudos.aibegins=function(b,c,d){var e=a(b),f=(e.data("tokens")||e.data("normalizedText")||e.text()).toString().toUpperCase();return f.startsWith(d[3].toUpperCase())};var f={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},g={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#x27;":"'","&#x60;":"`"},h=function(a){var b=function(b){return a[b]},c="(?:"+Object.keys(a).join("|")+")",d=RegExp(c),e=RegExp(c,"g");return function(a){return a=null==a?"":""+a,d.test(a)?a.replace(e,b):a}},i=h(f),j=h(g),k=function(b,c){d.useDefault||(a.valHooks.select.set=d._set,d.useDefault=!0),this.$element=a(b),this.$newElement=null,this.$button=null,this.$menu=null,this.$lis=null,this.options=c,null===this.options.title&&(this.options.title=this.$element.attr("title"));var e=this.options.windowPadding;"number"==typeof e&&(this.options.windowPadding=[e,e,e,e]),this.val=k.prototype.val,this.render=k.prototype.render,this.refresh=k.prototype.refresh,this.setStyle=k.prototype.setStyle,this.selectAll=k.prototype.selectAll,this.deselectAll=k.prototype.deselectAll,this.destroy=k.prototype.destroy,this.remove=k.prototype.remove,this.show=k.prototype.show,this.hide=k.prototype.hide,this.init()};k.VERSION="1.12.2",k.DEFAULTS={noneSelectedText:"Nothing selected",noneResultsText:"No results matched {0}",countSelectedText:function(a,b){return 1==a?"{0} item selected":"{0} items selected"},maxOptionsText:function(a,b){return[1==a?"Limit reached ({n} item max)":"Limit reached ({n} items max)",1==b?"Group limit reached ({n} item max)":"Group limit reached ({n} items max)"]},selectAllText:"Select All",deselectAllText:"Deselect All",doneButton:!1,doneButtonText:"Close",multipleSeparator:", ",styleBase:"btn",style:"btn-default",size:"auto",title:null,selectedTextFormat:"values",width:!1,container:!1,hideDisabled:!1,showSubtext:!1,showIcon:!0,showContent:!0,dropupAuto:!0,header:!1,liveSearch:!1,liveSearchPlaceholder:null,liveSearchNormalize:!1,liveSearchStyle:"contains",actionsBox:!1,iconBase:"glyphicon",tickIcon:"glyphicon-ok",showTick:!1,template:{caret:'<span class="caret"></span>'},maxOptions:!1,mobile:!1,selectOnTab:!1,dropdownAlignRight:!1,windowPadding:0},k.prototype={constructor:k,init:function(){var b=this,c=this.$element.attr("id");this.$element.addClass("bs-select-hidden"),this.liObj={},this.multiple=this.$element.prop("multiple"),this.autofocus=this.$element.prop("autofocus"),this.$newElement=this.createView(),this.$element.after(this.$newElement).appendTo(this.$newElement),this.$button=this.$newElement.children("button"),this.$menu=this.$newElement.children(".dropdown-menu"),this.$menuInner=this.$menu.children(".inner"),this.$searchbox=this.$menu.find("input"),this.$element.removeClass("bs-select-hidden"),this.options.dropdownAlignRight===!0&&this.$menu.addClass("dropdown-menu-right"),"undefined"!=typeof c&&(this.$button.attr("data-id",c),a('label[for="'+c+'"]').click(function(a){a.preventDefault(),b.$button.focus()})),this.checkDisabled(),this.clickListener(),this.options.liveSearch&&this.liveSearchListener(),this.render(),this.setStyle(),this.setWidth(),this.options.container&&this.selectPosition(),this.$menu.data("this",this),this.$newElement.data("this",this),this.options.mobile&&this.mobile(),this.$newElement.on({"hide.bs.dropdown":function(a){b.$menuInner.attr("aria-expanded",!1),b.$element.trigger("hide.bs.select",a)},"hidden.bs.dropdown":function(a){b.$element.trigger("hidden.bs.select",a)},"show.bs.dropdown":function(a){b.$menuInner.attr("aria-expanded",!0),b.$element.trigger("show.bs.select",a)},"shown.bs.dropdown":function(a){b.$element.trigger("shown.bs.select",a)}}),b.$element[0].hasAttribute("required")&&this.$element.on("invalid",function(){b.$button.addClass("bs-invalid").focus(),b.$element.on({"focus.bs.select":function(){b.$button.focus(),b.$element.off("focus.bs.select")},"shown.bs.select":function(){b.$element.val(b.$element.val()).off("shown.bs.select")},"rendered.bs.select":function(){this.validity.valid&&b.$button.removeClass("bs-invalid"),b.$element.off("rendered.bs.select")}})}),setTimeout(function(){b.$element.trigger("loaded.bs.select")})},createDropdown:function(){var b=this.multiple||this.options.showTick?" show-tick":"",c=this.$element.parent().hasClass("input-group")?" input-group-btn":"",d=this.autofocus?" autofocus":"",e=this.options.header?'<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>'+this.options.header+"</div>":"",f=this.options.liveSearch?'<div class="bs-searchbox"><input type="text" class="form-control" autocomplete="off"'+(null===this.options.liveSearchPlaceholder?"":' placeholder="'+i(this.options.liveSearchPlaceholder)+'"')+' role="textbox" aria-label="Search"></div>':"",g=this.multiple&&this.options.actionsBox?'<div class="bs-actionsbox"><div class="btn-group btn-group-sm btn-block"><button type="button" class="actions-btn bs-select-all btn btn-default">'+this.options.selectAllText+'</button><button type="button" class="actions-btn bs-deselect-all btn btn-default">'+this.options.deselectAllText+"</button></div></div>":"",h=this.multiple&&this.options.doneButton?'<div class="bs-donebutton"><div class="btn-group btn-block"><button type="button" class="btn btn-sm btn-default">'+this.options.doneButtonText+"</button></div></div>":"",j='<div class="btn-group bootstrap-select'+b+c+'"><button type="button" class="'+this.options.styleBase+' dropdown-toggle" data-toggle="dropdown"'+d+' role="button"><span class="filter-option pull-left"></span>&nbsp;<span class="bs-caret">'+this.options.template.caret+'</span></button><div class="dropdown-menu open" role="combobox">'+e+f+g+'<ul class="dropdown-menu inner" role="listbox" aria-expanded="false"></ul>'+h+"</div></div>";return a(j)},createView:function(){var a=this.createDropdown(),b=this.createLi();return a.find("ul")[0].innerHTML=b,a},reloadLi:function(){var a=this.createLi();this.$menuInner[0].innerHTML=a},createLi:function(){var c=this,d=[],e=0,f=document.createElement("option"),g=-1,h=function(a,b,c,d){return"<li"+("undefined"!=typeof c&""!==c?' class="'+c+'"':"")+("undefined"!=typeof b&null!==b?' data-original-index="'+b+'"':"")+("undefined"!=typeof d&null!==d?'data-optgroup="'+d+'"':"")+">"+a+"</li>"},j=function(d,e,f,g){return'<a tabindex="0"'+("undefined"!=typeof e?' class="'+e+'"':"")+(f?' style="'+f+'"':"")+(c.options.liveSearchNormalize?' data-normalized-text="'+b(i(a(d).html()))+'"':"")+("undefined"!=typeof g||null!==g?' data-tokens="'+g+'"':"")+' role="option">'+d+'<span class="'+c.options.iconBase+" "+c.options.tickIcon+' check-mark"></span></a>'};if(this.options.title&&!this.multiple&&(g--,!this.$element.find(".bs-title-option").length)){var k=this.$element[0];f.className="bs-title-option",f.innerHTML=this.options.title,f.value="",k.insertBefore(f,k.firstChild);var l=a(k.options[k.selectedIndex]);void 0===l.attr("selected")&&void 0===this.$element.data("selected")&&(f.selected=!0)}return this.$element.find("option").each(function(b){var f=a(this);if(g++,!f.hasClass("bs-title-option")){var k=this.className||"",l=this.style.cssText,m=f.data("content")?f.data("content"):f.html(),n=f.data("tokens")?f.data("tokens"):null,o="undefined"!=typeof f.data("subtext")?'<small class="text-muted">'+f.data("subtext")+"</small>":"",p="undefined"!=typeof f.data("icon")?'<span class="'+c.options.iconBase+" "+f.data("icon")+'"></span> ':"",q=f.parent(),r="OPTGROUP"===q[0].tagName,s=r&&q[0].disabled,t=this.disabled||s;if(""!==p&&t&&(p="<span>"+p+"</span>"),c.options.hideDisabled&&(t&&!r||s))return void g--;if(f.data("content")||(m=p+'<span class="text">'+m+o+"</span>"),r&&f.data("divider")!==!0){if(c.options.hideDisabled&&t){if(void 0===q.data("allOptionsDisabled")){var u=q.children();q.data("allOptionsDisabled",u.filter(":disabled").length===u.length)}if(q.data("allOptionsDisabled"))return void g--}var v=" "+q[0].className||"";if(0===f.index()){e+=1;var w=q[0].label,x="undefined"!=typeof q.data("subtext")?'<small class="text-muted">'+q.data("subtext")+"</small>":"",y=q.data("icon")?'<span class="'+c.options.iconBase+" "+q.data("icon")+'"></span> ':"";w=y+'<span class="text">'+i(w)+x+"</span>",0!==b&&d.length>0&&(g++,d.push(h("",null,"divider",e+"div"))),g++,d.push(h(w,null,"dropdown-header"+v,e))}if(c.options.hideDisabled&&t)return void g--;d.push(h(j(m,"opt "+k+v,l,n),b,"",e))}else if(f.data("divider")===!0)d.push(h("",b,"divider"));else if(f.data("hidden")===!0)d.push(h(j(m,k,l,n),b,"hidden is-hidden"));else{var z=this.previousElementSibling&&"OPTGROUP"===this.previousElementSibling.tagName;if(!z&&c.options.hideDisabled)for(var A=a(this).prevAll(),B=0;B<A.length;B++)if("OPTGROUP"===A[B].tagName){for(var C=0,D=0;D<B;D++){var E=A[D];(E.disabled||a(E).data("hidden")===!0)&&C++}C===B&&(z=!0);break}z&&(g++,d.push(h("",null,"divider",e+"div"))),d.push(h(j(m,k,l,n),b))}c.liObj[b]=g}}),this.multiple||0!==this.$element.find("option:selected").length||this.options.title||this.$element.find("option").eq(0).prop("selected",!0).attr("selected","selected"),d.join("")},findLis:function(){return null==this.$lis&&(this.$lis=this.$menu.find("li")),this.$lis},render:function(b){var c,d=this;b!==!1&&this.$element.find("option").each(function(a){var b=d.findLis().eq(d.liObj[a]);d.setDisabled(a,this.disabled||"OPTGROUP"===this.parentNode.tagName&&this.parentNode.disabled,b),d.setSelected(a,this.selected,b)}),this.togglePlaceholder(),this.tabIndex();var e=this.$element.find("option").map(function(){if(this.selected){if(d.options.hideDisabled&&(this.disabled||"OPTGROUP"===this.parentNode.tagName&&this.parentNode.disabled))return;var b,c=a(this),e=c.data("icon")&&d.options.showIcon?'<i class="'+d.options.iconBase+" "+c.data("icon")+'"></i> ':"";return b=d.options.showSubtext&&c.data("subtext")&&!d.multiple?' <small class="text-muted">'+c.data("subtext")+"</small>":"","undefined"!=typeof c.attr("title")?c.attr("title"):c.data("content")&&d.options.showContent?c.data("content").toString():e+c.html()+b}}).toArray(),f=this.multiple?e.join(this.options.multipleSeparator):e[0];if(this.multiple&&this.options.selectedTextFormat.indexOf("count")>-1){var g=this.options.selectedTextFormat.split(">");if(g.length>1&&e.length>g[1]||1==g.length&&e.length>=2){c=this.options.hideDisabled?", [disabled]":"";var h=this.$element.find("option").not('[data-divider="true"], [data-hidden="true"]'+c).length,i="function"==typeof this.options.countSelectedText?this.options.countSelectedText(e.length,h):this.options.countSelectedText;f=i.replace("{0}",e.length.toString()).replace("{1}",h.toString())}}void 0==this.options.title&&(this.options.title=this.$element.attr("title")),"static"==this.options.selectedTextFormat&&(f=this.options.title),f||(f="undefined"!=typeof this.options.title?this.options.title:this.options.noneSelectedText),this.$button.attr("title",j(a.trim(f.replace(/<[^>]*>?/g,"")))),this.$button.children(".filter-option").html(f),this.$element.trigger("rendered.bs.select")},setStyle:function(a,b){this.$element.attr("class")&&this.$newElement.addClass(this.$element.attr("class").replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi,""));var c=a?a:this.options.style;"add"==b?this.$button.addClass(c):"remove"==b?this.$button.removeClass(c):(this.$button.removeClass(this.options.style),this.$button.addClass(c))},liHeight:function(b){if(b||this.options.size!==!1&&!this.sizeInfo){var c=document.createElement("div"),d=document.createElement("div"),e=document.createElement("ul"),f=document.createElement("li"),g=document.createElement("li"),h=document.createElement("a"),i=document.createElement("span"),j=this.options.header&&this.$menu.find(".popover-title").length>0?this.$menu.find(".popover-title")[0].cloneNode(!0):null,k=this.options.liveSearch?document.createElement("div"):null,l=this.options.actionsBox&&this.multiple&&this.$menu.find(".bs-actionsbox").length>0?this.$menu.find(".bs-actionsbox")[0].cloneNode(!0):null,m=this.options.doneButton&&this.multiple&&this.$menu.find(".bs-donebutton").length>0?this.$menu.find(".bs-donebutton")[0].cloneNode(!0):null;if(i.className="text",c.className=this.$menu[0].parentNode.className+" open",d.className="dropdown-menu open",e.className="dropdown-menu inner",f.className="divider",i.appendChild(document.createTextNode("Inner text")),h.appendChild(i),g.appendChild(h),e.appendChild(g),e.appendChild(f),j&&d.appendChild(j),k){var n=document.createElement("input");k.className="bs-searchbox",n.className="form-control",k.appendChild(n),d.appendChild(k)}l&&d.appendChild(l),d.appendChild(e),m&&d.appendChild(m),c.appendChild(d),document.body.appendChild(c);var o=h.offsetHeight,p=j?j.offsetHeight:0,q=k?k.offsetHeight:0,r=l?l.offsetHeight:0,s=m?m.offsetHeight:0,t=a(f).outerHeight(!0),u="function"==typeof getComputedStyle&&getComputedStyle(d),v=u?null:a(d),w={vert:parseInt(u?u.paddingTop:v.css("paddingTop"))+parseInt(u?u.paddingBottom:v.css("paddingBottom"))+parseInt(u?u.borderTopWidth:v.css("borderTopWidth"))+parseInt(u?u.borderBottomWidth:v.css("borderBottomWidth")),horiz:parseInt(u?u.paddingLeft:v.css("paddingLeft"))+parseInt(u?u.paddingRight:v.css("paddingRight"))+parseInt(u?u.borderLeftWidth:v.css("borderLeftWidth"))+parseInt(u?u.borderRightWidth:v.css("borderRightWidth"))},x={vert:w.vert+parseInt(u?u.marginTop:v.css("marginTop"))+parseInt(u?u.marginBottom:v.css("marginBottom"))+2,horiz:w.horiz+parseInt(u?u.marginLeft:v.css("marginLeft"))+parseInt(u?u.marginRight:v.css("marginRight"))+2};document.body.removeChild(c),this.sizeInfo={liHeight:o,headerHeight:p,searchHeight:q,actionsHeight:r,doneButtonHeight:s,dividerHeight:t,menuPadding:w,menuExtras:x}}},setSize:function(){if(this.findLis(),this.liHeight(),this.options.header&&this.$menu.css("padding-top",0),this.options.size!==!1){var b,c,d,e,f,g,h,i,j=this,k=this.$menu,l=this.$menuInner,m=a(window),n=this.$newElement[0].offsetHeight,o=this.$newElement[0].offsetWidth,p=this.sizeInfo.liHeight,q=this.sizeInfo.headerHeight,r=this.sizeInfo.searchHeight,s=this.sizeInfo.actionsHeight,t=this.sizeInfo.doneButtonHeight,u=this.sizeInfo.dividerHeight,v=this.sizeInfo.menuPadding,w=this.sizeInfo.menuExtras,x=this.options.hideDisabled?".disabled":"",y=function(){var b,c=j.$newElement.offset(),d=a(j.options.container);j.options.container&&!d.is("body")?(b=d.offset(),b.top+=parseInt(d.css("borderTopWidth")),b.left+=parseInt(d.css("borderLeftWidth"))):b={top:0,left:0};var e=j.options.windowPadding;f=c.top-b.top-m.scrollTop(),g=m.height()-f-n-b.top-e[2],h=c.left-b.left-m.scrollLeft(),i=m.width()-h-o-b.left-e[1],f-=e[0],h-=e[3]};if(y(),"auto"===this.options.size){var z=function(){var m,n=function(b,c){return function(d){return c?d.classList?d.classList.contains(b):a(d).hasClass(b):!(d.classList?d.classList.contains(b):a(d).hasClass(b))}},u=j.$menuInner[0].getElementsByTagName("li"),x=Array.prototype.filter?Array.prototype.filter.call(u,n("hidden",!1)):j.$lis.not(".hidden"),z=Array.prototype.filter?Array.prototype.filter.call(x,n("dropdown-header",!0)):x.filter(".dropdown-header");y(),b=g-w.vert,c=i-w.horiz,j.options.container?(k.data("height")||k.data("height",k.height()),d=k.data("height"),k.data("width")||k.data("width",k.width()),e=k.data("width")):(d=k.height(),e=k.width()),j.options.dropupAuto&&j.$newElement.toggleClass("dropup",f>g&&b-w.vert<d),j.$newElement.hasClass("dropup")&&(b=f-w.vert),"auto"===j.options.dropdownAlignRight&&k.toggleClass("dropdown-menu-right",h>i&&c-w.horiz<e-o),m=x.length+z.length>3?3*p+w.vert-2:0,k.css({"max-height":b+"px",overflow:"hidden","min-height":m+q+r+s+t+"px"}),l.css({"max-height":b-q-r-s-t-v.vert+"px","overflow-y":"auto","min-height":Math.max(m-v.vert,0)+"px"})};z(),this.$searchbox.off("input.getSize propertychange.getSize").on("input.getSize propertychange.getSize",z),m.off("resize.getSize scroll.getSize").on("resize.getSize scroll.getSize",z)}else if(this.options.size&&"auto"!=this.options.size&&this.$lis.not(x).length>this.options.size){var A=this.$lis.not(".divider").not(x).children().slice(0,this.options.size).last().parent().index(),B=this.$lis.slice(0,A+1).filter(".divider").length;b=p*this.options.size+B*u+v.vert,j.options.container?(k.data("height")||k.data("height",k.height()),d=k.data("height")):d=k.height(),j.options.dropupAuto&&this.$newElement.toggleClass("dropup",f>g&&b-w.vert<d),k.css({"max-height":b+q+r+s+t+"px",overflow:"hidden","min-height":""}),l.css({"max-height":b-v.vert+"px","overflow-y":"auto","min-height":""})}}},setWidth:function(){if("auto"===this.options.width){this.$menu.css("min-width","0");var a=this.$menu.parent().clone().appendTo("body"),b=this.options.container?this.$newElement.clone().appendTo("body"):a,c=a.children(".dropdown-menu").outerWidth(),d=b.css("width","auto").children("button").outerWidth();a.remove(),b.remove(),this.$newElement.css("width",Math.max(c,d)+"px")}else"fit"===this.options.width?(this.$menu.css("min-width",""),this.$newElement.css("width","").addClass("fit-width")):this.options.width?(this.$menu.css("min-width",""),this.$newElement.css("width",this.options.width)):(this.$menu.css("min-width",""),this.$newElement.css("width",""));this.$newElement.hasClass("fit-width")&&"fit"!==this.options.width&&this.$newElement.removeClass("fit-width")},selectPosition:function(){this.$bsContainer=a('<div class="bs-container" />');var b,c,d,e=this,f=a(this.options.container),g=function(a){e.$bsContainer.addClass(a.attr("class").replace(/form-control|fit-width/gi,"")).toggleClass("dropup",a.hasClass("dropup")),b=a.offset(),f.is("body")?c={top:0,left:0}:(c=f.offset(),c.top+=parseInt(f.css("borderTopWidth"))-f.scrollTop(),c.left+=parseInt(f.css("borderLeftWidth"))-f.scrollLeft()),d=a.hasClass("dropup")?0:a[0].offsetHeight,e.$bsContainer.css({top:b.top-c.top+d,left:b.left-c.left,width:a[0].offsetWidth})};this.$button.on("click",function(){var b=a(this);e.isDisabled()||(g(e.$newElement),e.$bsContainer.appendTo(e.options.container).toggleClass("open",!b.hasClass("open")).append(e.$menu))}),a(window).on("resize scroll",function(){g(e.$newElement)}),this.$element.on("hide.bs.select",function(){e.$menu.data("height",e.$menu.height()),e.$bsContainer.detach()})},setSelected:function(a,b,c){c||(this.togglePlaceholder(),c=this.findLis().eq(this.liObj[a])),c.toggleClass("selected",b).find("a").attr("aria-selected",b)},setDisabled:function(a,b,c){c||(c=this.findLis().eq(this.liObj[a])),b?c.addClass("disabled").children("a").attr("href","#").attr("tabindex",-1).attr("aria-disabled",!0):c.removeClass("disabled").children("a").removeAttr("href").attr("tabindex",0).attr("aria-disabled",!1)},isDisabled:function(){return this.$element[0].disabled},checkDisabled:function(){var a=this;this.isDisabled()?(this.$newElement.addClass("disabled"),this.$button.addClass("disabled").attr("tabindex",-1).attr("aria-disabled",!0)):(this.$button.hasClass("disabled")&&(this.$newElement.removeClass("disabled"),this.$button.removeClass("disabled").attr("aria-disabled",!1)),this.$button.attr("tabindex")!=-1||this.$element.data("tabindex")||this.$button.removeAttr("tabindex")),this.$button.click(function(){return!a.isDisabled()})},togglePlaceholder:function(){var a=this.$element.val();this.$button.toggleClass("bs-placeholder",null===a||""===a||a.constructor===Array&&0===a.length)},tabIndex:function(){this.$element.data("tabindex")!==this.$element.attr("tabindex")&&this.$element.attr("tabindex")!==-98&&"-98"!==this.$element.attr("tabindex")&&(this.$element.data("tabindex",this.$element.attr("tabindex")),this.$button.attr("tabindex",this.$element.data("tabindex"))),this.$element.attr("tabindex",-98)},clickListener:function(){var b=this,c=a(document);c.data("spaceSelect",!1),this.$button.on("keyup",function(a){/(32)/.test(a.keyCode.toString(10))&&c.data("spaceSelect")&&(a.preventDefault(),c.data("spaceSelect",!1))}),this.$button.on("click",function(){b.setSize()}),this.$element.on("shown.bs.select",function(){if(b.options.liveSearch||b.multiple){if(!b.multiple){var a=b.liObj[b.$element[0].selectedIndex];if("number"!=typeof a||b.options.size===!1)return;var c=b.$lis.eq(a)[0].offsetTop-b.$menuInner[0].offsetTop;c=c-b.$menuInner[0].offsetHeight/2+b.sizeInfo.liHeight/2,b.$menuInner[0].scrollTop=c}}else b.$menuInner.find(".selected a").focus()}),this.$menuInner.on("click","li a",function(c){var d=a(this),f=d.parent().data("originalIndex"),g=b.$element.val(),h=b.$element.prop("selectedIndex"),i=!0;if(b.multiple&&1!==b.options.maxOptions&&c.stopPropagation(),c.preventDefault(),!b.isDisabled()&&!d.parent().hasClass("disabled")){var j=b.$element.find("option"),k=j.eq(f),l=k.prop("selected"),m=k.parent("optgroup"),n=b.options.maxOptions,o=m.data("maxOptions")||!1;if(b.multiple){if(k.prop("selected",!l),b.setSelected(f,!l),d.blur(),n!==!1||o!==!1){var p=n<j.filter(":selected").length,q=o<m.find("option:selected").length;if(n&&p||o&&q)if(n&&1==n)j.prop("selected",!1),k.prop("selected",!0),b.$menuInner.find(".selected").removeClass("selected"),b.setSelected(f,!0);else if(o&&1==o){m.find("option:selected").prop("selected",!1),k.prop("selected",!0);var r=d.parent().data("optgroup");b.$menuInner.find('[data-optgroup="'+r+'"]').removeClass("selected"),b.setSelected(f,!0)}else{var s="string"==typeof b.options.maxOptionsText?[b.options.maxOptionsText,b.options.maxOptionsText]:b.options.maxOptionsText,t="function"==typeof s?s(n,o):s,u=t[0].replace("{n}",n),v=t[1].replace("{n}",o),w=a('<div class="notify"></div>');t[2]&&(u=u.replace("{var}",t[2][n>1?0:1]),v=v.replace("{var}",t[2][o>1?0:1])),k.prop("selected",!1),b.$menu.append(w),n&&p&&(w.append(a("<div>"+u+"</div>")),i=!1,b.$element.trigger("maxReached.bs.select")),o&&q&&(w.append(a("<div>"+v+"</div>")),i=!1,b.$element.trigger("maxReachedGrp.bs.select")),setTimeout(function(){b.setSelected(f,!1)},10),w.delay(750).fadeOut(300,function(){a(this).remove()})}}}else j.prop("selected",!1),k.prop("selected",!0),b.$menuInner.find(".selected").removeClass("selected").find("a").attr("aria-selected",!1),b.setSelected(f,!0);!b.multiple||b.multiple&&1===b.options.maxOptions?b.$button.focus():b.options.liveSearch&&b.$searchbox.focus(),i&&(g!=b.$element.val()&&b.multiple||h!=b.$element.prop("selectedIndex")&&!b.multiple)&&(e=[f,k.prop("selected"),l],b.$element.triggerNative("change"))}}),this.$menu.on("click","li.disabled a, .popover-title, .popover-title :not(.close)",function(c){c.currentTarget==this&&(c.preventDefault(),c.stopPropagation(),b.options.liveSearch&&!a(c.target).hasClass("close")?b.$searchbox.focus():b.$button.focus())}),this.$menuInner.on("click",".divider, .dropdown-header",function(a){a.preventDefault(),a.stopPropagation(),b.options.liveSearch?b.$searchbox.focus():b.$button.focus()}),this.$menu.on("click",".popover-title .close",function(){b.$button.click()}),this.$searchbox.on("click",function(a){a.stopPropagation()}),this.$menu.on("click",".actions-btn",function(c){b.options.liveSearch?b.$searchbox.focus():b.$button.focus(),c.preventDefault(),c.stopPropagation(),a(this).hasClass("bs-select-all")?b.selectAll():b.deselectAll()}),this.$element.change(function(){b.render(!1),b.$element.trigger("changed.bs.select",e),e=null})},liveSearchListener:function(){var c=this,d=a('<li class="no-results"></li>');this.$button.on("click.dropdown.data-api",function(){c.$menuInner.find(".active").removeClass("active"),c.$searchbox.val()&&(c.$searchbox.val(""),c.$lis.not(".is-hidden").removeClass("hidden"),d.parent().length&&d.remove()),c.multiple||c.$menuInner.find(".selected").addClass("active"),setTimeout(function(){c.$searchbox.focus()},10)}),this.$searchbox.on("click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api",function(a){a.stopPropagation()}),this.$searchbox.on("input propertychange",function(){if(c.$lis.not(".is-hidden").removeClass("hidden"),c.$lis.filter(".active").removeClass("active"),d.remove(),c.$searchbox.val()){var e,f=c.$lis.not(".is-hidden, .divider, .dropdown-header");if(e=c.options.liveSearchNormalize?f.find("a").not(":a"+c._searchStyle()+'("'+b(c.$searchbox.val())+'")'):f.find("a").not(":"+c._searchStyle()+'("'+c.$searchbox.val()+'")'),e.length===f.length)d.html(c.options.noneResultsText.replace("{0}",'"'+i(c.$searchbox.val())+'"')),c.$menuInner.append(d),c.$lis.addClass("hidden");else{e.parent().addClass("hidden");var g,h=c.$lis.not(".hidden");h.each(function(b){var c=a(this);c.hasClass("divider")?void 0===g?c.addClass("hidden"):(g&&g.addClass("hidden"),g=c):c.hasClass("dropdown-header")&&h.eq(b+1).data("optgroup")!==c.data("optgroup")?c.addClass("hidden"):g=null}),g&&g.addClass("hidden"),f.not(".hidden").first().addClass("active")}}})},_searchStyle:function(){var a={begins:"ibegins",startsWith:"ibegins"};return a[this.options.liveSearchStyle]||"icontains"},val:function(a){return"undefined"!=typeof a?(this.$element.val(a),this.render(),this.$element):this.$element.val()},changeAll:function(b){if(this.multiple){"undefined"==typeof b&&(b=!0),this.findLis();var c=this.$element.find("option"),d=this.$lis.not(".divider, .dropdown-header, .disabled, .hidden"),e=d.length,f=[];if(b){if(d.filter(".selected").length===d.length)return}else if(0===d.filter(".selected").length)return;d.toggleClass("selected",b);for(var g=0;g<e;g++){var h=d[g].getAttribute("data-original-index");f[f.length]=c.eq(h)[0]}a(f).prop("selected",b),this.render(!1),this.togglePlaceholder(),this.$element.triggerNative("change")}},selectAll:function(){return this.changeAll(!0)},deselectAll:function(){return this.changeAll(!1)},toggle:function(a){a=a||window.event,a&&a.stopPropagation(),this.$button.trigger("click")},keydown:function(c){var d,e,f,g,h,i,j,k,l,m=a(this),n=m.is("input")?m.parent().parent():m.parent(),o=n.data("this"),p=":not(.disabled, .hidden, .dropdown-header, .divider)",q={32:" ",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",59:";",65:"a",66:"b",67:"c",68:"d",69:"e",70:"f",71:"g",72:"h",73:"i",74:"j",75:"k",76:"l",77:"m",78:"n",79:"o",80:"p",81:"q",82:"r",83:"s",84:"t",85:"u",86:"v",87:"w",88:"x",89:"y",90:"z",96:"0",97:"1",98:"2",99:"3",100:"4",101:"5",102:"6",103:"7",104:"8",105:"9"};if(o.options.liveSearch&&(n=m.parent().parent()),o.options.container&&(n=o.$menu),d=a('[role="listbox"] li',n),l=o.$newElement.hasClass("open"),!l&&(c.keyCode>=48&&c.keyCode<=57||c.keyCode>=96&&c.keyCode<=105||c.keyCode>=65&&c.keyCode<=90))return o.options.container?o.$button.trigger("click"):(o.setSize(),o.$menu.parent().addClass("open"),l=!0),void o.$searchbox.focus();if(o.options.liveSearch&&(/(^9$|27)/.test(c.keyCode.toString(10))&&l&&(c.preventDefault(),c.stopPropagation(),o.$menuInner.click(),o.$button.focus()),d=a('[role="listbox"] li'+p,n),m.val()||/(38|40)/.test(c.keyCode.toString(10))||0===d.filter(".active").length&&(d=o.$menuInner.find("li"),d=o.options.liveSearchNormalize?d.filter(":a"+o._searchStyle()+"("+b(q[c.keyCode])+")"):d.filter(":"+o._searchStyle()+"("+q[c.keyCode]+")"))),d.length){if(/(38|40)/.test(c.keyCode.toString(10)))e=d.index(d.find("a").filter(":focus").parent()),g=d.filter(p).first().index(),h=d.filter(p).last().index(),f=d.eq(e).nextAll(p).eq(0).index(),i=d.eq(e).prevAll(p).eq(0).index(),j=d.eq(f).prevAll(p).eq(0).index(),o.options.liveSearch&&(d.each(function(b){a(this).hasClass("disabled")||a(this).data("index",b)}),e=d.index(d.filter(".active")),g=d.first().data("index"),h=d.last().data("index"),f=d.eq(e).nextAll().eq(0).data("index"),i=d.eq(e).prevAll().eq(0).data("index"),j=d.eq(f).prevAll().eq(0).data("index")),k=m.data("prevIndex"),38==c.keyCode?(o.options.liveSearch&&e--,e!=j&&e>i&&(e=i),e<g&&(e=g),e==k&&(e=h)):40==c.keyCode&&(o.options.liveSearch&&e++,e==-1&&(e=0),e!=j&&e<f&&(e=f),e>h&&(e=h),e==k&&(e=g)),m.data("prevIndex",e),o.options.liveSearch?(c.preventDefault(),m.hasClass("dropdown-toggle")||(d.removeClass("active").eq(e).addClass("active").children("a").focus(),m.focus())):d.eq(e).children("a").focus();else if(!m.is("input")){var r,s,t=[];d.each(function(){a(this).hasClass("disabled")||a.trim(a(this).children("a").text().toLowerCase()).substring(0,1)==q[c.keyCode]&&t.push(a(this).index())}),r=a(document).data("keycount"),r++,a(document).data("keycount",r),s=a.trim(a(":focus").text().toLowerCase()).substring(0,1),s!=q[c.keyCode]?(r=1,a(document).data("keycount",r)):r>=t.length&&(a(document).data("keycount",0),r>t.length&&(r=1)),d.eq(t[r-1]).children("a").focus()}if((/(13|32)/.test(c.keyCode.toString(10))||/(^9$)/.test(c.keyCode.toString(10))&&o.options.selectOnTab)&&l){if(/(32)/.test(c.keyCode.toString(10))||c.preventDefault(),o.options.liveSearch)/(32)/.test(c.keyCode.toString(10))||(o.$menuInner.find(".active a").click(),
m.focus());else{var u=a(":focus");u.click(),u.focus(),c.preventDefault(),a(document).data("spaceSelect",!0)}a(document).data("keycount",0)}(/(^9$|27)/.test(c.keyCode.toString(10))&&l&&(o.multiple||o.options.liveSearch)||/(27)/.test(c.keyCode.toString(10))&&!l)&&(o.$menu.parent().removeClass("open"),o.options.container&&o.$newElement.removeClass("open"),o.$button.focus())}},mobile:function(){this.$element.addClass("mobile-device")},refresh:function(){this.$lis=null,this.liObj={},this.reloadLi(),this.render(),this.checkDisabled(),this.liHeight(!0),this.setStyle(),this.setWidth(),this.$lis&&this.$searchbox.trigger("propertychange"),this.$element.trigger("refreshed.bs.select")},hide:function(){this.$newElement.hide()},show:function(){this.$newElement.show()},remove:function(){this.$newElement.remove(),this.$element.remove()},destroy:function(){this.$newElement.before(this.$element).remove(),this.$bsContainer?this.$bsContainer.remove():this.$menu.remove(),this.$element.off(".bs.select").removeData("selectpicker").removeClass("bs-select-hidden selectpicker")}};var l=a.fn.selectpicker;a.fn.selectpicker=c,a.fn.selectpicker.Constructor=k,a.fn.selectpicker.noConflict=function(){return a.fn.selectpicker=l,this},a(document).data("keycount",0).on("keydown.bs.select",'.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input',k.prototype.keydown).on("focusin.modal",'.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input',function(a){a.stopPropagation()}),a(window).on("load.bs.select.data-api",function(){a(".selectpicker").each(function(){var b=a(this);c.call(b,b.data())})})}(a)});
//# sourceMappingURL=bootstrap-select.js.map
(function(global){
'use strict';
/**
 * @name morpheus
 * @namespace
 */
var morpheus = (typeof morpheus !== 'undefined') ? morpheus : {};
if (typeof module !== 'undefined' && module.exports) {
  module.exports = morpheus; // Node
} else if (typeof define === 'function' && define.amd) {
  define(function () { // AMD module
    return morpheus;
  });
} else {
  global.morpheus = morpheus; // browser global
}
morpheus.Util = function () {
};

morpheus.Util.RIGHT_ARROW = String.fromCharCode(8594);
/**
 * Add properties in c2 to c1
 *
 * @param {Object}
 *            c1 The object that will inherit from obj2
 * @param {Object}
 *            c2 The object that obj1 inherits from
 */
morpheus.Util.extend = function (c1, c2) {
  for (var key in c2.prototype) {
    if (!(key in c1.prototype)) {
      c1.prototype[key] = c2.prototype[key];
    }
  }
};
morpheus.Util.isFetchStreamingSupported = function () {
  return typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') !== -1;
};

morpheus.Util.viewPortSize = function () {
  return window.getComputedStyle(document.body, ':before').content.replace(
    /"/g, '');
};

morpheus.Util.TRACKING_ENABLED = true;
morpheus.Util.TRACKING_CODE_LOADED = false;
morpheus.Util.loadTrackingCode = function () {
  if (morpheus.Util.TRACKING_ENABLED && typeof window !== 'undefined' && typeof navigator !== 'undefined' && navigator.onLine) {
    if (morpheus.Util.TRACKING_CODE_LOADED) {
      return;
    } else if (typeof ga === 'undefined') {
      morpheus.Util.TRACKING_CODE_LOADED = true;
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments);
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    }
    if (typeof ga !== 'undefined') {
      ga('create', 'UA-53973555-1', 'auto', 'morpheus');
      ga('morpheus.send', 'pageview');
    }
    morpheus.Util.TRACKING_CODE_LOADED = true;
  }
};

morpheus.Util.measureScrollbar = function () {
  var $c = $(
    '<div style=\'position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;\'></div>')
    .appendTo('body');
  var dim = {
    width: Math.max(0, $c.width() - $c[0].clientWidth),
    height: $c.height() - $c[0].clientHeight
  };
  $c.remove();
  return dim;
};
morpheus.Util.trackEvent = function (options) {
  if (typeof window !== 'undefined') {
    if (!morpheus.Util.TRACKING_CODE_LOADED) {
      morpheus.Util.loadTrackingCode();
    }
    if (morpheus.Util.TRACKING_CODE_LOADED && typeof ga !== 'undefined') {
      ga('morpheus.send', {
        hitType: 'event',
        eventCategory: options.eventCategory,
        eventAction: options.eventAction,
        eventLabel: options.eventLabel
      });
    }
  }

};

morpheus.Util.isString = function (value) {
  return typeof value === 'string' || value instanceof String;
};
/**
 *
 * @param val The value to determine the data type for.
 * @return {String} One of string, number, object, [string], [number], [object]
 */
morpheus.Util.getDataType = function (val) {
  var dataType;
  var isArray = morpheus.Util.isArray(val);
  if (isArray && val.length > 0) {
    val = val[0];
  }
  if (morpheus.Util.isString(val)) {
    dataType = 'string';
  } else if (_.isNumber(val)) {
    dataType = 'number';
  } else {
    dataType = 'object';
  }
  if (isArray) {
    dataType = '[' + dataType + ']';
  }
  return dataType;
};

/**
 * Checks whether supplied argument is an array
 */
morpheus.Util.isArray = function (array) {
  var types = [
    Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array,
    Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
  // handle native arrays
  for (var i = 0, length = types.length; i < length; i++) {
    if (array instanceof types[i]) {
      return true;
    }
  }
  return false;
};
morpheus.Util.getWindowSearchObject = function () {
  var searchObject = {};
  var hashObject = {};
  if (window.location.search.length > 0) {
    searchObject = morpheus.Util.getQueryParams(window.location.search
      .substring(1));
  }
  if (window.location.hash.length > 0) {
    hashObject = morpheus.Util.getQueryParams(window.location.hash
      .substring(1));
  }
  return _.extend(hashObject, searchObject);
};

morpheus.Util.copyString = function (s) {
  return (' ' + s).substr(1);
  //return (' ' + s).slice(1);
  // var copy = [];
  // for (var i = 0, end = s.length; i < end; i++) {
  // 	copy.push(s[i]);
  // }
  // return copy.join('');
};
morpheus.Util.getQueryParams = function (s) {
  var params = {};
  if (!s) {
    return params;
  }
  var search = decodeURIComponent(s);
  var keyValuePairs = search.split('&');
  for (var i = 0; i < keyValuePairs.length; i++) {
    var pair = keyValuePairs[i].split('=');
    if (pair[1] != null && pair[1] !== '') {
      var array = params[pair[0]];
      if (array === undefined) {
        array = [];
        params[pair[0]] = array;
      }
      array.push(pair[1]);
    }
  }
  return params;
};
morpheus.Util.getScriptPath = function (name) {
  if (!name) {
    name = 'morpheus-latest.min.js';
  }
  var scripts = document.getElementsByTagName('script');
  for (var i = scripts.length - 1; i >= 0; i--) {
    var src = scripts[i].src;
    var index = src.lastIndexOf('/');
    if (index !== -1) {
      src = src.substring(index + 1);
    }
    if (src === name) {
      return scripts[i].src;
    }
  }

  // not found
  if (name === 'morpheus-latest.min.js') {
    return morpheus.Util.getScriptPath('morpheus.js');
  }
  // return 1st script
  return scripts.length > 0 ? scripts[0].src : '';
};

morpheus.Util.forceDelete = function (obj) {
  try {
    var _garbageCollector = (function () {
      var ef = URL.createObjectURL(new Blob([''], {
        type: 'text/javascript'
      })), w = new Worker(ef);

      URL.revokeObjectURL(ef);
      return w;
    })();

    _garbageCollector.postMessage(obj, [obj]);
  }
  catch (x) {
    console.log('Unable to delete');
  }
};
morpheus.Util.getFileName = function (fileOrUrl) {
  if (morpheus.Util.isFile(fileOrUrl)) {
    return fileOrUrl.name;
  }
  if (fileOrUrl.name !== undefined) {
    return fileOrUrl.name;
  }
  var name = '' + fileOrUrl;
  var question = name.indexOf('?');
  if (question !== -1) {
    var params = name.substring(question + 1);
    var keyValuePairs = decodeURIComponent(params).split('&');

    // check for parameters in name
    for (var i = 0; i < keyValuePairs.length; i++) {
      var pair = keyValuePairs[i].split('=');
      if (pair[0] === 'file' || pair[0] === 'name') {
        name = pair[1];
        break;
      }
    }
  } else {
    var slash = name.lastIndexOf('/');
    if (slash === name.length - 1) {
      name = name.substring(0, name.length - 1);
      slash = name.lastIndexOf('/');
    }
    if (slash !== -1) {
      name = name.substring(slash + 1); // get stuff after slash
    }
  }
  return name;
};
morpheus.Util.prefixWithZero = function (value) {
  return value < 10 ? '0' + value : value;
};
morpheus.Util.getExtension = function (name) {
  name = '' + name;
  var dotIndex = name.lastIndexOf('.');
  if (dotIndex > 0) {
    var suffix = name.substring(dotIndex + 1).toLowerCase();
    if (suffix === 'txt' || suffix === 'gz' || suffix === 'tsv') { // see if file is in
      // the form
      // name.gct.txt
      var newPath = name.substring(0, dotIndex);
      var secondDotIndex = newPath.lastIndexOf('.');
      if (secondDotIndex > 0) {// see if file has another suffix
        var secondSuffix = newPath.substring(secondDotIndex + 1,
          newPath.length).toLowerCase();
        if (secondSuffix === 'segtab' || secondSuffix === 'seg'
          || secondSuffix === 'maf' || secondSuffix === 'gct'
          || secondSuffix === 'txt' || secondSuffix === 'gmt') {
          return secondSuffix;
        }
      }
    }
    return suffix;
  }
  return '';
};
/**
 * Gets the base file name. For example, if name is 'test.txt' the method
 * returns the string 'test'. If the name is 'test.txt.gz', the method also
 * returns the string 'test'.
 *
 * @param name
 *            The file name.
 * @return The base file name.
 */
morpheus.Util.getBaseFileName = function (name) {
  var dotIndex = name.lastIndexOf('.');
  if (dotIndex > 0) {
    var suffix = name.substring(dotIndex + 1, name.length);
    if (suffix === 'gz' || suffix === 'zip' || suffix === 'bz2') {
      return morpheus.Util.getBaseFileName(name.substring(0, dotIndex));
    }
    return name.substring(0, dotIndex);
  }
  return name;
};
morpheus.Util.seq = function (length) {
  var array = [];
  for (var i = 0; i < length; i++) {
    array.push(i);
  }
  return array;
};

morpheus.Util.sequ32 = function (length) {
  var array = new Uint32Array(length);
  for (var i = 0; i < length; i++) {
    array[i] = i;
  }
  return array;
};

/**
 * Converts window hash or search to an object that maps keys to an array of
 * values. For example ?foo=bar returns {foo:[bar]}
 */
morpheus.Util.paramsToObject = function (hash) {
  var search = hash ? window.location.hash : window.location.search;
  if (search.length <= 1) {
    return {};
  }
  search = decodeURIComponent(search);
  var keyValuePairs = search.substring(1).split('&');
  var result = {};
  for (var i = 0, length = keyValuePairs.length; i < length; i++) {
    var pair = keyValuePairs[i].split('=');
    var values = result[pair[0]];
    if (values === undefined) {
      values = [];
      result[pair[0]] = values;
    }
    values.push(pair[1]);
  }
  return result;
};

morpheus.Util.isHeadless = function () {
  return typeof $.ui === 'undefined';
};

morpheus.Util.isFile = function (f) {
  return typeof File !== 'undefined' && f instanceof File;
};
morpheus.Util.endsWith = function (string, suffix) {
  return string.length >= suffix.length
    && string.substr(string.length - suffix.length) === suffix;
};
morpheus.Util.measureSvgText = function (text, classname) {
  if (!text || text.length === 0) {
    return {
      height: 0,
      width: 0
    };
  }
  var container = d3.select('body').append('svg');
  if (classname) {
    container.attr('class', classname);
  }
  container.append('text').attr({
    x: -1000,
    y: -1000
  }).text(text);
  var bbox = container.node().getBBox();
  container.remove();
  return {
    height: bbox.height,
    width: bbox.width
  };
};
morpheus.Util.IS_MAC = false;
if (typeof navigator !== 'undefined') {
  morpheus.Util.IS_MAC = navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i) ? true
    : false;
}
morpheus.Util.COMMAND_KEY = morpheus.Util.IS_MAC ? '&#8984;' : 'Ctrl+';

morpheus.Util.hammer = function (el, recognizers) {
  if (typeof Hammer !== 'undefined') {
    var hammer = new Hammer(el, {
      recognizers: []
    });

    if (_.indexOf(recognizers, 'pan') !== -1) {
      hammer.add(new Hammer.Pan({
        threshold: 1,
        direction: Hammer.DIRECTION_ALL
      }));
    } else if (_.indexOf(recognizers, 'panh') !== -1) {
      hammer.add(new Hammer.Pan({
        threshold: 1,
        direction: Hammer.DIRECTION_HORIZONTAL
      }));
    } else if (_.indexOf(recognizers, 'panv') !== -1) {
      hammer.add(new Hammer.Pan({
        threshold: 1,
        direction: Hammer.DIRECTION_VERTICAL
      }));
    }
    if (_.indexOf(recognizers, 'tap') !== -1) {
      // var singleTap = new Hammer.Tap({
      // event : 'singletap',
      // interval : 50
      // });
      // var doubleTap = new Hammer.Tap({
      // event : 'doubletap',
      // taps : 2
      // });
      // doubleTap.recognizeWith(singleTap);
      // singleTap.requireFailure([ doubleTap ]);
      // hammer.add([ doubleTap, singleTap ]);
      hammer.add(new Hammer.Tap());
    }
    if (_.indexOf(recognizers, 'pinch') !== -1) {
      hammer.add(new Hammer.Pinch());
    }
    if (_.indexOf(recognizers, 'longpress') !== -1) {
      hammer.add(new Hammer.Press({
        event: 'longpress',
        time: 1000
      }));
    }
    if (_.indexOf(recognizers, 'press') !== -1) {
      hammer.add(new Hammer.Press());
    }
    if (_.indexOf(recognizers, 'swipe') !== -1) {
      hammer.add(new Hammer.Swipe());
    }
    return hammer;
  } else {
    return $();
  }

};

morpheus.Util.createTextDecoder = function () {
  if (typeof TextDecoder !== 'undefined') {
    var textDecoder = new TextDecoder();
    return function (buf, start, end) {
      return textDecoder.decode(buf.subarray(start, end));
    };
  } else {
    return function (buf, start, end) {
      // TODO convert in chunks
      var s = [];
      for (var i = start; i < end; i++) {
        s.push(String.fromCharCode(buf[i]));
      }
      return s.join('');
    };
  }
};
morpheus.Util.autocompleteArrayMatcher = function (token, cb, array, fields, max) {
  var filteredSet = new morpheus.Set();
  var regex = new RegExp(morpheus.Util.escapeRegex(token), 'i');
  var regexMatch = new RegExp('(' + morpheus.Util.escapeRegex(token) + ')', 'i');
  // iterate through the pool of strings and for any string that
  // contains the substring `q`, add it to the `matches` array
  if (fields) {
    var nfields = fields.length;
    for (var i = 0, n = array.length; i < n; i++) {
      var item = array[i];
      for (var j = 0; j < nfields; j++) {
        var field = fields[j];
        var value = item[field];
        if (regex.test(value)) {
          filteredSet.add(value);
          break;
        }
      }
      if (filteredSet.size() === max) {
        break;
      }
    }
  } else {
    for (var i = 0, n = array.length; i < n; i++) {
      var value = array[i];
      if (regex.test(value)) {
        filteredSet.add(value);
        if (filteredSet.size() === max) {
          break;
        }
      }

    }
  }
  var matches = [];

  filteredSet.forEach(function (value) {
    var quotedValue = value;
    if (quotedValue.indexOf(' ') !== -1) {
      quotedValue = '"' + quotedValue + '"';
    }
    matches.push({
      value: quotedValue,
      label: '<span>' + value.replace(regexMatch, '<b>$1</b>')
      + '</span>'
    });
  });

  cb(matches);
};

/**
 *
 * @param array. Array of format,data
 */
morpheus.Util.setClipboardData = function (clipboardData, delay) {
  var isRTL = document.documentElement.getAttribute('dir') == 'rtl';
  var fakeElem = document.createElement('div');
  fakeElem.contentEditable = true;

  // Prevent zooming on iOS
  fakeElem.style.fontSize = '12pt';
  // Reset box model

  fakeElem.style.border = '0';
  fakeElem.style.padding = '0';
  fakeElem.style.margin = '0';
  // Move element out of screen horizontally
  fakeElem.style.position = 'absolute';
  fakeElem.style[isRTL ? 'right' : 'left'] = '-999999px';
  // Move element to the same position vertically
  fakeElem.style.top = (window.pageYOffset || document.documentElement.scrollTop) + 'px';
  fakeElem.setAttribute('readonly', '');
  //fakeElem.innerHTML = html;
  var f = function (e) {
    clipboardData.forEach(function (elem) {
      e.clipboardData.setData(elem.format, elem.data);
    });

    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    fakeElem.removeEventListener('copy', f);
  };
  fakeElem.addEventListener('copy', f);

  document.body.appendChild(fakeElem);
  // if (fakeElem.hasAttribute('contenteditable')) {
  fakeElem.focus();
  // }
  var selection = window.getSelection();
  var range = document.createRange();
  range.selectNodeContents(fakeElem);
  selection.removeAllRanges();
  selection.addRange(range);
  if (delay) {
    setTimeout(function () {
      if (!document.execCommand('copy')) {
        console.log('copy failed');
      }
      document.body.removeChild(fakeElem);
    }, 20);
  } else {
    if (!document.execCommand('copy')) {
      console.log('copy failed');
    }
    document.body.removeChild(fakeElem);
  }
};

/**
 * @param {Number}
 *            [options.delay=500] - Delay to short autosuggestions.
 * @param {jQuery}
 *            options.$el - Text box to apply autosuggest to.
 * @param {Function}
 *            options.filter - Callback to invoke to filter a suggested term.
 *            Invoked with array of tokens and response.
 * @param {Function}
 *            options.select - Callback to invoke when a suggested term is
 *            selected.
 * @param {Boolean}
 *            [options.multi=true] - Whether to allow more than one search term.
 * @param {Boolean}
 *            [options.suggestWhenEmpty=true] - Whether to autosuggest terms
 *            when text field is empty.
 *
 */
morpheus.Util.autosuggest = function (options) {
  options = $.extend({}, {
    multi: true,
    delay: 500,
    minLength: 0,
    suggestWhenEmpty: true
  }, options);

  var searching = false;

  function _select(event, ui, isKey) {
    if (ui.item.skip) {
      return false;
    }
    if (options.multi) {
      var terms = morpheus.Util
        .getAutocompleteTokens(
          options.$el[0].value,
          {
            trim: false,
            selectionStart: options.$el[0].selectionStart
          });

      var field = (event.toElement && event.toElement.dataset) ? event.toElement.dataset.autocomplete : null;
      var value = field ? ui.item[field] : ui.item.value;
      var show = ui.item.show;

      // replace the current input
      if (terms.length === 0) {
        terms.push(value);
      } else if (ui.item.clear) {
        terms = [value];
      } else {
        terms[terms.selectionStartIndex === -1
        || terms.selectionStartIndex === undefined ? terms.length - 1
          : terms.selectionStartIndex] = value;
      }
      // add the selected item
      options.$el[0].value = terms.join(' ');
      if ((show && !isKey) || (isKey && event.which === 13)) { // did
        // we
        // select
        // just a
        // field name?
        searching = true;
        setTimeout(function () {
          options.$el.autocomplete('search',
            options.$el.val());
        }, 20);
        setTimeout(function () {
          searching = false;
        }, 100);

      }
      if (!isKey && options.select) {
        options.select();
      }
      return false;
    }
    if (!isKey && options.select) {
      options.select();
    }
    if (!isKey && event.which === 13) {
      event.stopImmediatePropagation();
    }
  }

  options.$el
  // don't navigate away from the field on tab when selecting an item
    .on(
      'keydown',
      function (event) {
        if ((event.keyCode === $.ui.keyCode.TAB)
          && $(this).data('ui-autocomplete').menu.active) {
          event.preventDefault();
        }
      })
    .autocomplete(
      {
        minLength: options.minLength,
        delay: options.delay,
        source: function (request, response) {
          if (request.term.history && options.history) {
            return options.history(response);
          }
          // delegate back to autocomplete, but extract the
          // autocomplete term
          var terms = morpheus.Util
            .getAutocompleteTokens(
              request.term,
              {
                trim: false,
                selectionStart: options.$el[0].selectionStart
              });

          if (terms.selectionStartIndex === undefined
            || terms.selectionStartIndex === -1) {
            terms.selectionStartIndex = terms.length - 1;
          }
          if (options.suggestWhenEmpty || terms.length > 0) {
            options.filter(terms, response);
          }
        },
        focus: function (event, ui) {
          var original = event.originalEvent;
          while (original.originalEvent != null) {
            original = original.originalEvent;
          }
          if (original && /^key/.test(original.type)) {
            return _select(original, ui, true);
          }
          return false;
        },
        select: function (event, ui) {
          return _select(event, ui, false);
        }
      });

  // use html for label instead of default text, class for categories vs. items
  var instance = options.$el.autocomplete('instance');
  if (instance != null) {
    instance._renderItem = function (ul, item) {
      if (item.value == null) { // category
        return $('<li class="' + (item.class ? (' ' + item.class) : '') + ' search-category">')
          .append($('<div>').html(item.label))
          .appendTo(ul);
      }
      return $('<li class="' + (item.class ? (' ' + item.class) : '') + ' search-item">')
        .append($('<div>').html(item.label))
        .appendTo(ul);
    };
    instance._normalize = function (items) {
      return items;
    };
    instance._resizeMenu = function () {
      var ul = this.menu.element;
      ul.outerWidth(instance.element.outerWidth());
    };
  }
  var menu = options.$el.autocomplete('widget');
  menu.menu('option', 'items', '> :not(.search-category)');
  if (menu) {
    menu.addClass('search-menu');
  }
  if (options.suggestWhenEmpty) {
    options.$el.on('focus', function () {
      options.$el.autocomplete('search', options.$el.val());
    });
  }

  options.$el.on('keyup', function (e) {
    if (e.which === 13 && !searching) {
      options.$el.autocomplete('close');
    } else if (e.which === 38 && options.history) { // up arrow
      options.$el.autocomplete('search', {history: true});
    } else if (options.suggestWhenEmpty && options.$el.val() === '') {
      options.$el.autocomplete('search', '');
    }
  });

};

morpheus.Util.getAutocompleteTokens = function (text, options) {
  options = $.extend({}, {
    trim: true
  }, options);
  if (options.trim) {
    text = $.trim(text);
  }
  if (text === '') {
    return [];
  }
  var inQuote = false;
  var inParen = false;
  var tokens = [];
  var currentToken = [];

  for (var i = 0, n = text.length; i < n; i++) {
    var c = text[i];
    if (c === '"') {
      inQuote = !inQuote;
      currentToken.push(c);
    } else if (c === '(' || c === ')') {
      inParen = c === '(';
      currentToken.push(c);
    } else {
      if ((c === ' ' || c === '\t') && !inQuote && !inParen) {
        tokens.push({
          s: currentToken.join(''),
          inSelectionStart: currentToken.inSelectionStart
        });
        currentToken = []; // start new token
      } else { // add to current token
        currentToken.push(c);
      }
    }
    if (i === options.selectionStart - 1) {
      currentToken.inSelectionStart = true;
    }

  }

  tokens.push({
    s: currentToken.join(''),
    inSelectionStart: currentToken.inSelectionStart
  });
  // add trailing token
  if (!options.trim && !inQuote && text[text.length - 1] === ' ') {
    tokens.push({
      s: ' ',
      inSelectionStart: false
    });
  }
  // remove empty tokens
  // keep spaces at end of input "field:value" for next autocomplete
  var filteredTokens = [];
  var selectionStartIndex = -1;
  for (var i = 0, ntokens = tokens.length; i < ntokens; i++) {
    var token = tokens[i];
    var s = token.s;
    if (options.trim || i < (ntokens - 1)) {
      s = $.trim(s);
    }
    if (s !== '') {
      if (token.inSelectionStart) {
        selectionStartIndex = filteredTokens.length;
      }
      filteredTokens.push(s);
    }
  }
  filteredTokens.selectionStartIndex = selectionStartIndex;
  return filteredTokens;
};

morpheus.Util.showDialog = function ($el, title, options) {
  var $dialog = $('<div></div>');
  $el.appendTo($dialog);
  $dialog.appendTo($(document.body));
  if (!options) {
    options = {};
  }
  $dialog.dialog({
    width: 670,
    height: 590,
    title: title,
    // resizeStop : function(event, ui) {
    // var w = parseInt($dialog.width());
    // var h = parseInt($dialog.height());
    // //var d = Math.min(w, h);
    // svg.attr("width", w - 50);
    // svg.attr("height", h - 50);
    // chart.update();
    // },
    close: function (event, ui) {
      $dialog.remove();
      if (options.close) {
        options.close();
      }
    }
  });
};
/**
 * @param sheet
 *            An xlsx sheet
 * @param delim
 *            If a delim is specified each row, will contain a string separated
 *            by delim. Otherwise each row will contain an array.
 */
morpheus.Util.sheetToArray = function (sheet, delim) {
  var r = XLSX.utils.decode_range(sheet['!ref']);
  var rows = [];
  var colors = [];
  var header = [];
  for (var C = r.s.c; C <= r.e.c; ++C) {
    var val = sheet[XLSX.utils.encode_cell({
      c: C,
      r: r.s.r
    })];
    var txt = String(XLSX.utils.format_cell(val));
    header.push(txt);
  }
  for (var R = r.s.r; R <= r.e.r; ++R) {
    var row = [];
    var isRowEmpty = true;
    for (var C = r.s.c; C <= r.e.c; ++C) {
      var val = sheet[XLSX.utils.encode_cell({
        c: C,
        r: R
      })];
      if (!val) {
        row.push('');
        continue;
      }
      isRowEmpty = false;
      var txt = String(XLSX.utils.format_cell(val));
      if (val.s != null && val.s.fgColor != null) {
        var color = '#' + val.s.fgColor.rgb;
        colors.push({
          header: header[row.length],
          color: color,
          value: txt
        });
      }
      row.push(txt);
    }
    if (!isRowEmpty) {
      rows.push(delim ? row.join(delim) : row);
    }
  }
  rows.colors = colors;
  return rows;
};
morpheus.Util.linesToObjects = function (lines) {
  var header = lines[0];
  var array = [];
  var nfields = header.length;
  for (var i = 1, length = lines.length; i < length; i++) {
    var line = lines[i];
    var obj = {};
    for (var f = 0; f < nfields; f++) {
      var value = line[f];
      var field = header[f];
      obj[field] = value;
    }
    array.push(obj);
  }
  return array;
};
/**
 *
 * @param options.data Binary data string
 * @param options.prompt Prompt for sheet name
 * @param callback {Function} Callback
 */
morpheus.Util.xlsxTo2dArray = function (options, callback) {
  var workbook = XLSX.read(options.data, {
    type: 'binary',
    cellFormula: false,
    cellHTML: false,
    cellStyles: true
  });
  var sheetNames = workbook.SheetNames;
  if (options.prompt && sheetNames.length > 1) {
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'sheet',
      type: 'bootstrap-select',
      options: sheetNames,
      required: true,
      style: 'max-width:100px;'
    });
    morpheus.FormBuilder.showInModal({
      title: 'Choose Sheet',
      html: formBuilder.$form,
      focus: document.activeElement,
      onClose: function () {
        var worksheet = workbook.Sheets[formBuilder.getValue('sheet')];
        var lines = morpheus.Util.sheetToArray(worksheet);
        callback(null, lines);
      }
    });

  } else {
    var worksheet = workbook.Sheets[sheetNames[0]];
    var lines = morpheus.Util.sheetToArray(worksheet);
    callback(null, lines);
  }

};
/**
 *
 * @param options.data Binary data string
 * @param options.prompt Prompt for sheet name
 * @param callback {Function} Callback
 */
morpheus.Util.xlsxTo1dArray = function (options, callback) {
  var workbook = XLSX.read(options.data, {
    type: 'binary',
    cellFormula: false,
    cellHTML: false,
    cellStyles: true
  });
  var sheetNames = workbook.SheetNames;
  if (options.prompt && sheetNames.length > 1) {
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'sheet',
      type: 'bootstrap-select',
      options: sheetNames,
      required: true,
      style: 'max-width:100px;'
    });

    morpheus.FormBuilder.showOkCancel({
      title: 'Choose Sheet',
      cancel: false,
      focus: document.activeElement,
      content: formBuilder.$form,
      okCallback: function () {
        var worksheet = workbook.Sheets[formBuilder.getValue('sheet')];
        callback(null, morpheus.Util.sheetToArray(worksheet, '\t'));
      }
    });

  } else {
    var worksheet = workbook.Sheets[sheetNames[0]];
    callback(null, morpheus.Util.sheetToArray(worksheet, '\t'));
  }

};

/**
 * Returns a promise that resolves to a string
 */
morpheus.Util.getText = function (fileOrUrl) {
  var deferred = $.Deferred();
  if (morpheus.Util.isString(fileOrUrl)) {
    fetch(fileOrUrl).then(function (response) {
      if (response.ok) {
        return response.text();
      } else {
        deferred.reject(response.status + ' ' + response.statusText);
      }
    }).then(function (text) {
      // var type = xhr.getResponseHeader('Content-Type');
      deferred.resolve(text);
    }).catch(function (err) {
      deferred.reject(err);
    });
  } else if (morpheus.Util.isFile(fileOrUrl)) {
    var reader = new FileReader();
    reader.onload = function (event) {
      deferred.resolve(event.target.result);
    };
    reader.readAsText(fileOrUrl);
  } else {
    // what is fileOrUrl?
    deferred.resolve(fileOrUrl);
  }
  return deferred.promise();
};
morpheus.Util.createOptions = function (values, none) {
  var html = [];
  if (none) {
    html.push('<option value="">(None)</option>');
  }
  _.each(values, function (val) {
    html.push('<option value="');
    html.push(val);
    html.push('">');
    html.push(val);
    html.push('</option>');
  });
  return html.join('');
};

/**
 * Computes the rank using the given index array. The index array can be
 * obtained from the morpheus.Util.indexSort method. Does not handle ties.
 *
 * @param index
 * @return The ranks.
 */
morpheus.Util.rankIndexArray = function (index) {
  var rank = [];
  var n = index.length;
  for (var j = 0; j < n; j++) {
    rank[index[j]] = j + 1;
  }
  return rank;
};

morpheus.Util.indexSort = function (array, ascending) {
  var pairs = [];
  for (var i = 0, length = array.length; i < length; i++) {
    pairs.push({
      value: array[i],
      index: i
    });
  }
  return morpheus.Util.indexSortPairs(pairs, ascending);
};
morpheus.Util.indexSortPairs = function (array, ascending) {
  if (ascending) {
    array.sort(function (a, b) {
      return (a.value < b.value ? -1 : (a.value === b.value ? (a.index < b.index ? -1 : 1) : 1));
    });
  } else {
    array.sort(function (a, b) {
      return (a.value < b.value ? 1 : (a.value === b.value ? (a.index < b.index ? 1 : -1) : -1));
    });
  }
  var indices = [];
  array.forEach(function (item) {
    indices.push(item.index);
  });
  return indices;
};
morpheus.Util.arrayEquals = function (array1, array2, comparator) {
  if (array1 == array2) {
    return true;
  }
  if (array1 == null || array2 == null) {
    return false;
  }
  if (!comparator) {
    comparator = function (a, b) {
      return a === b;
    };
  }
  var length = array1.length;
  if (array2.length !== length) {
    return false;
  }
  for (var i = 0; i < length; i++) {
    if (!comparator(array1[i], array2[i])) {
      return false;
    }
  }
  return true;
};
morpheus.Util._intFormat = typeof d3 !== 'undefined' ? d3.format(',i')
  : function (d) {
    return '' + Math.round(d);
  };
morpheus.Util.intFormat = function (n) {
  return morpheus.Util._intFormat(n);
};
morpheus.Util._nf = typeof d3 !== 'undefined' ? d3.format('.2f') : function (d) {
  return '' + d;
};

morpheus.Util.getNumberFormatPatternFractionDigits = function (pattern) {
  return parseInt(pattern.substring(1, pattern.length - 1)) || 0;
};

morpheus.Util.nf = function (n) {
  // var str = (n < 1 && n > -1 && n.toPrecision !== undefined) ? n
  // .toPrecision(4) : morpheus.Util._nf(n);
  // return morpheus.Util.removeTrailingZerosInFraction(str);
  return morpheus.Util._nf(n);
};
morpheus.Util.createNumberFormat = function (pattern) {
  var f = d3.format(pattern);
  f.toJSON = function () {
    return {pattern: pattern};
  };
  return f;
};

morpheus.Util.wrapNumber = function (value, object) {
  var n = new Number(value);
  n.toObject = function () {
    return object;
  };
  return n;
};
morpheus.Util.toString = function (value) {
  if (value == null) {
    return '';
  } else if (_.isNumber(value)) {
    return morpheus.Util.nf(value);
  } else if (morpheus.Util.isArray(value)) {
    return morpheus.Util.arrayToString(value, ', ');
  }
  return '' + value;
};

morpheus.Util.arrayToString = function (value, sep) {
  var s = [];
  for (var i = 0, length = value.length; i < length; i++) {
    var val_i = value[i];
    if (_.isNumber(val_i)) {
      s.push(morpheus.Util.nf(val_i));
    } else {
      s.push('' + val_i);
    }

  }
  return s.join(sep);

};
morpheus.Util.removeTrailingZerosInFraction = function (str) {
  var index = str.lastIndexOf('.');
  if (index !== -1) {
    var len = str.length;
    var zeros = len;
    for (var i = len - 1; i > index; i--, zeros--) {
      if (str[i] != '0') {
        break;
      }
    }
    if (zeros === (index + 1)) {
      return str.substring(0, index);
    }
    if (zeros < len) {
      return str.substring(0, index) + str.substring(index, zeros);
    }
  }
  return str;
};
morpheus.Util.s = function (n) {
  return n === 1 ? '' : 's';
};
morpheus.Util.create2dArray = function (rows, columns) {
  var array2d = [];
  for (var i = 0; i < rows; i++) {
    var array = [];
    for (var j = 0; j < columns; j++) {
      array[j] = NaN;
    }
    array2d.push(array);
  }
  return array2d;
};
morpheus.Util.escapeRegex = function (value) {
  return value.replace(/[*]/g, '.*')
    .replace(/[-[\]{}()+?,\\^$|#\s]/g, '\\$&');
};

morpheus.Util.createSearchPredicates = function (options) {
  options = $.extend({}, {
    validateFieldNames: true,
    caseSensitive: true
  }, options);
  var tokens = options.tokens;
  if (tokens == null) {
    return [];
  }
  var availableFields = options.fields;
  if (!options.caseSensitive && availableFields != null) {
    for (var i = 0; i < availableFields.length; i++) {
      availableFields[i] = availableFields[i].toLowerCase();
    }
  }
  var validateFieldNames = options.validateFieldNames;
  var fieldSearchEnabled = !validateFieldNames
    || (availableFields != null && availableFields.length > 0);

  var fieldRegExp = /\\:/g;
  var predicates = [];
  var defaultIsExactMatch = options.defaultMatchMode === 'exact';

  tokens
    .forEach(function (token) {
      var isNot = false;
      if (token[0] === '-') { // not predicate
        token = token.substring(1);
        isNot = true;
      }
      var field = null;
      var semi = token.indexOf(':');
      if (semi > 0) { // field search?
        if (!fieldSearchEnabled
          || token.charCodeAt(semi - 1) === 92) { // \:
          token = token.replace(fieldRegExp, ':');
        } else { // only a field search if field matches
          // one of available fields
          var possibleToken = $.trim(token.substring(semi + 1));
          // check for "field":"val" and "field:val"
          var possibleField = $.trim(token.substring(0, semi)); // split
          // on :
          if (possibleField.length > 0
            && possibleField[0] === '"'
            && possibleField[possibleField.length - 1] === '"') {
            possibleField = possibleField.substring(1,
              possibleField.length - 1);
          } else if (possibleField.length > 0
            && possibleField[0] === '"'
            && possibleToken[possibleToken.length - 1] === '"'
            && possibleToken[0] !== '"') {
            possibleField = possibleField.substring(1,
              possibleField.length);
            possibleToken = '"' + possibleToken;

          }

          if (!validateFieldNames
            || availableFields.indexOf(options.caseSensitive ? possibleField : possibleField.toLowerCase()) !== -1) {
            token = possibleToken;
            field = possibleField;
          }
        }
      }

      var predicate;
      var rangeIndex = -1;
      var rangeToken = null;
      var rangeIndicators = ['..', '>=', '>', '<=', '<', '='];
      for (var i = 0; i < rangeIndicators.length; i++) {
        rangeIndex = token.indexOf(rangeIndicators[i]);
        if (rangeIndex !== -1) {
          rangeToken = rangeIndicators[i];
          break;
        }
      }

      if (rangeIndex !== -1) { // range query
        if (rangeToken === '..') {
          var start = parseFloat(token.substring(0, rangeIndex));
          var end = parseFloat(token.substring(rangeIndex + 2));
          if (!isNaN(start) && !isNaN(end)) {
            predicate = new morpheus.Util.NumberRangePredicate(
              field, start, end);
          }
        } else if (rangeToken === '>') {
          var val = parseFloat(token.substring(rangeIndex + 1));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.GreaterThanPredicate(
              field, val);
          }
        } else if (rangeToken === '>=') {
          var val = parseFloat(token.substring(rangeIndex + 2));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.GreaterThanOrEqualPredicate(
              field, val);
          }
        } else if (rangeToken === '<') {
          var val = parseFloat(token.substring(rangeIndex + 1));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.LessThanPredicate(
              field, val);
          }
        } else if (rangeToken === '<=') {
          var val = parseFloat(token.substring(rangeIndex + 2));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.LessThanOrEqualPredicate(
              field, val);
          }
        } else if (rangeToken === '=') {
          var val = parseFloat(token.substring(rangeIndex + 1));
          predicate = new morpheus.Util.EqualsPredicate(
            field, val);
        } else {
          console.log('Unknown range token:' + rangeToken);
        }
      } else if (token[0] === '"' && token[token.length - 1] === '"') { // exact
        token = token.substring(1, token.length - 1);
        predicate = new morpheus.Util.ExactTermPredicate(field,
          token);
      } else if (token[0] === '(' && token[token.length - 1] === ')') { // exact terms
        token = token.substring(1, token.length - 1);
        var values = morpheus.Util.getAutocompleteTokens(token);

        if (values.length > 0) {
          predicate = new morpheus.Util.ExactTermsPredicate(field,
            values.map(function (val) {
              if (val[0] === '"' && val[val.length - 1] === '"') {
                val = val.substring(1, val.length - 1);
              }
              return val.toLowerCase();
            }));
        }
      } else if (token.indexOf('*') !== -1) { // contains
        predicate = new morpheus.Util.RegexPredicate(field, token);
      } else {
        predicate = defaultIsExactMatch ? new morpheus.Util.ExactTermPredicate(
          field, token)
          : new morpheus.Util.RegexPredicate(field, token);

      }
      if (predicate != null) {
        predicates.push(isNot ? new morpheus.Util.NotPredicate(
          predicate) : predicate);
      }

    });
  return predicates;
}
;

morpheus.Util.createRegExpStringToMatchText = function (text) {
  var tokens = morpheus.Util.getAutocompleteTokens(text);
  if (tokens.length === 0) {
    return null;
  }
  var regex = [];
  _.each(tokens, function (token) {
    if (token[0] === '"' && token[token.length - 1] === '"') {
      token = token.substring(1, token.length - 1);
      regex.push('^' + morpheus.Util.escapeRegex(token) + '$'); // exact
      // match
    } else {
      regex.push(morpheus.Util.escapeRegex(token));
    }
  });
  return '(' + regex.join('|') + ')';
};
morpheus.Util.createRegExpToMatchText = function (text) {
  var s = morpheus.Util.createRegExpStringToMatchText(text);
  return s == null ? null : new RegExp(s, 'i');
};
morpheus.Util.reorderArray = function (array, index) {
  var newArray = [];
  for (var i = 0; i < index.length; i++) {
    newArray.push(array[index[i]]);
  }
  return newArray;
};
morpheus.Util.getSearchString = function () {
  var s = window.location.search;
  return s.length > 1 ? s.substring(1) : '';
};
/**
 * Takes an array of strings and splits each string by \t
 *
 * @return An array of arrays
 */
morpheus.Util.splitLines = function (lines) {
  var tab = /\t/;
  var tokens = [];
  for (var i = 0, nlines = lines.length; i < nlines; i++) {
    var line = lines[i];
    if (line === '') {
      continue;
    }
    tokens.push(line.split(tab));
  }
  return tokens;
};

/**
 * @param file
 *            a File or url
 * @return A deferred object that resolves to an array of strings
 */
morpheus.Util.readLines = function (fileOrUrl, interactive) {
  var isFile = morpheus.Util.isFile(fileOrUrl);
  var isString = morpheus.Util.isString(fileOrUrl);
  var name = morpheus.Util.getFileName(fileOrUrl);
  var ext = morpheus.Util.getExtension(name);
  var deferred = $.Deferred();
  if (isString) { // URL
    if (ext === 'xlsx') {
      var fetchOptions = {};
      if (fileOrUrl.headers) {
        fetchOptions.headers = new Headers();
        for (var header in fileOrUrl.headers) {
          fetchOptions.headers.append(header, fileOrUrl.headers[header]);
        }
      }
      fetch(fileOrUrl, fetchOptions).then(function (response) {
        if (response.ok) {
          return response.arrayBuffer();
        } else {
          deferred.reject(response);
        }
      }).then(function (arrayBuffer) {
        if (arrayBuffer) {
          var data = new Uint8Array(arrayBuffer);
          var arr = [];
          for (var i = 0; i != data.length; ++i) {
            arr[i] = String.fromCharCode(data[i]);
          }
          var bstr = arr.join('');
          morpheus.Util.xlsxTo1dArray({
            data: bstr,
            prompt: interactive
          }, function (err, lines) {
            deferred.resolve(lines);
          });

        } else {
          deferred.reject();
        }
      });
    } else {
      fetch(fileOrUrl, fetchOptions).then(function (response) {
        if (response.ok) {
          return response.text();
        } else {
          deferred.reject();
        }
      }).then(function (text) {
        deferred.resolve(morpheus.Util.splitOnNewLine(text));
      }).catch(function (err) {
        deferred.reject(err);
      });
    }
  } else if (isFile) {
    var reader = new FileReader();
    reader.onerror = function () {
      console.log('Unable to read file');
      deferred.reject('Unable to read file');
    };
    reader.onload = function (event) {
      if (ext === 'xlsx' || ext === 'xls') {
        var data = new Uint8Array(event.target.result);
        var arr = [];
        for (var i = 0; i != data.length; ++i) {
          arr[i] = String.fromCharCode(data[i]);
        }
        var bstr = arr.join('');
        morpheus.Util
          .xlsxTo1dArray({
            data: bstr,
            prompt: interactive
          }, function (err, lines) {
            deferred.resolve(lines);
          });
      } else {
        deferred.resolve(morpheus.Util.splitOnNewLine(event.target.result));
      }

    };
    if (ext === 'xlsx' || ext === 'xls') {
      reader.readAsArrayBuffer(fileOrUrl);
    } else {
      reader.readAsText(fileOrUrl);
    }
  } else { // it's already lines?
    deferred.resolve(fileOrUrl);
  }
  return deferred;
};
morpheus.Util.createValueToIndices = function (array, field) {
  var map = new morpheus.Map();
  _.each(array, function (item) {
    var key = item[field];
    var values = map.get(key);
    if (values === undefined) {
      values = [];
      map.set(key, values);
    }
    values.push(item);
  });
  return map;
};

morpheus.Util.createMorpheusHeader = function () {
  var html = [];
  html.push('<div style="display:inline-block;' +
    ' vertical-align:top;font-size:24px;font-family:sans-serif;">');
  html.push('<span>M</span>');
  html.push('<span>O</span>');
  html.push('<span>R</span>');
  html.push('<span>P</span>');
  html.push('<span>H</span>');
  html.push('<span>E</span>');
  html.push('<span>U</span>');
  html.push('<span>S</span>');
  html.push('</span>');
  html.push('</div>');
  var $div = $(html.join(''));
  var colorScale = d3.scale.linear().domain([0, 4, 7]).range(['#ca0020', '#999999', '#0571b0']).clamp(true);
  var brands = $div.find('span');
  var index = 0;
  var step = function () {
    brands[index].style.color = colorScale(index);
    index++;
    if (index < brands.length) {
      setTimeout(step, 200);
    }
  };
  setTimeout(step, 500);
  return $div;
};
morpheus.Util.createLoadingEl = function () {
  return $(
    '<div style="overflow:hidden;text-align:center;"><i class="fa fa-spinner fa-spin fa-3x"></i><span style="padding-left:4px;vertical-align:middle;font-weight:bold;">Loading...</span></div>');
};
/**
 * Splits a string by the new line character, trimming whitespace
 */
morpheus.Util.splitOnNewLine = function (text, commentChar) {
  var commentCharCode = commentChar !== undefined ? commentChar.charCodeAt(0)
    : undefined;

  var lines = text.split(/\n/);
  if (lines.length === 1) {
    var tmp = text.split(/\r/); // old school mac?
    if (tmp.length > 1) {
      lines = tmp;
    }
  }

  var rows = [];
  var rtrim = /\s+$/;
  for (var i = 0, nlines = lines.length; i < nlines; i++) {
    var line = lines[i].replace(rtrim, '');
    if (line !== '') {
      if (commentCharCode !== undefined) {
        if (line.charCodeAt(0) !== commentCharCode) {
          rows.push(line);
        }
      } else {
        rows.push(line);
      }
    }
  }
  return rows;
};

morpheus.Util.ContainsPredicate = function (field, text) {
  this.field = field;
  text = text.toLowerCase();
  this.text = text;
};
morpheus.Util.ContainsPredicate.prototype = {
  accept: function (value) {
    if (value == null) {
      return false;
    }
    value = ('' + value).toLowerCase();
    return value.indexOf(this.text) !== -1;
  },
  getField: function () {
    return this.field;
  },
  getText: function () {
    return this.text;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'ContainsPredicate ' + this.field + ':' + this.text;
  }
};
morpheus.Util.ExactTermsPredicate = function (field, values) {
  this.field = field;
  this.values = new morpheus.Set();
  for (var i = 0, nvalues = values.length; i < nvalues; i++) {
    this.values.add(values[i]);
  }
};
morpheus.Util.ExactTermsPredicate.prototype = {
  accept: function (value) {
    if (value == null) {
      return false;
    }
    value = ('' + value).toLowerCase();
    return this.values.has(value);
  },
  getField: function () {
    return this.field;
  },
  getValues: function () {
    return this.values;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'ExactTermsPredicate ' + this.field + ':' + this.text;
  }
};

morpheus.Util.ExactTermPredicate = function (field, term) {
  this.field = field;
  term = term.toLowerCase();
  this.text = term;
};
morpheus.Util.ExactTermPredicate.prototype = {
  accept: function (value) {
    if (value == null) {
      return false;
    }
    value = ('' + value).toLowerCase();
    return value === this.text;
  },
  getField: function () {
    return this.field;
  },
  getText: function () {
    return this.text;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'ExactTermPredicate ' + this.field + ':' + this.text;
  }
};
morpheus.Util.RegexPredicate = function (field, text) {
  this.field = field;
  this.text = text;
  this.regex = new RegExp(morpheus.Util.escapeRegex(text), 'i');
};
morpheus.Util.RegexPredicate.prototype = {
  accept: function (value) {
    return this.regex.test('' + value);
  },
  getField: function () {
    return this.field;
  },
  getText: function () {
    return this.text;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'RegexPredicate ' + this.field + ':' + this.regex;
  }
};
morpheus.Util.NumberRangePredicate = function (field, min, max) {
  this.field = field;
  this.min = min;
  this.max = max;
};
morpheus.Util.NumberRangePredicate.prototype = {
  accept: function (value) {
    return value >= this.min && value <= this.max;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  },
  toString: function () {
    return 'NumberRangePredicate ' + this.field + ':' + this.min + '...'
      + this.max;
  }
};

morpheus.Util.GreaterThanPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.GreaterThanPredicate.prototype = {
  accept: function (value) {
    return value > this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};

morpheus.Util.GreaterThanOrEqualPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.GreaterThanOrEqualPredicate.prototype = {
  accept: function (value) {
    return value >= this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.LessThanPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.LessThanPredicate.prototype = {
  accept: function (value) {
    return value < this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.LessThanOrEqualPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.LessThanOrEqualPredicate.prototype = {
  accept: function (value) {
    return value <= this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.EqualsPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.EqualsPredicate.prototype = {
  accept: function (value) {
    return value === this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.NotPredicate = function (p) {
  this.p = p;
};
morpheus.Util.NotPredicate.prototype = {
  accept: function (value) {
    return !this.p.accept(value);
  },
  getField: function () {
    return this.p.getField();
  },
  isNumber: function () {
    return this.p.isNumber();
  },
  toString: function () {
    return 'NotPredicate ' + this.p;
  }
};

// code taken from KineticJS
morpheus.Events = function () {
};
morpheus.Events.prototype = {
  /**
   * Pass in a string of events delimmited by a space to bind multiple events
   * at once such as 'mousedown mouseup mousemove'. Include a namespace to
   * bind an event by name such as 'click.foobar'.
   *
   * @param {String}
   *            evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo
   *            touchstart.foo'
   * @param {Function}
   *            handler The handler function is passed an event object
   */
  on: function (evtStr, handler) {
    if (!handler) {
      throw Error('Handler not specified');
    }
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    var events = evtStr.split(' '), len = events.length, n, event, parts, baseEvent, name;
    /*
     * loop through types and attach event listeners to each one. eg. 'click
     * mouseover.namespace mouseout' will create three event bindings
     */
    for (n = 0; n < len; n++) {
      event = events[n];
      parts = event.split('.');
      baseEvent = parts[0];
      name = parts[1] || '';
      // create events array if it doesn't exist
      if (!this.eventListeners[baseEvent]) {
        this.eventListeners[baseEvent] = [];
      }
      this.eventListeners[baseEvent].push({
        name: name,
        handler: handler
      });
    }
    return this;
  },
  getListeners: function () {
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    return this.eventListeners;
  },
  setListeners: function (eventListeners) {
    this.eventListeners = eventListeners;
  },
  /**
   * Fire an event.
   *
   * @param eventType
   * @param evt
   */
  trigger: function (eventType, evt) {
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    if (!evt) {
      evt = {};
    }
    evt.type = eventType;
    if (!evt.source) {
      evt.source = this;
    }
    var events = this.eventListeners[eventType];
    if (events) {
      var len = events.length;
      for (var i = 0; i < len; i++) {
        events[i].handler.apply(this, [evt]);
      }
    }
    return this;
  },
  /**
   * Remove event bindings. Pass in a string of event types delimmited by a
   * space to remove multiple event bindings at once such as 'mousedown
   * mouseup mousemove'. include a namespace to remove an event binding by
   * name such as 'click.foobar'. If you only give a name like '.foobar', all
   * events in that namespace will be removed.
   *
   * @param {String}
   *            evtStr e.g. 'click', 'mousedown.foo touchstart', '.foobar'
   */
  off: function (evtStr, handler) {
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    var events = (evtStr || '').split(' '), len = events.length, n, t, event, parts, baseEvent, name;
    if (!evtStr) {
      // remove all events
      for (t in this.eventListeners) {
        this._off(t, null, handler);
      }
    }
    for (n = 0; n < len; n++) {
      event = events[n];
      parts = event.split('.');
      baseEvent = parts[0];
      name = parts[1];
      if (baseEvent) {
        if (this.eventListeners[baseEvent]) {
          this._off(baseEvent, name, handler);
        }
      } else {
        for (t in this.eventListeners) {
          this._off(t, name, handler);
        }
      }
    }
    return this;
  },
  _off: function (type, name, handler) {
    var evtListeners = this.eventListeners[type], i, evtName;
    for (i = 0; i < evtListeners.length; i++) {
      evtName = evtListeners[i].name;
      // check if an event name is not specified, or if one is specified,
      // it matches the current event name
      if ((!name || evtName === name)
        && (handler == null || handler == evtListeners[i].handler)) {
        evtListeners.splice(i, 1);
        if (evtListeners.length === 0) {
          delete this.eventListeners[type];
          break;
        }
        i--;
      }
    }
  }
};

morpheus.Identifier = function (array) {
  this.array = array;
};
morpheus.Identifier.prototype = {
  toString: function () {
    return this.array.join(',');
  },
  equals: function (otherId) {
    var other = otherId.getArray();
    var length = this.array.length;
    if (other.length !== length) {
      return false;
    }
    for (var i = 0; i < length; i++) {
      if (this.array[i] !== other[i]) {
        return false;
      }
    }
    return true;
  },
  getArray: function () {
    return this.array;
  }
};

morpheus.Map = function () {
  this.map = {}; // object string -> key, value
  // the key field is stored to get the original key object back
  this.n = 0;
};
morpheus.Map.prototype = {
  toJSON: function () {
    var json = {};
    this.forEach(function (value, key) {
      json[key] = value;
    });
    return json;
  },
  toString: function () {
    var s = [];
    this.forEach(function (value, key) {
      if (s.length > 0) {
        s.push(', ');
      }
      s.push(key);
      s.push('=');
      s.push(value);
    });
    return s.join('');
  },
  keys: function () {
    var keys = [];
    for (var key in this.map) {
      var pair = this.map[key];
      keys.push(pair.key);
    }
    return keys;
  },
  size: function () {
    return this.n;
  },
  equals: function (m) {
    if (m.size() !== this.size()) {
      return false;
    }
    var ret = true;
    try {
      this.forEach(function (value, key) {
        if (value !== m.get(key)) {
          ret = false;
          throw 'break'; // break out of loop
        }
      });
    }
    catch (e) {
      // catch break out of loop
    }
    return ret;
  },
  setAll: function (map) {
    var _this = this;
    map.forEach(function (value, key) {
      _this.set(key, value);
    });
  },
  set: function (key, value) {
    var skey = '\0' + key;
    var previous = this.map[skey];
    if (previous === undefined) { // only increment size when this is a
      // new key
      this.n++;
    }
    this.map[skey] = {
      key: key,
      value: value
    };
  },
  forEach: function (callback) {
    for (var key in this.map) {
      var pair = this.map[key];
      callback(pair.value, pair.key);
    }
  },
  entries: function () {
    var array = [];
    this.forEach(function (value, key) {
      array.push({
        value: value,
        key: key
      });
    });
    return array;
  },
  values: function () {
    var values = [];
    for (var key in this.map) {
      var pair = this.map[key];
      values.push(pair.value);
    }
    return values;
  },
  get: function (key) {
    var skey = '\0' + key;
    var pair = this.map[skey];
    return pair !== undefined ? pair.value : undefined;
  },
  clear: function () {
    this.map = {};
    this.n = 0;
  },
  remove: function (key) {
    var skey = '\0' + key;
    var pair = this.map[skey];
    if (pair !== undefined) {
      delete this.map[skey];
      this.n--;
      return pair.value;
    }
  },
  has: function (key) {
    var skey = '\0' + key;
    return this.map[skey] !== undefined;
  }
};

morpheus.Map.fromJSON = function (json) {
  var map = new morpheus.Map();
  for (var key in json) {
    map.set(key, json[key]);
  }
  return map;
};

morpheus.Set = function () {
  this._map = new morpheus.Map();
};
morpheus.Set.prototype = {
  toJSON: function () {
    var json = [];
    this.forEach(function (value) {
      json.push(value);
    });
    return json;
  },
  toString: function () {
    var s = [];
    this.forEach(function (key) {
      if (s.length > 0) {
        s.push(', ');
      }
      s.push(key);
    });
    return s.join('');
  },
  size: function () {
    return this._map.size();
  },
  equals: function (m) {
    return this._map.equals(m);
  },
  forEach: function (callback) {
    this._map.forEach(function (value, key) {
      callback(key);
    });
  },
  add: function (value) {
    this._map.set(value, true);
  },
  values: function () {
    var values = [];
    this._map.forEach(function (value, key) {
      values.push(key);
    });
    return values;
  },
  clear: function () {
    this._map.clear();
  },
  remove: function (key) {
    this._map.remove(key);
  },
  has: function (key) {
    return this._map.has(key);
  }
};

morpheus.Set.fromJSON = function (json) {
  var set = new morpheus.Set();
  for (var i = 0, length = json.length; i < length; i++) {
    set.add(json[i]);
  }
  return set;
};

morpheus.ArrayBufferReader = function (buffer) {
  this.buffer = buffer;
  this.bufferLength = buffer.length;
  this.index = 0;
  this.decoder = morpheus.Util.createTextDecoder();
};

morpheus.ArrayBufferReader.prototype = {
  readLine: function () {
    var index = this.index;
    var bufferLength = this.bufferLength;
    if (index >= bufferLength) {
      return null;
    }
    var buffer = this.buffer;
    var start = index;
    var end = start;
    // dos: \r\n, old mac:\r
    for (; index < bufferLength; index++) {
      var c = buffer[index];
      if (c === 10 || c === 13) { // \n or \r
        end = index;
        if ((index !== bufferLength - 1) && buffer[index + 1] === 10) { // skip
          // ahead
          index++;
        }
        index++;
        break;
      }
    }
    this.index = index;
    if (start === end && index === bufferLength) { // eof
      return this.decoder(this.buffer, start, bufferLength);
    }

    return this.decoder(this.buffer, start, end);

  }
};

morpheus.ArrayBufferReader.getArrayBuffer = function (fileOrUrl, callback) {
  var isString = typeof fileOrUrl === 'string' || fileOrUrl instanceof String;
  if (isString) { // URL
    var fetchOptions = {};
    if (fileOrUrl.headers) {
      fetchOptions.headers = new Headers();
      for (var header in fileOrUrl.headers) {
        fetchOptions.headers.append(header, fileOrUrl.headers[header]);
      }
    }
    fetch(fileOrUrl, fetchOptions).then(function (response) {
      if (response.ok) {
        return response.arrayBuffer();
      } else {
        callback(new Error(fileOrUrl + ' status: ' + response.status));
      }
    }).then(function (buf) {
      callback(null, buf);
    }).catch(function (error) {
      console.log('Fetch error', error);
      callback(error);
    });

  } else {
    var reader = new FileReader();
    reader.onload = function (event) {
      callback(null, event.target.result);
    };
    reader.onerror = function (event) {
      callback(event);
    };
    reader.readAsArrayBuffer(fileOrUrl);
  }
};

morpheus.Array2dReaderInteractive = function () {

};

morpheus.Array2dReaderInteractive.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util.getFileName(fileOrUrl));
    var html = [];
    html.push('<div>');
    html.push('<label>Click the table cell containing the first data row and column.</label>');
    html.push('<div class="checkbox"> <label> <input name="transpose" type="checkbox">' +
      ' Tranpose </label>' +
      ' </div>');

    html.push('<div' +
      ' style="display:inline-block;width:10px;height:10px;background-color:#b3cde3;"></div><span> Data Matrix</span>');
    html.push('<br /><div' +
      ' style="display:inline-block;width:10px;height:10px;background-color:#fbb4ae;"></div><span> Column' +
      ' Annotations</span>');
    html.push('<br /><div' +
      ' style="display:inline-block;' +
      ' width:10px;height:10px;background-color:#ccebc5;"></div><span> Row' +
      ' Annotations</span>');

    html.push('<div class="slick-bordered-table" style="width:550px;height:300px;"></div>');
    html.push('</div>');
    var $el = $(html.join(''));

    morpheus.Util.readLines(fileOrUrl, true).done(function (lines) {
      // show in table
      var tab = /\t/;
      for (var i = 0, nrows = lines.length; i < nrows; i++) {
        lines[i] = lines[i].split(tab);
      }
      var grid;
      var columns = [];
      for (var j = 0, ncols = lines[0].length; j < ncols; j++) {
        columns.push({
          id: j,
          field: j
        });
      }

      var dataRowStart = 1;
      var dataColumnStart = 1;
      var _lines = lines;
      var grid = new Slick.Grid($el.find('.slick-bordered-table')[0], lines, columns, {
        enableCellNavigation: true,
        headerRowHeight: 0,
        showHeaderRow: false,
        multiColumnSort: false,
        multiSelect: false,
        topPanelHeight: 0,
        enableColumnReorder: false,
        enableTextSelectionOnCells: true,
        forceFitColumns: false,
        defaultFormatter: function (row, cell, value, columnDef, dataContext) {
          var color = 'white';
          if (cell >= dataColumnStart && row >= dataRowStart) {
            color = '#b3cde3'; // data
          } else if (row <= (dataRowStart - 1) && cell >= dataColumnStart) {
            color = '#fbb4ae'; // column
          } else if (cell < dataColumnStart && row >= dataRowStart) {
            color = '#ccebc5'; // row
          }
          var html = ['<div style="width:100%;height:100%;background-color:' + color + '">'];
          if (_.isNumber(value)) {
            html.push(morpheus.Util.nf(value));
          } else if (morpheus.Util.isArray(value)) {
            var s = [];
            for (var i = 0, length = value.length; i < length; i++) {
              if (i > 0) {
                s.push(', ');
              }
              var val = value[i];
              s.push(value[i]);
            }
            html.push(s.join(''));
          } else {
            html.push(value);
          }
          html.push('</div>');
          return html.join('');
        }
      });
      var transposedLines;
      var transposedColumns;
      $el.find('[name=transpose]').on('click', function (e) {
        if ($(this).prop('checked')) {
          if (transposedLines == null) {
            transposedLines = [];
            for (var j = 0, ncols = lines[0].length; j < ncols; j++) {
              var row = [];
              transposedLines.push(row);
              for (var i = 0, nrows = lines.length; i < nrows; i++) {
                row.push(lines[i][j]);
              }
            }

            transposedColumns = [];
            for (var j = 0, ncols = transposedLines[0].length; j < ncols; j++) {
              transposedColumns.push({
                id: j,
                field: j
              });
            }

          }
          lines = transposedLines;
          grid.setData(transposedLines);
          grid.setColumns(transposedColumns);
          grid.resizeCanvas();
          grid.invalidate();
        } else {
          grid.setData(_lines);
          grid.setColumns(columns);
          grid.resizeCanvas();
          grid.invalidate();
          lines = _lines;
        }
      });
      grid.onClick.subscribe(function (e, args) {
        dataRowStart = args.row;
        dataColumnStart = args.cell;
        grid.invalidate();
      });

      $el.find('.slick-header').remove();
      var footer = [];
      footer
        .push('<button name="ok" type="button" class="btn btn-default">OK</button>');
      footer
        .push('<button name="cancel" type="button" data-dismiss="modal" class="btn btn-default">Cancel</button>');
      var $footer = $(footer.join(''));

      morpheus.FormBuilder.showOkCancel({
        title: 'Open',
        content: $el,
        close: false,
        focus: document.activeElement,
        cancelCallback: function () {
          callback(null);
        },
        okCallback: function () {
          _this._read(name, lines, dataColumnStart, dataRowStart, callback);
        }
      });
      grid.resizeCanvas();

    }).fail(function (err) {
      callback(err);
    });

  },
  _read: function (datasetName, lines, dataColumnStart, dataRowStart, cb) {
    var columnCount = lines[0].length;
    var columns = columnCount - dataColumnStart;
    var rows = lines.length - dataRowStart;
    var dataset = new morpheus.Dataset({
      name: datasetName,
      rows: rows,
      columns: columns,
      dataType: 'Float32'
    });

    // column metadata names are in 1st
    // column
    if (dataColumnStart > 0) {
      for (var i = 0; i < dataRowStart; i++) {
        var name = lines[i][0];
        if (name == null || name === '' || name === 'na') {
          name = 'id';
        }
        var unique = 1;
        while (dataset.getColumnMetadata().getByName(name) != null) {
          name = name + '-' + unique;
          unique++;
        }
        var v = dataset.getColumnMetadata().add(name);
        var nonEmpty = false;
        for (var j = 0; j < columns; j++) {
          var s = lines[i][j + dataColumnStart];
          if (s != null && s !== '') {
            nonEmpty = true;
            v.setValue(j, s);
          }
        }
        if (!nonEmpty) {
          dataset.getColumnMetadata().remove(morpheus.MetadataUtil.indexOf(dataset.getColumnMetadata(), v.getName()));
        }

      }
    }
    if (dataRowStart > 0) {
      // row metadata names are in first row
      for (var j = 0; j < dataColumnStart; j++) {
        var name = lines[0][j];
        if (name == null || name === '') {
          name = 'id';
        }
        var unique = 1;
        while (dataset.getRowMetadata().get(name) != null) {
          name = name + '-' + unique;
          unique++;
        }
        dataset.getRowMetadata().add(name);

      }
    }

    for (var i = 0; i < rows; i++) {
      for (var j = 0, k = 0; k < dataset.getRowMetadata().getMetadataCount(); j++, k++) {
        var metaDataValue = lines[i + dataRowStart][j];
        dataset.getRowMetadata().get(j).setValue(i, metaDataValue);
      }
    }

    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        var s = lines[i + dataRowStart][j + dataColumnStart];
        dataset.setValue(i, j, parseFloat(s));
      }
    }

    morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
    morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
      1);
    cb(null, dataset);
  }
};

morpheus.BufferedReader = function (reader, callback, doneCallback) {
  var textDecoder = morpheus.Util.createTextDecoder();
  var skipLF = false;
  var text = '';
  reader.read().then(function processResult(result) {
    // result contains a value which is an array of Uint8Array
    text += (result.done ? '' : textDecoder(result.value, 0, result.value.length));
    var start = 0;
    // TODO no need to search previous chunk of text
    for (var i = 0, length = text.length; i < length; i++) {
      var c = text[i];
      if (skipLF && c === '\n') {
        start++;
        skipLF = false;
      } else if (c === '\n' || c === '\r') {
        skipLF = c === '\r'; // \r\n windows line ending
        var s = morpheus.Util.copyString(text.substring(start, i));
        callback(s);
        start = i + 1;
      } else {
        skipLF = false;
      }
    }
    text = start < text.length ? text.substring(start) : '';
    if (!result.done) {
      return reader.read().then(processResult);
    } else {
      if (text !== '' && text !== '\r') {
        callback(text);
      }
      doneCallback();
    }
  });
};

morpheus.BufferedReader.parse = function (url, options) {
  var delim = options.delimiter;
  var regex = new RegExp(delim);
  var handleTokens = options.handleTokens;
  var complete = options.complete;

  var fetchOptions = {};
  if (url.headers) {
    fetchOptions.headers = new Headers();
    for (var header in url.headers) {
      fetchOptions.headers.append(header, url.headers[header]);
    }
  }
  fetch(url, fetchOptions).then(function (response) {
    if (response.ok) {
      var reader = response.body.getReader();
      new morpheus.BufferedReader(reader, function (line) {
        handleTokens(line.split(regex));
      }, function () {
        complete();
      });
    } else {
      options.error('Network error');
    }
  }).catch(function (error) {
    options.error(error);
  });
};


/**
 * Class for reading cls files. <p/> <p/> The CLS files are simple files created
 * to load class information into GeneCluster. These files use spaces to
 * separate the fields.
 * </P>
 * <UL>
 * <LI>The first line of a CLS file contains numbers indicating the number of
 * samples and number of classes. The number of samples should correspond to the
 * number of samples in the associated RES or GCT data file.</LI>
 * <p/>
 * <UL>
 * <LI>Line format: (number of samples) (space) (number of classes) (space) 1</LI>
 * <LI>For example: 58 2 1</LI>
 * </UL>
 * <p/>
 * <LI>The second line in a CLS file contains names for the class numbers. The
 * line should begin with a pound sign (#) followed by a space.</LI>
 * <p/>
 * <UL>
 * <LI>Line format: # (space) (class 0 name) (space) (class 1 name)</LI>
 * <p/>
 * <LI>For example: # cured fatal/ref.</LI>
 * </UL>
 * <p/>
 * <LI>The third line contains numeric class labels for each of the samples.
 * The number of class labels should be the same as the number of samples
 * specified in the first line.</LI>
 * <UL>
 * <LI>Line format: (sample 1 class) (space) (sample 2 class) (space) ...
 * (sample N class)</LI>
 * <LI>For example: 0 0 0 ... 1
 * </UL>
 * <p/>
 * </UL>
 */
morpheus.ClsReader = function () {
};
morpheus.ClsReader.prototype = {
  /**
   * Parses the cls file.
   *
   * @param lines
   *            The lines to read.
   * @throw Error If there is a problem with the data
   */
  read: function (lines) {
    var regex = /[ ,]+/;
    // header= <num_data> <num_classes> 1
    var header = lines[0].split(regex);
    if (header.length < 3) {
      throw new Error('Header line needs three numbers');
    }
    var headerNumbers = [];
    try {
      for (var i = 0; i < 3; i++) {
        headerNumbers[i] = parseInt($.trim(header[i]));
      }
    }
    catch (e) {
      throw new Error('Header line element ' + i + ' is not a number');
    }
    if (headerNumbers[0] <= 0) {
      throw new Error(
        'Header line missing first number, number of data points');
    }
    if (headerNumbers[1] <= 0) {
      throw new Error(
        'Header line missing second number, number of classes');
    }
    var numClasses = headerNumbers[1];
    var numItems = headerNumbers[0];
    var classDefinitionLine = lines[1];
    classDefinitionLine = classDefinitionLine.substring(classDefinitionLine
      .indexOf('#') + 1);
    var classNames = $.trim(classDefinitionLine).split(regex);
    if (classNames.length < numClasses) {
      throw new Error('First line specifies ' + numClasses
        + ' classes, but found ' + classNames.length + '.');
    }
    var dataLine = lines[2];
    var assignments = dataLine.split(regex);
    // convert the assignments to names
    for (var i = 0; i < assignments.length; i++) {
      var assignment = $.trim(assignments[i]);
      var index = parseInt(assignment);
      var tmp = classNames[index];
      if (tmp !== undefined) {
        assignments[i] = tmp;
      }
    }
    return assignments;
  }
};

morpheus.ClsWriter = function () {

};
morpheus.ClsWriter.prototype = {
  write: function (vector) {
    var pw = [];
    var size = vector.size();
    pw.push(size);
    pw.push(' ');
    var set = morpheus.VectorUtil.getSet(vector);
    pw.push(set.size());
    pw.push(' ');
    pw.push('1\n');
    pw.push('#');
    var valueToIndex = new morpheus.Map();
    var index = 0;
    set.forEach(function (name) {
      pw.push(' ');
      pw.push(name);
      valueToIndex.set(name, index++);
    });
    pw.push('\n');
    for (var i = 0; i < size; i++) {
      if (i > 0) {
        pw.push(' ');
      }
      pw.push(valueToIndex.get(vector.getValue(i)));
    }
    pw.push('\n');
    return pw.join('');
  }
};

morpheus.GctReader = function () {

};

morpheus.GctReader.prototype = {
  getFormatName: function () {
    return 'gct';
  },
  read: function (fileOrUrl, callback) {
    var _this = this;
    if (morpheus.Util.isFile(fileOrUrl)) {
      this._readChunking(fileOrUrl, callback, false);
    } else {
      if (morpheus.Util.isFetchStreamingSupported()) {
        this._readChunking(fileOrUrl, callback, true);
      } else {
        this._readNoChunking(fileOrUrl, callback);
      }
      // XXX only do byte range requests from S3
      // if (fileOrUrl.indexOf('s3.amazonaws.com') !== -1) {
      // 	$.ajax({
      // 		url: fileOrUrl,
      // 		method: 'HEAD'
      // 	}).done(function (data, textStatus, jqXHR) {
      // 		if ('gzip' === jqXHR.getResponseHeader('Content-Encoding')) {
      // 			_this._readNoChunking(fileOrUrl, callback);
      // 		} else {
      // 			_this._readChunking(fileOrUrl, callback, false);
      // 		}
      // 	}).fail(function () {
      // 		_this._readNoChunking(fileOrUrl, callback);
      // 	});
      // } else {
      // 	_this._readNoChunking(fileOrUrl, callback);
      // }
    }
  },
  _readChunking: function (fileOrUrl, callback, useFetch) {
    var _this = this;
    // Papa.LocalChunkSize = 10485760 * 10; // 100 MB
    //Papa.RemoteChunkSize = 10485760 / 2; // 10485760 = 10MB
    var lineNumber = 0;
    var version;
    var numRowAnnotations = 1; // in addition to row id
    var numColumnAnnotations = 0; // in addition to column id
    var nrows = -1;
    var ncols = -1;
    var version = 2;
    var rowMetadataNames = [];
    var columnMetadataNames = [];
    var rowMetadata = [[]];
    var columnMetadata = [[]];
    var dataColumnStart;
    var matrix = [];
    var dataMatrixLineNumberStart;
    var columnIdFieldName = 'id';
    var rowIdFieldName = 'id';
    var columnNamesArray;

    var handleTokens = function (tokens) {
      if (lineNumber === 0) {
        var text = tokens[0].trim();
        if ('#1.2' === text) {
          version = 2;
        } else if ('#1.3' === text) {
          version = 3;
        } else {
          console.log('Unknown version: assuming version 2');
        }
      } else if (lineNumber === 1) {
        var dimensions = tokens;
        if (version === 3) {
          if (dimensions.length >= 4) {
            nrows = parseInt(dimensions[0]);
            ncols = parseInt(dimensions[1]);
            numRowAnnotations = parseInt(dimensions[2]);
            numColumnAnnotations = parseInt(dimensions[3]);
          } else { // no dimensions specified
            numRowAnnotations = parseInt(dimensions[0]);
            numColumnAnnotations = parseInt(dimensions[1]);
          }
        } else {
          nrows = parseInt(dimensions[0]);
          ncols = parseInt(dimensions[1]);
          if (nrows <= 0 || ncols <= 0) {
            callback(
              'Number of rows and columns must be greater than 0.');
          }
        }
        dataColumnStart = numRowAnnotations + 1;
      } else if (lineNumber === 2) {
        columnNamesArray = tokens;
        for (var i = 0; i < columnNamesArray.length; i++) {
          columnNamesArray[i] = morpheus.Util.copyString(columnNamesArray[i]);
        }
        if (ncols === -1) {
          ncols = columnNamesArray.length - numRowAnnotations - 1;
        }
        if (version == 2) {
          var expectedColumns = ncols + 2;
          if (columnNamesArray.length !== expectedColumns) {
            // check for trailing tabs
            if (columnNamesArray.length > expectedColumns) {
              var skip = columnNamesArray.length - 1;
              for (var i = columnNamesArray.length - 1; i >= 0; i--, skip--) {
                if (columnNamesArray[i] !== '') {
                  break;
                }
              }
              if (skip !== columnNamesArray.length - 1) {
                columnNamesArray = columnNamesArray.slice(0, skip + 1);
              }
            }
            if (columnNamesArray.length !== expectedColumns) {
              return callback('Expected ' + (expectedColumns - 2)
                + ' column names, but read '
                + (columnNamesArray.length - 2) + ' column names.');
            }
          }
        }
        var name = columnNamesArray[0];
        var slashIndex = name.lastIndexOf('/');

        if (slashIndex != -1 && slashIndex < (name.length - 1)) {
          rowIdFieldName = name.substring(0, slashIndex);
          columnIdFieldName = name.substring(slashIndex + 1);
        }
        rowMetadataNames.push(rowIdFieldName);
        columnMetadataNames.push(columnIdFieldName);
        for (var j = 0; j < ncols; j++) {
          var index = j + numRowAnnotations + 1;
          var columnName = index < columnNamesArray.length ? columnNamesArray[index]
            : null;
          columnMetadata[0].push(morpheus.Util.copyString(columnName));
        }

        for (var j = 0; j < numRowAnnotations; j++) {
          var rowMetadataName = '' === columnNamesArray[1] ? 'description'
            : columnNamesArray[j + 1];
          rowMetadataNames.push(
            rowMetadataName);
          rowMetadata.push([]);
        }
        dataMatrixLineNumberStart = 3 + numColumnAnnotations;
      } else { // lines >=3
        if (lineNumber < dataMatrixLineNumberStart) {
          var metadataName = morpheus.Util.copyString(tokens[0]);
          var v = [];
          columnMetadata.push(v);
          columnMetadataNames.push(metadataName);
          for (var j = 0; j < ncols; j++) {
            v.push(morpheus.Util.copyString(tokens[j + dataColumnStart]));
          }
        } else { // data lines
          if (tokens[0] !== '') {
            var array = new Float32Array(ncols);
            matrix.push(array);
            // we iterate to numRowAnnotations + 1 to include id row
            // metadata field
            for (var rowAnnotationIndex = 0; rowAnnotationIndex <= numRowAnnotations; rowAnnotationIndex++) {
              var rowMetadataValue = tokens[rowAnnotationIndex];
              rowMetadata[rowAnnotationIndex].push(
                morpheus.Util.copyString(rowMetadataValue));

            }

            for (var columnIndex = 0; columnIndex < ncols; columnIndex++) {
              var token = tokens[columnIndex + dataColumnStart];
              array[columnIndex] = parseFloat(token);
            }
          }
        }
      }
      lineNumber++;

    };
    (useFetch ? morpheus.BufferedReader : Papa).parse(fileOrUrl, {
      delimiter: '\t',	// auto-detect
      newline: '',	// auto-detect
      header: false,
      dynamicTyping: false,
      preview: 0,
      encoding: '',
      worker: false,
      comments: false,
      handleTokens: handleTokens,
      step: function (result) {
        handleTokens(result.data[0]);
      },
      complete: function () {
        var dataset = new morpheus.Dataset({
          name: morpheus.Util.getBaseFileName(morpheus.Util
            .getFileName(fileOrUrl)),
          rows: matrix.length,
          columns: ncols,
          array: matrix,
          dataType: 'Float32'
        });
        for (var i = 0; i < rowMetadataNames.length; i++) {
          dataset.getRowMetadata().add(rowMetadataNames[i]).array = rowMetadata[i];
        }
        for (var i = 0; i < columnMetadataNames.length; i++) {
          dataset.getColumnMetadata().add(columnMetadataNames[i]).array = columnMetadata[i];
        }
        morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
        morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
          1);
        callback(null, dataset);
      },
      error: function (err) {
        callback(err);
      },
      download: !morpheus.Util.isFile(fileOrUrl),
      skipEmptyLines: false,
      chunk: undefined,
      fastMode: true,
      beforeFirstChunk: undefined,
      withCredentials: undefined
    });
  },
  _read: function (datasetName, reader) {
    var tab = /\t/;
    var versionLine = morpheus.Util.copyString(reader.readLine().trim());
    if (versionLine === '') {
      throw new Error('Missing version line');
    }
    var version = 2;
    if ('#1.2' === versionLine) {
      version = 2;
    } else if ('#1.3' === versionLine) {
      version = 3;
    } else {
      console.log('Unknown version: assuming version 2');
    }
    var dimensionsLine = morpheus.Util.copyString(reader.readLine());
    if (dimensionsLine == null) {
      throw new Error('No dimensions specified');
    }
    // <numRows> <tab> <numCols>
    var dimensions = dimensionsLine.split(/[ \t]/);
    var numRowAnnotations = 1; // in addition to row id
    var numColumnAnnotations = 0; // in addition to column id
    var nrows = -1;
    var ncols = -1;
    if (version === 3) {
      if (dimensions.length >= 4) {
        nrows = parseInt(dimensions[0]);
        ncols = parseInt(dimensions[1]);
        numRowAnnotations = parseInt(dimensions[2]);
        numColumnAnnotations = parseInt(dimensions[3]);
      } else { // no dimensions specified
        numRowAnnotations = parseInt(dimensions[0]);
        numColumnAnnotations = parseInt(dimensions[1]);
      }
    } else {
      nrows = parseInt(dimensions[0]);
      ncols = parseInt(dimensions[1]);
      if (nrows <= 0 || ncols <= 0) {
        throw new Error(
          'Number of rows and columns must be greater than 0.');
      }
    }
    var columnNamesLine = morpheus.Util.copyString(reader.readLine());
    if (columnNamesLine == null) {
      throw new Error('No column annotations');
    }

    var columnNamesArray = columnNamesLine.split(tab);
    if (ncols === -1) {
      ncols = columnNamesArray.length - numRowAnnotations - 1;
    }
    if (version == 2) {
      var expectedColumns = ncols + 2;
      if (columnNamesArray.length !== expectedColumns) {
        throw new Error('Expected ' + (expectedColumns - 2)
          + ' column names, but read '
          + (columnNamesArray.length - 2) + ' column names.');
      }
    }
    var name = columnNamesArray[0];
    var slashIndex = name.lastIndexOf('/');
    var columnIdFieldName = 'id';
    var rowIdFieldName = 'id';
    if (slashIndex != -1 && slashIndex < (name.length - 1)) {
      rowIdFieldName = name.substring(0, slashIndex);
      columnIdFieldName = name.substring(slashIndex + 1);
    }
    if (nrows === -1) {
      var matrix = [];
      var rowMetadataNames = [rowIdFieldName];
      var columnMetadataNames = [columnIdFieldName];
      var rowMetadata = [[]];
      var columnMetadata = [[]];
      for (var j = 0; j < ncols; j++) {
        var index = j + numRowAnnotations + 1;
        var columnName = index < columnNamesArray.length ? columnNamesArray[index]
          : null;
        columnMetadata[0].push(morpheus.Util.copyString(columnName));
      }

      for (var j = 0; j < numRowAnnotations; j++) {
        var rowMetadataName = '' === columnNamesArray[1] ? 'description'
          : columnNamesArray[j + 1];
        rowMetadataNames.push(
          rowMetadataName);
        rowMetadata.push([]);
      }

      var dataColumnStart = numRowAnnotations + 1;
      var ntokens = ncols + numRowAnnotations + 1;
      var linen = 3;
      if (numColumnAnnotations > 0) {
        for (var columnAnnotationIndex = 0; columnAnnotationIndex < numColumnAnnotations; columnAnnotationIndex++) {
          var tokens = reader.readLine().split(tab);
          var metadataName = tokens[0];
          var v = [];
          columnMetadata.push(v);
          columnMetadataNames.push(metadataName);
          for (var j = 0; j < ncols; j++) {
            v.push(morpheus.Util.copyString(tokens[j + dataColumnStart]));
          }
        }
      }

      var nonEmptyDescriptionFound = false;
      var numRowAnnotationsPlusOne = numRowAnnotations + 1;
      var s;
      while ((s = reader.readLine()) !== null) {
        if (s !== '') {
          var array = new Float32Array(ncols);
          matrix.push(array);
          var tokens = s.split(tab);
          // we iterate to numRowAnnotations + 1 to include id row
          // metadata field
          for (var rowAnnotationIndex = 0; rowAnnotationIndex < numRowAnnotationsPlusOne; rowAnnotationIndex++) {
            var rowMetadataValue = tokens[rowAnnotationIndex];
            rowMetadata[rowAnnotationIndex].push(
              morpheus.Util.copyString(rowMetadataValue));

          }

          for (var columnIndex = 0; columnIndex < ncols; columnIndex++) {
            var token = tokens[columnIndex + dataColumnStart];
            array[columnIndex] = parseFloat(token);
          }
        }

      }
      var dataset = new morpheus.Dataset({
        name: datasetName,
        rows: matrix.length,
        columns: ncols,
        array: matrix,
        dataType: 'Float32'
      });
      for (var i = 0; i < rowMetadataNames.length; i++) {
        dataset.getRowMetadata().add(rowMetadataNames[i]).array = rowMetadata[i];
      }
      for (var i = 0; i < columnMetadataNames.length; i++) {
        dataset.getColumnMetadata().add(columnMetadataNames[i]).array = columnMetadata[i];
      }
      morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
      morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
        1);
      return dataset;

    } else {
      var dataset = new morpheus.Dataset({
        dataType: 'Float32',
        name: datasetName,
        rows: nrows,
        columns: ncols
      });

      var columnIds = dataset.getColumnMetadata().add(columnIdFieldName);
      if (version == 3) {
        for (var j = 0; j < ncols; j++) {
          var index = j + numRowAnnotations + 1;
          var columnName = index < columnNamesArray.length ? columnNamesArray[index]
            : null;
          columnIds.setValue(j, morpheus.Util.copyString(columnName));
        }

      } else {
        for (var j = 0; j < ncols; j++) {
          var columnName = columnNamesArray[j + numRowAnnotations + 1];
          columnIds.setValue(j, morpheus.Util.copyString(columnName));
        }
      }

      var rowAnnotationVectors = [
        dataset.getRowMetadata().add(
          rowIdFieldName)];
      if (version === 3) {
        for (var j = 0; j < numRowAnnotations; j++) {
          var rowMetadataName = '' === columnNamesArray[1] ? 'description'
            : columnNamesArray[j + 1];
          rowAnnotationVectors.push(dataset.getRowMetadata().add(
            rowMetadataName));
        }

      } else {
        rowAnnotationVectors.push(dataset.getRowMetadata().add(
          columnNamesArray[1]));
      }

      var dataColumnStart = numRowAnnotations + 1;
      var ntokens = ncols + numRowAnnotations + 1;
      var linen = 3;
      if (numColumnAnnotations > 0) {
        for (var columnAnnotationIndex = 0; columnAnnotationIndex < numColumnAnnotations; columnAnnotationIndex++) {
          var tokens = reader.readLine().split(tab);
          var metadataName = tokens[0];
          var v = dataset.getColumnMetadata().add(metadataName);
          for (var j = 0; j < ncols; j++) {
            v.setValue(j, morpheus.Util.copyString(tokens[j + dataColumnStart]));
          }
        }
      }

      var nonEmptyDescriptionFound = false;
      var numRowAnnotationsPlusOne = numRowAnnotations + 1;
      for (var rowIndex = 0, nrows = dataset.getRowCount(); rowIndex < nrows; rowIndex++) {
        var s = reader.readLine();
        if (s === null) {
          throw new Error('Missing data rows.');
        }
        var tokens = s.split(tab);
        if (version === 2) {
          rowAnnotationVectors[0].setValue(rowIndex, morpheus.Util.copyString(tokens[0]));
          var desc = tokens[1];
          if (!nonEmptyDescriptionFound) {
            nonEmptyDescriptionFound = desc !== '';
          }
          rowAnnotationVectors[1].setValue(rowIndex, morpheus.Util.copyString(desc));
        } else {
          // we iterate to numRowAnnotations + 1 to include id row
          // metadata field
          for (var rowAnnotationIndex = 0; rowAnnotationIndex < numRowAnnotationsPlusOne; rowAnnotationIndex++) {
            var rowMetadataValue = tokens[rowAnnotationIndex];
            rowAnnotationVectors[rowAnnotationIndex].setValue(rowIndex,
              morpheus.Util.copyString(rowMetadataValue));

          }
        }
        for (var columnIndex = 0; columnIndex < ncols; columnIndex++) {
          var token = tokens[columnIndex + dataColumnStart];
          // if (token[0] === '{') {
          // var value = JSON.parse(token);
          // dataset.setValue(rowIndex, columnIndex, morpheus.Util
          // .wrapNumber(value.__v, value));
          // } else {
          // dataset.setValue(rowIndex, columnIndex, parseFloat(token));
          // }
          dataset.setValue(rowIndex, columnIndex, parseFloat(token));
        }

      }

      if (version === 2 && !nonEmptyDescriptionFound) {
        dataset.getRowMetadata().remove(1);
      }
      if (rowIndex !== nrows) {
        throw new Error('Missing data rows');
      }

      morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
      morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
        1);
      return dataset;
    }
  },
  _readNoChunking: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err, arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        callback(null, _this._read(name,
          new morpheus.ArrayBufferReader(new Uint8Array(
            arrayBuffer))));
      }
    });
    // $.ajax({
    // 	url: fileOrUrl,
    // 	dataType: 'text'
    // }).done(function (text) {
    // 	callback(null, _this.read(name, new morpheus.StringReader(text)));
    // }).fail(function (err) {
    // 	callback(err);
    // });

  }
};

morpheus.GctWriter = function () {
  this.nf = morpheus.Util.createNumberFormat('.2f');
};

morpheus.GctWriter.idFirst = function (model) {
  var fields = ['id', 'Id', 'pr_id'];
  var idIndex = -1;
  for (var i = 0; i < fields.length; i++) {
    idIndex = morpheus.MetadataUtil.indexOf(model, fields[i]);
    if (idIndex !== -1) {
      break;
    }
  }
  if (idIndex !== -1) {
    var order = [];
    order[0] = idIndex;
    for (var i = 0, j = 1, count = model.getMetadataCount(); i < count; i++) {
      if (i !== idIndex) {
        order[j++] = i;
      }
    }
    return new morpheus.MetadataModelColumnView(model, order);
  }
  return model;
};

morpheus.GctWriter.prototype = {
  setNumberFormat: function (nf) {
    this.nf = nf;
  },
  getExtension: function () {
    return 'gct';
  },
  write: function (dataset, pw) {
    if (pw == null) {
      pw = [];
    }
    var rowMetadata = morpheus.GctWriter.idFirst(dataset.getRowMetadata());
    var columnMetadata = morpheus.GctWriter.idFirst(dataset
    .getColumnMetadata());
    this.writeHeader(rowMetadata, columnMetadata, pw);
    this.writeData(dataset, rowMetadata, pw);
    return pw.join('');
  },
  writeData: function (dataset, rowMetadata, pw) {
    var ncols = dataset.getColumnCount();
    var rowMetadataCount = rowMetadata.getMetadataCount();
    var nf = this.nf;
    for (var i = 0, rows = dataset.getRowCount(); i < rows; i++) {
      for (var rowMetadataIndex = 0; rowMetadataIndex < rowMetadataCount; rowMetadataIndex++) {
        if (rowMetadataIndex > 0) {
          pw.push('\t');
        }
        var vector = rowMetadata.get(rowMetadataIndex);
        var value = vector.getValue(i);

        if (value !== null) {
          var toString = morpheus.VectorTrack.vectorToString(vector);
          pw.push(toString(value));
        }
      }
      for (var j = 0; j < ncols; j++) {
        pw.push('\t');
        var value = dataset.getValue(i, j);
        pw.push(nf(value));
      }
      pw.push('\n');
    }
  },
  writeHeader: function (rowMetadata, columnMetadata, pw) {
    var rows = rowMetadata.getItemCount();
    var ncols = columnMetadata.getItemCount();
    pw.push('#1.3\n');
    var rowMetadataCount = rowMetadata.getMetadataCount();
    pw.push(rows + '\t' + ncols + '\t' + (rowMetadataCount - 1) + '\t'
      + (columnMetadata.getMetadataCount() - 1));
    pw.push('\n');
    for (var i = 0; i < rowMetadataCount; i++) {
      if (i > 0) {
        pw.push('\t');
      }
      var name = rowMetadata.get(i).getName();
      if (i === 0 && name !== columnMetadata.get(0).getName()) {
        name = name + '/' + columnMetadata.get(0).getName();
      }
      pw.push(name);
    }
    var toString = morpheus.VectorTrack.vectorToString(columnMetadata.get(0));
    for (var j = 0; j < ncols; j++) {
      pw.push('\t');
      pw.push(toString(columnMetadata.get(0).getValue(j)));
    }
    pw.push('\n');
    for (var columnMetadataIndex = 1, metadataSize = columnMetadata
    .getMetadataCount(); columnMetadataIndex < metadataSize; columnMetadataIndex++) {
      pw.push(columnMetadata.get(columnMetadataIndex).getName());
      for (var i = 1; i < rowMetadataCount; i++) {
        pw.push('\t');
        pw.push('na');
      }
      for (var j = 0; j < ncols; j++) {
        pw.push('\t');
        var vector = columnMetadata.get(columnMetadataIndex);
        var value = vector.getValue(j);
        if (value != null) {
          toString = morpheus.VectorTrack.vectorToString(columnMetadata.get(0));
          pw.push(toString(value));
        }
      }
      pw.push('\n');
    }
  }
};

morpheus.GctWriter12 = function () {
  this.options = {
    rowDescription: 'Description',
    rowId: 'id',
    columnId: 'id'
  };
  this.nf = morpheus.Util.createNumberFormat('.2f');
};
morpheus.GctWriter12.prototype = {
  setNumberFormat: function (nf) {
    this.nf = nf;
  },
  getExtension: function () {
    return 'gct';
  },
  write: function (dataset, pw) {
    if (pw == null) {
      pw = [];
    }
    var rows = dataset.getRowCount();
    var columns = dataset.getColumnCount();
    var version = '#1.2';
    pw.push(version);
    pw.push('\n');
    pw.push(rows + '\t' + columns);
    pw.push('\n');
    var rowMetadata = morpheus.GctWriter.idFirst(dataset.getRowMetadata());
    var columnMetadata = morpheus.GctWriter.idFirst(dataset
    .getColumnMetadata());
    pw.push('Name');
    pw.push('\t');
    pw.push('Description');
    var columnIds = columnMetadata.getByName(this.options.columnId);
    if (!columnIds) {
      columnIds = columnMetadata.get(0);
    }
    var columnIdToString = morpheus.VectorTrack.vectorToString(columnIds);
    for (var j = 0; j < columns; j++) {
      pw.push('\t');
      pw.push(columnIdToString(columnIds.getValue(j)));
    }
    var rowIds = rowMetadata.get(this.options.rowId);
    if (!rowIds) {
      rowIds = rowMetadata.get(0);
    }
    var rowDescriptions = rowMetadata
    .getByName(this.options.rowDescription);
    if (rowDescriptions == null && rowMetadata.getMetadataCount() > 1) {
      rowDescriptions = rowMetadata.get(1);
    }
    var rowIdToString = morpheus.VectorTrack.vectorToString(rowIds);
    var rowDescriptionToString = rowDescriptions != null ? morpheus.VectorTrack.vectorToString(rowDescriptions) : null;
    var nf = this.nf;
    for (var i = 0; i < rows; i++) {
      pw.push('\n');
      pw.push(rowIdToString(rowIds.getValue(i)));
      pw.push('\t');
      var rowDescription = rowDescriptions != null ? rowDescriptions
      .getValue(i) : null;
      if (rowDescription != null) {
        pw.push(rowDescriptionToString(rowDescription));
      }
      for (var j = 0; j < columns; j++) {
        pw.push('\t');
        pw.push(nf(dataset.getValue(i, j)));
      }
    }
    pw.push('\n');
    return pw.join('');
  }
};

morpheus.GisticReader = function () {

};
morpheus.GisticReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
    .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, _this._read(name,
            new morpheus.ArrayBufferReader(new Uint8Array(
              arrayBuffer))));
        }
        catch (x) {
          if (x.stack) {
            console.log(x.stack);
          }
          callback(x);
        }
      }
    });

  },
  _read: function (datasetName, reader) {
    var tab = /\t/;
    var header = reader.readLine().trim().split(tab);

    // Unique Name, Descriptor, Wide Peak Limits, Peak Limits, Region
    // Limits, q values, Residual q values after removing segments shared
    // with higher peaks, Broad or Focal, Amplitude Threshold

    var ncols = header.length - 9;
    var matrix = [];
    var s;
    var rowIds = [];
    var qValues = [];
    while ((s = reader.readLine()) !== null) {
      s = s.trim();

      if (s !== '') {
        var tokens = s.split(tab);
        if (tokens[8] === 'Actual Copy Change Given') {
          var array = new Float32Array(ncols);
          matrix.push(array);
          rowIds.push(String($.trim(tokens[1])));
          qValues.push(parseFloat(tokens[5]));
          for (var j = 9; j <= ncols; j++) {
            var token = tokens[j];
            array[j - 9] = parseFloat(token);
          }
        }
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      rows: matrix.length,
      columns: ncols,
      array: matrix,
      dataType: 'Float32'
    });

    var columnIds = dataset.getColumnMetadata().add('id');
    for (var j = 0; j < ncols; j++) {
      columnIds.setValue(j, String(header[j + 9]));
    }

    dataset.getRowMetadata().add('id').array = rowIds;
    dataset.getRowMetadata().add('q_value').array = qValues;
    return dataset;
  }
};

morpheus.GmtDatasetReader = function () {
};
morpheus.GmtDatasetReader.prototype = {
  getFormatName: function () {
    return 'gmt';
  },
  read: function (fileOrUrl, callback) {
    var name = morpheus.Util.getBaseFileName(morpheus.Util
    .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err, arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, morpheus.DatasetUtil.geneSetsToDataset(name,
            new morpheus.GmtReader()
            .read(new morpheus.ArrayBufferReader(
              new Uint8Array(arrayBuffer)))));
        }
        catch (x) {
          callback(x);
        }
      }
    });

  }
};

morpheus.GmtReader = function () {
};
morpheus.GmtReader.prototype = {
  read: function (reader) {
    var sets = [];
    var tab = /\t/;
    var s;
    while ((s = reader.readLine()) != null) {
      if (s === '' || s[0] === '#') {
        continue;
      }
      var tokens = s.split(tab);
      var name = tokens[0].trim();
      var description = tokens.length > 1 ? tokens[1].trim() : '';
      if ('BLANK' === description) {
        description = '';
      }
      var ids = [];
      for (var i = 2; i < tokens.length; i++) {
        var geneName = tokens[i].trim();
        if (geneName !== '') {
          ids.push(geneName);
        }
      }
      var set = {
        name: name,
        description: description,
        ids: ids
      };
      set.toString = function () {
        return this.name;
      };
      sets.push(set);
    }
    return sets;
  }
};

morpheus.JsonDatasetReader = function () {

};

morpheus.JsonDatasetReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util.getFileName(fileOrUrl));
    var isString = typeof fileOrUrl === 'string' || fileOrUrl instanceof String;
    if (isString) {
      fetch(fileOrUrl).then(function (response) {
        if (response.ok) {
          return response.text();
        } else {
          callback(response.status + ' ' + response.statusText);
        }
      }).then(function (text) {
        callback(null, morpheus.Dataset.fromJSON(JSON.parse(text.trim())));
      }).catch(function (err) {
        callback(err);
      });
    } else {
      var reader = new FileReader();
      reader.onload = function (event) {
        callback(null, morpheus.Dataset.fromJSON(JSON.parse(event.target.result)));
      };
      reader.onerror = function (event) {
        callback(event);
      };
      reader.readAsText(fileOrUrl);
    }

  }
};

morpheus.MafFileReader = function () {
  this.geneFilter = null;
};
/**
 *
 * @param options.dataset
 * @param options.fields
 */
morpheus.MafFileReader.summarizeMutations = function (options) {
  var dataset = options.dataset;
  var fields = options.fields;
  var count = fields.length;
  var vector = dataset.getRowMetadata().add('mutation_summary');
  vector.getProperties().set(
    morpheus.VectorKeys.FIELDS, fields);
  vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, '[number]');

  // computing dynamically screws things up b/c summary is computed for other data types (e.g. CN)
  for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
    var bins = new Int32Array(count); // 1-count
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      var value = dataset.getValue(i, j);
      if (value > 0) {
        bins[value - 1]++;
      }
    }
    vector.setValue(i, bins);
  }
};

morpheus.MafFileReader.getField = function (fieldNames, headerToIndex) {
  var name;
  var index;

  for (var i = 0; i < fieldNames.length; i++) {
    name = fieldNames[i];

    var lc = name.toLowerCase();
    index = headerToIndex[lc];

    if (index !== undefined) {
      break;
    }
  }

  if (index !== undefined) {
    return {
      name: name,
      index: index
    };
  }
};

morpheus.MafFileReader.VARIANT_MAP = new morpheus.Map();
// silent
morpheus.MafFileReader.VARIANT_MAP.set('Silent', 1);
// in-frame indel
morpheus.MafFileReader.VARIANT_MAP.set('In_Frame_Del', 2);
morpheus.MafFileReader.VARIANT_MAP.set('In_Frame_Ins', 2);
morpheus.MafFileReader.VARIANT_MAP.set('Inframe_Del', 2);
morpheus.MafFileReader.VARIANT_MAP.set('Inframe_Ins', 2);

// other
morpheus.MafFileReader.VARIANT_MAP.set('Translation_Start_Site', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Nonstop_Mutation', 3);
morpheus.MafFileReader.VARIANT_MAP.set('3\'UTR', 3);
morpheus.MafFileReader.VARIANT_MAP.set('3\'Flank', 3);
morpheus.MafFileReader.VARIANT_MAP.set('5\'UTR', 3);
morpheus.MafFileReader.VARIANT_MAP.set('5\'Flank', 3);
morpheus.MafFileReader.VARIANT_MAP.set('IGR', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Intron', 3);
morpheus.MafFileReader.VARIANT_MAP.set('RNA', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Targeted_Region', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Unknown', 3);
morpheus.MafFileReader.VARIANT_MAP.set('1DEL', 3); // single copy loss from oncopanel
morpheus.MafFileReader.VARIANT_MAP.set('HA', 3); // high amplification from oncopanel

// mis-sense
morpheus.MafFileReader.VARIANT_MAP.set('Missense_Mutation', 4);
morpheus.MafFileReader.VARIANT_MAP.set('Missense', 4);

// splice site
morpheus.MafFileReader.VARIANT_MAP.set('Splice_Site', 5);
morpheus.MafFileReader.VARIANT_MAP.set('Splice_Acceptor', 5);
morpheus.MafFileReader.VARIANT_MAP.set('Splice_Region', 5);

// frame shift indel
morpheus.MafFileReader.VARIANT_MAP.set('Frame_Shift_Del', 6);
morpheus.MafFileReader.VARIANT_MAP.set('Frame_Shift_Ins', 6);
morpheus.MafFileReader.VARIANT_MAP.set('Frameshift', 6);

// non-sense
morpheus.MafFileReader.VARIANT_MAP.set('Nonsense_Mutation', 7);
morpheus.MafFileReader.VARIANT_MAP.set('Nonsense', 7);
morpheus.MafFileReader.VARIANT_MAP.set('2DEL', 7); // homozygous deletion from oncopanel

morpheus.MafFileReader.FIELD_NAMES = [
  'Synonymous', 'In Frame Indel', 'Other Non-Synonymous',
  'Missense', 'Splice Site', 'Frame Shift', 'Nonsense'];

morpheus.MafFileReader.prototype = {
  setGeneFilter: function (geneFilter) {
    this.geneFilter = geneFilter;
  },
  getFormatName: function () {
    return 'maf';
  },
  _getGeneLevelDataset: function (datasetName, reader) {
    var _this = this;
    var tab = /\t/;
    var header = reader.readLine().split(tab);
    var headerToIndex = {};
    for (var i = 0, length = header.length; i < length; i++) {
      headerToIndex[header[i].toLowerCase()] = i;
    }
    // TODO six classes of base substitutionC>A, C>G, C>T, T>A, T>C, T>G
    // (all substitutions are referred to by the pyrimidine of the mutated
    // WatsonCrick base pair)
    // var fields = ['Hugo_Symbol', 'Chromosome', 'Start_position',
    //   'Reference_Allele', 'Tumor_Seq_Allele2',
    //   'Variant_Classification', 'Protein_Change', 'Protein_Change', 'ccf_hat',
    //   'tumor_f', 'i_tumor_f', 'Tumor_Sample_Barcode', 'tumor_name',
    //   'Tumor_Sample_UUID', 'encoding'];
    //
    var sampleField = morpheus.MafFileReader.getField([
        'Tumor_Sample_Barcode', 'tumor_name', 'Tumor_Sample_UUID'],
      headerToIndex);
    var encodingField = morpheus.MafFileReader.getField([
        'encoding'],
      headerToIndex); // gives a numeric value for string
    if (sampleField == null) {
      throw new Error('Sample id column not found.');
    }
    var encodingColumnIndex = encodingField == null ? -1 : encodingField.index;
    var sampleColumnName = sampleField.name;
    var sampleIdColumnIndex = sampleField.index;
    var tumorFractionField = morpheus.MafFileReader.getField([
      'ccf_hat',
      'tumor_f', 'i_tumor_f'], headerToIndex);
    var ccfColumnName;
    var ccfColumnIndex;
    if (tumorFractionField !== undefined) {
      ccfColumnName = tumorFractionField.name;
      ccfColumnIndex = tumorFractionField.index;
    }
    var chromosomeColumn = headerToIndex['Chromosome'.toLowerCase()];
    var startPositionColumn = headerToIndex['Start_position'
      .toLowerCase()];
    var refAlleleColumn = headerToIndex['Reference_Allele'.toLowerCase()];
    var tumorAllelColumn = headerToIndex['Tumor_Seq_Allele2'
      .toLowerCase()];

    var proteinChangeColumn = headerToIndex['Protein_Change'.toLowerCase()];
    if (proteinChangeColumn == null) {
      proteinChangeColumn = headerToIndex['Protein'.toLowerCase()];
    }

    var geneSymbolColumn = headerToIndex['Hugo_Symbol'.toLowerCase()];
    if (geneSymbolColumn == null) {
      geneSymbolColumn = headerToIndex['gene'];
    }
    if (geneSymbolColumn == null) {
      throw new Error('Gene symbol column not found.');
    }
    var variantColumnIndex = headerToIndex['Variant_Classification'
      .toLowerCase()];
    if (variantColumnIndex == null) {
      variantColumnIndex = headerToIndex['variant'
        .toLowerCase()];
    }
    if (variantColumnIndex == null) {
      throw new Error('Variant_Classification not found');
    }
    // keep fields that are in file only

    var geneSymbolToIndex = new morpheus.Map();
    var sampleIdToIndex = new morpheus.Map();
    var variantMatrix = [];
    var ccfMatrix = [];
    var s;
    var customNumberToValueMap = new morpheus.Map();

    var hasMutationInfo = chromosomeColumn !== undefined && startPositionColumn !== undefined && refAlleleColumn !== undefined && tumorAllelColumn !== undefined;
    while ((s = reader.readLine()) !== null) {
      var tokens = s.split(tab);
      var sample = String(tokens[sampleIdColumnIndex]);
      var columnIndex = sampleIdToIndex.get(sample);
      if (columnIndex === undefined) {
        columnIndex = sampleIdToIndex.size();
        sampleIdToIndex.set(sample, columnIndex);
      }
      var gene = String(tokens[geneSymbolColumn]);
      if (gene === 'Unknown') {
        continue;
      }
      if (this.geneFilter == null
        || this.geneFilter.has(tokens[geneSymbolColumn])) {
        var rowIndex = geneSymbolToIndex.get(gene);
        if (rowIndex === undefined) {
          rowIndex = geneSymbolToIndex.size();
          geneSymbolToIndex.set(gene, rowIndex);
        }
        var value = String(tokens[variantColumnIndex]);
        var variantCode;
        if (encodingColumnIndex === -1) {
          variantCode = morpheus.MafFileReader.VARIANT_MAP.get(value);
          if (variantCode === undefined) {
            variantCode = 3;
          }
        } else {
          variantCode = parseInt(tokens[encodingColumnIndex]);
          customNumberToValueMap.set(variantCode, value);
        }

        var variantObject = {};
        var Protein_Change = tokens[proteinChangeColumn];
        if (Protein_Change) {
          variantObject.Protein = String(Protein_Change);
        }
        variantObject.__v = variantCode;
        variantObject.Variant = value;
        if (hasMutationInfo) {
          variantObject.Mutation = String(tokens[chromosomeColumn]) + ':'
            + String(tokens[startPositionColumn]) + ' '
            + String(tokens[refAlleleColumn]) + ' > '
            + String(tokens[tumorAllelColumn]);
        }
        var wrappedVariant = morpheus.Util.wrapNumber(variantCode,
          variantObject);
        var variantRow = variantMatrix[rowIndex];
        if (variantRow === undefined) {
          variantRow = [];
          variantMatrix[rowIndex] = variantRow;
        }
        var ccf = -1;
        var priorCcf = -1;
        if (ccfColumnIndex !== undefined) {
          var ccfRow = ccfMatrix[rowIndex];
          if (ccfRow === undefined) {
            ccfRow = [];
            ccfMatrix[rowIndex] = ccfRow;
          }
          ccf = parseFloat(tokens[ccfColumnIndex]);
          priorCcf = ccfRow[columnIndex] || -1;
        }
        var priorValue = variantRow[columnIndex] || -1;
        if (variantCode > priorValue) { // take most severe mutation
          variantRow[columnIndex] = wrappedVariant;
          if (ccfColumnIndex !== undefined) {
            ccfRow[columnIndex] = ccf;
          }
        } else if (variantCode === priorValue && ccf > priorCcf) {
          variantRow[columnIndex] = wrappedVariant;
          ccfRow[columnIndex] = ccf;
        }
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      array: variantMatrix,
      dataType: 'Number',
      rows: geneSymbolToIndex.size(),
      columns: sampleIdToIndex.size()
    });
    var columnIds = dataset.getColumnMetadata().add('id');
    sampleIdToIndex.forEach(function (index, id) {
      columnIds.setValue(index, id);
    });
    var rowIds = dataset.getRowMetadata().add('id');
    geneSymbolToIndex.forEach(function (index, id) {
      rowIds.setValue(index, id);
    });
    for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
      .getColumnCount(); i < nrows; i++) {
      for (var j = 0; j < ncols; j++) {
        if (variantMatrix[i][j] === undefined) {
          variantMatrix[i][j] = 0;
        }
      }
    }
    if (ccfColumnIndex !== undefined) {
      dataset.addSeries({
        dataType: 'Float32',
        name: 'allelic_fraction',
        array: ccfMatrix
      });
    }
    if (this.geneFilter) {
      var orderVector = dataset.getRowMetadata().add('order');
      for (var i = 0, size = orderVector.size(); i < size; i++) {
        var gene = rowIds.getValue(i);
        var order = this.geneFilter.get(gene);
        orderVector.setValue(i, order);
      }
      var project = new morpheus.Project(dataset);
      project.setRowSortKeys([
        new morpheus.SortKey('order',
          morpheus.SortKey.SortOrder.ASCENDING)], true); // sort
      // collapsed
      // dataset
      var tmp = project.getSortedFilteredDataset();
      project = new morpheus.Project(tmp);
      var columnIndices = morpheus.Util.seq(tmp.getColumnCount());
      columnIndices
        .sort(function (a, b) {
          for (var i = 0, nrows = tmp.getRowCount(); i < nrows; i++) {
            for (var seriesIndex = 0, nseries = tmp
              .getSeriesCount(); seriesIndex < nseries; seriesIndex++) {
              var f1 = tmp.getValue(i, a, seriesIndex);
              if (isNaN(f1)) {
                f1 = Number.NEGATIVE_INFINITY;
              }
              f1 = f1.valueOf();
              var f2 = tmp.getValue(i, b, seriesIndex);
              if (isNaN(f2)) {
                f2 = Number.NEGATIVE_INFINITY;
              }
              f2 = f2.valueOf();
              var returnVal = (f1 === f2 ? 0 : (f1 < f2 ? 1
                : -1));
              if (returnVal !== 0) {
                return returnVal;
              }
            }
          }
          return 0;
        });
      dataset = new morpheus.SlicedDatasetView(dataset, null,
        columnIndices);
    }

    var fieldNames = morpheus.MafFileReader.FIELD_NAMES;
    if (customNumberToValueMap.size() > 0) {
      var pairs = [];
      customNumberToValueMap.forEach(function (value, key) {
        pairs.push({
          key: key,
          value: value
        });
      });
      pairs.sort(function (a, b) {
        return (a.key === b.key ? 0 : (a.key < b.key ? -1 : 1));
      });
      fieldNames = pairs.map(function (p) {
        return p.value;
      });
    }
    var numUniqueValues = fieldNames.length;
    morpheus.MafFileReader.summarizeMutations({
      dataset: dataset,
      fields: fieldNames
    });
    morpheus.MafFileReader
      .summarizeMutations({
        dataset: new morpheus.TransposedDatasetView(dataset),
        fields: fieldNames
      });

    var mutationSummarySelectionVector = dataset.getColumnMetadata().add('mutation_summary_selection');
    mutationSummarySelectionVector.getProperties().set(
      morpheus.VectorKeys.FIELDS,
      fieldNames);
    mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, '[number]');
    mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.RECOMPUTE_FUNCTION_SELECTION, true);
    var datasetName = dataset.getName();
    mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.FUNCTION, {
      binSize: 1,
      domain: [1, 8],
      cumulative: false
    });
    // mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.FUNCTION, function (view, selectedDataset, columnIndex) {
    //   var sourceVector = selectedDataset.getRowMetadata().getByName('Source');
    //   var bins = new Int32Array(numUniqueValues); // 1-7
    //   for (var i = 0, nrows = selectedDataset.getRowCount(); i < nrows; i++) {
    //     var source = sourceVector.getValue(i);
    //     if (source == null || source === datasetName) {
    //       var value = selectedDataset.getValue(i, columnIndex);
    //       if (value > 0) {
    //         bins[value - 1]++;
    //       }
    //     }
    //   }
    //   return bins;
    // });

    return dataset;
  },
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err, arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, _this._getGeneLevelDataset(name,
            new morpheus.ArrayBufferReader(new Uint8Array(
              arrayBuffer))));
        }
        catch (err) {
          callback(err);
        }
      }
    });

  }
};

morpheus.SegTabReader = function () {
  this.regions = null;
};
morpheus.SegTabReader.binByRegion = function (dataset, regions) {

  var chromosomeVector = dataset.getRowMetadata().getByName('Chromosome');
  var startVector = dataset.getRowMetadata().getByName('Start_bp');
  var endVector = dataset.getRowMetadata().getByName('End_bp');

  var collapsedDataset = new morpheus.Dataset({
    name: dataset.getName(),
    rows: regions.length,
    columns: dataset.getColumnCount(),
    dataType: 'Float32'
  });
  morpheus.DatasetUtil.fill(collapsedDataset, NaN);
  var regionIdVector = collapsedDataset.getRowMetadata().add('id');
  var newChromosomeVector = collapsedDataset.getRowMetadata().add(
    'chromosome');
  var newStartVector = collapsedDataset.getRowMetadata().add('start');
  var newEndVector = collapsedDataset.getRowMetadata().add('end');
  var nsegmentsVector = collapsedDataset.getRowMetadata().add('nsegments');
  var nseries = dataset.getSeriesCount();

  for (var series = 1; series < nseries; series++) {
    collapsedDataset.addSeries({
      name: dataset.getName(series),
      dataType: 'Float32'
    });

  }

  var summarizeFunction = morpheus.Mean;
  collapsedDataset.setColumnMetadata(dataset.getColumnMetadata());
  for (var regionIndex = 0; regionIndex < regions.length; regionIndex++) {
    var region = regions[regionIndex];
    var rowIndices = [];
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      var chromosome = chromosomeVector.getValue(i);
      var start = startVector.getValue(i);
      var end = endVector.getValue(i);
      if (region.chromosome == chromosome && start >= region.start
        && end <= region.end) {
        rowIndices.push(i);
      }
    }
    if (rowIndices.length > 0) {
      var slice = morpheus.DatasetUtil.slicedView(dataset, rowIndices,
        null);
      var columnView = new morpheus.DatasetColumnView(slice);
      for (var j = 0; j < dataset.getColumnCount(); j++) {
        columnView.setIndex(j);
        for (var series = 0; series < nseries; series++) {
          columnView.setSeriesIndex(series);
          collapsedDataset.setValue(regionIndex, j,
            summarizeFunction(columnView), series);
        }

      }
    }
    nsegmentsVector.setValue(regionIndex, rowIndices.length);
    regionIdVector.setValue(regionIndex, region.id);
    newChromosomeVector.setValue(regionIndex, region.chromosome);
    newStartVector.setValue(regionIndex, region.start);
    newEndVector.setValue(regionIndex, region.end);
  }
  return collapsedDataset;
};

morpheus.SegTabReader.prototype = {
  getFormatName: function () {
    return 'seg';
  },
  setRegions: function (regions) {
    this.regions = regions;
  },
  _read: function (datasetName, reader) {
    var tab = /\t/;
    var header = reader.readLine().split(tab);
    var fieldNameToIndex = {};
    for (var i = 0, length = header.length; i < length; i++) {
      var name = header[i].toLowerCase();
      fieldNameToIndex[name] = i;
    }

    var sampleField = morpheus.MafFileReader.getField(['pair_id',
      'Tumor_Sample_Barcode', 'tumor_name', 'Tumor_Sample_UUID',
      'Sample'], fieldNameToIndex);
    var sampleColumnName = sampleField.name;
    var sampleIdColumnIndex = sampleField.index;
    var tumorFractionField = morpheus.MafFileReader.getField(['ccf_hat',
      'tumor_f', 'i_tumor_f'], fieldNameToIndex);
    var ccfColumnName;
    var ccfColumnIndex;
    if (tumorFractionField !== undefined) {
      ccfColumnName = tumorFractionField.name;
      ccfColumnIndex = tumorFractionField.index;
    }
    var chromosomeColumn = fieldNameToIndex.Chromosome;
    var startPositionColumn = morpheus.MafFileReader.getField(['Start_bp',
      'Start'], fieldNameToIndex).index;
    var endPositionColumn = morpheus.MafFileReader.getField(['End_bp',
      'End'], fieldNameToIndex, {
      remove: false,
      lc: true
    }).index;
    var valueField = morpheus.MafFileReader.getField(['tau',
      'Segment_Mean']).index;
    var s;
    var matrix = [];
    var ccfMatrix = [];
    var sampleIdToIndex = new morpheus.Map();
    var chromosomeStartEndToIndex = new morpheus.Map();
    while ((s = reader.readLine()) !== null) {
      if (s === '') {
        continue;
      }
      var tokens = s.split(tab);
      var sample = String(tokens[sampleIdColumnIndex]);
      var columnIndex = sampleIdToIndex.get(sample);
      if (columnIndex === undefined) {
        columnIndex = sampleIdToIndex.size();
        sampleIdToIndex.set(sample, columnIndex);
      }
      var rowId = new morpheus.Identifier([
        String(tokens[chromosomeColumn]),
        String(tokens[startPositionColumn]),
        String(tokens[endPositionColumn])]);

      var rowIndex = chromosomeStartEndToIndex.get(rowId);
      if (rowIndex === undefined) {
        rowIndex = chromosomeStartEndToIndex.size();
        chromosomeStartEndToIndex.set(rowId, rowIndex);
      }
      var value = parseFloat(String(tokens[valueField]));
      value = isNaN(value) ? value : (morpheus.Log2(value) - 1);
      var matrixRow = matrix[rowIndex];
      if (matrixRow === undefined) {
        matrixRow = [];
        matrix[rowIndex] = matrixRow;
        if (ccfColumnIndex !== undefined) {
          ccfMatrix[rowIndex] = [];
        }
      }
      matrixRow[columnIndex] = value;
      if (ccfColumnIndex !== undefined) {
        ccfMatrix[rowIndex][columnIndex] = parseFloat(tokens[ccfColumnIndex]);
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      array: matrix,
      dataType: 'number',
      rows: chromosomeStartEndToIndex.size(),
      columns: sampleIdToIndex.size()
    });

    var columnIds = dataset.getColumnMetadata().add('id');
    sampleIdToIndex.forEach(function (index, id) {
      columnIds.setValue(index, id);
    });

    var chromosomeVector = dataset.getRowMetadata().add('Chromosome');
    var startVector = dataset.getRowMetadata().add('Start_bp');
    var endVector = dataset.getRowMetadata().add('End_bp');
    chromosomeStartEndToIndex.forEach(function (index, id) {
      chromosomeVector.setValue(index, id.getArray()[0]);
      startVector.setValue(index, id.getArray()[1]);
      endVector.setValue(index, id.getArray()[2]);
    });

    if (ccfColumnIndex !== undefined) {
      dataset.addSeries({
        dataType: 'number',
        name: 'ccf',
        array: ccfMatrix
      });
    }

    if (this.regions != null && this.regions.length > 0) {
      dataset = morpheus.SegTabReader.binByRegion(dataset, this.regions);
    }
    return dataset;
  },
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
    .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        // try {
        callback(null, _this._read(name, new morpheus.ArrayBufferReader(
          new Uint8Array(arrayBuffer))));
        // } catch (err) {
        // callback(err);
        // }
      }
    });

  }
};

morpheus.TcgaUtil = function () {

};

morpheus.TcgaUtil.DISEASE_STUDIES = {
  'ACC': 'Adrenocortical carcinoma',
  'BLCA': 'Bladder Urothelial Carcinoma',
  'BRCA': 'Breast invasive carcinoma',
  'CESC': 'Cervical squamous cell carcinoma and endocervical adenocarcinoma',
  'CHOL': 'Cholangiocarcinoma',
//	'CNTL': 'Controls',
  'COAD': 'Colon adenocarcinoma',
  'COADREAD': 'Colonrectal adenocarcinoma',
  'DLBC': 'Lymphoid Neoplasm Diffuse Large B-cell Lymphoma',
  'ESCA': 'Esophageal carcinoma ',
//	'FPPP': 'FFPE Pilot Phase II',
  'GBM': 'Glioblastoma multiforme',
  'GBMLGG': 'Glioma',
  'HNSC': 'Head and Neck squamous cell carcinoma',
  'KICH': 'Kidney Chromophobe',
  'KIPAN': 'Pan-Kidney Cohort',
  'KIRC': 'Kidney renal clear cell carcinoma',
  'KIRP': 'Kidney renal papillary cell carcinoma',
  'LAML': 'Acute Myeloid Leukemia',
  'LCML': 'Chronic Myelogenous Leukemia',
  'LGG': 'Brain Lower Grade Glioma',
  'LIHC': 'Liver hepatocellular carcinoma',
  'LUAD': 'Lung adenocarcinoma',
  'LUSC': 'Lung squamous cell carcinoma',
  'MESO': 'Mesothelioma',
//	'MISC': 'Miscellaneous',
  'OV': 'Ovarian serous cystadenocarcinoma',
  'PAAD': 'Pancreatic adenocarcinoma',
  'PCPG': 'Pheochromocytoma and Paraganglioma',
  'PRAD': 'Prostate adenocarcinoma',
  'READ': 'Rectum adenocarcinoma',
  'SARC': 'Sarcoma',
  'SKCM': 'Skin Cutaneous Melanoma',
  'STAD': 'Stomach adenocarcinoma',
  'STES': 'Stomach and Esophageal Carcinoma',
  'TGCT': 'Testicular Germ Cell Tumors',
  'THCA': 'Thyroid carcinoma',
  'THYM': 'Thymoma',
  'UCEC': 'Uterine Corpus Endometrial Carcinoma',
  'UCS': 'Uterine Carcinosarcoma',
  'UVM': 'Uveal Melanoma'
};

morpheus.TcgaUtil.SAMPLE_TYPES = {
  '01': 'Primary solid Tumor',
  '02': 'Recurrent Solid Tumor',
  '03': 'Primary Blood Derived Cancer - Peripheral Blood',
  '04': 'Recurrent Blood Derived Cancer - Bone Marrow',
  '05': 'Additional - New Primary',
  '06': 'Metastatic',
  '07': 'Additional Metastatic',
  '08': 'Human Tumor Original Cells',
  '09': 'Primary Blood Derived Cancer - Bone Marrow',
  '10': 'Blood Derived Normal',
  '11': 'Solid Tissue Normal',
  '12': 'Buccal Cell Normal',
  '13': 'EBV Immortalized Normal',
  '14': 'Bone Marrow Normal',
  '20': 'Control Analyte',
  '40': 'Recurrent Blood Derived Cancer - Peripheral Blood',
  '50': 'Cell Lines',
  '60': 'Primary Xenograft Tissue',
  '61': 'Cell Line Derived Xenograft Tissue'
};

morpheus.TcgaUtil.barcode = function (s) {
  // e.g. TCGA-AC-A23H-01A-11D-A159-09
  // see https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode
  // TCGA, Tissue source site, Study participant, Sample type
  var tokens = s.split('-');
  var id = tokens[2];
  var sampleType;

  if (tokens.length > 3) {
    sampleType = tokens[3];
    if (sampleType.length > 2) {
      sampleType = sampleType.substring(0, 2);
    }
    sampleType = morpheus.TcgaUtil.SAMPLE_TYPES[sampleType];
  } else {
    sampleType = morpheus.TcgaUtil.SAMPLE_TYPES['01'];
  }
  return {
    id: id.toLowerCase(),
    sampleType: sampleType
  };
};

morpheus.TcgaUtil.setIdAndSampleType = function (dataset) {
  var idVector = dataset.getColumnMetadata().get(0);
  var participantId = dataset.getColumnMetadata().add('participant_id');
  var sampleType = dataset.getColumnMetadata().add('sample_type');
  for (var i = 0, size = idVector.size(); i < size; i++) {
    var barcode = morpheus.TcgaUtil.barcode(idVector.getValue(i));
    idVector.setValue(i, barcode.id + '-' + barcode.sampleType);
    sampleType.setValue(i, barcode.sampleType);
    participantId.setValue(i, barcode.id);
  }
};

morpheus.TcgaUtil.getDataset = function (options) {
  var promises = [];
  var datasets = [];
  var returnDeferred = $.Deferred();

  if (options.mrna) {
    // id + type
    var mrna = $.Deferred();
    promises.push(mrna);
    new morpheus.TxtReader().read(options.mrna, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      mrna.resolve();
    });
  }
  var sigGenesLines;
  if (options.mutation) {
    var mutation = $.Deferred();
    promises.push(mutation);
    new morpheus.MafFileReader().read(options.mutation, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      mutation.resolve();
    });
    var sigGenesAnnotation = morpheus.Util.readLines(options.sigGenes);
    sigGenesAnnotation.done(function (lines) {
      sigGenesLines = lines;
    });
    promises.push(sigGenesAnnotation);
  }
  if (options.gistic) {
    var gistic = $.Deferred();
    promises.push(gistic);
    new morpheus.GisticReader().read(options.gistic,
      function (err, dataset) {
        if (err) {
          console.log('Error reading file:' + err);
        } else {
          datasets.push(dataset);
          morpheus.TcgaUtil.setIdAndSampleType(dataset);
        }
        gistic.resolve();
      });

  }
  if (options.gisticGene) {
    var gisticGene = $.Deferred();
    promises.push(gisticGene);

    new morpheus.TxtReader({
      dataColumnStart: 3

    }).read(options.gisticGene, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      gisticGene.resolve();
    });

  }
  if (options.seg) {
    var seg = $.Deferred();
    promises.push(seg);
    new morpheus.SegTabReader().read(options.seg, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      seg.resolve();
    });
  }
  if (options.rppa) {
    // id + type
    var rppa = $.Deferred();
    promises.push(rppa);

    new morpheus.TxtReader({dataColumnStart: 2}).read(options.rppa, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }

      rppa.resolve();
    });

  }
  if (options.methylation) {
    // id + type
    var methylation = $.Deferred();
    promises.push(methylation);
    new morpheus.TxtReader({}).read(options.methylation, function (
      err,
      dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      methylation.resolve();
    });
  }

  var mrnaClustPromise = morpheus.Util.readLines(options.mrnaClust);
  promises.push(mrnaClustPromise);
  var sampleIdToClusterId;
  mrnaClustPromise.done(function (lines) {
    // SampleName cluster silhouetteValue
    // SampleName cluster silhouetteValue
    // TCGA-OR-A5J1-01 1 0.00648776228925048
    sampleIdToClusterId = new morpheus.Map();
    var lineNumber = 0;
    while (lines[lineNumber].indexOf('SampleName') !== -1) {
      lineNumber++;
    }
    var tab = /\t/;
    for (; lineNumber < lines.length; lineNumber++) {
      var tokens = lines[lineNumber].split(tab);
      var barcode = morpheus.TcgaUtil.barcode(tokens[0]);
      sampleIdToClusterId.set(barcode.id + '-' + barcode.sampleType, tokens[1]);
    }
  });
  var annotationCallbacks = [];
  var annotationDef = null;
  if (options.columnAnnotations) {
    // match datasetField: 'participant_id' to fileField: 'patient_id', // e.g. tcga-5l-aat0
    annotationDef = morpheus.DatasetUtil.annotate({
      annotations: options.columnAnnotations,
      isColumns: true
    });
    promises.push(annotationDef);
    annotationDef.done(function (array) {
      annotationCallbacks = array;
    });
  }
  $.when.apply($, promises).then(
    function () {
      var datasetToReturn = null;
      if (datasets.length === 1) {
        var sourceName = datasets[0].getName();
        var sourceVector = datasets[0].getRowMetadata().add(
          'Source');
        for (var i = 0; i < sourceVector.size(); i++) {
          sourceVector.setValue(i, sourceName);
        }
        datasetToReturn = datasets[0];

      } else {
        var maxIndex = 0;
        var maxColumns = datasets[0].getColumnCount();
        // use dataset with most columns as the reference or
        // mutation data
        for (var i = 1; i < datasets.length; i++) {
          if (datasets[i].getColumnCount() > maxColumns) {
            maxColumns = datasets[i].getColumnCount();
            maxIndex = i;
          }
          if (datasets[i].getName() === 'mutations_merged.maf') {
            maxColumns = Number.MAX_VALUE;
            maxIndex = i;
          }
        }
        var datasetIndices = [];
        datasetIndices.push(maxIndex);
        for (var i = 0; i < datasets.length; i++) {
          if (i !== maxIndex) {
            datasetIndices.push(i);
          }
        }

        var joined = new morpheus.JoinedDataset(
          datasets[datasetIndices[0]],
          datasets[datasetIndices[1]], 'id', 'id');
        for (var i = 2; i < datasetIndices.length; i++) {
          joined = new morpheus.JoinedDataset(joined,
            datasets[datasetIndices[i]], 'id', 'id');
        }
        datasetToReturn = joined;
      }

      var clusterIdVector = datasetToReturn.getColumnMetadata().add(
        'mRNAseq_cluster');
      var idVector = datasetToReturn.getColumnMetadata().getByName(
        'id');
      for (var j = 0, size = idVector.size(); j < size; j++) {
        clusterIdVector.setValue(j, sampleIdToClusterId
          .get(idVector.getValue(j)));
      }
      // view in space of mutation sample ids only
      if (options.mutation) {
        var sourceToIndices = morpheus.VectorUtil
          .createValueToIndicesMap(datasetToReturn
            .getRowMetadata().getByName('Source'));
        var mutationDataset = new morpheus.SlicedDatasetView(
          datasetToReturn, sourceToIndices
            .get('mutations_merged.maf'));
        new morpheus.OpenFileTool()
          .annotate(sigGenesLines, mutationDataset, false,
            null, 'id', 'gene', ['q']);
        var qVector = mutationDataset.getRowMetadata().getByName(
          'q');
        var qValueVector = mutationDataset.getRowMetadata()
          .getByName('q_value');
        if (qValueVector == null) {
          qValueVector = mutationDataset.getRowMetadata().add(
            'q_value');
        }
        for (var i = 0, size = qValueVector.size(); i < size; i++) {
          qValueVector.setValue(i, qVector.getValue(i));
        }

        mutationDataset.getRowMetadata().remove(
          morpheus.MetadataUtil.indexOf(mutationDataset
            .getRowMetadata(), 'q'));
      }
      if (annotationDef) {
        annotationCallbacks.forEach(function (f) {
          f(datasetToReturn);
        });
      }
      returnDeferred.resolve(datasetToReturn);
    });
  return returnDeferred;
};

/**
 *
 * @param options.dataRowStart
 * @param options.dataColumnStart
 * @constructor
 */
morpheus.TxtReader = function (options) {
  if (options == null) {
    options = {};
  }
  this.options = options;
};
morpheus.TxtReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
    .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, _this._read(name,
            new morpheus.ArrayBufferReader(new Uint8Array(
              arrayBuffer))));
        }
        catch (x) {
          callback(x);
        }
      }
    });

  },
  _read: function (datasetName, reader) {
    var dataColumnStart = this.options.dataColumnStart;
    var dataRowStart = this.options.dataRowStart;
    if (dataRowStart == null) {
      dataRowStart = 1;
    }
    var tab = /\t/;
    var header = reader.readLine().trim().split(tab);
    if (dataRowStart > 1) {
      for (var i = 1; i < dataRowStart; i++) {
        reader.readLine(); // skip
      }
    }
    var testLine = null;
    if (dataColumnStart == null) { // try to figure out where data starts by finding 1st
      // numeric column
      testLine = reader.readLine().trim();
      var tokens = testLine.split(tab);
      for (var i = 1; i < tokens.length; i++) {
        var token = tokens[i];
        if (token === '' || token === 'NA' || token === 'NaN' || $.isNumeric(token)) {
          dataColumnStart = i;
          break;
        }
      }

      if (dataColumnStart == null) {
        dataColumnStart = 1;
      }
    }

    var ncols = header.length - dataColumnStart;
    var matrix = [];
    var s;
    var arrayOfRowArrays = [];
    for (var i = 0; i < dataColumnStart; i++) {
      arrayOfRowArrays.push([]);
    }
    if (testLine != null) {
      var array = new Float32Array(ncols);
      matrix.push(array);
      var tokens = testLine.split(tab);
      for (var j = 0; j < dataColumnStart; j++) {
        // row metadata
        arrayOfRowArrays[j].push(morpheus.Util.copyString(tokens[j]));
      }
      for (var j = dataColumnStart, k = 0; k < ncols; j++, k++) {
        var token = tokens[j];
        array[j - dataColumnStart] = parseFloat(token);
      }
    }
    while ((s = reader.readLine()) !== null) {
      s = s.trim();
      if (s !== '') {
        var array = new Float32Array(ncols);
        matrix.push(array);
        var tokens = s.split(tab);
        for (var j = 0; j < dataColumnStart; j++) {
          // row metadata
          arrayOfRowArrays[j].push(morpheus.Util.copyString(tokens[j]));
        }
        for (var j = dataColumnStart, k = 0; k < ncols; j++, k++) {
          var token = tokens[j];
          array[j - dataColumnStart] = parseFloat(token);
        }
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      rows: matrix.length,
      columns: ncols,
      array: matrix,
      dataType: 'Float32'
    });

    var columnIds = dataset.getColumnMetadata().add('id');
    for (var i = 0, j = dataColumnStart; i < ncols; i++, j++) {
      columnIds.setValue(i, morpheus.Util.copyString(header[j]));
    }
    var rowIdVector = dataset.getRowMetadata().add('id');
    rowIdVector.array = arrayOfRowArrays[0];
    // add additional row metadata
    for (var i = 1; i < dataColumnStart; i++) {
      var v = dataset.getRowMetadata().add(header[i]);
      v.array = arrayOfRowArrays[i];
    }

    return dataset;
  }
};

morpheus.XlsxDatasetReader = function () {
};
morpheus.XlsxDatasetReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
    .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          var data = new Uint8Array(arrayBuffer);
          var arr = [];
          for (var i = 0; i != data.length; ++i) {
            arr[i] = String.fromCharCode(data[i]);
          }
          var bstr = arr.join('');
          _this._read(name, bstr, callback);
        }
        catch (x) {
          callback(x);
        }
      }
    });

  },

  _read: function (datasetName, bstr, callback) {
    morpheus.Util.xlsxTo2dArray({data: bstr}, function (err, lines) {
      var nrows = lines.length - 1;
      var header = lines[0];
      var ncols = header.length - 1;
      var dataset = new morpheus.Dataset({
        name: datasetName,
        rows: nrows,
        columns: ncols
      });
      var columnIds = dataset.getColumnMetadata().add('id');
      for (var j = 1; j <= ncols; j++) {
        columnIds.setValue(j - 1, header[j]);
      }
      var rowIds = dataset.getRowMetadata().add('id');
      for (var i = 1; i < lines.length; i++) {
        var tokens = lines[i];
        rowIds.setValue(i - 1, tokens[0]);
        for (var j = 1; j <= ncols; j++) {
          var token = tokens[j];
          var value = parseFloat(token);
          dataset.setValue(i - 1, j - 1, value);
        }
      }
      callback(null, dataset);
    });

  }
};

morpheus.VectorAdapter = function (v) {
  if (v == null) {
    throw 'vector is null';
  }
  this.v = v;
};
morpheus.VectorAdapter.prototype = {
  setValue: function (i, value) {
    this.v.setValue(i, value);
  },
  getValue: function (i) {
    return this.v.getValue(i);
  },
  getProperties: function () {
    return this.v.getProperties();
  },
  size: function () {
    return this.v.size();
  },
  getName: function () {
    return this.v.getName();
  },
  setName: function (name) {
    this.v.setName(name);
  }
};

/**
 *
 * Creates a new dataset with the specified dimensions. Subclasses must implement getValue and
 * setValue.
 * @param rows {number} The number of rows
 * @param columns {number} The number of columns
 * @implements {morpheus.DatasetInterface}
 * @constructor
 */
morpheus.AbstractDataset = function (rows, columns) {
  this.seriesNames = [];
  this.seriesArrays = [];
  this.seriesDataTypes = [];
  this.rows = rows;
  this.columns = columns;
  this.rowMetadataModel = new morpheus.MetadataModel(rows);
  this.columnMetadataModel = new morpheus.MetadataModel(columns);

};
morpheus.AbstractDataset.prototype = {
  /**
   * @ignore
   * @param metadata
   */
  setRowMetadata: function (metadata) {
    this.rowMetadataModel = metadata;
  },
  /**
   * @ignore
   * @param metadata
   */
  setColumnMetadata: function (metadata) {
    this.columnMetadataModel = metadata;
  },
  /**
   * Returns the name for the given series. Series can be used to store
   * standard error of data points for example.
   *
   * @param seriesIndex
   *            the series
   * @return the series name
   */
  getName: function (seriesIndex) {
    return this.seriesNames[seriesIndex || 0];
  },
  /**
   * Sets the name for the given series. Series can be used to store standard
   * error of data points for example.
   *
   * @param seriesIndex
   *            the series *
   * @param name
   *            the series name
   */
  setName: function (seriesIndex, name) {
    this.seriesNames[seriesIndex || 0] = name;
  },
  /**
   * Gets the row metadata for this dataset.
   *
   * @return the row metadata
   */
  getRowMetadata: function () {
    return this.rowMetadataModel;
  },
  /**
   * Gets the column metadata for this dataset.
   *
   * @return The column metadata
   */
  getColumnMetadata: function () {
    return this.columnMetadataModel;
  },
  /**
   * Returns the number of rows in the dataset.
   *
   * @return the number of rows
   */
  getRowCount: function () {
    return this.rows;
  },
  /**
   * Returns the number of columns in the dataset.
   *
   * @return the number of columns
   */
  getColumnCount: function () {
    return this.columns;
  },
  /**
   * Returns the value at the given row and column for the given series.
   * Series can be used to store standard error of data points for example.
   *
   * @param rowIndex
   *            the row index
   * @param columnIndex
   *            the column index
   * @param seriesIndex
   *            the series index
   * @return the value
   */
  getValue: function (rowIndex, columnIndex, seriesIndex) {
    // not implemented
  },
  /**
   * Sets the value at the given row and column for the given series.
   *
   * @param rowIndex
   *            the row index
   *
   * @param columnIndex
   *            the column index
   * @param value
   *            the value
   * @param seriesIndex
   *            the series index
   *
   */
  setValue: function (rowIndex, columnIndex, value, seriesIndex) {
    // not implemented
  },
  /**
   * Adds the specified series.
   *
   * @param options
   * @param options.name
   *            the series name
   * @param options.dataType
   *            the series data type (e.g. object, Float32, Int8)
   * @return the series index
   */
  addSeries: function (options) {
    // not implemented
  },
  /**
   * Removes the specified series.
   *
   * @param seriesIndex The series index.
   */
  removeSeries: function (seriesIndex) {
    this.seriesArrays.splice(seriesIndex, 1);
    this.seriesNames.splice(seriesIndex, 1);
    this.seriesDataTypes.splice(seriesIndex, 1);
  },
  /**
   * Returns the number of matrix series. Series can be used to store standard
   * error of data points for example.
   *
   * @return the number of series
   */
  getSeriesCount: function () {
    return this.seriesArrays.length;
  },
  /**
   * Returns the data type at the specified series index.
   *
   * @param seriesIndex
   *            the series index
   * @return the series data type (e.g. Number, Float32, Int8)
   */
  getDataType: function (seriesIndex) {
    return this.seriesDataTypes[seriesIndex || 0];
  },
  toString: function () {
    return this.getName();
  }
};

/**
 *
 * Creates a new vector with the given name and size. Subclasses must implement getValue
 *
 * @param {string} name
 *            the vector name
 * @param size {number}
 *            the number of elements in this vector
 * @implements {morpheus.VectorInterface}
 * @constructor
 */
morpheus.AbstractVector = function (name, size) {
  this.name = name;
  this.n = size;
  this.properties = new morpheus.Map();
};

morpheus.AbstractVector.prototype = {
  getValue: function (index) {
    throw new Error('Not implemented');
  },
  getProperties: function () {
    return this.properties;
  },
  size: function () {
    return this.n;
  },
  getName: function () {
    return this.name;
  }
};

morpheus.SignalToNoise = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  var s1 = Math.sqrt(morpheus.Variance(list1, m1));
  var s2 = Math.sqrt(morpheus.Variance(list2, m2));
  return (m1 - m2) / (s1 + s2);
};
morpheus.SignalToNoise.toString = function () {
  return 'Signal to noise';
};

morpheus.createSignalToNoiseAdjust = function (percent) {
  percent = percent || 0.2;
  var f = function (list1, list2) {
    var m1 = morpheus.Mean(list1);
    var m2 = morpheus.Mean(list2);
    var s1 = Math.sqrt(morpheus.Variance(list1, m1));
    var s2 = Math.sqrt(morpheus.Variance(list2, m2));
    s1 = morpheus.SignalToNoise.thresholdStandardDeviation(m1, s1, percent);
    s2 = morpheus.SignalToNoise.thresholdStandardDeviation(m2, s2, percent);
    // ensure variance is at least 20% of mean
    return (m1 - m2) / (s1 + s2);
  };
  f.toString = function () {
    return 'Signal to noise (adjust standard deviation)';
  };
  return f;
};

morpheus.SignalToNoise.thresholdStandardDeviation = function (mean,
                                                              standardDeviation, percent) {
  var returnValue = standardDeviation;
  var absMean = Math.abs(mean);
  var minStdev = percent * absMean;
  if (minStdev > standardDeviation) {
    returnValue = minStdev;
  }

  if (returnValue < percent) {
    returnValue = percent;
  }
  return returnValue;
};

morpheus.createContingencyTable = function (listOne, listTwo, groupingValue) {
  if (groupingValue == null || isNaN(groupingValue)) {
    groupingValue = 1;
  }
  var aHit = 0;
  var aMiss = 0;
  for (var j = 0, size = listOne.size(); j < size; j++) {
    var val = listOne.getValue(j);
    if (!isNaN(val)) {
      if (val >= groupingValue) {
        aHit++;
      } else {
        aMiss++;
      }
    }

  }
  var bHit = 0;
  var bMiss = 0;
  for (var j = 0, size = listTwo.size(); j < size; j++) {
    var val = listTwo.getValue(j);
    if (!isNaN(val)) {
      if (val >= groupingValue) {
        bHit++;
      } else {
        bMiss++;
      }
    }

  }
  // listOne=drawn, listTwo=not drawn
  // green=1, red=0
  var N = aHit + aMiss + bHit + bMiss;
  var K = aHit + bHit;
  var n = aHit + aMiss;
  var k = aHit;
  var a = k;
  var b = K - k;
  var c = n - k;
  var d = N + k - n - K;
  return [a, b, c, d];
};
morpheus.FisherExact = function (listOne, listTwo) {
  var abcd = morpheus.createContingencyTable(listOne, listTwo, 1);
  return morpheus.FisherExact.fisherTest(abcd[0], abcd[1], abcd[2], abcd[3]);
};

morpheus.createFisherExact = function (groupingValue) {
  var f = function (listOne, listTwo) {
    var abcd = morpheus.createContingencyTable(listOne, listTwo,
      groupingValue);
    return morpheus.FisherExact.fisherTest(abcd[0], abcd[1], abcd[2],
      abcd[3]);
  };
  return f;

};

/**
 * Computes the hypergeometric probability.
 */
morpheus.FisherExact.phyper = function (a, b, c, d) {
  return Math
  .exp((morpheus.FisherExact.logFactorial(a + b)
    + morpheus.FisherExact.logFactorial(c + d)
    + morpheus.FisherExact.logFactorial(a + c) + morpheus.FisherExact
    .logFactorial(b + d))
    - (morpheus.FisherExact.logFactorial(a)
    + morpheus.FisherExact.logFactorial(b)
    + morpheus.FisherExact.logFactorial(c)
    + morpheus.FisherExact.logFactorial(d) + morpheus.FisherExact
    .logFactorial(a + b + c + d)));

};

morpheus.FisherExact.logFactorials = [0.00000000000000000,
  0.00000000000000000, 0.69314718055994531, 1.79175946922805500,
  3.17805383034794562, 4.78749174278204599, 6.57925121201010100,
  8.52516136106541430, 10.60460290274525023, 12.80182748008146961,
  15.10441257307551530, 17.50230784587388584, 19.98721449566188615,
  22.55216385312342289, 25.19122118273868150, 27.89927138384089157,
  30.67186010608067280, 33.50507345013688888, 36.39544520803305358,
  39.33988418719949404, 42.33561646075348503, 45.38013889847690803,
  48.47118135183522388, 51.60667556776437357, 54.78472939811231919,
  58.00360522298051994, 61.26170176100200198, 64.55753862700633106,
  67.88974313718153498, 71.25703896716800901];
morpheus.FisherExact.logFactorial = function (k) {
  if (k >= 30) { // stirlings approximation
    var C0 = 9.18938533204672742e-01;
    var C1 = 8.33333333333333333e-02;
    var C3 = -2.77777777777777778e-03;
    var C5 = 7.93650793650793651e-04;
    var C7 = -5.95238095238095238e-04;
    var r = 1.0 / k;
    var rr = r * r;
    return (k + 0.5) * Math.log(k) - k + C0 + r
      * (C1 + rr * (C3 + rr * (C5 + rr * C7)));
    // log k! = (k + 1/2)log(k) - k + (1/2)log(2Pi) + stirlingCorrection(k)
  }
  return morpheus.FisherExact.logFactorials[k];
};

morpheus.FisherExact.fisherTest = function (a, b, c, d) {
  // match R 2-sided fisher.test
  var p = morpheus.FisherExact.phyper(a, b, c, d);
  var sum = p;
  for (var _a = 0, n = a + b + c + d; _a <= n; _a++) {
    var _b = a + b - _a;
    var _c = a + c - _a;
    var _d = b + d - _b;
    if (_a !== a && _b >= 0 && _c >= 0 && _d >= 0) {
      var _p = morpheus.FisherExact.phyper(_a, _b, _c, _d);
      if (_p <= p) {
        sum += _p;
      }
    }
  }
  return Math.min(1, sum);
  // var lt = jStat.hypgeom.cdf(a, a + b + c + d, a + b, a + c);
  // var gt = jStat.hypgeom.cdf(b, a + b + c + d, a + b, b + d);
  // return Math.min(1, 2 * Math.min(lt, gt));
};
morpheus.FisherExact.toString = function () {
  return 'Fisher Exact Test';
};

morpheus.FoldChange = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  return (m1 / m2);
};
morpheus.FoldChange.toString = function () {
  return 'Fold Change';
};

morpheus.MeanDifference = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  var diff = m1 - m2;
  return diff;
};
morpheus.MeanDifference.toString = function () {
  return 'Mean Difference';
};
morpheus.TTest = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  var s1 = Math.sqrt(morpheus.Variance(list1, m1));
  var s2 = Math.sqrt(morpheus.Variance(list2, m2));
  var n1 = morpheus.CountNonNaN(list1);
  var n2 = morpheus.CountNonNaN(list2);
  return ((m1 - m2) / Math.sqrt((s1 * s1 / n1) + (s2 * s2 / n2)));
};
morpheus.TTest.toString = function () {
  return 'T-Test';
};
/**
 * Computes approximate degrees of freedom for 2-sample t-test.
 *
 * @param v1 first sample variance
 * @param v2 second sample variance
 * @param n1 first sample n
 * @param n2 second sample n
 * @return approximate degrees of freedom
 */
morpheus.DegreesOfFreedom = function (v1, v2, n1, n2) {
  return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2))) / ((v1 * v1) / (n1 * n1 * (n1 - 1.0)) + (v2 * v2) / (n2 * n2 * (n2 - 1.0)));
};

morpheus.Spearman = function (list1, list2) {
  var flist1 = [];
  var flist2 = [];
  for (var i = 0, n = list1.size(); i < n; i++) {
    var v1 = list1.getValue(i);
    var v2 = list2.getValue(i);
    if (isNaN(v1) || isNaN(v2)) {
      continue;
    }
    flist1.push(v1);
    flist2.push(v2);
  }
  var rank1 = morpheus.Ranking(flist1);
  var rank2 = morpheus.Ranking(flist2);
  return morpheus.Pearson(new morpheus.Vector('', rank1.length)
  .setArray(rank1), new morpheus.Vector('', rank2.length)
  .setArray(rank2));
};
morpheus.Spearman.toString = function () {
  return 'Spearman rank correlation';
};
morpheus.WeightedMean = function (weights, values) {
  var numerator = 0;
  var denom = 0;
  for (var i = 0, size = values.size(); i < size; i++) {
    var value = values.getValue(i);
    if (!isNaN(value)) {
      var weight = Math.abs(weights.getValue(i));
      if (!isNaN(weight)) {
        numerator += (weight * value);
        denom += weight;
      }
    }
  }
  return denom === 0 ? NaN : numerator / denom;
};
morpheus.WeightedMean.toString = function () {
  return 'Weighted average';
};

morpheus.createOneMinusMatrixValues = function (dataset) {
  var f = function (listOne, listTwo) {
    return 1 - dataset.getValue(listOne.getIndex(), listTwo.getIndex());
  };
  f.toString = function () {
    return 'One minus matrix values (for a precomputed similarity matrix)';
  };
  return f;
};

morpheus.Pearson = function (listOne, listTwo) {
  var sumx = 0;
  var sumxx = 0;
  var sumy = 0;
  var sumyy = 0;
  var sumxy = 0;
  var N = 0;
  for (var i = 0, size = listOne.size(); i < size; i++) {
    var x = listOne.getValue(i);
    var y = listTwo.getValue(i);
    if (isNaN(x) || isNaN(y)) {
      continue;
    }
    sumx += x;
    sumxx += x * x;
    sumy += y;
    sumyy += y * y;
    sumxy += x * y;
    N++;
  }
  var numr = sumxy - (sumx * sumy / N);
  var denr = Math.sqrt((sumxx - (sumx * sumx / N))
    * (sumyy - (sumy * sumy / N)));
  return denr == 0 ? 1 : numr / denr;
};
morpheus.Pearson.toString = function () {
  return 'Pearson correlation';
};

morpheus.Jaccard = function (listOne, listTwo) {

  var orCount = 0;
  var andCount = 0;
  for (var i = 0, size = listOne.size(); i < size; i++) {
    var xval = listOne.getValue(i);
    var yval = listTwo.getValue(i);
    if (isNaN(xval) || isNaN(yval)) {
      continue;
    }
    var x = xval > 0;
    var y = yval > 0;
    if (x && y) {
      andCount++;
    } else if (x || y) {
      orCount++;
    }
  }
  if (orCount === 0) {
    return 1;
  }
  return 1 - (andCount / orCount);
};

morpheus.Jaccard.toString = function () {
  return 'Jaccard distance';
};

morpheus.Cosine = function (listOne, listTwo) {
  var sumX2 = 0;
  var sumY2 = 0;
  var sumXY = 0;
  for (var i = 0, size = listOne.size(); i < size; i++) {
    var x = listOne.getValue(i);
    var y = listTwo.getValue(i);
    if (isNaN(x) || isNaN(y)) {
      continue;
    }
    sumX2 += x * x;
    sumY2 += y * y;
    sumXY += x * y;
  }
  return (sumXY / Math.sqrt(sumX2 * sumY2));
};

morpheus.Cosine.toString = function () {
  return 'Cosine similarity';
};

morpheus.Euclidean = function (x, y) {
  var dist = 0;
  for (var i = 0, size = x.size(); i < size; ++i) {
    var x_i = x.getValue(i);
    var y_i = y.getValue(i);
    if (isNaN(x_i) || isNaN(y_i)) {
      continue;
    }
    dist += (x_i - y_i) * (x_i - y_i);
  }
  return Math.sqrt(dist);
};
morpheus.Euclidean.toString = function () {
  return 'Euclidean distance';
};
morpheus.OneMinusFunction = function (f) {
  var dist = function (x, y) {
    return 1 - f(x, y);
  };
  dist.toString = function () {
    var s = f.toString();
    return 'One minus ' + s[0].toLowerCase() + s.substring(1);
  };
  return dist;
};

morpheus.LinearRegression = function (xVector, yVector) {
  var sumX = 0;
  var sumY = 0;
  var sumXX = 0;
  var sumXY = 0;
  var count = 0;
  for (var i = 0, size = xVector.size(); i < size; i++) {
    var x = xVector.getValue(i);
    var y = yVector.getValue(i);
    if (!isNaN(x) && !isNaN(y)) {
      sumX += x;
      sumY += y;
      sumXX += x * x;
      sumXY += x * y;
      count++;
    }
  }

  var m = ((count * sumXY) - (sumX * sumY)) /
    ((count * sumXX) - (sumX * sumX));
  var b = (sumY / count) - ((m * sumX) / count);
  return {
    m: m,
    b: b
  };
};

morpheus.KendallsCorrelation = function (x, y) {

  /**
   * Returns the sum of the number from 1 .. n according to Gauss' summation formula:
   * \[ \sum\limits_{k=1}^n k = \frac{n(n + 1)}{2} \]
   *
   * @param n the summation end
   * @return the sum of the number from 1 to n
   */
  function sum(n) {
    return n * (n + 1) / 2;
  }

  var xArray = [];
  var yArray = [];
  for (var i = 0, size = x.size(); i < size; ++i) {
    var x_i = x.getValue(i);
    var y_i = y.getValue(i);
    if (isNaN(x_i) || isNaN(y_i)) {
      continue;
    }
    xArray.push(x_i);
    yArray.push(y_i);
  }
  var n = xArray.length;
  var numPairs = sum(n - 1);
  var pairs = [];
  for (var i = 0; i < n; i++) {
    pairs[i] = [xArray[i], yArray[i]];
  }
  pairs.sort(function (pair1, pair2) {
    var a = pair1[0];
    var b = pair2[0];
    var compareFirst = (a === b ? 0 : (a < b ? -1 : 1));
    if (compareFirst !== 0) {
      return compareFirst;
    }
    a = pair1[1];
    b = pair2[1];
    return (a === b ? 0 : (a < b ? -1 : 1));
  });

  var tiedXPairs = 0;
  var tiedXYPairs = 0;
  var consecutiveXTies = 1;
  var consecutiveXYTies = 1;
  var prev = pairs[0];
  for (var i = 1; i < n; i++) {
    var curr = pairs[i];
    if (curr[0] === prev[0]) {
      consecutiveXTies++;
      if (curr[1] === prev[1]) {
        consecutiveXYTies++;
      } else {
        tiedXYPairs += sum(consecutiveXYTies - 1);
        consecutiveXYTies = 1;
      }
    } else {
      tiedXPairs += sum(consecutiveXTies - 1);
      consecutiveXTies = 1;
      tiedXYPairs += sum(consecutiveXYTies - 1);
      consecutiveXYTies = 1;
    }
    prev = curr;
  }
  tiedXPairs += sum(consecutiveXTies - 1);
  tiedXYPairs += sum(consecutiveXYTies - 1);
  var swaps = 0;
  var pairsDestination = [];
  for (var segmentSize = 1; segmentSize < n; segmentSize <<= 1) {
    for (var offset = 0; offset < n; offset += 2 * segmentSize) {
      var i = offset;
      var iEnd = Math.min(i + segmentSize, n);
      var j = iEnd;
      var jEnd = Math.min(j + segmentSize, n);
      var copyLocation = offset;
      while (i < iEnd || j < jEnd) {
        if (i < iEnd) {
          if (j < jEnd) {
            var c = (pairs[i][1] === pairs[j][1] ? 0 : (pairs[i][1] < pairs[j][1] ? -1 : 1));
            if (c <= 0) {
              pairsDestination[copyLocation] = pairs[i];
              i++;
            } else {
              pairsDestination[copyLocation] = pairs[j];
              j++;
              swaps += iEnd - i;
            }
          } else {
            pairsDestination[copyLocation] = pairs[i];
            i++;
          }
        } else {
          pairsDestination[copyLocation] = pairs[j];
          j++;
        }
        copyLocation++;
      }
    }
    var pairsTemp = pairs;
    pairs = pairsDestination;
    pairsDestination = pairsTemp;
  }

  var tiedYPairs = 0;
  var consecutiveYTies = 1;
  prev = pairs[0];
  for (var i = 1; i < n; i++) {
    var curr = pairs[i];
    if (curr[1] === prev[1]) {
      consecutiveYTies++;
    } else {
      tiedYPairs += sum(consecutiveYTies - 1);
      consecutiveYTies = 1;
    }
    prev = curr;
  }
  tiedYPairs += sum(consecutiveYTies - 1);

  var concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
  var nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (numPairs - tiedYPairs);
  return concordantMinusDiscordant / Math.sqrt(nonTiedPairsMultiplied);
};
morpheus.KendallsCorrelation.toString = function () {
  return 'Kendall\'s correlation';
};

/**
 * Creates a new computed vector with the given name and size.
 *
 * @param name
 *            the vector name
 * @param size
 *            the number of elements in this vector
 * @param callback {Function} that takes an index and returns the value at the specified index
 * @constructor
 */
morpheus.ComputedVector = function (name, size, callback) {
  morpheus.AbstractVector.call(this, name, size);
  this.callback = callback;
};

morpheus.ComputedVector.prototype = {
  getValue: function (index) {
    return this.callback(index);
  }
};
morpheus.Util.extend(morpheus.ComputedVector, morpheus.AbstractVector);

morpheus.DatasetAdapter = function (dataset, rowMetadata, columnMetadata) {
  if (dataset == null) {
    throw 'dataset is null';
  }
  this.dataset = dataset;
  this.rowMetadata = rowMetadata || dataset.getRowMetadata();
  this.columnMetadata = columnMetadata || dataset.getColumnMetadata();

};
morpheus.DatasetAdapter.prototype = {
  getDataset: function () {
    return this.dataset;
  },
  getName: function (seriesIndex) {
    return this.dataset.getName(seriesIndex);
  },
  setName: function (seriesIndex, name) {
    this.dataset.setName(seriesIndex, name);
  },
  getRowMetadata: function () {
    return this.rowMetadata;
  },
  getColumnMetadata: function () {
    return this.columnMetadata;
  },
  getRowCount: function () {
    return this.dataset.getRowCount();
  },
  getColumnCount: function () {
    return this.dataset.getColumnCount();
  },
  getValue: function (rowIndex, columnIndex, seriesIndex) {
    return this.dataset.getValue(rowIndex, columnIndex, seriesIndex);
  },
  setValue: function (rowIndex, columnIndex, value, seriesIndex) {
    this.dataset.setValue(rowIndex, columnIndex, value, seriesIndex);
  },
  addSeries: function (options) {
    return this.dataset.addSeries(options);
  },
  removeSeries: function (seriesIndex) {
    this.dataset.removeSeries(seriesIndex);
  },
  getSeriesCount: function () {
    return this.dataset.getSeriesCount();
  },
  getDataType: function (seriesIndex) {
    return this.dataset.getDataType(seriesIndex);
  },
  toString: function () {
    return this.dataset.toString();
  }
};

morpheus.DatasetColumnView = function (dataset) {
  this.dataset = dataset;
  this.columnIndex = 0;
  this.seriesIndex = 0;
};
morpheus.DatasetColumnView.prototype = {
  columnIndex: -1,
  size: function () {
    return this.dataset.getRowCount();
  },
  getValue: function (rowIndex) {
    return this.dataset.getValue(rowIndex, this.columnIndex,
      this.seriesIndex);
  },
  setIndex: function (newColumnIndex) {
    this.columnIndex = newColumnIndex;
    return this;
  },
  setSeriesIndex: function (seriesIndex) {
    this.seriesIndex = seriesIndex;
    return this;
  }
};

/**
 * The interface for a dataset consisting of a two-dimensional matrix of
 * values. A dataset may also optionally contain one or more series of
 * two-dimensional matrices. A dataset also has metadata associated with each
 * row and column.
 *
 * @interface morpheus.DatasetInterface
 */

/**
 * Returns the name for the given series. Series can be used to store
 * standard error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#getName
 * @param seriesIndex {number} the series
 * @return {string} the series name
 */

/**
 * Sets the name for the given series. Series can be used to store standard
 * error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#setName
 * @param seriesIndex {number} the series
 * @param name {string} the series name
 */

/**
 * Gets the row metadata for this dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getRowMetadata
 * @return {morpheus.MetadataModelInterface} the row metadata
 */

/**
 * Gets the column metadata for this dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getColumnMetadata
 * @return {morpheus.MetadataModelInterface} The column metadata
 */

/**
 * Returns the number of rows in the dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getRowCount
 * @return {number} the number of rows
 */

/**
 * Returns the number of columns in the dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getColumnCount
 * @return {number} the number of columns
 */

/**
 * Returns the value at the given row and column for the given series.
 * Series can be used to store standard error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#getValue
 * @param rowIndex {number} the row index
 * @param columnIndex {number} the column index
 * @param seriesIndex {number} the series index
 * @return the value
 */

/**
 * Sets the value at the given row and column for the given series.
 *
 * @function
 * @name morpheus.DatasetInterface#setValue
 * @param rowIndex {number} the row index
 * @param columnIndex {number} the column index
 * @param value the value
 * @param seriesIndex {number} the series index
 */

/**
 * Adds the specified series.
 *
 * @function
 * @name morpheus.DatasetInterface#addSeries
 * @param options.name {string} the series name
 * @param options.dataType {string} the series data type (e.g. object, Float32, Int8)
 * @return {number} the series index
 */

/**
 * Removes the specified series.
 *
 * @function
 * @name morpheus.DatasetInterface#removeSeries
 * @param seriesIndex {number} The series index.
 */

/**
 * Returns the number of matrix series. Series can be used to store standard
 * error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#getSeriesCount
 * @return {number} the number of series
 */

/**
 * Returns the data type at the specified series index.
 *
 * @function
 * @name morpheus.DatasetInterface#getDataType
 * @param seriesIndex {number} the series index
 * @return {string} the series data type (e.g. Number, Float32, Int8)
 */


morpheus.DatasetRowView = function (dataset) {
  this.dataset = dataset;
  this.index = 0;
  this.seriesIndex = 0;
};
morpheus.DatasetRowView.prototype = {
  size: function () {
    return this.dataset.getColumnCount();
  },
  getIndex: function () {
    return this.index;
  },
  getValue: function (columnIndex) {
    return this.dataset.getValue(this.index, columnIndex, this.seriesIndex);
  },
  setIndex: function (newRowIndex) {
    this.index = newRowIndex;
    return this;
  },
  setSeriesIndex: function (seriesIndex) {
    this.seriesIndex = seriesIndex;
    return this;
  },
  setDataset: function (dataset) {
    this.dataset = dataset;
    return this;
  }
};

morpheus.DatasetSeriesView = function (dataset, seriesIndices) {
  morpheus.DatasetAdapter.call(this, dataset);
  this.seriesIndices = seriesIndices;
};
morpheus.DatasetSeriesView.prototype = {
  getValue: function (i, j, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    return this.dataset.getValue(i, j, this.seriesIndices[seriesIndex]);
  },
  setValue: function (i, j, value, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    this.dataset.setValue(i, j, value, this.seriesIndices[seriesIndex]);
  },
  getName: function (seriesIndex) {
    seriesIndex = seriesIndex || 0;
    return this.dataset.getName(this.seriesIndices[seriesIndex]);
  },
  setName: function (seriesIndex, name) {
    seriesIndex = seriesIndex || 0;
    this.dataset.setName(this.seriesIndices[seriesIndex], name);
  },
  addSeries: function (options) {
    var index = this.dataset.addSeries(options);
    this.seriesIndices.push(index);
    return index;
  },
  getSeriesCount: function () {
    return this.seriesIndices.length;
  },
  toString: function () {
    return this.getName();
  }
};
morpheus.Util.extend(morpheus.DatasetSeriesView, morpheus.DatasetAdapter);

/**
 * Static utilities for morpheus.DatasetInterface instances
 *
 * @class morpheus.DatasetUtil
 */
morpheus.DatasetUtil = function () {
};
morpheus.DatasetUtil.min = function (dataset, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  var min = Number.MAX_VALUE;
  for (var i = 0, rows = dataset.getRowCount(); i < rows; i++) {
    for (var j = 0, columns = dataset.getColumnCount(); j < columns; j++) {
      var d = dataset.getValue(i, j, seriesIndex);
      if (isNaN(d)) {
        continue;
      }
      min = Math.min(min, d);
    }
  }
  return min;
};
morpheus.DatasetUtil.slicedView = function (dataset, rows, columns) {
  return new morpheus.SlicedDatasetView(dataset, rows, columns);
};
morpheus.DatasetUtil.transposedView = function (dataset) {
  return dataset instanceof morpheus.TransposedDatasetView ? dataset
    .getDataset() : new morpheus.TransposedDatasetView(dataset);
};
morpheus.DatasetUtil.max = function (dataset, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  var max = -Number.MAX_VALUE;
  for (var i = 0, rows = dataset.getRowCount(); i < rows; i++) {
    for (var j = 0, columns = dataset.getColumnCount(); j < columns; j++) {
      var d = dataset.getValue(i, j, seriesIndex);
      if (isNaN(d)) {
        continue;
      }
      max = Math.max(max, d);
    }
  }
  return max;
};

morpheus.DatasetUtil.getDatasetReader = function (ext, options) {
  if (options == null) {
    options = {};
  }
  var datasetReader = null;
  if (ext === 'maf') {
    datasetReader = new morpheus.MafFileReader();
    if (options && options.mafGeneFilter) {
      datasetReader.setGeneFilter(options.mafGeneFilter);
    }
  } else if (ext === 'gct') {
    datasetReader = new morpheus.GctReader();
    // datasetReader = new morpheus.StreamingGctReader();
  } else if (ext === 'gmt') {
    datasetReader = new morpheus.GmtDatasetReader();
  } else if (ext === 'xlsx' || ext === 'xls') {
    datasetReader = options.interactive ? new morpheus.Array2dReaderInteractive() : new morpheus.XlsxDatasetReader();
  } else if (ext === 'segtab' || ext === 'seg') {
    datasetReader = new morpheus.SegTabReader();
    if (options && options.regions) {
      datasetReader.setRegions(options.regions);
    }
  } else if (ext === 'txt' || ext === 'tsv' || ext === 'csv') {
    datasetReader = options.interactive ? new morpheus.Array2dReaderInteractive() : new morpheus.TxtReader();
  } else if (ext === 'json') {
    datasetReader = new morpheus.JsonDatasetReader();
  } else if (ext === 'gct') {
    datasetReader = new morpheus.GctReader();
  }
  return datasetReader;
};

morpheus.DatasetUtil.readDatasetArray = function (datasets) {
  var retDef = $.Deferred();
  var loadedDatasets = [];
  var promises = [];
  _.each(datasets, function (url, i) {
    var p = morpheus.DatasetUtil.read(url);
    p.index = i;
    p.done(function (dataset) {
      loadedDatasets[this.index] = dataset;
    });
    p.fail(function (err) {
      var message = [
        'Error opening ' + morpheus.Util
          .getFileName(url) + '.'];
      if (err.message) {
        message.push('<br />Cause: ');
        message.push(err.message);
      }
      retDef.reject(message.join(''));

    });
    promises.push(p);
  });
  if (promises.length === 0) {
    retDef.reject('No datasets specified.');
  }

  $.when
    .apply($, promises)
    .then(
      function () {
        retDef.resolve(morpheus.DatasetUtil.join(loadedDatasets, 'id'));
      });
  return retDef;
};
/**
 * Annotate a dataset from external file or text.
 *
 * @param options.annotations -
 *            Array of file, datasetField, and fileField, and transposed.
 * @param options.isColumns
 *            Whether to annotate columns
 *
 * @return A jQuery Deferred object that resolves to an array of functions to
 *         execute with a dataset parameter.
 */
morpheus.DatasetUtil.annotate = function (options) {
  var retDef = $.Deferred();
  var promises = [];
  var functions = [];
  var isColumns = options.isColumns;
  _.each(options.annotations, function (ann, annotationIndex) {
    if (morpheus.Util.isArray(ann.file)) { // already parsed text
      functions[annotationIndex] = function (dataset) {
        new morpheus.OpenFileTool().annotate(ann.file, dataset,
          isColumns, null, ann.datasetField, ann.fileField,
          ann.include);
      };
    } else {
      var result = morpheus.Util.readLines(ann.file);
      var fileName = morpheus.Util.getFileName(ann.file);
      var deferred = $.Deferred();
      promises.push(deferred);
      result.fail(function (message) {
        deferred.reject(message);
      });
      result.done(function (lines) {
        if (morpheus.Util.endsWith(fileName, '.gmt')) {
          var sets = new morpheus.GmtReader().parseLines(lines);
          functions[annotationIndex] = function (dataset) {
            new morpheus.OpenFileTool().annotate(null, dataset,
              isColumns, sets, ann.datasetField,
              ann.fileField);
          };
          deferred.resolve();
        } else if (morpheus.Util.endsWith(fileName, '.cls')) {
          functions[annotationIndex] = function (dataset) {
            new morpheus.OpenFileTool().annotateCls(null, dataset,
              fileName, isColumns, lines);
          };
          deferred.resolve();
        } else {
          functions[annotationIndex] = function (dataset) {
            new morpheus.OpenFileTool().annotate(lines, dataset,
              isColumns, null, ann.datasetField,
              ann.fileField, ann.include, ann.transposed);
          };
          deferred.resolve();
        }
      });
    }
  });
  $.when.apply($, promises).then(function () {
    retDef.resolve(functions);
  });
  return retDef;
};
/**
 * Reads a dataset at the specified URL or file
 * @param fileOrUrl
 *            a File or URL
 * @param options.background
 * @params options.interactive
 * @params options.extension
 * @return A promise that resolves to morpheus.DatasetInterface
 */
morpheus.DatasetUtil.read = function (fileOrUrl, options) {
  if (fileOrUrl == null) {
    throw 'File is null';
  }
  if (options == null) {
    options = {};
  }
  var isFile = morpheus.Util.isFile(fileOrUrl);
  var isString = morpheus.Util.isString(fileOrUrl);
  var ext = options.extension ? options.extension : morpheus.Util.getExtension(morpheus.Util.getFileName(fileOrUrl));
  var datasetReader;
  var str = fileOrUrl.toString();
  if (ext === '' && str != null && str.indexOf('blob:') === 0) {
    datasetReader = options.interactive ? new morpheus.Array2dReaderInteractive() : new morpheus.TxtReader(); // copy from clipboard
  } else {
    datasetReader = morpheus.DatasetUtil.getDatasetReader(ext, options);
    if (datasetReader == null) {
      datasetReader = isFile ? (options.interactive ? new morpheus.Array2dReaderInteractive() : new morpheus.TxtReader()) : new morpheus.GctReader();
    }
  }
  if (isString || isFile) { // URL or file
    var deferred = $.Deferred();
    if (options.background) {
      var path = morpheus.Util.getScriptPath();
      var blob = new Blob(
        [
          'self.onmessage = function(e) {'
          + 'importScripts(e.data.path);'
          + 'var ext = morpheus.Util.getExtension(morpheus.Util'
          + '.getFileName(e.data.fileOrUrl));'
          + 'var datasetReader = morpheus.DatasetUtil.getDatasetReader(ext,'
          + '	e.data.options);'
          + 'datasetReader.read(e.data.fileOrUrl, function(err,dataset) {'
          + '	self.postMessage(dataset);' + '	});' + '}']);

      var blobURL = window.URL.createObjectURL(blob);
      var worker = new Worker(blobURL);
      worker.addEventListener('message', function (e) {
        deferred.resolve(morpheus.Dataset.fromJSON(e.data));
        window.URL.revokeObjectURL(blobURL);
      }, false);
      // start the worker
      worker.postMessage({
        path: path,
        fileOrUrl: fileOrUrl,
        options: options
      });

    } else {
      datasetReader.read(fileOrUrl, function (err, dataset) {
        if (err) {
          deferred.reject(err);
        } else {
          deferred.resolve(dataset);
        }
      });
    }
    var pr = deferred.promise();
    // override toString so can determine file name
    pr.toString = function () {
      return '' + fileOrUrl;
    };
    return pr;
  } else if (typeof fileOrUrl.done === 'function') { // assume it's a
    // deferred
    return fileOrUrl;
  } else { // it's already a dataset?
    if (fileOrUrl.promise) { // it's a promise
      return fileOrUrl;
    }
    var deferred = $.Deferred();
    if (fileOrUrl.getRowCount) { // it's a dataset
      deferred.resolve(fileOrUrl);
    } else { // JSON
      deferred.resolve(morpheus.Dataset.fromJSON(fileOrUrl));
    }
    return deferred.promise();
  }

};

/**
 * @param dataset
 *            The dataset to convert to an array
 * @param options.columns
 *            An array of column indices to include from the dataset
 * @param options.columnFields
 *            An array of field names to use in the returned objects that
 *            correspond to the column indices in the dataset
 * @param options.metadataFields
 *            An array of row metadata fields to include from the dataset
 *
 */
morpheus.DatasetUtil.toObjectArray = function (dataset, options) {
  var columns = options.columns || [0];
  var columnFields = options.columnFields || ['value'];
  if (columnFields.length !== columns.length) {
    throw 'columns.length !== columnFields.length';
  }
  var metadataFields = options.metadataFields;
  // grab all of the headers and filter the meta data vectors in the dataset
  // down
  // to the ones specified in metaFields. If metaFields is not passed, take
  // all metadata
  var rowMetadata = dataset.getRowMetadata();
  if (!metadataFields) {
    metadataFields = morpheus.MetadataUtil.getMetadataNames(rowMetadata);
  }
  var vectors = morpheus.MetadataUtil.getVectors(rowMetadata, metadataFields);
  // build an object that contains the matrix values for the given columns
  // along
  // with any metadata
  var array = [];
  for (var i = 0; i < dataset.getRowCount(); i++) {
    var obj = {};
    for (var j = 0; j < columns.length; j++) {
      obj[columnFields[j]] = dataset.getValue(i, columns[j]);
    }
    for (var j = 0; j < vectors.length; j++) {
      obj[vectors[j].getName()] = vectors[j].getValue(i);
    }
    array.push(obj);
  }
  return array;
};
morpheus.DatasetUtil.fixL1K = function (dataset) {
  var names = {
    'cell_id': 'Cell Line',
    'pert_idose': 'Dose (\u00B5M)',
    'pert_iname': 'Name',
    'pert_itime': 'Time (hr)',
    'distil_ss': 'Signature Strength',
    'pert_type': 'Type',
    'cell_lineage': 'Lineage',
    'cell_histology': 'Histology',
    'cell_type': 'Cell Type'
  };
  var fixNames = function (metadata) {
    for (var i = 0, count = metadata.getMetadataCount(); i < count; i++) {
      var v = metadata.get(i);
      var name = v.getName();
      var mapped = names[name];
      if (mapped) {
        v.setName(mapped);
      }
    }
  };
  fixNames(dataset.getRowMetadata());
  fixNames(dataset.getColumnMetadata());
  var fix666 = function (metadata) {
    for (var i = 0, count = metadata.getMetadataCount(); i < count; i++) {
      var v = metadata.get(i);
      if (v.getName() == 'Dose (\u00B5M)') { // convert to number
        for (var j = 0, size = v.size(); j < size; j++) {
          var value = v.getValue(j);
          if (value != null) {
            v.setValue(j, parseFloat(value));
          }
        }
      }
      var isNumber = false;
      for (var j = 0, size = v.size(); j < size; j++) {
        var value = v.getValue(j);
        if (value != null) {
          isNumber = _.isNumber(value);
          break;
        }
      }
      var newValue = isNumber || v.getName() == 'Dose (\u00B5M)' ? 0 : '';
      for (var j = 0, size = v.size(); j < size; j++) {
        var value = v.getValue(j);
        if (value != null && value == '-666') {
          v.setValue(j, newValue);
        }
      }
    }
  };
  fix666(dataset.getRowMetadata());
  fix666(dataset.getColumnMetadata());
  var fixCommas = function (metadata) {
    var regex = /(,)([^ ])/g;
    _.each(['Lineage', 'Histology'], function (name) {
      var v = metadata.getByName(name);
      if (v != null) {
        for (var i = 0, size = v.size(); i < size; i++) {
          var val = v.getValue(i);
          if (val) {
            v.setValue(i, val.replace(regex, ', $2'));
          }
        }
      }
    });
  };
  fixCommas(dataset.getRowMetadata());
  fixCommas(dataset.getColumnMetadata());
};
morpheus.DatasetUtil.geneSetsToDataset = function (name, sets) {
  var uniqueIds = new morpheus.Map();
  for (var i = 0, length = sets.length; i < length; i++) {
    var ids = sets[i].ids;
    for (var j = 0, nIds = ids.length; j < nIds; j++) {
      uniqueIds.set(ids[j], 1);
    }
  }
  var uniqueIdsArray = uniqueIds.keys();
  var dataset = new morpheus.Dataset({
    name: name,
    rows: uniqueIdsArray.length,
    columns: sets.length
  });
  var columnIds = dataset.getColumnMetadata().add('id');
  for (var i = 0, length = sets.length; i < length; i++) {
    columnIds.setValue(i, sets[i].name);
  }
  var rowIds = dataset.getRowMetadata().add('id');
  for (var i = 0, size = uniqueIdsArray.length; i < size; i++) {
    rowIds.setValue(i, uniqueIdsArray[i]);
  }
  var rowIdToIndex = morpheus.VectorUtil.createValueToIndexMap(rowIds);
  for (var i = 0, length = sets.length; i < length; i++) {
    var ids = sets[i].ids;
    for (var j = 0, nIds = ids.length; j < nIds; j++) {
      dataset.setValue(rowIdToIndex.get(ids[j]), i, 1);
    }
  }
  return dataset;
};

morpheus.DatasetUtil.getRootDataset = function (dataset) {
  while (dataset.getDataset) {
    dataset = dataset.getDataset();
  }
  return dataset;
};

morpheus.DatasetUtil.getSeriesIndex = function (dataset, name) {
  for (var i = 0, nseries = dataset.getSeriesCount(); i < nseries; i++) {
    if (name === dataset.getName(i)) {
      return i;
    }
  }
  return -1;
};
morpheus.DatasetUtil.getSeriesNames = function (dataset) {
  var names = [];
  for (var i = 0, nseries = dataset.getSeriesCount(); i < nseries; i++) {
    names.push(dataset.getName(i));
  }
  // names.sort(function (a, b) {
  // 	a = a.toLowerCase();
  // 	b = b.toLowerCase();
  // 	return (a < b ? -1 : (a === b ? 0 : 1));
  // });
  return names;
};

/**
 * Search dataset values.
 *
 * @param options.dataset
 *      The dataset
 * @param options.text
 *            Search text
 * @param options.defaultMatchMode
 *            'exact' or 'contains'
 * @param options.matchAllPredicates Whether to match all predicates
 * @return Set of matching indices.
 *
 */
morpheus.DatasetUtil.searchValues = function (options) {
  if (text === '') {
    return;
  }
  var dataset = options.dataset;
  var text = options.text;
  var tokens = morpheus.Util.getAutocompleteTokens(text);
  if (tokens.length == 0) {
    return;
  }
  var predicates = morpheus.Util.createSearchPredicates({
    tokens: tokens,
    defaultMatchMode: options.defaultMatchMode
  });
  var matchAllPredicates = options.matchAllPredicates === true;
  var npredicates = predicates.length;
  var viewIndices = new morpheus.Set();

  function isMatch(object, toObject, predicate) {
    if (object != null) {
      if (toObject) {
        var filterColumnName = predicate.getField();
        if (filterColumnName != null) {
          var value = object[filterColumnName];
          return predicate.accept(value);
        } else { // try all fields
          for (var name in object) {
            var value = object[name];
            return predicate.accept(value);
          }
        }
      } else {
        var filterColumnName = predicate.getField();
        if (filterColumnName == null || filterColumnName === dataset.getName(k)) {
          return predicate.accept(object);

        }
      }
    }
  }

  for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      var matches = false;
      itemSearch:
        if (matchAllPredicates) {
          matches = true;
          for (var p = 0; p < npredicates; p++) {
            var predicate = predicates[p];
            var pmatch = false;
            for (var k = 0, nseries = dataset.getSeriesCount(); k < nseries; k++) {
              var element = dataset.getValue(i, j, k);
              var isObject = element != null && element.toObject != null;
              if (isObject) {
                element = element.toObject();
              }
              if (isMatch(element, isObject, predicate)) {
                pmatch = true;
                break;
              }
            }
            if (!pmatch) {
              matches = false;
              break itemSearch;
            }
          }
        } else {
          for (var k = 0, nseries = dataset.getSeriesCount(); k < nseries; k++) {
            var element = dataset.getValue(i, j, k);
            var isObject = element != null && element.toObject != null;
            if (isObject) {
              element = element.toObject();
            }
            for (var p = 0; p < npredicates; p++) {
              var predicate = predicates[p];
              if (isMatch(element, isObject, predicate)) {
                matches = true;
                break itemSearch;
              }
            }
          }
        }

      if (matches) {
        viewIndices
          .add(new morpheus.Identifier(
            [i, j]));
      }
    }
  }
  return viewIndices;

};

/**
 * Search dataset values.
 */
morpheus.DatasetUtil.autocompleteValues = function (dataset) {
  return function (tokens, cb) {

    var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
      : '';
    token = $.trim(token);
    var seriesIndices = [];
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      for (var k = 0, nseries = dataset.getSeriesCount(); k < nseries; k++) {
        if (dataset.getDataType(i, k) === 'Number') {
          seriesIndices.push([i, k]);
        }
      }
    }
    if (seriesIndices.length === 0) {
      return cb();
    }
    var _val; // first non-null value
    elementSearch: for (var k = 0, nseries = seriesIndices.length; k < nseries; k++) {
      var pair = seriesIndices[k];
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        var element = dataset.getValue(pair[0], j, pair[1]);
        if (element != null && element.toObject) {
          _val = element.toObject();
          break elementSearch;
        }
      }
    }
    var matches = [];
    var fields = _val == null ? [] : _.keys(_val);
    if (token === '') {
      fields.sort(function (a, b) {
        return (a === b ? 0 : (a < b ? -1 : 1));
      });
      fields.forEach(function (field) {
        matches.push({
          value: field + ':',
          label: '<span style="font-weight:300;">' + field
          + ':</span>',
          show: true
        });
      });
      return cb(matches);
    }

    var field = null;
    var semi = token.indexOf(':');
    if (semi > 0) { // field search?
      if (token.charCodeAt(semi - 1) !== 92) { // \:
        var possibleField = $.trim(token.substring(0, semi));
        if (possibleField.length > 0 && possibleField[0] === '"'
          && possibleField[token.length - 1] === '"') {
          possibleField = possibleField.substring(1,
            possibleField.length - 1);
        }
        var index = fields.indexOf(possibleField);
        if (index !== -1) {
          token = $.trim(token.substring(semi + 1));
          field = possibleField;
        }
      }

    }

    var set = new morpheus.Set();
    // regex used to determine if a string starts with substring `q`
    var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
    // iterate through the pool of strings and for any string that
    // contains the substring `q`, add it to the `matches` array
    var max = 10;

    loop: for (var k = 0, nseries = seriesIndices.length; k < nseries; k++) {
      var pair = seriesIndices[k];
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        var element = dataset.getValue(pair[0], j, pair[1]);
        if (element && element.toObject) {
          var object = element.toObject();
          if (field !== null) {
            var val = object[field];
            if (val != null) {
              var id = new morpheus.Identifier([val, field]);
              if (!set.has(id) && regex.test(val)) {
                set.add(id);
                if (set.size() === max) {
                  break loop;
                }
              }
            }
          } else { // search all fields
            for (var name in object) {
              var val = object[name];
              var id = new morpheus.Identifier([val, name]);
              if (!set.has(id) && regex.test(val)) {
                set.add(id);
                if (set.size() === max) {
                  break loop;
                }
              }
            }
          }

        }
      }
    }
    set.forEach(function (id) {
      var array = id.getArray();
      var field = array[1];
      var val = array[0];
      matches.push({
        value: field + ':' + val,
        label: '<span style="font-weight:300;">' + field + ':</span>'
        + '<span style="font-weight:900;">' + val + '</span>'
      });

    });
    if (field == null) {
      fields.forEach(function (field) {
        if (regex.test(field)) {
          matches.push({
            value: field + ':',
            label: '<span style="font-weight:300;">' + field
            + ':</span>',
            show: true
          });
        }
      });
    }
    cb(matches);
  };

};
// morpheus.DatasetUtil.toJSON = function(dataset) {
// var json = [];
// json.push('{');
// json.push('"name":"' + dataset.getName() + '", ');
// json.push('"v":['); // row major 2d array
// for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
// if (i > 0) {
// json.push(',\n');
// }
// json.push('[');
// for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
// if (j > 0) {
// json.push(',');
// }
// json.push(JSON.stringify(dataset.getValue(i, j)));
// }
// json.push(']');
// }
// json.push(']'); // end v
// var metadatatoJSON = function(model) {
// json.push('[');
// for (var i = 0, count = model.getMetadataCount(); i < count; i++) {
// var v = model.get(i);
// if (i > 0) {
// json.push(',\n');
// }
// json.push('{');
// json.push('"id":"' + v.getName() + '"');
// json.push(', "v":[');
// for (var j = 0, nitems = v.size(); j < nitems; j++) {
// if (j > 0) {
// json.push(',');
// }
// json.push(JSON.stringify(v.getValue(j)));
// }
// json.push(']'); // end v array
// json.push('}');
// }
// json.push(']');
// };
// json.push(', "cols":');
// metadatatoJSON(dataset.getColumnMetadata());
// json.push(', "rows":');
// metadatatoJSON(dataset.getRowMetadata());
// json.push('}'); // end json object
// return json.join('');
// };
morpheus.DatasetUtil.fill = function (dataset, value, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
    .getColumnCount(); i < nrows; i++) {
    for (var j = 0; j < ncols; j++) {
      dataset.setValue(i, j, value, seriesIndex);
    }
  }
};

/**
 * Add an additional series to a dataset from another dataset.
 * @param options.dataset The dataset to add a series to
 * @param options.newDataset The dataset that is used as the source for the overlay
 * @param options.rowAnnotationName dataset row annotation name to use for matching
 * @param options.columnAnnotationName dataset column annotation name to use for matching
 * @param options.newRowAnnotationName newDataset row annotation name to use for matching
 * @param options.newColumnAnnotationName newDataset column annotation name to use for matching
 *
 */
morpheus.DatasetUtil.overlay = function (options) {
  var dataset = options.dataset;
  var newDataset = options.newDataset;
  var current_dataset_row_annotation_name = options.rowAnnotationName;
  var current_dataset_column_annotation_name = options.columnAnnotationName;
  var new_dataset_row_annotation_name = options.newRowAnnotationName;
  var new_dataset_column_annotation_name = options.newColumnAnnotationName;

  var rowValueToIndexMap = morpheus.VectorUtil
    .createValueToIndexMap(dataset
      .getRowMetadata()
      .getByName(
        current_dataset_row_annotation_name));
  var columnValueToIndexMap = morpheus.VectorUtil
    .createValueToIndexMap(dataset
      .getColumnMetadata()
      .getByName(
        current_dataset_column_annotation_name));
  var seriesIndex = dataset
    .addSeries({
      name: newDataset
        .getName(),
      dataType: newDataset.getDataType(0)
    });

  var rowVector = newDataset
    .getRowMetadata()
    .getByName(
      new_dataset_row_annotation_name);
  var rowIndices = [];
  var newDatasetRowIndicesSubset = [];
  for (var i = 0, size = rowVector
    .size(); i < size; i++) {
    var index = rowValueToIndexMap
      .get(rowVector
        .getValue(i));
    if (index !== undefined) {
      rowIndices.push(index);
      newDatasetRowIndicesSubset
        .push(i);
    }
  }

  var columnVector = newDataset
    .getColumnMetadata()
    .getByName(
      new_dataset_column_annotation_name);
  var columnIndices = [];
  var newDatasetColumnIndicesSubset = [];
  for (var i = 0, size = columnVector
    .size(); i < size; i++) {
    var index = columnValueToIndexMap
      .get(columnVector
        .getValue(i));
    if (index !== undefined) {
      columnIndices.push(index);
      newDatasetColumnIndicesSubset
        .push(i);
    }
  }
  newDataset = new morpheus.SlicedDatasetView(
    newDataset,
    newDatasetRowIndicesSubset,
    newDatasetColumnIndicesSubset);
  for (var i = 0, nrows = newDataset
    .getRowCount(); i < nrows; i++) {
    for (var j = 0, ncols = newDataset
      .getColumnCount(); j < ncols; j++) {
      dataset.setValue(
        rowIndices[i],
        columnIndices[j],
        newDataset
          .getValue(
            i,
            j),
        seriesIndex);

    }
  }
};
/**
 * Joins datasets by appending rows.
 * @param datasets
 * @param field
 * @return {morpheus.AbstractDataset} The joined dataset.
 */
morpheus.DatasetUtil.join = function (datasets, field) {
  if (datasets.length === 0) {
    throw 'No datasets';
  }
  if (datasets.length === 1) {
    var name = datasets[0].getName();
    // var sourceVector = datasets[0].getRowMetadata().add('Source');
    // for (var i = 0, size = sourceVector.size(); i < size; i++) {
    //   sourceVector.setValue(i, name);
    // }
    return datasets[0];
  }
  // take union of all ids
  var ids = new morpheus.Set();
  for (var i = 0; i < datasets.length; i++) {
    var idVector = datasets[i].getColumnMetadata().getByName(field);
    for (var j = 0, size = idVector.size(); j < size; j++) {
      ids.add(idVector.getValue(j));
    }
  }
  var dummyDataset = new morpheus.Dataset({
    rows: 0,
    columns: ids.size(),
    name: datasets[0].getName()
  });
  var dummyIdVector = dummyDataset.getColumnMetadata().add(field);
  var counter = 0;
  ids.forEach(function (id) {
    dummyIdVector.setValue(counter++, id);
  });

  var dataset = new morpheus.JoinedDataset(
    dummyDataset, datasets[0], field,
    field);
  for (var i = 1; i < datasets.length; i++) {
    dataset = new morpheus.JoinedDataset(dataset,
      datasets[i], field, field);
  }
  return dataset;
};
morpheus.DatasetUtil.shallowCopy = function (dataset) {
  // make a shallow copy of the dataset, metadata is immutable via the UI
  var rowMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getRowMetadata());
  var columnMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getColumnMetadata());
  dataset.getRowMetadata = function () {
    return rowMetadataModel;
  };
  dataset.getColumnMetadata = function () {
    return columnMetadataModel;
  };
  return dataset;
};

morpheus.DatasetUtil.copy = function (dataset) {
  var newDataset = new morpheus.Dataset({
    name: dataset.getName(),
    rows: dataset.getRowCount(),
    columns: dataset.getColumnCount(),
    dataType: dataset.getDataType(0)
  });
  for (var seriesIndex = 0,
         nseries = dataset.getSeriesCount(); seriesIndex < nseries; seriesIndex++) {
    if (seriesIndex > 0) {
      newDataset.addSeries({
        name: dataset.getName(seriesIndex),
        rows: dataset.getRowCount(),
        columns: dataset.getColumnCount(),
        dataType: dataset.getDataType(seriesIndex)
      });
    }
    for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
      .getColumnCount(); i < nrows; i++) {
      for (var j = 0; j < ncols; j++) {
        newDataset.setValue(i, j, dataset.getValue(i, j, seriesIndex),
          seriesIndex);
      }
    }
  }
  var rowMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getRowMetadata());
  var columnMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getColumnMetadata());
  newDataset.getRowMetadata = function () {
    return rowMetadataModel;
  };
  newDataset.getColumnMetadata = function () {
    return columnMetadataModel;
  };
  return newDataset;
};
morpheus.DatasetUtil.toString = function (dataset, value, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  var s = [];
  for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
    .getColumnCount(); i < nrows; i++) {
    for (var j = 0; j < ncols; j++) {
      if (j > 0) {
        s.push(', ');
      }
      s.push(morpheus.Util.nf(dataset.getValue(i, j, seriesIndex)));
    }
    s.push('\n');
  }
  return s.join('');
};
morpheus.DatasetUtil.getNonEmptyRows = function (dataset) {
  var rowsToKeep = [];
  for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
    var keep = false;
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      var value = dataset.getValue(i, j);
      if (!isNaN(value)) {
        keep = true;
        break;
      }
    }
    if (keep) {
      rowsToKeep.push(i);
    }
  }
  return rowsToKeep;
};

/**
 * Default implementation of a dataset.
 *
 * @extends {morpheus.AbstractDataset}
 * @param options.rows {number} Number of rows
 * @param options.columns {number} Number of columns
 * @param options.name {string} Dataset name
 * @param options.dataType {string=} Data type that 1st series holds.
 * @constructor
 */
morpheus.Dataset = function (options) {
  morpheus.AbstractDataset.call(this, options.rows,
    options.columns);

  if (options.dataType == null) {
    options.dataType = 'Float32';
  }

  this.seriesNames.push(options.name);
  this.seriesArrays.push(options.array ? options.array : morpheus.Dataset
    .createArray(options));
  this.seriesDataTypes.push(options.dataType);
};
/**
 *
 * @param dataset
 * @param options.rowFields
 * @param options.columnFields
 * @param options.seriesIndices
 * @return JSON representation of a dataset
 */
morpheus.Dataset.toJSON = function (dataset, options) {
  options = options || {};
  var seriesArrays = [];
  var seriesDataTypes = [];
  var seriesNames = [];
  var seriesIndices = options.seriesIndices;
  if (seriesIndices == null) {
    seriesIndices = morpheus.Util.sequ32(dataset.getSeriesCount());
  }
  for (var series = 0; series < seriesIndices.length; series++) {
    var seriesIndex = seriesIndices[series];
    seriesNames.push(dataset.getName(seriesIndex));
    seriesDataTypes.push(dataset.getDataType(seriesIndex));
    var data = [];
    seriesArrays.push(data);
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      var row = [];
      data.push(row);
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        row[j] = dataset.getValue(i, j, seriesIndex);
      }
    }
  }
  var vectorToJSON = function (vector) {
    var array = [];
    for (var i = 0, size = vector.size(); i < size; i++) {
      array[i] = vector.getValue(i);
    }
    var properties = new morpheus.Map();
    vector.getProperties().forEach(function (value, key) {
      if (morpheus.VectorKeys.JSON_WHITELIST.has(key)) {
        properties.set(key, value);
      }
    });
    return {
      properties: properties,
      name: vector.getName(),
      array: array
    };
  };
  var metadatatoJSON = function (metadata, fields) {
    var vectors = [];
    var filter;
    if (fields) {
      filter = new morpheus.Set();
      fields.forEach(function (field) {
        filter.add(field);
      });
    }
    for (var i = 0, count = metadata.getMetadataCount(); i < count; i++) {
      var v = metadata.get(i);
      if (!v.getProperties().has(morpheus.VectorKeys.IS_INDEX)) {
        if (filter) {
          if (filter.has(v.getName())) {
            vectors.push(vectorToJSON(v));
          }
        } else {
          vectors.push(vectorToJSON(v));
        }
      }
    }
    return vectors;
  };
  return {
    rows: dataset.getRowCount(),
    columns: dataset.getColumnCount(),
    seriesArrays: seriesArrays,
    seriesDataTypes: seriesDataTypes,
    seriesNames: seriesNames,
    rowMetadataModel: {
      vectors: metadatatoJSON(dataset.getRowMetadata(),
        options.rowFields)
    },
    columnMetadataModel: {
      vectors: metadatatoJSON(dataset.getColumnMetadata(),
        options.columnFields)
    }
  };
};
morpheus.Dataset.fromJSON = function (options) {
  // Object {seriesNames:
  // Array[1], seriesArrays:
  // Array[1], rows:
  // 6238, columns: 7251,
  // rowMetadataModel: Object}
  // columnMetadataModel: Object
  // itemCount: 7251
  // vectors: Array[3]
  // array: Array[7251]
  // n: 7251
  // name: "pert_id"
  // properties: Object
  // columns: 7251
  // rowMetadataModel: Object
  // rows: 6238
  // seriesArrays: Array[1]
  // seriesNames: Array[1]
  // var array = morpheus.Dataset.createArray(options);
  // for (var i = 0; i < options.rows; i++) {
  // var row = array[i];
  // var jsonRow = options.array[i];
  // for (var j = 0; j < options.columns; j++) {
  // row[j] = jsonRow[j];
  // }
  // }

  if (options.seriesMappings) {
    for (var seriesIndex = 0; seriesIndex < options.seriesMappings.length; seriesIndex++) {
      // map ordinal values
      if (options.seriesMappings[seriesIndex]) {

        var map = options.seriesMappings[seriesIndex]; // e.g. foo:1, bar:3
        var valueMap = new morpheus.Map();
        for (var key in map) {
          var value = map[key];
          valueMap.set(value, morpheus.Util.wrapNumber(value, key));
        }

        var array = options.seriesArrays[seriesIndex];
        for (var i = 0; i < options.rows; i++) {
          for (var j = 0; j < options.columns; j++) {
            var value = array[i][j];
            array[i][j] = valueMap.get(value);
          }
        }
        options.seriesDataTypes[seriesIndex] = 'Number';
      }
    }
  }

  for (var seriesIndex = 0; seriesIndex < options.seriesArrays.length; seriesIndex++) {
    var array = options.seriesArrays[seriesIndex];
    for (var i = 0; i < options.rows; i++) {
      for (var j = 0; j < options.columns; j++) {
        var value = array[i][j];
        if (value == null) {
          array[i][j] = NaN;
        }
      }
    }
  }
  var dataset = new morpheus.Dataset({
    name: options.seriesNames[0],
    dataType: options.seriesDataTypes[0],
    array: options.seriesArrays[0],
    rows: options.rows,
    columns: options.columns
  });

  if (options.rowMetadataModel) {
    options.rowMetadataModel.vectors.forEach(function (v) {
      var vector = new morpheus.Vector(v.name, dataset.getRowCount());
      vector.array = v.array;
      vector.properties = morpheus.Map.fromJSON(v.properties);
      dataset.rowMetadataModel.vectors.push(vector);
    });
  }
  if (options.columnMetadataModel) {
    options.columnMetadataModel.vectors.forEach(function (v) {
      var vector = new morpheus.Vector(v.name, dataset.getColumnCount());
      vector.array = v.array;
      vector.properties = morpheus.Map.fromJSON(v.properties);
      dataset.columnMetadataModel.vectors.push(vector);

    });
  }
  for (var i = 1; i < options.seriesArrays.length; i++) {
    dataset.addSeries({
      name: options.seriesNames[i],
      dataType: options.seriesDataTypes[i],
      array: options.seriesArrays[i]
    });
  }
  return dataset;
};
morpheus.Dataset.createArray = function (options) {
  var array = [];
  if (options.dataType == null || options.dataType === 'Float32') {
    for (var i = 0; i < options.rows; i++) {
      array.push(new Float32Array(options.columns));
    }
  } else if (options.dataType === 'Int8') {
    for (var i = 0; i < options.rows; i++) {
      array.push(new Int8Array(options.columns));
    }
  } else if (options.dataType === 'Int16') {
    for (var i = 0; i < options.rows; i++) {
      array.push(new Int16Array(options.columns));
    }
  } else { // [object, number, Number] array of arrays
    for (var i = 0; i < options.rows; i++) {
      array.push([]);
    }
  }
  return array;
};
morpheus.Dataset.prototype = {
  getValue: function (i, j, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    return this.seriesArrays[seriesIndex][i][j];
  },
  toString: function () {
    return this.getName();
  },
  setValue: function (i, j, value, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    this.seriesArrays[seriesIndex][i][j] = value;
  },
  addSeries: function (options) {
    options = $.extend({}, {
      rows: this.getRowCount(),
      columns: this.getColumnCount(),
      dataType: 'Float32'
    }, options);
    this.seriesDataTypes.push(options.dataType);
    this.seriesNames.push(options.name);
    this.seriesArrays.push(options.array != null ? options.array
      : morpheus.Dataset.createArray(options));
    return this.seriesNames.length - 1;
  }
};
morpheus.Util.extend(morpheus.Dataset, morpheus.AbstractDataset);

morpheus.ElementSelectionModel = function (project) {
  this.viewIndices = new morpheus.Set();
  this.project = project;
};
morpheus.ElementSelectionModel.prototype = {
  click: function (rowIndex, columnIndex, add) {
    var id = new morpheus.Identifier([rowIndex, columnIndex]);
    var isSelected = this.viewIndices.has(id);
    if (add) {
      isSelected ? this.viewIndices.remove(id) : this.viewIndices.add(id);
    } else {
      this.viewIndices.clear();
      if (!isSelected) {
        this.viewIndices.add(id);
      }
    }
    this.trigger('selectionChanged');
  },
  getProject: function () {
    return this.project;
  },
  setViewIndices: function (indices) {
    this.viewIndices = indices;
    this.trigger('selectionChanged');
  },
  clear: function () {
    this.viewIndices = new morpheus.Set();
  },
  /**
   *
   * @returns {morpheus.Set}
   */
  getViewIndices: function () {
    return this.viewIndices;
  },
  count: function () {
    return this.viewIndices.size();
  },
  toModelIndices: function () {
    var project = this.project;
    var modelIndices = [];
    this.viewIndices.forEach(function (id) {
      modelIndices.push(project
      .convertViewRowIndexToModel(id.getArray()[0]), project
      .convertViewColumnIndexToModel(id.getArray()[1]));
    });
    return modelIndices;
  },
  save: function () {
    this.modelIndices = this.toModelIndices();
  },
  restore: function () {
    var project = this.project;
    this.viewIndices = new morpheus.Set();
    for (var i = 0, length = this.modelIndices.length; i < length; i++) {
      var rowIndex = project
      .convertModelRowIndexToView(this.modelIndices[i][0]);
      var columnIndex = project
      .convertModelColumnIndexToView(this.modelIndices[i][1]);
      if (rowIndex !== -1 && columnIndex !== -1) {
        this.viewIndices.add(new morpheus.Identifier([rowIndex,
          columnIndex]));
      }
    }
  }
};
morpheus.Util.extend(morpheus.ElementSelectionModel, morpheus.Events);

morpheus.CombinedFilter = function (isAndFilter) {
  this.filters = [];
  this.isAndFilter = isAndFilter;
  this.enabledFilters = [];
  this.name = 'combined filter';
};

morpheus.CombinedFilter.prototype = {
  shallowClone: function () {
    var f = new morpheus.CombinedFilter(this.isAndFilter);
    f.filters = this.filters.slice(0);
    return f;
  },
  isColumns: function () {
    return this.filters[0].isColumns();
  },
  toString: function () {
    return this.name;
  },
  setAnd: function (isAndFilter, notify) {
    this.isAndFilter = isAndFilter;
    if (notify) {
      this.trigger('and', {});
    }
  },
  isAnd: function () {
    return this.isAndFilter;
  },
  equals: function (f) {
    if (!(f instanceof morpheus.CombinedFilter)) {
      return false;
    }
    if (this.isAndFilter !== f.isAndFilter) {
      return false;
    }
    if (this.filters.length !== f.filters.length) {
      return false;
    }
    for (var i = 0, length = this.filters.length; i < length; i++) {
      if (!this.filters[i].equals(f.filters[i])) {
        return false;
      }
    }
    return true;
  },
  add: function (filter, notify) {
    this.filters.push(filter);
    if (notify) {
      this.trigger('add', {
        filter: filter,
      });
    }
  },
  getFilters: function () {
    return this.filters;
  },
  get: function (index) {
    return this.filters[index];
  },
  indexOf: function (name, type) {
    for (var i = 0, length = this.filters.length; i < length; i++) {
      if (this.filters[i].toString() === name
        && (type == null ? true : this.filters[i] instanceof type)) {
        return i;
      }
    }
    return -1;
  },
  remove: function (index, notify) {
    this.filters.splice(index, 1);
    if (notify) {
      this.trigger('remove', {
        index: index,
      });
    }
  },
  set: function (index, filter) {
    this.filters[index] = filter;
  },
  insert: function (index, filter) {
    this.filters.splice(index, 0, filter);
  },
  clear: function () {
    this.filters = [];
  },
  init: function (dataset) {
    for (var i = 0, nfilters = this.filters.length; i < nfilters; i++) {
      if (this.filters[i].isColumns()) { // all filters operate on rows
        this.filters[i].init(new morpheus.TransposedDatasetView(dataset));
      } else {
        this.filters[i].init(dataset);
      }

    }
    this.enabledFilters = this.filters.filter(function (filter) {
      return filter.isEnabled();
    });
  },
  accept: function (index) {
    var filters = this.enabledFilters;
    if (this.isAndFilter) {
      for (var i = 0, nfilters = filters.length; i < nfilters; i++) {
        if (filters[i].accept(index) === false) {
          return false;
        }
      }
      return true;
    } else {
      for (var i = 0, nfilters = filters.length; i < nfilters; i++) {
        if (filters[i].accept(index)) {
          return true;
        }
      }
      return false;
    }
  },
  isEnabled: function () {
    return this.enabledFilters.length > 0;
  },
};
morpheus.Util.extend(morpheus.CombinedFilter, morpheus.Events);
/**
 * @param acceptIndicesSet
 *            a morpheus.Set that contains the model indices in the dataset to
 *            retain.
 */
morpheus.IndexFilter = function (acceptIndicesSet, name, isColumns) {
  this.acceptIndicesSet = acceptIndicesSet;
  this.name = name;
  this.columns = isColumns;
};
morpheus.IndexFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled;
  },
  setAcceptIndicesSet: function (acceptIndicesSet) {
    this.acceptIndicesSet = acceptIndicesSet;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  equals: function (filter) {
    return filter instanceof morpheus.IndexFilter
      && this.acceptIndicesSet.equals(filter.acceptIndicesSet);
  },
  init: function (dataset) {
  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.acceptIndicesSet.has(index);
  },
};
morpheus.VectorFilter = function (set, maxSetSize, name, isColumns) {
  this.set = set;
  this.name = name;
  this.maxSetSize = maxSetSize;
  this.columns = isColumns;
};

morpheus.VectorFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && this.set.size() > 0
      && this.set.size() !== this.maxSetSize && this.vector != null;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  equals: function (filter) {
    return filter instanceof morpheus.VectorFilter
      && this.name === filter.name;
  },
  init: function (dataset) {
    this.vector = dataset.getRowMetadata().getByName(this.name);
  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.set.has(this.vector.getValue(index));
  },
};

morpheus.NotNullFilter = function (name, isColumns) {
  this.name = name;
  this.columns = isColumns;
};
morpheus.NotNullFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && this.vector != null;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  equals: function (filter) {
    return filter instanceof morpheus.NotNullFilter
      && this.name === filter.name;
  },
  init: function (dataset) {
    this.vector = dataset.getRowMetadata().getByName(this.name);
  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.vector.getValue(index) != null;
  },
};

morpheus.RangeFilter = function (min, max, name, isColumns) {
  this.min = min;
  this.max = max;
  this.name = name;
  this.columns = isColumns;
};

morpheus.RangeFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && (!isNaN(this.min) || !isNaN(this.max))
      && this.vector;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  setMin: function (value) {
    this.min = isNaN(value) ? -Number.MAX_VALUE : value;
  },
  setMax: function (value) {
    this.max = isNaN(value) ? Number.MAX_VALUE : value;
  },
  equals: function (filter) {
    return filter instanceof morpheus.RangeFilter
      && this.name === filter.name;
  },
  init: function (dataset) {
    this.vector = dataset.getRowMetadata().getByName(this.name);

  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    var value = this.vector.getValue(index);
    return value >= this.min && value <= this.max;
  },
};

morpheus.TopNFilter = function (n, direction, name, isColumns) {
  this.n = n;
  this.direction = direction;
  this.name = name;
  this.columns = isColumns;
};

morpheus.TopNFilter.TOP = 0;
morpheus.TopNFilter.BOTTOM = 1;
morpheus.TopNFilter.TOP_BOTTOM = 2;
morpheus.TopNFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && this.n > 0 && this.vector;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  setN: function (value) {
    this.n = value;
  },
  /**
   *
   * @param direction
   *            one of '
   */
  setDirection: function (direction) {
    this.direction = direction;
  },
  equals: function (filter) {
    return filter instanceof morpheus.TopNFilter
      && this.name === filter.name && this.n === filter.n
      && this.direction === filter.direction;
  },

  init: function (dataset) {
    if (!this.vector ||
      this.vector !== dataset.getRowMetadata().getByName(this.name)) {
      var vector = dataset.getRowMetadata().getByName(this.name);
      if (vector == null) {
        vector = {
          getValue: function () {
          },
          size: function () {
            return 0;
          },
        };
      }
      this.vector = vector;
      var set = new morpheus.Set();
      for (var i = 0, size = vector.size(); i < size; i++) {
        var value = vector.getValue(i);
        if (!isNaN(value)) {
          set.add(value);
        }
      }
      var values = set.values();
      // ascending order
      values.sort(function (a, b) {
        return (a === b ? 0 : (a < b ? -1 : 1));
      });
      this.sortedValues = values;
    }
    var topAndBottomIndices = [
      (this.sortedValues.length - this.n),
      (this.n - 1)];

    for (var i = 0; i < topAndBottomIndices.length; i++) {
      topAndBottomIndices[i] = Math.max(0, topAndBottomIndices[i]);
      topAndBottomIndices[i] = Math.min(this.sortedValues.length - 1,
        topAndBottomIndices[i]);
    }

    var topAndBottomValues = [
      this.sortedValues[topAndBottomIndices[0]],
      this.sortedValues[topAndBottomIndices[1]]];

    if (this.direction === morpheus.TopNFilter.TOP) {
      this.f = function (val) {
        return isNaN(val) ? false : val >= topAndBottomValues[0];
      };
    } else if (this.direction === morpheus.TopNFilter.BOTTOM) {
      this.f = function (val) {
        return isNaN(val) ? false : val <= topAndBottomValues[1];
      };
    } else {
      this.f = function (val) {
        return isNaN(val) ? false
          : (val >= topAndBottomValues[0] || val <= topAndBottomValues[1]);
      };
    }

  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.f(this.vector.getValue(index));
  },
  toString: function () {
    return this.name;
  },
};

morpheus.AlwaysTrueFilter = function () {

};

morpheus.AlwaysTrueFilter.prototype = {
  isEnabled: function () {
    return false;
  },
  setEnabled: function (enabled) {

  },
  equals: function (filter) {
    return filter instanceof morpheus.AlwaysTrueFilter;

  },
  init: function (dataset) {

  },
  toString: function () {
    return 'AlwaysTrue';
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return true;
  },
};

morpheus.CombinedFilter.fromJSON = function (combinedFilter, json) {
  combinedFilter.setAnd(json.isAnd);
  json.filters.forEach(function (filter) {
    var name = filter.name != null ? filter.name : filter.field;
    if (filter.type === 'set') {
      var set = new morpheus.Set();
      filter.values.forEach(function (value) {
        set.add(value);
      });
      combinedFilter.add(new morpheus.VectorFilter(
        set,
        filter.maxSetSize,
        name,
        filter.isColumns
      ));
    } else if (filter.type === 'range') {
      combinedFilter.add(new morpheus.RangeFilter(
        filter.min,
        filter.max,
        name,
        filter.isColumns
      ));
    } else if (filter.type === 'top') {
      if (_.isString(filter.direction)) {
        if (filter.direction === 'top') {
          filter.direction = morpheus.TopNFilter.TOP;
        } else if (filter.direction === 'bottom') {
          filter.direction = morpheus.TopNFilter.BOTTOM;
        } else if (filter.direction === 'topAndBottom') {
          filter.direction = morpheus.TopNFilter.TOP_BOTTOM;
        }
      }
      combinedFilter.add(new morpheus.TopNFilter(
        filter.n,
        filter.direction,
        name,
        filter.isColumns
      ));
    } else if (filter.type === 'index') {
      var set = new morpheus.Set();
      filter.indices.forEach(function (value) {
        set.add(value);
      });
      combinedFilter.add(new morpheus.IndexFilter(
        set,
        name,
        filter.isColumns
      ));
    } else {
      console.log('Unknown filter type');
    }
  });
};

morpheus.CombinedFilter.toJSON = function (filter) {
  var json = {
    isAnd: filter.isAnd(),
    filters: [],
  };
  filter.getFilters().forEach(function (filter) {
    if (filter.isEnabled()) {
      if (filter instanceof morpheus.VectorFilter) {
        // morpheus.VectorFilter = function (set, maxSetSize, name, isColumns)
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          values: filter.set.values(),
          maxSetSize: filter.maxSetSize,
          type: 'set',
        });
      } else if (filter instanceof morpheus.RangeFilter) {
        // morpheus.RangeFilter = function (min, max, name, isColumns)
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          min: filter.min,
          max: filter.max,
          type: 'range',
        });
      } else if (filter instanceof morpheus.TopNFilter) {
        // morpheus.TopNFilter = function (n, direction, name, isColumns)

        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          n: filter.n,
          direction: filter.direction,
          type: 'top',
        });
      } else if (filter instanceof morpheus.IndexFilter) {
        // morpheus.IndexFilter = function (acceptIndicesSet, name, isColumns
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          indices: filter.acceptIndicesSet.values(),
          type: 'index',
        });
      }
    }
  });
  return json;
};

morpheus.IndexMapper = function (project, isRows) {
  this.project = project;
  this.isRows = isRows;
  this.sortKeys = [];
  /**
   * {morpheus.Map} Maps from model index to view index. Note that not all
   * model indices are contained in the map because they might have been
   * filtered from the view.
   */
  this.modelToView = null;
  /** {Array} filtered model indices */
  this.filteredModelIndices = null;
  /** {Array} sorted and filtered model indices */
  this.filteredSortedModelIndices = null;
  this.filter = new morpheus.CombinedFilter(true);
  this._filter();
  this._sort();
};

morpheus.IndexMapper.prototype = {
  convertModelIndexToView: function (modelIndex) {
    var index = this.modelToView.get(modelIndex);
    return index !== undefined ? index : -1;
  },
  convertViewIndexToModel: function (viewIndex) {
    return (viewIndex < this.filteredSortedModelIndices.length
    && viewIndex >= 0 ? this.filteredSortedModelIndices[viewIndex]
      : -1);
  },
  convertToView: function () {
    return this.filteredSortedModelIndices;
  },
  setFilter: function (filter) {
    this.filter = filter;
    this._filter();
    this._sort();
  },
  _filter: function () {
    var filter = this.filter;
    var dataset = this.project.getFullDataset();
    var count = this.isRows ? dataset.getRowCount() : dataset.getColumnCount();
    var filteredModelIndices;
    if (filter != null) {
      filter.init(dataset); // filter needs to transpose if columns
      if (filter.isEnabled()) {
        filteredModelIndices = [];

        for (var i = 0; i < count; i++) {
          if (filter.accept(i)) {
            filteredModelIndices.push(i);
          }
        }
      }
    }

    this.filteredModelIndices = filteredModelIndices != null ? filteredModelIndices
      : morpheus.Util.seq(count);
  },
  _sort: function () {
    var sortKeys = this.sortKeys;
    if (sortKeys.length > 0) {
      var dataset = this.project.getFullDataset();

      var nkeys = sortKeys.length;
      for (var i = 0; i < nkeys; i++) {
        sortKeys[i].init(sortKeys[i].isColumns() ? new morpheus.TransposedDatasetView(dataset) : dataset, this.filteredSortedModelIndices);
      }
      this.filteredSortedModelIndices = this.filteredModelIndices
      .slice(0);
      this.filteredSortedModelIndices.sort(function (a, b) {
        for (var i = 0; i < nkeys; i++) {
          var key = sortKeys[i];
          var comparator = key.getComparator();
          var val1 = key.getValue(a);
          var val2 = key.getValue(b);
          var c = comparator(val1, val2);
          if (c !== 0) {
            return c;
          }
        }
        return 0;
      });
    } else {
      this.filteredSortedModelIndices = this.filteredModelIndices;
    }

    var modelToView = new morpheus.Map();
    for (var i = 0, length = this.filteredSortedModelIndices.length; i < length; i++) {
      modelToView.set(this.filteredSortedModelIndices[i], i);
    }
    this.modelToView = modelToView;
  },
  getFilter: function () {
    return this.filter;
  },
  getViewCount: function () {
    if (this.project.getFullDataset() == null) {
      return 0;
    }
    return this.filteredSortedModelIndices.length;
  },
  setSelectedModelIndices: function (selectedModelIndices) {
    this.selectionModel.setSelectedModelIndices(selectedModelIndices);
  },
  setSortKeys: function (sortKeys) {
    if (sortKeys == null) {
      sortKeys = [];
    }
    this.sortKeys = sortKeys;
    this._sort();
  }
};

/**
 * Adds rows in dataset2 to dataset1
 */
morpheus.JoinedDataset = function (dataset1, dataset2, dataset1Field,
                                   dataset2Field, sourceFieldName) {
  sourceFieldName = sourceFieldName || 'Source';
  this.dataset1Field = dataset1Field;
  this.dataset2Field = dataset2Field;
  if (dataset1 == null) {
    throw 'dataset1 is null';
  }
  if (dataset2 == null) {
    throw 'dataset2 is null';
  }
  if (dataset1Field) { // reorder dataset 2 to match dataset 1
    var v1 = dataset1.getColumnMetadata().getByName(dataset1Field);
    var dataset2ValueToIndex = morpheus.VectorUtil
    .createValueToIndexMap(dataset2.getColumnMetadata().getByName(
      dataset2Field));
    var dataset2ColumnIndices = [];
    for (var i = 0; i < v1.size(); i++) {
      dataset2ColumnIndices[i] = dataset2ValueToIndex.get(v1.getValue(i));
      // undefined indices are handles in SlicedDatasetWithNulls
    }
    dataset2 = new morpheus.SlicedDatasetWithNulls(dataset2,
      dataset2ColumnIndices, dataset1.getColumnCount(), dataset1
      .getColumnMetadata());
  }

  if (!dataset1.getRowMetadata().getByName(sourceFieldName)) {
    var sourceVector = dataset1.getRowMetadata().add(sourceFieldName);
    var name = dataset1.getName();
    for (var i = 0, nrows = sourceVector.size(); i < nrows; i++) {
      sourceVector.setValue(i, name);
    }
  }
  if (!dataset2.getRowMetadata().getByName(sourceFieldName)) {
    var sourceVector = dataset2.getRowMetadata().add(sourceFieldName);
    var name = dataset2.getName();
    for (var i = 0, nrows = sourceVector.size(); i < nrows; i++) {
      sourceVector.setValue(i, name);
    }

  }

  // make sure dataset1 and dataset2 have the same row metadata fields in the
  // same order
  for (var i = 0, count = dataset1.getRowMetadata().getMetadataCount(); i < count; i++) {
    var name = dataset1.getRowMetadata().get(i).getName();
    if (dataset2.getRowMetadata().getByName(name) == null) {
      dataset2.getRowMetadata().add(name);
    }
  }
  for (var i = 0, count = dataset2.getRowMetadata().getMetadataCount(); i < count; i++) {
    var name = dataset2.getRowMetadata().get(i).getName();
    if (dataset1.getRowMetadata().getByName(name) == null) {
      dataset1.getRowMetadata().add(name);
    }
  }

  // put dataset2 row metadata names in same order as dataset1
  var dataset2RowMetadataOrder = [];
  var metadataInDifferentOrder = false;
  for (var i = 0, count = dataset1.getRowMetadata().getMetadataCount(); i < count; i++) {
    var name = dataset1.getRowMetadata().get(i).getName();
    var index = morpheus.MetadataUtil.indexOf(dataset2.getRowMetadata(),
      name);
    dataset2RowMetadataOrder.push(index);
    if (index !== i) {
      metadataInDifferentOrder = true;
    }
  }
  this.dataset1 = dataset1;
  this.dataset2 = dataset2;
  // TODO put series in same order
  var maxSeriesCount = Math.max(this.dataset1.getSeriesCount(), this.dataset2
  .getSeriesCount());
  for (var i = this.dataset1.getSeriesCount(); i < maxSeriesCount; i++) {
    this.dataset1.addSeries({
      name: this.dataset2.getName(i)
    });
  }
  for (var i = this.dataset2.getSeriesCount(); i < maxSeriesCount; i++) {
    this.dataset2.addSeries({
      name: this.dataset1.getName(i)
    });
  }

  this.rowMetadata = new morpheus.JoinedMetadataModel(this.dataset1
  .getRowMetadata(), !metadataInDifferentOrder ? this.dataset2
    .getRowMetadata() : new morpheus.MetadataModelColumnView(
      this.dataset2.getRowMetadata(), dataset2RowMetadataOrder));
};
morpheus.JoinedDataset.prototype = {
  getName: function (seriesIndex) {
    return this.dataset1.getName(seriesIndex);
  },
  setName: function (seriesIndex, name) {
    this.dataset1.setName(seriesIndex, name);
  },
  getDataType: function (seriesIndex) {
    return this.dataset1.getDataType(seriesIndex);
  },
  getDatasets: function () {
    return [this.dataset1, this.dataset2];
  },
  getDataset1: function () {
    return this.dataset1;
  },
  getRowMetadata: function () {
    return this.rowMetadata;
  },
  getColumnMetadata: function () {
    return this.dataset1.getColumnMetadata();
  },
  getRowCount: function () {
    return this.dataset1.getRowCount() + this.dataset2.getRowCount();
  },
  getColumnCount: function () {
    return this.dataset1.getColumnCount();
  },
  getValue: function (i, j, seriesIndex) {
    return i < this.dataset1.getRowCount() ? this.dataset1.getValue(i, j,
        seriesIndex) : this.dataset2.getValue(i
        - this.dataset1.getRowCount(), j, seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    i < this.dataset1.getRowCount() ? this.dataset1.setValue(i, j, value,
        seriesIndex) : this.dataset2.setValue(i
        - this.dataset1.getRowCount(), j, value, seriesIndex);
  },
  getSeriesCount: function () {
    return this.dataset1.getSeriesCount();
  },
  addSeries: function (options) {
    this.dataset1.addSeries(options);
    return this.dataset2.addSeries(options);
  },
  removeSeries: function (seriesIndex) {
    this.dataset1.removeSeries(seriesIndex);
    this.dataset2.removeSeries(seriesIndex);
  },
  toString: function () {
    return this.getName();
  }
};
morpheus.SlicedDatasetWithNulls = function (dataset, columnIndices, columnCount,
                                            columnMetadata) {
  morpheus.DatasetAdapter.call(this, dataset);
  this.columnIndices = columnIndices;
  this.columnCount = columnCount;
  this.columnMetadata = columnMetadata;
};
morpheus.SlicedDatasetWithNulls.prototype = {
  getColumnMetadata: function () {
    return this.columnMetadata;
  },
  getColumnCount: function () {
    return this.columnCount;
  },
  getValue: function (i, j, seriesIndex) {
    var index = this.columnIndices[j];
    return index === undefined ? undefined : this.dataset.getValue(i,
        index, seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    var index = this.columnIndices[j];
    if (index !== undefined) {
      this.dataset.setValue(i, index, value, seriesIndex);
    } else {
      console.log(j + ' out of range');
    }
  }
};
morpheus.Util.extend(morpheus.SlicedDatasetWithNulls, morpheus.DatasetAdapter);
morpheus.JoinedVector = function (v1, v2) {
  this.v1 = v1;
  this.v2 = v2;
  morpheus.VectorAdapter.call(this, v1);
  this.properties = new morpheus.Map();
};
morpheus.JoinedVector.prototype = {
  setValue: function (i, value) {
    i < this.v1.size() ? this.v1.setValue(i, value) : this.v2.setValue(i
        - this.v1.size(), value);
  },
  getValue: function (i) {
    return i < this.v1.size() ? this.v1.getValue(i) : this.v2.getValue(i
        - this.v1.size());
  },
  size: function () {
    return this.v1.size() + this.v2.size();
  },
  getProperties: function () {
    return this.properties;
  }
};
morpheus.Util.extend(morpheus.JoinedVector, morpheus.VectorAdapter);
morpheus.JoinedMetadataModel = function (m1, m2) {
  this.m1 = m1;
  this.m2 = m2;
  this.vectors = [];
  for (var i = 0, count = m1.getMetadataCount(); i < count; i++) {
    var v1 = this.m1.get(i);
    var v2 = this.m2.get(i);
    var v = new morpheus.JoinedVector(v1, v2);
    // copy properties
    v1.getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        v.properties.set(key, val);
      }
    });
    v2.getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        v.properties.set(key, val);
      }
    });

    this.vectors.push(v);
  }
};
morpheus.JoinedMetadataModel.prototype = {
  add: function (name) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    var oldVector;
    if (index !== -1) {
      oldVector = this.remove(index);
    }
    var v = new morpheus.Vector(name, this.getItemCount());
    if (oldVector != null) {
      // copy properties
      oldVector.getProperties().forEach(function (val, key) {
        v.getProperties().set(key, val);
      });
      // copy values
      for (var i = 0, size = oldVector.size(); i < size; i++) {
        v.setValue(i, oldVector.getValue(i));
      }
    }
    this.vectors.push(v);
    return v;
  },
  getItemCount: function () {
    return this.m1.getItemCount() + this.m2.getItemCount();
  },
  get: function (index) {
    return this.vectors[index];
  },
  remove: function (index) {
    return this.vectors.splice(index, 1)[0];
  },
  getByName: function (name) {
    for (var i = 0, length = this.vectors.length; i < length; i++) {
      if (name === this.vectors[i].getName()) {
        return this.vectors[i];
      }
    }
  },
  getMetadataCount: function () {
    return this.vectors.length;
  }
};

/**
 *
 *@implements {morpheus.MetadataModelInterface}
 */
morpheus.MetadataModelAdapter = function (model) {
  this.model = model;
};
morpheus.MetadataModelAdapter.prototype = {
  add: function (name) {
    return this.model.add(name);
  },
  getItemCount: function () {
    return this.model.getItemCount();
  },
  get: function (index) {
    return this.model.get(index);
  },
  remove: function (index) {
    return this.model.remove(index);
  },
  getByName: function (name) {
    return this.model.getByName(name);
  },
  getMetadataCount: function () {
    return this.model.getMetadataCount();
  }
};

morpheus.MetadataModelColumnView = function (model, indices) {
  this.model = model;
  this.indices = indices;
};
morpheus.MetadataModelColumnView.prototype = {
  add: function (name) {
    var vector = this.model.add(name);
    var index = morpheus.MetadataUtil.indexOf(this.model, name);
    this.indices.push(index);
    return vector;
  },
  getMetadataCount: function () {
    return this.indices.length;
  },
  get: function (index) {
    if (index < 0 || index >= this.indices.length) {
      throw 'index out of bounds';
    }
    return this.model.get(this.indices[index]);
  },
  remove: function (index) {
    if (index < 0 || index >= this.indices.length) {
      throw 'index out of bounds';
    }
    var v = this.model.remove(this.indices[index]);
    this.indices.splice(index, 1);
    return v;
  },
  getByName: function (name) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    return index !== -1 ? this.get(index) : undefined;
  }
};
morpheus.Util.extend(morpheus.MetadataModelColumnView,
  morpheus.MetadataModelAdapter);

/**
 * Stores annotations for the rows or columns of a dataset.
 * @interface morpheus.MetadataModelInterface
 *
 */

/**
 * Appends the specified vector to this meta data. If an existing vector
 * with the same name already exists, it is removed and existing properties
 * and values copied to the new vector before appending the new vector.
 * @function
 * @name morpheus.MetadataModelInterface#add
 * @param name {String} The vector name to be inserted into this meta data instance.
 * @param options {object}
 * @return {morpheus.VectorInterface} the added vector.
 */

/**
 * Returns the number of items that a vector in this meta data model
 * contains.
 *
 * @function
 * @name morpheus.MetadataModelInterface#getItemCount
 * @return {number} the item count
 */

/**
 * Returns the vector at the specified metadata index.
 *
 * @function
 * @name morpheus.MetadataModelInterface#get
 * @param index {number} the metadata index
 * @return {morpheus.VectorInterface} the vector
 */

/**
 * Removes the column at the specified position in this meta data instance
 * Shifts any subsequent columns to the left (subtracts one from their
 * indices).
 *
 * @function
 * @name morpheus.MetadataModelInterface#remove
 * @param index {number} the meta data index to remove.
 * @return {morpheus.VectorInterface} the removed vector
 * @throws Error if index < 0 or >= getMetadataCount
 */

/**
 * Returns the vector witht the specified name.
 *
 * @function
 * @name morpheus.MetadataModelInterface#getByName
 * @param name {string} the vector name
 * @return {morpheus.VectorInterface} the vector
 */

/**
 * Returns the number of vectors in this meta data instance.
 *
 * @function
 * @name morpheus.MetadataModelInterface#getMetadataCount
 * @return {number} the number of vectors.
 */



morpheus.MetadataModelItemView = function (model, indices) {
  this.model = model;
  this.indices = indices;
};
morpheus.MetadataModelItemView.prototype = {
  add: function (name) {
    var v = this.model.add(name);
    return new morpheus.SlicedVector(v, this.indices);
  },
  getItemCount: function () {
    return this.indices.length;
  },
  get: function (index) {
    var v = this.model.get(index);
    if (v === undefined) {
      return undefined;
    }
    return new morpheus.SlicedVector(v, this.indices);
  },
  getByName: function (name) {
    var v = this.model.getByName(name);
    if (v === undefined) {
      return undefined;
    }
    return new morpheus.SlicedVector(v, this.indices);
  },
  getMetadataCount: function () {
    return this.model.getMetadataCount();
  }
};
morpheus.Util.extend(morpheus.MetadataModelItemView,
  morpheus.MetadataModelAdapter);

/**
 * Creates a new meta data model instance.
 *
 * @param itemCount {number}
 *            the number of items that vectors in this instances will hold.
 * @implements {morpheus.MetadataModelInterface}
 * @constructor
 */
morpheus.MetadataModel = function (itemCount) {
  this.itemCount = itemCount;
  this.vectors = [];
};
morpheus.MetadataModel.prototype = {
  add: function (name, options) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    var oldVector;
    if (index !== -1) {
      oldVector = this.get(index);
    }
    var v = new morpheus.Vector(name, this.getItemCount());
    if (oldVector != null) {
      // copy values
      for (var i = 0, size = oldVector.size(); i < size; i++) {
        var val = oldVector.getValue(i);
        v.setValue(i, val);
      }
    }
    if (index !== -1) {
      // replace old vector
      this.vectors.splice(index, 1, v);
    } else {
      this.vectors.push(v);
    }
    return v;
  },
  getItemCount: function () {
    return this.itemCount;
  },
  get: function (index) {
    return this.vectors[index];
  },
  remove: function (index) {
    return this.vectors.splice(index, 1)[0];
  },
  getByName: function (name) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    return index !== -1 ? this.get(index) : undefined;
  },
  getMetadataCount: function () {
    return this.vectors.length;
  }
};

morpheus.MetadataUtil = function () {
};

morpheus.MetadataUtil.renameFields = function (dataset, options) {
  _.each(options.rows, function (item) {
    if (item.renameTo) {
      var v = dataset.getRowMetadata().getByName(item.field);
      if (v) {
        v.setName(item.renameTo);
      }
    }
  });
  _.each(options.columns, function (item) {
    if (item.renameTo) {
      var v = dataset.getColumnMetadata().getByName(item.field);
      if (v) {
        v.setName(item.renameTo);
      }
    }
  });
};

/**
 * @param options.model
 *            Metadata model of currently visible tracks
 * @param options.fullModel
 *            Metadata model of all metadata tracks
 * @param options.text
 *            Search text
 * @param options.isColumns
 *            Whether to search columns
 * @param options.defaultMatchMode
 *            'exact' or 'contains'
 * @param options.matchAllPredicates Whether to match all predicates
 *
 */
morpheus.MetadataUtil.search = function (options) {
  var model = options.model;
  var fullModel = options.fullModel;
  if (!fullModel) {
    fullModel = model;
  }
  var text = options.text;
  var isColumns = options.isColumns;
  text = $.trim(text);
  if (text === '') {
    return null;
  }
  var tokens = morpheus.Util.getAutocompleteTokens(text);
  if (tokens.length == 0) {
    return null;
  }
  var indexField = '#';
  var fieldNames = morpheus.MetadataUtil.getMetadataNames(fullModel);
  fieldNames.push(indexField);
  var predicates = morpheus.Util.createSearchPredicates({
    tokens: tokens,
    fields: fieldNames,
    defaultMatchMode: options.defaultMatchMode
  });
  var vectors = [];
  var nameToVector = new morpheus.Map();
  for (var j = 0; j < fullModel.getMetadataCount(); j++) {
    var v = fullModel.get(j);
    var dataType = morpheus.VectorUtil.getDataType(v);
    var wrapper = {
      vector: v,
      dataType: dataType,
      isArray: dataType.indexOf('[') === 0
    };
    nameToVector.set(v.getName(), wrapper);
    if (model.getByName(v.getName()) != null) {
      vectors.push(wrapper);
    }

  }
  // TODO only search numeric fields for range searches
  var indices = [];
  var npredicates = predicates.length;
  for (var p = 0; p < npredicates; p++) {
    var predicate = predicates[p];
    var filterColumnName = predicate.getField();
    if (filterColumnName != null && !predicate.isNumber()) {
      var wrapper = nameToVector.get(filterColumnName);
      if (wrapper && (wrapper.dataType === 'number' || wrapper.dataType === '[number]')) {
        if (predicate.getText) {
          predicates[p] = new morpheus.Util.EqualsPredicate(filterColumnName, parseFloat(predicate.getText()));
        } else if (predicate.getValues) {
          var values = [];
          predicate.getValues().forEach(function (val) {
            values.push(parseFloat(val));
          });
          predicate[p] = new morpheus.Util.ExactTermsPredicate(filterColumnName, values);
        }
      }
    }

  }

  var matchAllPredicates = options.matchAllPredicates === true;

  function isPredicateMatch(predicate) {
    var filterColumnName = predicate.getField();
    if (filterColumnName != null) {
      var value = null;
      if (filterColumnName === indexField) {
        value = i + 1;
        if (predicate.accept(value)) {
          return true;
        }
      } else {
        var wrapper = nameToVector.get(filterColumnName);
        if (wrapper) {
          value = wrapper.vector.getValue(i);
          if (wrapper.isArray) {
            if (value != null) {
              for (var k = 0; k < value.length; k++) {
                if (predicate.accept(value[k])) {
                  return true;

                }
              }
            }
          } else {
            if (predicate.accept(value)) {
              return true;
            }
          }

        }
      }

    }
    else { // try all fields
      for (var j = 0; j < nfields; j++) {
        var wrapper = vectors[j];
        var value = wrapper.vector.getValue(i);

        if (wrapper.isArray) {
          if (value != null) {
            for (var k = 0; k < value.length; k++) {
              if (predicate.accept(value[k])) {
                return true;
              }
            }
          }
        } else {
          if (predicate.accept(value)) {
            return true;
          }
        }

      }
    }

  }

  var nfields = vectors.length;
  for (var i = 0, nitems = model.getItemCount(); i < nitems; i++) {
    if (!matchAllPredicates) { // at least one predicate matches
      for (var p = 0; p < npredicates; p++) {
        var predicate = predicates[p];
        if (isPredicateMatch(predicate)) {
          indices.push(i);
          break;
        }
      }
    } else {
      var matches = true;
      for (var p = 0; p < npredicates; p++) {
        var predicate = predicates[p];
        if (!isPredicateMatch(predicate)) {
          matches = false;
          break;
        }
      }
      if (matches) {
        indices.push(i);
      }
    }

  }
  return indices;
};

morpheus.MetadataUtil.shallowCopy = function (model) {
  var copy = new morpheus.MetadataModel(model.getItemCount());
  for (var i = 0; i < model.getMetadataCount(); i++) {
    var v = model.get(i);
    // copy properties b/c they can be modified via ui
    var newVector = new morpheus.VectorAdapter(v);
    newVector.properties = new morpheus.Map();
    newVector.getProperties = function () {
      return this.properties;
    };

    v.getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        newVector.properties.set(key, val);
      }

    });

    copy.vectors.push(newVector);
  }
  return copy;
};
morpheus.MetadataUtil.autocomplete = function (model) {
  return function (tokens, cb) {
    // check for term:searchText
    var matches = [];
    var regex = null;
    var regexMatch = null;
    var searchModel = model;
    var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
      : '';
    token = $.trim(token);
    var fieldSearchFieldName = null;
    if (token !== '') {
      var semi = token.indexOf(':');
      if (semi > 0) { // field search?
        if (token.charCodeAt(semi - 1) !== 92) { // \:
          var possibleField = $.trim(token.substring(0, semi));
          if (possibleField.length > 0
            && possibleField[0] === '"'
            && possibleField[token.length - 1] === '"') {
            possibleField = possibleField.substring(1,
              possibleField.length - 1);
          }
          var index = morpheus.MetadataUtil.indexOf(searchModel,
            possibleField);
          if (index !== -1) {
            fieldSearchFieldName = possibleField;
            token = $.trim(token.substring(semi + 1));
            searchModel = new morpheus.MetadataModelColumnView(
              model, [index]);
          }
        }

      }
      var set = new morpheus.Set();
      // regex used to determine if a string starts with substring `q`

      regex = new RegExp(morpheus.Util.escapeRegex(token), 'i');
      regexMatch = new RegExp('(' + morpheus.Util.escapeRegex(token) + ')', 'i');
      // iterate through the pool of strings and for any string that
      // contains the substring `q`, add it to the `matches` array
      var max = 10;

      var vectors = [];
      var isArray = [];
      for (var j = 0; j < searchModel.getMetadataCount(); j++) {
        var v = searchModel.get(j);
        var dataType = morpheus.VectorUtil.getDataType(v);
        if (dataType === 'string' || dataType === '[string]') { // skip
          // numeric
          // fields
          vectors.push(v);
          isArray.push(dataType === '[string]');
        }
      }

      var nfields = vectors.length;

      loop: for (var i = 0, nitems = searchModel.getItemCount(); i < nitems; i++) {
        for (var j = 0; j < nfields; j++) {
          var v = vectors[j];
          var val = v.getValue(i);
          if (val != null) {
            if (isArray[j]) {
              for (var k = 0; k < val.length; k++) {
                var id = new morpheus.Identifier([val[k],
                  v.getName()]);
                if (!set.has(id) && regex.test(val[k])) {
                  set.add(id);
                  if (set.size() === max) {
                    break loop;
                  }
                }
              }
            } else {
              var id = new morpheus.Identifier([val,
                v.getName()]);
              if (!set.has(id) && regex.test(val)) {
                set.add(id);
                if (set.size() === max) {
                  break loop;
                }
              }
            }
          }

        }
      }

      set.forEach(function (id) {
        var array = id.getArray();
        var field = array[1];
        var val = array[0];
        var quotedField = field;
        if (quotedField.indexOf(' ') !== -1) {
          quotedField = '"' + quotedField + '"';
        }
        var quotedValue = val;
        if (quotedValue.indexOf(' ') !== -1) {
          quotedValue = '"' + quotedValue + '"';
        }
        matches.push({
          value: quotedField + ':' + quotedValue,
          label: '<span style="font-weight:300;">' + field
          + ':</span>'
          + '<span>' + val.replace(regexMatch, '<b>$1</b>')
          + '</span>'
        });

      });
    }

    // field names
    if (regex == null) {
      regex = new RegExp('.*', 'i');
    }

    for (var j = 0; j < searchModel.getMetadataCount(); j++) {
      var v = searchModel.get(j);
      var dataType = morpheus.VectorUtil.getDataType(v);
      var field = v.getName();
      if (dataType === 'number' || dataType === 'string'
        || dataType === '[string]') {
        if (regex.test(field) && field !== fieldSearchFieldName) {
          var quotedField = field;
          if (quotedField.indexOf(' ') !== -1) {
            quotedField = '"' + quotedField + '"';
          }
          matches.push({
            value: quotedField + ':',
            label: '<span style="font-weight:300;">' + (regexMatch == null ? field : field.replace(regexMatch, '<b>$1</b>'))
            + ':</span>' + (dataType === 'number' ? ('<span' +
              ' style="font-weight:300;font-size:85%;">.., >, <, >=, <=,' +
              ' =</span>') : ''),
            show: true
          });
        }
      }
    }
    cb(matches);
  };
};

morpheus.MetadataUtil.getMetadataNames = function (metadataModel) {
  var names = [];
  for (var i = 0, count = metadataModel.getMetadataCount(); i < count; i++) {
    names.push(metadataModel.get(i).getName(i));
  }
  names.sort(function (a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return (a < b ? -1 : (a === b ? 0 : 1));
  });
  return names;
};
morpheus.MetadataUtil.getVectors = function (metadataModel, names) {
  var vectors = [];
  names.forEach(function (name) {
    var v = metadataModel.getByName(name);
    if (!v) {
      throw name + ' not found. Available fields are '
      + morpheus.MetadataUtil.getMetadataNames(metadataModel);
    }
    vectors.push(v);
  });
  return vectors;
};
morpheus.MetadataUtil.indexOf = function (metadataModel, name) {
  for (var i = 0, length = metadataModel.getMetadataCount(); i < length; i++) {
    if (name === metadataModel.get(i).getName()) {
      return i;
    }
  }
  return -1;
};

morpheus.MetadataUtil.DEFAULT_STRING_ARRAY_FIELDS = ['target', 'gene_target', 'moa'];

morpheus.MetadataUtil.DEFAULT_HIDDEN_FIELDS = new morpheus.Set();
['pr_analyte_id', 'pr_gene_title', 'pr_gene_id', 'pr_analyte_num',
  'pr_bset_id', 'pr_lua_id', 'pr_pool_id', 'pr_is_bing', 'pr_is_inf',
  'pr_is_lmark', 'qc_slope', 'qc_f_logp', 'qc_iqr', 'bead_batch',
  'bead_revision', 'bead_set', 'det_mode', 'det_plate', 'det_well',
  'mfc_plate_dim', 'mfc_plate_id', 'mfc_plate_name', 'mfc_plate_quad',
  'mfc_plate_well', 'pert_dose_unit', 'pert_id_vendor', 'pert_mfc_desc',
  'pert_mfc_id', 'pert_time', 'pert_time_unit', 'pert_univ_id',
  'pert_vehicle', 'pool_id', 'rna_plate', 'rna_well', 'count_mean',
  'count_cv', 'provenance_code'].forEach(function (name) {
  morpheus.MetadataUtil.DEFAULT_HIDDEN_FIELDS.add(name);
});

morpheus.MetadataUtil.maybeConvertStrings = function (metadata,
                                                      metadataStartIndex) {
  for (var i = metadataStartIndex, count = metadata.getMetadataCount(); i < count; i++) {
    morpheus.VectorUtil.maybeConvertStringToNumber(metadata.get(i));
  }
  morpheus.MetadataUtil.DEFAULT_STRING_ARRAY_FIELDS.forEach(function (field) {
    if (metadata.getByName(field)) {
      morpheus.VectorUtil.maybeConvertToStringArray(metadata
      .getByName(field), ',');
    }
  });

};
morpheus.MetadataUtil.copy = function (src, dest) {
  if (src.getItemCount() != dest.getItemCount()) {
    throw 'Item count not equal in source and destination. '
    + src.getItemCount() + ' != ' + dest.getItemCount();
  }
  var itemCount = src.getItemCount();
  var metadataColumns = src.getMetadataCount();
  for (var j = 0; j < metadataColumns; j++) {
    var srcVector = src.get(j);
    var destVector = dest.getByName(srcVector.getName());
    if (destVector == null) {
      destVector = dest.add(srcVector.getName());
    }
    for (var i = 0; i < itemCount; i++) {
      destVector.setValue(i, srcVector.getValue(i));
    }
  }
};
morpheus.MetadataUtil.addVectorIfNotExists = function (metadataModel, name) {
  var v = metadataModel.getByName(name);
  if (!v) {
    v = metadataModel.add(name);
  }
  return v;
};
morpheus.MetadataUtil.getMatchingIndices = function (metadataModel, tokens) {
  var indices = {};
  for (var itemIndex = 0, nitems = metadataModel.getItemCount(); itemIndex < nitems; itemIndex++) {
    var matches = false;
    for (var metadataIndex = 0, metadataCount = metadataModel
    .getMetadataCount(); metadataIndex < metadataCount && !matches; metadataIndex++) {
      var vector = metadataModel.get(metadataModel
      .getColumnName(metadataIndex));
      var value = vector.getValue(itemIndex);
      for (var i = 0, length = tokens.length; i < length; i++) {
        if (tokens[i] == value) {
          matches = true;
          break;
        }
      }
    }
    if (matches) {
      indices[itemIndex] = 1;
    }
  }
  return indices;
};

morpheus.MolarConcentration = function () {

};
/*
 *
 millimolar 	mM 	10-3 molar 	10-0 mol/m3
 micromolar 	uM 	10-6 molar 	10-3 mol/m3
 nanomolar 	nM 	10-9 molar 	10-6 mol/m3
 picomolar 	pM 	10-12 molar 	10-9 mol/m3
 femtomolar 	fM 	10-15 molar 	10-12 mol/m3
 attomolar 	aM 	10-18 molar 	10-15 mol/m3
 zeptomolar 	zM 	10-21 molar 	10-18 mol/m3
 yoctomolar 	yM[3] 	10-24 molar	10-27 mol/m3
 */
morpheus.MolarConcentration.getMicroMolarConcentration = function (text) {
  /** concentration in molar*/
  text = text.toLowerCase();
  for (var i = 0; i < morpheus.MolarConcentration.CONCENTRATIONS.length; i++) {
    var pair = morpheus.MolarConcentration.CONCENTRATIONS[i];
    var key = pair[0];
    var factorToMolar = pair[1];
    var index = text.indexOf(key);
    if (index != -1) {
      var value = text.substring(0, index).trim();
      var factor = factorToMolar / 10E6;
      var conc = parseFloat(value);
      return conc / factor;

    }
  }
};
morpheus.MolarConcentration.CONCENTRATIONS = [
  ['mm', 10E3],
  ['um', 10E6],
  ['\u00B5' + 'm', 10E6],
  ['nm', 10E9],
  ['pm', 10E12],
  ['fm', 10E15],
  ['am', 10E18],
  ['zm', 10E21],
  ['ym', 10E24],
  ['m', 1]];





morpheus.Positions = function () {
  this.spaces = undefined;
  this.defaultPositionFunction = function (index) {
    return (this.size * index);
  };
  this.squishedPositionFunction = function (index) {
    return this.positions[index];
  };
  this.positionFunction = this.defaultPositionFunction;
  this.squishedIndices = {};
  this.isSquished = false;
};
morpheus.Positions.getBottom = function (rect, rowPositions) {
  var bottom = rowPositions.getLength();
  if (rect != null) {
    bottom = 1 + rowPositions.getIndex(rect.y + rect.height, false);
    bottom = Math.max(0, bottom);
    bottom = Math.min(rowPositions.getLength(), bottom);
  }
  return bottom;
};
morpheus.Positions.getTop = function (rect, rowPositions) {
  var top = 0;
  if (rect != null) {
    top = rowPositions.getIndex(rect.y, false) - 1;
    top = Math.max(0, top);
    top = Math.min(rowPositions.getLength(), top);
  }
  return top;
};
morpheus.Positions.getLeft = function (rect, columnPositions) {
  var left = 0;
  if (rect != null) {
    left = columnPositions.getIndex(rect.x, false) - 1;
    left = Math.max(0, left);
    left = Math.min(columnPositions.getLength(), left);
  }
  return left;
};
morpheus.Positions.getRight = function (rect, columnPositions) {
  var right = columnPositions.getLength();
  if (rect != null) {
    right = 1 + columnPositions.getIndex(rect.x + rect.width, false);
    right = Math.min(columnPositions.getLength(), right);
  }
  return right;
};
morpheus.Positions.prototype = {
  length: 0,
  size: 13,
  squishFactor: 0.1,
  compress: true,
  copy: function () {
    var copy = new morpheus.Positions();
    if (this.spaces) {
      copy.spaces = this.spaces.slice();
    }
    copy.compress = this.compress;
    copy.squishFactor = this.squishFactor;
    copy.size = this.size;
    copy.length = this.length;
    if (this.isSquished) {
      copy.positionFunction = copy.squishedPositionFunction;
      copy.squishedIndices = _.clone(this.squishedIndices);
      copy.isSquished = true;
    }
    return copy;
  },
  getIndex: function (position, exact) {
    if (this.getLength() === 0) {
      return -1;
    }
    if (exact) {
      return this.binaryExactSearch(position);
    } else {
      return this.binaryInExactSearch(position);
    }
  },
  getLength: function () {
    return this.length;
  },
  getPosition: function (index) {
    return this.positionFunction(index)
      + (this.spaces !== undefined ? this.spaces[index] : 0);
  },
  getItemSize: function (index) {
    return this.squishedIndices[index] === true ? this.size
      * this.squishFactor : this.size;
  },
  getSize: function () {
    return this.size;
  },
  setSpaces: function (spaces) {
    this.spaces = spaces;
  },
  setLength: function (length) {
    this.length = length;
    this.trigger('change', {
      source: this,
      value: 'length'
    });
  },
  setSize: function (size) {
    this.size = size;
    if (this.isSquished) {
      this.setSquishedIndices(this.squishedIndices);
    }
    this.trigger('change', {
      source: this,
      value: 'size'
    });
  },
  setSquishedIndices: function (squishedIndices) {
    if (squishedIndices != null) {
      var compress = this.compress;
      this.squishedIndices = squishedIndices;
      var positions = [];
      var squishFactor = this.squishFactor;
      var size = this.size;
      var position = 0;
      for (var i = 0, length = this.getLength(); i < length; i++) {
        var itemSize;
        if (squishedIndices[i] === true) {
          positions.push(position);
          itemSize = size * squishFactor;
          position += itemSize;
        } else {
          if (!compress) {
            position = size * i;
          }
          positions.push(position);
          position += size;
        }
      }
      this.isSquished = true;
      this.positions = positions;
      this.positionFunction = this.squishedPositionFunction;
    } else {
      this.squishedIndices = {};
      this.isSquished = false;
      this.positionFunction = this.defaultPositionFunction;
    }
    this.trigger('change', {
      source: this,
      value: 'squishedIndices'
    });
  },
  setSquishFactor: function (f) {
    if (this.squishFactor !== f) {
      this.squishFactor = f;
      if (this.isSquished) {
        this.setSquishedIndices(this.squishedIndices);
      }
      this.trigger('change', {
        source: this,
        value: 'squishFactor'
      });
    }
  },
  getSquishFactor: function () {
    return this.squishFactor;
  },
  binaryExactSearch: function (position) {
    var low = 0;
    var high = this.length - 1;
    while (low <= high) {
      var mid = (low + high) >> 1;
      var midVal = this.getPosition(mid);
      var size = this.getItemSize(mid);
      if (midVal <= position && position < (midVal + size)) {
        return mid;
      }
      if (midVal < position) {
        low = mid + 1;
      } else if (midVal > position) {
        high = mid - 1;
      } else {
        return mid;
        // key found
      }
    }
    return -1;
    // key not found
  },
  binaryInExactSearch: function (position) {
    var low = 0;
    var high = this.getLength() - 1;
    var maxIndex = this.getLength() - 1;
    if (position <= this.getPosition(0)) {
      return 0;
    }
    while (low <= high) {
      var mid = (low + high) >> 1;
      var midVal = this.getPosition(mid);
      var size = this.getItemSize(mid);
      var nextStart = maxIndex === mid ? midVal + size : this
      .getPosition(mid + 1);
      if (midVal <= position && position < nextStart) {
        return mid;
      }
      if (midVal < position) {
        low = mid + 1;
      } else if (midVal > position) {
        high = mid - 1;
      } else {
        return mid;
        // key found
      }
    }
    return low - 1;
    // key not found
  }
};

morpheus.Util.extend(morpheus.Positions, morpheus.Events);

/**
 *
 * @param dataset
 * @constructor
 */
morpheus.Project = function (dataset) {
  this.originalDataset = dataset;
  this.rowIndexMapper = new morpheus.IndexMapper(this, true);
  this.columnIndexMapper = new morpheus.IndexMapper(this, false);
  this.groupRows = [];
  this.groupColumns = [];
  this.rowColorModel = new morpheus.VectorColorModel();
  this.columnColorModel = new morpheus.VectorColorModel();
  this.rowShapeModel = new morpheus.VectorShapeModel();
  this.columnShapeModel = new morpheus.VectorShapeModel();
  this.rowFontModel = new morpheus.VectorFontModel();
  this.columnFontModel = new morpheus.VectorFontModel();
  this.hoverColumnIndex = -1;
  this.hoverRowIndex = -1;
  this.columnSelectionModel = new morpheus.SelectionModel(this, true);
  this.rowSelectionModel = new morpheus.SelectionModel(this, false);
  this.elementSelectionModel = new morpheus.ElementSelectionModel(this);
  this.symmetricProjectListener = null;
  morpheus.Project._recomputeCalculatedColumnFields(this.originalDataset, morpheus.VectorKeys.RECOMPUTE_FUNCTION_NEW_HEAT_MAP);
  morpheus.Project
    ._recomputeCalculatedColumnFields(new morpheus.TransposedDatasetView(
      this.originalDataset), morpheus.VectorKeys.RECOMPUTE_FUNCTION_NEW_HEAT_MAP);
};
morpheus.Project.Events = {
  DATASET_CHANGED: 'datasetChanged',
  ROW_GROUP_BY_CHANGED: 'rowGroupByChanged',
  COLUMN_GROUP_BY_CHANGED: 'columnGroupByChanged',
  ROW_FILTER_CHANGED: 'rowFilterChanged',
  COLUMN_FILTER_CHANGED: 'columnFilterChanged',
  ROW_SORT_ORDER_CHANGED: 'rowSortOrderChanged',
  COLUMN_SORT_ORDER_CHANGED: 'columnSortOrderChanged',
  ROW_TRACK_REMOVED: 'rowTrackRemoved',
  COLUMN_TRACK_REMOVED: 'columnTrackRemoved'
};

morpheus.Project._recomputeCalculatedColumnFields = function (dataset, key) {
  var metadata = dataset.getColumnMetadata();
  var view = new morpheus.DatasetColumnView(dataset);
  var nfound = 0;

  for (var metadataIndex = 0,
         count = metadata.getMetadataCount(); metadataIndex < count; metadataIndex++) {
    var vector = metadata.get(metadataIndex);
    if (vector.getProperties().get(morpheus.VectorKeys.FUNCTION) != null
      && vector.getProperties().get(key)) {

      // // copy properties
      // var v = metadata.add(name);
      // vector.getProperties().forEach(function (val, key) {
      //   v.getProperties().set(key, val);
      // });
      // vector = v;
      var f = morpheus.VectorUtil.jsonToFunction(vector, morpheus.VectorKeys.FUNCTION);
      for (var j = 0, size = vector.size(); j < size; j++) {
        view.setIndex(j);
        vector.setValue(j, f(view, dataset, j));
      }
      nfound++;
    }
  }
  return nfound;
};
morpheus.Project.prototype = {
  isSymmetric: function () {
    return this.symmetricProjectListener != null;
  },
  setSymmetric: function (heatMap) {
    if (heatMap != null) {
      if (this.symmetricProjectListener == null) {
        this.symmetricProjectListener = new morpheus.SymmetricProjectListener(heatMap.getProject(), heatMap.vscroll, heatMap.hscroll);
      }
    } else {
      if (this.symmetricProjectListener != null) {
        this.symmetricProjectListener.dispose();
      }
      this.symmetricProjectListener = null;
    }
  },
  getHoverColumnIndex: function () {
    return this.hoverColumnIndex;
  },
  setHoverColumnIndex: function (index) {
    this.hoverColumnIndex = index;
  },
  getHoverRowIndex: function () {
    return this.hoverRowIndex;
  },
  setHoverRowIndex: function (index) {
    this.hoverRowIndex = index;
  },
  getRowColorModel: function () {
    return this.rowColorModel;
  },
  getRowShapeModel: function () {
    return this.rowShapeModel;
  },
  getColumnShapeModel: function () {
    return this.columnShapeModel;
  },
  getRowFontModel: function () {
    return this.rowFontModel;
  },
  getColumnFontModel: function () {
    return this.columnFontModel;
  },
  getGroupRows: function () {
    return this.groupRows;
  },
  getGroupColumns: function () {
    return this.groupColumns;
  },
  getFullDataset: function () {
    return this.originalDataset;
  },
  getColumnSelectionModel: function () {
    return this.columnSelectionModel;
  },
  getRowSelectionModel: function () {
    return this.rowSelectionModel;
  },
  getFilteredSortedRowIndices: function () {
    return this.rowIndexMapper.convertToView();
  },
  getFilteredSortedColumnIndices: function () {
    return this.columnIndexMapper.convertToView();
  },
  getElementSelectionModel: function () {
    return this.elementSelectionModel;
  },
  setFullDataset: function (dataset, notify) {
    this.originalDataset = dataset;
    this.rowIndexMapper.setFilter(this.rowIndexMapper.getFilter());
    this.columnIndexMapper.setFilter(this.columnIndexMapper.getFilter());
    this.columnSelectionModel.clear();
    this.rowSelectionModel.clear();
    this.elementSelectionModel.clear();
    if (notify) {
      this.trigger(morpheus.Project.Events.DATASET_CHANGED);
    }
  },
  setGroupRows: function (keys, notify) {
    this.groupRows = keys;
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(false);
      }
    }
    if (notify) {
      this.trigger(morpheus.Project.Events.ROW_GROUP_BY_CHANGED);
    }
  },
  setGroupColumns: function (keys, notify) {
    this.groupColumns = keys;
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(true);
      }
    }
    if (notify) {
      this.trigger(morpheus.Project.Events.COLUMN_GROUP_BY_CHANGED);
    }
  },
  setRowFilter: function (filter, notify) {
    this._saveSelection(false);
    this.rowIndexMapper.setFilter(filter);
    this._restoreSelection(false);
    if (notify) {
      this.trigger(morpheus.Project.Events.ROW_FILTER_CHANGED);
    }
  },
  getRowFilter: function () {
    return this.rowIndexMapper.getFilter();
  },
  getColumnFilter: function () {
    return this.columnIndexMapper.getFilter();
  },
  setColumnFilter: function (filter, notify) {
    this._saveSelection(true);
    this.columnIndexMapper.setFilter(filter);
    this._restoreSelection(true);
    if (notify) {
      this.trigger(morpheus.Project.Events.COLUMN_FILTER_CHANGED);
    }
  },
  getColumnColorModel: function () {
    return this.columnColorModel;
  },
  getSortedFilteredDataset: function () {
    return morpheus.DatasetUtil.slicedView(this.getFullDataset(),
      this.rowIndexMapper.convertToView(), this.columnIndexMapper
        .convertToView());
  },
  getSelectedDataset: function (options) {
    options = $.extend({}, {
      selectedRows: true,
      selectedColumns: true,
      emptyToAll: true
    }, options);
    var dataset = this.getSortedFilteredDataset();
    var rows = null;
    if (options.selectedRows) {
      rows = this.rowSelectionModel.getViewIndices().values().sort(
        function (a, b) {
          return (a === b ? 0 : (a < b ? -1 : 1));
        });
      if (rows.length === 0 && options.emptyToAll) {
        rows = null;
      }
    }
    var columns = null;
    if (options.selectedColumns) {
      columns = this.columnSelectionModel.getViewIndices().values().sort(
        function (a, b) {
          return (a === b ? 0 : (a < b ? -1 : 1));
        });
      if (columns.length === 0 && options.emptyToAll) {
        columns = null;
      }
    }
    return rows == null && columns == null ? dataset : new morpheus.SlicedDatasetView(dataset, rows, columns);
  },
  _saveSelection: function (isColumns) {
    this.elementSelectionModel.save();
    if (isColumns) {
      this.columnSelectionModel.save();
    } else {
      this.rowSelectionModel.save();
    }
  },
  _restoreSelection: function (isColumns) {
    if (isColumns) {
      this.columnSelectionModel.restore();
    } else {
      this.rowSelectionModel.restore();
    }
    this.elementSelectionModel.restore();
  },
  setRowSortKeys: function (keys, notify) {
    this._saveSelection(false);
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(false);
      }
    }
    this.rowIndexMapper.setSortKeys(keys);
    this._restoreSelection(false);
    if (notify) {
      this.trigger(morpheus.Project.Events.ROW_SORT_ORDER_CHANGED);
    }
  },
  setColumnSortKeys: function (keys, notify) {
    this._saveSelection(true);
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(true);
      }
    }
    this.columnIndexMapper.setSortKeys(keys);
    this._restoreSelection(true);
    if (notify) {
      this.trigger(morpheus.Project.Events.COLUMN_SORT_ORDER_CHANGED);
    }
  },
  getRowSortKeys: function () {
    return this.rowIndexMapper.sortKeys;
  },
  getColumnSortKeys: function () {
    return this.columnIndexMapper.sortKeys;
  },
  convertViewColumnIndexToModel: function (viewIndex) {
    return this.columnIndexMapper.convertViewIndexToModel(viewIndex);
  },
  convertViewRowIndexToModel: function (viewIndex) {
    return this.rowIndexMapper.convertViewIndexToModel(viewIndex);
  },
  convertModelRowIndexToView: function (modelIndex) {
    return this.rowIndexMapper.convertModelIndexToView(modelIndex);
  },
  convertModelColumnIndexToView: function (modelIndex) {
    return this.columnIndexMapper.convertModelIndexToView(modelIndex);
  },
  isColumnViewIndexSelected: function (index) {
    return this.columnSelectionModel.isViewIndexSelected(index);
  },
  isRowViewIndexSelected: function (index) {
    return this.rowSelectionModel.isViewIndexSelected(index);
  }
};
morpheus.Util.extend(morpheus.Project, morpheus.Events);

morpheus.QNorm = function () {

};
/**
 * Performs quantile normalization.
 */
morpheus.QNorm.execute = function (data) {
  var rows = data.getRowCount();
  var cols = data.getColumnCount();
  var i, j, ind;
  var dimat;
  var row_mean = new Float32Array(rows);
  var ranks = new Float32Array(rows);
  /* # sort original columns */
  dimat = morpheus.QNorm.get_di_matrix(data);
  for (j = 0; j < cols; j++) {
    dimat[j].sort(function (s1, s2) {
      if (s1.data < s2.data) {
        return -1;
      }
      if (s1.data > s2.data) {
        return 1;
      }
      return 0;
    });

  }
  /* # calculate means */
  for (i = 0; i < rows; i++) {
    var sum = 0.0;
    var numNonMissing = 0;
    for (j = 0; j < cols; j++) {
      var f = dimat[j][i].data;
      if (!isNaN(f)) {
        sum += f;
        numNonMissing++;
      }
    }
    row_mean[i] = sum / numNonMissing;
  }

  /* # unsort mean columns */
  for (j = 0; j < cols; j++) {
    morpheus.QNorm.get_ranks(ranks, dimat[j], rows);
    for (i = 0; i < rows; i++) {
      ind = dimat[j][i].rank;
      if (ranks[i] - Math.floor(ranks[i]) > 0.4) {
        data.setValue(ind, j, 0.5 * (row_mean[Math.floor(ranks[i]) - 1] + row_mean[Math.floor(ranks[i])]));
      } else {
        data.setValue(ind, j, row_mean[Math.floor(ranks[i]) - 1]);
      }
    }
  }
};

/**
 * ************************************************************************
 * * * dataitem **get_di_matrix(var *data, var rows, var cols) * * given
 * data form a matrix of dataitems, each element of * matrix holds datavalue
 * and original index so that * normalized data values can be resorted to
 * the original order *
 * ************************************************************************
 */

morpheus.QNorm.get_di_matrix = function (data) {
  var i, j;
  var rows = data.getRowCount();
  var cols = data.getColumnCount();
  var dimat = [];
  for (j = 0; j < cols; j++) {
    dimat.push([]);
    for (i = 0; i < rows; i++) {
      dimat[j][i] = {};
      dimat[j][i].data = data.getValue(i, j);
      dimat[j][i].rank = i;
    }
  }
  return dimat;
};

/**
 * ************************************************************************
 * * * var *get_ranks(dataitem *x,var n) * * getParameterValue ranks in
 * the same manner as R does. Assume that *x is * already sorted *
 * ************************************************************************
 */

morpheus.QNorm.get_ranks = function (rank, x, n) {
  var i, j, k;
  i = 0;
  while (i < n) {
    j = i;
    while ((j < n - 1) && (x[j].data == x[j + 1].data)) {
      j++;
    }
    if (i != j) {
      for (k = i; k <= j; k++) {
        rank[k] = (i + j + 2) / 2.0;
      }
    } else {
      rank[i] = i + 1;
    }
    i = j + 1;
  }
};


morpheus.SelectionModel = function (project, isColumns) {
  this.viewIndices = new morpheus.Set();
  this.project = project;
  this.isColumns = isColumns;
};
morpheus.SelectionModel.prototype = {
  setViewIndices: function (indices, notify) {
    this.viewIndices = indices;
    if (notify) {
      this.trigger('selectionChanged');
    }
  },
  isViewIndexSelected: function (index) {
    return this.viewIndices.has(index);
  },
  clear: function () {
    this.viewIndices = new morpheus.Set();
  },
  /**
   *
   * @returns {morpheus.Set}
   */
  getViewIndices: function () {
    return this.viewIndices;
  },
  count: function () {
    return this.viewIndices.size();
  },
  toModelIndices: function () {
    var project = this.project;
    var f = this.isColumns ? project.convertViewColumnIndexToModel
      : project.convertViewRowIndexToModel;
    f = _.bind(f, project);
    var modelIndices = [];
    this.viewIndices.forEach(function (index) {
      var m = f(index);
      modelIndices.push(m);
    });
    return modelIndices;
  },
  save: function () {
    this.modelIndices = this.toModelIndices();
  },
  restore: function () {
    var project = this.project;
    this.viewIndices = new morpheus.Set();
    var f = this.isColumns ? project.convertModelColumnIndexToView
      : project.convertModelRowIndexToView;
    f = _.bind(f, project);
    for (var i = 0, length = this.modelIndices.length; i < length; i++) {
      var index = f(this.modelIndices[i]);
      if (index !== -1) {
        this.viewIndices.add(index);
      }
    }
  },
};
morpheus.Util.extend(morpheus.SelectionModel, morpheus.Events);

morpheus.SlicedDatasetView = function (dataset, rowIndices, columnIndices) {
  morpheus.DatasetAdapter.call(this, dataset);
  if (rowIndices == null) {
    rowIndices = null;
  }
  if (columnIndices == null) {
    columnIndices = null;
  }
  this.rowIndices = rowIndices;
  this.columnIndices = columnIndices;
};
morpheus.SlicedDatasetView.prototype = {
  getRowCount: function () {
    return this.rowIndices !== null ? this.rowIndices.length : this.dataset
      .getRowCount();
  },
  getColumnCount: function () {
    return this.columnIndices !== null ? this.columnIndices.length
      : this.dataset.getColumnCount();
  },
  getValue: function (i, j, seriesIndex) {
    return this.dataset.getValue(
      this.rowIndices !== null ? this.rowIndices[i] : i,
      this.columnIndices !== null ? this.columnIndices[j] : j,
      seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    this.dataset.setValue(
      this.rowIndices !== null ? this.rowIndices[i] : i,
      this.columnIndices !== null ? this.columnIndices[j] : j, value,
      seriesIndex);
  },
  getRowMetadata: function () {
    return this.rowIndices !== null ? new morpheus.MetadataModelItemView(
        this.dataset.getRowMetadata(), this.rowIndices) : this.dataset
      .getRowMetadata();
  },
  getColumnMetadata: function () {
    return this.columnIndices !== null ? new morpheus.MetadataModelItemView(
        this.dataset.getColumnMetadata(), this.columnIndices)
      : this.dataset.getColumnMetadata();
  },
  toString: function () {
    return this.getName();
  }
};
morpheus.Util.extend(morpheus.SlicedDatasetView, morpheus.DatasetAdapter);

morpheus.SlicedVector = function (v, indices) {
  morpheus.VectorAdapter.call(this, v);
  this.indices = indices;
};
morpheus.SlicedVector.prototype = {
  setValue: function (i, value) {
    this.v.setValue(this.indices[i], value);
  },
  getValue: function (i) {
    return this.v.getValue(this.indices[i]);
  },
  size: function () {
    return this.indices.length;
  }
};
morpheus.Util.extend(morpheus.SlicedVector, morpheus.VectorAdapter);

morpheus.AbstractSortKey = function (name, columns) {
  this.name = name;
  this.columns = columns;
};

morpheus.AbstractSortKey.prototype = {
  lockOrder: 0,
  columns: true,
  preservesDendrogram: false,
  unlockable: true,
  /**
   * Indicates whether this key is sorting rows or columns.
   * @return {Boolean}
   */
  isColumns: function () {
    return this.columns;
  },
  /**
   * Sets whether this key is columns (true) or rows (false).
   * @param columns {Boolean}
   */
  setColumns: function (columns) {
    this.columns = columns;
  },
  isPreservesDendrogram: function () {
    return this.preservesDendrogram;
  },
  setPreservesDendrogram: function (preservesDendrogram) {
    this.preservesDendrogram = preservesDendrogram;
  },
  getLockOrder: function () {
    return this.lockOrder;
  },
  /**
   * When lock order is set, indicates whether lock order can be unlocked. For example, bring matches to top sort key can not be unlocked.
   */
  isUnlockable: function () {
    return this.unlockable;
  },
  setUnlockable: function (unlockable) {
    this.unlockable = unlockable;
  },
  /**
   * Sets the sort key lock order. One is locked to beginning of sort keys, two is locked to end of sort keys. Zero clears lock order.
   * Dendrogram sort key is locked to end. Selection on top sort key is locked to beginning.
   * @param lockOrder {Number}
   */
  setLockOrder: function (lockOrder) {
    this.lockOrder = lockOrder;
  },
  setSortOrder: function (sortOrder) {
    this.sortOrder = sortOrder;
  },
  getSortOrder: function () {
    return this.sortOrder;
  },
  init: function () {

  }
};
morpheus.MatchesOnTopSortKey = function (project, modelIndices, name, columns) {
  morpheus.AbstractSortKey.call(this, name, columns);
  var highlightedModelIndices = {};
  var p = project;
  var viewIndices = [];
  for (var i = 0, j = modelIndices.length, length = modelIndices.length; i < length; i++, j--) {
    highlightedModelIndices[modelIndices[i]] = -1; // tie
    viewIndices.push(i);
  }
  this.comparator = function (i1, i2) {
    var a = highlightedModelIndices[i1];
    if (a === undefined) {
      a = 0;
    }
    var b = highlightedModelIndices[i2];
    if (b === undefined) {
      b = 0;
    }
    return (a === b ? 0 : (a < b ? -1 : 1));
  };
  this.indices = viewIndices;
};
morpheus.MatchesOnTopSortKey.prototype = {
  toString: function () {
    return this.name;
  },
  getSortOrder: function () {
    return 2;
  },
  getComparator: function () {
    return this.comparator;
  },
  getValue: function (i) {
    return i;
  }
};
morpheus.Util.extend(morpheus.MatchesOnTopSortKey, morpheus.AbstractSortKey);

morpheus.SortKey = function (field, sortOrder, columns) {
  morpheus.AbstractSortKey.call(this, field, columns);
  if (typeof sortOrder === 'string') {
    sortOrder = morpheus.SortKey.SortOrder[sortOrder.toUpperCase()];
    if (sortOrder === undefined) {
      sortOrder = 0;
    }
  }
  this.v = null;
  this.c = null;
  this.setSortOrder(sortOrder);
};

morpheus.SortKey.prototype = {
  toString: function () {
    return this.name;
  },
  init: function (dataset, visibleModelIndices) {
    this.v = dataset.getRowMetadata().getByName(this.name);
    if (!this.v) {
      this.v = {};
      this.v.getValue = function () {
        return 0;
      };
      this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.ASCENDING_COMPARATOR
        : morpheus.SortKey.DESCENDING_COMPARATOR;
    } else {
      var dataType = morpheus.VectorUtil.getDataType(this.v);
      if (dataType === 'number') {
        this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR
          : morpheus.SortKey.NUMBER_DESCENDING_COMPARATOR;
      } else if (dataType === '[number]') {
        var summary = this.v.getProperties().get(
          morpheus.VectorKeys.ARRAY_SUMMARY_FUNCTION)
          || morpheus.SortKey.ARRAY_MAX_SUMMARY_FUNCTION;
        this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey
            .ARRAY_ASCENDING_COMPARATOR(summary)
          : morpheus.SortKey.ARRAY_DESCENDING_COMPARATOR(summary);
      } else {
        this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.ASCENDING_COMPARATOR
          : morpheus.SortKey.DESCENDING_COMPARATOR;
      }
      if (this.customComparator != null) {
        var oldC = this.c;
        var customComparator = this.customComparator;
        if (this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING) {
          this.c = function (a, b) {
            var val = customComparator(a, b);
            return val === 0 ? oldC(a, b) : val;
          };
        } else {
          this.c = function (a, b) {
            var val = customComparator(b, a);
            return val === 0 ? oldC(a, b) : val;
          };
        }
      }
    }

    if (this.sortOrder === morpheus.SortKey.SortOrder.TOP_N) {
      var pairs = [];
      var missingIndices = [];
      for (var i = 0, nrows = visibleModelIndices.length; i < nrows; i++) {
        var index = visibleModelIndices[i];
        var value = this.v.getValue(index);
        if (!isNaN(value)) {
          pairs.push({
            index: index,
            value: value
          });
        } else {
          missingIndices.push(index);
        }
      }
      // sort values in descending order
      var c = this.c;
      this.c = morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR;
      pairs
        .sort(function (pair1, pair2) {
          return c(pair1.value, pair2.value);
        });

      var modelIndexToValue = [];
      var nInGroup = Math.min(pairs.length, 10);
      var counter = 0;
      var topIndex = 0;

      var half = Math.floor(pairs.length / 2);
      var topPairs = pairs.slice(0, half);
      var bottomPairs = pairs.slice(half);
      var bottomIndex = bottomPairs.length - 1;
      var ntop = topPairs.length;
      var npairs = pairs.length;
      while (counter < npairs) {
        for (var i = 0; i < nInGroup && topIndex < ntop; i++, topIndex++, counter++) {
          modelIndexToValue[topPairs[topIndex].index] = counter;
        }
        var indexCounterPairs = [];
        for (var i = 0; i < nInGroup && bottomIndex >= 0; i++, bottomIndex--, counter++) {
          indexCounterPairs.push([
            bottomPairs[bottomIndex].index,
            counter]);
        }
        for (var i = indexCounterPairs.length - 1, j = 0; i >= 0; i--, j++) {
          var item_i = indexCounterPairs[i];
          var item_j = indexCounterPairs[j];
          modelIndexToValue[item_i[0]] = item_j[1];
        }

      }

      // add on missing
      for (var i = 0, length = missingIndices.length; i < length; i++, counter++) {
        modelIndexToValue[missingIndices[i]] = counter;
      }
      this.modelIndexToValue = modelIndexToValue;

    }
    else {
      delete this.modelIndexToValue;
    }
  },
  getComparator: function () {
    return this.c;
  },
  getValue: function (i) {
    return this.modelIndexToValue ? this.modelIndexToValue[i] : this.v.getValue(i);
  }
};
morpheus.Util.extend(morpheus.SortKey, morpheus.AbstractSortKey);
/**
 * @param modelIndices
 *            Selected rows or columns
 * @param isColumnSort -
 *            sort columns by selected rows.
 */
morpheus.SortByValuesKey = function (modelIndices, sortOrder, isColumnSort) {
  morpheus.AbstractSortKey.call(this, 'values', isColumnSort);
  this.bothCount = 10;
  this.modelIndices = modelIndices;
  this.sortOrder = sortOrder;
  this.setSortOrder(sortOrder);

};
morpheus.SortByValuesKey.prototype = {
  toString: function () {
    return this.name;
  },
  init: function (dataset, visibleModelIndices) {
    // isColumnSort-sort columns by selected rows
    // dataset is transposed if !isColumnSort
    this.dataset = morpheus.DatasetUtil.slicedView(dataset, null,
      this.modelIndices);
    this.rowView = new morpheus.DatasetRowView(this.dataset);
    this.summaryFunction = this.modelIndices.length > 1 ? morpheus.Median
      : function (row) {
        return row.getValue(0);
      };
    if (this.sortOrder === morpheus.SortKey.SortOrder.TOP_N) {
      var pairs = [];
      var missingIndices = [];
      for (var i = 0, nrows = visibleModelIndices.length; i < nrows; i++) {
        var index = visibleModelIndices[i];
        var value = this.summaryFunction(this.rowView.setIndex(index));
        if (!isNaN(value)) {
          pairs.push({
            index: index,
            value: value
          });
        } else {
          missingIndices.push(index);
        }
      }
      // sort values in descending order
      pairs
        .sort(function (a, b) {
          return (a.value < b.value ? 1
            : (a.value === b.value ? 0 : -1));
        });

      var modelIndexToValue = [];
      var nInGroup = Math.min(pairs.length, this.bothCount);
      var counter = 0;
      var topIndex = 0;

      var half = Math.floor(pairs.length / 2);
      var topPairs = pairs.slice(0, half);
      var bottomPairs = pairs.slice(half);
      var bottomIndex = bottomPairs.length - 1;
      var ntop = topPairs.length;
      var npairs = pairs.length;
      while (counter < npairs) {
        for (var i = 0; i < nInGroup && topIndex < ntop; i++, topIndex++, counter++) {
          modelIndexToValue[topPairs[topIndex].index] = counter;
        }
        var indexCounterPairs = [];
        for (var i = 0; i < nInGroup && bottomIndex >= 0; i++, bottomIndex--, counter++) {
          indexCounterPairs.push([
            bottomPairs[bottomIndex].index,
            counter]);
        }
        for (var i = indexCounterPairs.length - 1, j = 0; i >= 0; i--, j++) {
          var item_i = indexCounterPairs[i];
          var item_j = indexCounterPairs[j];
          modelIndexToValue[item_i[0]] = item_j[1];
        }

      }

      // add on missing
      for (var i = 0, length = missingIndices.length; i < length; i++, counter++) {
        modelIndexToValue[missingIndices[i]] = counter;
      }
      this.modelIndexToValue = modelIndexToValue;

    } else {
      delete this.modelIndexToValue;
    }
  },
  getComparator: function () {
    return this.c;
  },
  getValue: function (i) {
    return this.modelIndexToValue ? this.modelIndexToValue[i] : this
      .summaryFunction(this.rowView.setIndex(i));
  },
  setSortOrder: function (sortOrder) {
    if (typeof sortOrder === 'string') {
      sortOrder = morpheus.SortKey.SortOrder[sortOrder.toUpperCase()];
    }
    this.sortOrder = sortOrder;
    if (this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING) {
      this.c = morpheus.SortKey.ELEMENT_ASCENDING_COMPARATOR;
    } else if (this.sortOrder === morpheus.SortKey.SortOrder.DESCENDING) {
      this.c = morpheus.SortKey.ELEMENT_DESCENDING_COMPARATOR;
    } else {
      this.c = morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR;
    }

  }
};
morpheus.Util.extend(morpheus.SortByValuesKey, morpheus.AbstractSortKey);

/**
 * @param modelIndices
 *            Array of model indices
 * @param nvisible
 *            The number of visible indices at the time this sort key was
 *            created. Used by dendrogram to determine if dendrogram should be
 *            shown.
 * @param name
 *            This sort key name
 * @param columns Whether column sort
 */
morpheus.SpecifiedModelSortOrder = function (modelIndices, nvisible, name, columns) {
  morpheus.AbstractSortKey.call(this, name, columns);
  this.nvisible = nvisible;
  var modelIndexToValue = [];
  for (var i = 0, length = modelIndices.length; i < length; i++) {
    modelIndexToValue[modelIndices[i]] = i;
  }
  this.modelIndices = modelIndices;
  this.modelIndexToValue = modelIndexToValue;
  this.c = morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR;
};
morpheus.SpecifiedModelSortOrder.prototype = {
  toString: function () {
    return this.name;
  },
  getComparator: function (a, b) {
    return this.c;
  },
  getValue: function (i) {
    return this.modelIndexToValue[i];
  },
  setSortOrder: function (sortOrder) {
    this.sortOrder = sortOrder;
    this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR
      : morpheus.SortKey.NUMBER_DESCENDING_COMPARATOR;
  }
};
morpheus.Util.extend(morpheus.SpecifiedModelSortOrder, morpheus.AbstractSortKey);

/**
 * Group by key
 *
 * @param values
 */
morpheus.SpecifiedGroupByKey = function (clusterIds, columns) {
  morpheus.AbstractSortKey.call(this, 'Dendrogram Cut', columns);
  this.clusterIds = clusterIds;
  this.c = function (a, b) {
    return (a === b ? 0 : // Values are equal
      (a < b ? -1 : // (-0.0, 0.0) or (!NaN, NaN)
        1));
  };
};
morpheus.SpecifiedGroupByKey.prototype = {
  toString: function () {
    return this.name;
  },
  getComparator: function (a, b) {
    return this.c;
  },
  getValue: function (i) {
    return this.clusterIds[i];
  }
};
morpheus.Util.extend(morpheus.SpecifiedGroupByKey, morpheus.AbstractSortKey);

morpheus.SortKey.SortOrder = {
  ASCENDING: 0,
  DESCENDING: 1,
  UNSORTED: 2,
  CUSTOM: 3,
  TOP_N: 4
};
/**
 * Comparator to sort ascending using lowercase string comparison
 */
morpheus.SortKey.ASCENDING_COMPARATOR = function (a, b) {
  // we want NaNs to end up at the bottom
  var aNaN = (a == null);
  var bNaN = (b == null);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  a = ('' + a).toLowerCase();
  b = ('' + b).toLowerCase();
  return (a === b ? 0 : (a < b ? -1 : 1));
};
/**
 * Comparator to sort descending using lowercase string comparison
 */
morpheus.SortKey.DESCENDING_COMPARATOR = function (a, b) {
  var aNaN = (a == null);
  var bNaN = (b == null);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  a = ('' + a).toLowerCase();
  b = ('' + b).toLowerCase();
  return (a === b ? 0 : (a < b ? 1 : -1));
};

morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR = function (a, b) {
  // we want NaNs to end up at the bottom
  var aNaN = (a == null || isNaN(a));
  var bNaN = (b == null || isNaN(b));
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  return (a === b ? 0 : (a < b ? -1 : 1));
};

morpheus.SortKey.NUMBER_DESCENDING_COMPARATOR = function (a, b) {
  var aNaN = (a == null || isNaN(a));
  var bNaN = (b == null || isNaN(b));
  if (aNaN && bNaN) {
    return 0;
  }
  //noinspection JSConstructorReturnsPrimitive
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  return (a === b ? 0 : (a < b ? 1 : -1));
};

morpheus.SortKey.STRING_ASCENDING_COMPARATOR = function (a, b) {
  a = (a == null || a.toLowerCase === undefined) ? null : a.toLowerCase();
  b = (b == null || b.toLowerCase === undefined) ? null : b.toLowerCase();
  return (a === b ? 0 : (a < b ? -1 : 1));
};
morpheus.SortKey.STRING_DESCENDING_COMPARATOR = function (a, b) {
  a = (a == null || a.toLowerCase === undefined) ? null : a.toLowerCase();
  b = (b == null || b.toLowerCase === undefined) ? null : b.toLowerCase();
  return (a === b ? 0 : (a < b ? 1 : -1));
};

morpheus.SortKey.ELEMENT_ASCENDING_COMPARATOR = function (obj1, obj2) {
  var a = +obj1;
  var b = +obj2;
  var aNaN = isNaN(a);
  var bNaN = isNaN(b);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }

  if (a === b) {
    if (obj1 != null && obj1.toObject && obj2 != null && obj2.toObject) {
      var a1 = obj1.toObject();
      var b1 = obj2.toObject();
      for (var name in a1) {
        a = a1[name];
        b = b1[name];

        var c = (a === b ? 0 : (a < b ? -1 : 1));
        if (c !== 0) {
          return c;
        }
      }
    }
  }
  return (a === b ? 0 : (a < b ? -1 : 1));
};

morpheus.SortKey.ELEMENT_DESCENDING_COMPARATOR = function (obj1, obj2) {
  // we want NaNs to end up at the bottom
  var a = +obj1;
  var b = +obj2;
  var aNaN = isNaN(a);
  var bNaN = isNaN(b);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  if (a === b) {
    if (obj1 != null && obj1.toObject && obj2 != null && obj2.toObject) {
      var a1 = obj1.toObject();
      var b1 = obj2.toObject();
      for (var name in a1) {
        a = a1[name];
        b = b1[name];
        var c = (a === b ? 0 : (a < b ? 1 : -1));
        if (c !== 0) {
          return c;
        }
      }
    }
  }
  return (a === b ? 0 : (a < b ? 1 : -1));
};
morpheus.SortKey.BOX_PLOT_SUMMARY_FUNCTION = function (array) {
  var box = array.box;
  if (box == null) {
    var v = morpheus.VectorUtil.arrayAsVector(array);
    box = morpheus
      .BoxPlotItem(this.indices != null ? new morpheus.SlicedVector(
        v, this.indices) : v);
    array.box = box;
  }

  return box.q3;
};

morpheus.SortKey.ARRAY_MAX_SUMMARY_FUNCTION = function (array) {
  var a = 0;
  if (array != null) {
    var aPosMax = -Number.MAX_VALUE;
    var aNegMax = Number.MAX_VALUE;
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (!isNaN(value)) {
        if (value >= 0) {
          aPosMax = value > aPosMax ? value : aPosMax;
        } else {
          aNegMax = value < aNegMax ? value : aNegMax;
        }
      }
    }

    if (aPosMax !== -Number.MAX_VALUE) {
      a = aPosMax;
    }
    if (aNegMax !== Number.MAX_VALUE) {
      a = Math.abs(aNegMax) > a ? aNegMax : a;
    }
  }
  return a;
};
morpheus.SortKey.ARRAY_ASCENDING_COMPARATOR = function (summary) {
  return function (a, b) {
    var aNaN = a == null;
    var bNaN = b == null;
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    a = summary(a);
    b = summary(b);
    aNaN = isNaN(a);
    bNaN = isNaN(b);
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    return (a === b ? 0 : (a < b ? -1 : 1));
  };
};

morpheus.SortKey.ARRAY_DESCENDING_COMPARATOR = function (summary) {
  return function (a, b) {
    var aNaN = a == null;
    var bNaN = b == null;
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    a = summary(a);
    b = summary(b);
    aNaN = isNaN(a);
    bNaN = isNaN(b);
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    return (a === b ? 0 : (a < b ? 1 : -1));
  };
};

morpheus.SortKey.reverseComparator = function (c) {
  return function (a, b) {
    return c(b, a);
  };
};
morpheus.SortKey.keepExistingSortKeys = function (newSortKeys, existingSortKeys) {
  for (var i = 0, length = existingSortKeys.length; i < length; i++) {
    var key = existingSortKeys[i];
    if (key.getLockOrder() > 0) {
      // 1 is beginning, 2 is end
      // don' add it 2x
      var existingIndex = -1;
      for (var j = 0; j < newSortKeys.length; j++) {
        if (newSortKeys[j] === key) {
          existingIndex = j;
          break;
        }
      }
      if (existingIndex !== -1) { // remove
        newSortKeys.splice(existingIndex, 1);
      }
      newSortKeys.splice(key.getLockOrder() === 1 ? 0 : newSortKeys.length, 0, key);
    }
  }
  return newSortKeys;
};

morpheus.SortKey.fromJSON = function (project, json) {
  var sortKeys = [];
  json.forEach(function (key) {
    var sortKey = null;
    if (key.type === 'annotation') {
      sortKey = new morpheus.SortKey(key.field, key.order, key.isColumns);
      if (key.customSortOrder != null) {

        var customSortOrderMap = new morpheus.Map();
        for (var i = 0, size = key.customSortOrder.length; i < size; i++) {
          customSortOrderMap.set(key.customSortOrder[i], i);
        }
        var comparator = function (a, b) {
          var v1 = customSortOrderMap.get(a);
          var v2 = customSortOrderMap.get(b);
          if (v1 === undefined && v2 === undefined) {
            return 0;
          }
          if (v1 === undefined) {
            v1 = Infinity;
          }
          if (v2 === undefined) {
            v2 = Infinity;
          }
          return (v1 < v2 ? -1 : 1);
        };
        sortKey.customComparator = comparator;
        if (key.preservesDendrogram) {
          sortKey.nvisible = key.customSortOrder.length;
        }
      }

    } else if (key.type === 'byValues') {
      sortKey = new morpheus.SortByValuesKey(key.modelIndices, key.order, key.isColumns);
    } else if (key.type === 'specified') {
      sortKey = new morpheus.SpecifiedModelSortOrder(key.modelIndices, key.nvisible, key.name, key.isColumns);
    } else if (key.type === 'matchesOnTop') {
      sortKey = new morpheus.MatchesOnTopSortKey(project, key.modelIndices, key.name, key.isColumns);
    } else {
      if (key.field != null) {
        sortKey = new morpheus.SortKey(key.field, key.order);
      } else {
        console.log('Unknown key: ' + key);
      }
    }
    if (sortKey != null) {
      if (key.preservesDendrogram != null) {
        sortKey.setPreservesDendrogram(key.preservesDendrogram);
      }
      if (key.lockOrder != null && key.lockOrder !== 0) {
        sortKey.setLockOrder(key.lockOrder);
        sortKey.setUnlockable(key.unlockable);
      }
      sortKeys.push(sortKey);
    }
  });
  return sortKeys;
};

morpheus.SortKey.toJSON = function (sortKeys) {
  var json = [];
  sortKeys.forEach(function (key) {
    var sortKey = null;
    if (key instanceof morpheus.SortKey) {
      sortKey = {
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'annotation',
        field: '' + key
      };
    } else if (key instanceof morpheus.SortByValuesKey) {
      sortKey = {
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'byValues',
        modelIndices: key.modelIndices
      };
    } else if (key instanceof morpheus.SpecifiedModelSortOrder) {
      sortKey = {
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'specified',
        modelIndices: key.modelIndices,
        name: key.name,
        nvisible: key.nvisible
      };
    } else if (key instanceof morpheus.MatchesOnTopSortKey) {
      sortKey = {
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'matchesOnTop',
        modelIndices: key.modelIndices,
        name: key.name
      };
    }
    if (sortKey != null) {
      sortKey.preservesDendrogram = key.isPreservesDendrogram();
      if (key.getLockOrder && key.getLockOrder() !== 0) {
        sortKey.lockOrder = key.getLockOrder();
        sortKey.unlockable = key.isUnlockable ? key.isUnlockable() : false;
      }
      json.push(sortKey);
    } else {
      console.log('Unknown sort key type');
    }
  });
  return json;
};

morpheus.SymmetricProjectListener = function (project, vscroll, hscroll) {
  var ignoreEvent = false;
  var rowGroupBy;
  var columnGroupBy;
  var rowFilter;
  var columnFilter;
  var rowSortOrder;
  var columnSortOrder;
  var columnSelection;
  var rowSelection;
  var vscrollFunction;
  var hscrollFunction;
  project.on(morpheus.Project.Events.ROW_GROUP_BY_CHANGED, rowGroupBy = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setGroupColumns(project.getGroupRows(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.COLUMN_GROUP_BY_CHANGED, columnGroupBy = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setGroupRows(project.getGroupColumns(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.ROW_FILTER_CHANGED, rowFilter = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setColumnFilter(project.getRowFilter(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.COLUMN_FILTER_CHANGED, columnFilter = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setRowFilter(project.getColumnFilter(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.ROW_SORT_ORDER_CHANGED, rowSortOrder = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setColumnSortKeys(project.getRowSortKeys(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.COLUMN_SORT_ORDER_CHANGED, columnSortOrder = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setRowSortKeys(project.getColumnSortKeys(), true);
    ignoreEvent = false;
  });
  project.getColumnSelectionModel().on('selectionChanged', columnSelection = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.getRowSelectionModel().setViewIndices(project.getColumnSelectionModel().getViewIndices(), true);
    ignoreEvent = false;
  });
  project.getRowSelectionModel().on('selectionChanged', rowSelection = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.getColumnSelectionModel().setViewIndices(project.getRowSelectionModel().getViewIndices(), true);
    ignoreEvent = false;
  });
  vscroll.on('scroll', vscrollFunction = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    var f = vscroll.getMaxValue() === 0 ? 0 : vscroll.getValue() / vscroll.getMaxValue();
    hscroll.setValue(f * hscroll.getMaxValue(), true);
    ignoreEvent = false;
  });
  hscroll.on('scroll', hscrollFunction = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    var f = hscroll.getMaxValue() === 0 ? 0 : hscroll.getValue() / hscroll.getMaxValue();
    vscroll.setValue(f * vscroll.getMaxValue(), true);
    ignoreEvent = false;
  });

  this.dispose = function () {
    project.off(morpheus.Project.Events.ROW_GROUP_BY_CHANGED, rowGroupBy);
    project.off(morpheus.Project.Events.COLUMN_GROUP_BY_CHANGED, columnGroupBy);
    project.off(morpheus.Project.Events.ROW_FILTER_CHANGED, rowFilter);
    project.off(morpheus.Project.Events.COLUMN_FILTER_CHANGED, columnFilter);
    project.off(morpheus.Project.Events.ROW_SORT_ORDER_CHANGED, rowSortOrder);
    project.off(morpheus.Project.Events.COLUMN_SORT_ORDER_CHANGED, columnSortOrder);
    project.getColumnSelectionModel().off('selectionChanged', columnSelection);
    project.getRowSelectionModel().off('selectionChanged', rowSelection);
    vscroll.off('scroll', vscrollFunction);
    hscroll.off('scroll', hscrollFunction);
  };
};




morpheus.TransposedDatasetView = function (dataset) {
  morpheus.DatasetAdapter.call(this, dataset);
};
morpheus.TransposedDatasetView.prototype = {
  getRowCount: function () {
    return this.dataset.getColumnCount();
  },
  getColumnCount: function () {
    return this.dataset.getRowCount();
  },
  getValue: function (i, j, seriesIndex) {
    return this.dataset.getValue(j, i, seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    this.dataset.setValue(j, i, value, seriesIndex);
  },
  getRowMetadata: function () {
    return this.dataset.getColumnMetadata();
  },
  getColumnMetadata: function () {
    return this.dataset.getRowMetadata();
  }
};
morpheus.Util.extend(morpheus.TransposedDatasetView, morpheus.DatasetAdapter);

/**
 * Provides percentile computation.
 * <p>
 * There are several commonly used methods for estimating percentiles (a.k.a.
 * quantiles) based on sample data. For large samples, the different methods
 * agree closely, but when sample sizes are small, different methods will give
 * significantly different results. The algorithm implemented here works as
 * follows:
 * <ol>
 * <li>Let <code>n</code> be the length of the (sorted) array and
 * <code>0 < p <= 100</code> be the desired percentile.</li>
 * <li>If <code> n = 1 </code> return the unique array element (regardless of
 * the value of <code>p</code>); otherwise</li>
 * <li>Compute the estimated percentile position
 * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>
 * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional
 * part of <code>pos</code>). If <code>pos >= n</code> return the largest
 * element in the array; otherwise</li>
 * <li>Let <code>lower</code> be the element in position
 * <code>floor(pos)</code> in the array and let <code>upper</code> be the
 * next element in the array. Return <code>lower + d * (upper - lower)</code></li>
 * </ol>
 *
 * @param p Percentile between 0 and 100
 */
morpheus.Percentile = function (vector, p, isSorted) {
  return morpheus.ArrayPercentile(morpheus.RemoveNaN(vector), p, isSorted);
};
morpheus.Percentile.toString = function () {
  return 'Percentile';
};
/**
 * @private
 * @ignore
 */
morpheus.RemoveNaN = function (values) {
  var array = [];
  for (var i = 0, size = values.size(); i < size; i++) {
    var value = values.getValue(i);
    if (!isNaN(value)) {
      array.push(value);
    }
  }
  return array;
};
morpheus.Median = function (vector) {
  return morpheus.ArrayPercentile(morpheus.RemoveNaN(vector), 50, false);
};
morpheus.Median.toString = function () {
  return 'Median';
};
/**
 * @ignore
 */
morpheus.ArrayPercentile = function (values, p, isSorted) {

  if (!isSorted) {
    values.sort(function (a, b) {
      return (a < b ? -1 : (a === b ? 0 : 1));
    });
  }
  return d3.quantile(values, p / 100);
};
/**
 * @ignore
 */
morpheus.MaxPercentiles = function (percentiles) {
  var f = function (vector) {
    var values = [];
    for (var i = 0, size = vector.size(); i < size; i++) {
      var value = vector.getValue(i);
      if (!isNaN(value)) {
        values.push(value);
      }
    }
    if (values.length === 0) {
      return NaN;
    }
    values.sort(function (a, b) {
      return (a < b ? -1 : (a === b ? 0 : 1));
    });
    var max = 0;
    for (var i = 0; i < percentiles.length; i++) {
      var p = morpheus.ArrayPercentile(values, percentiles[i], true);
      if (Math.abs(p) > Math.abs(max)) {
        max = p;
      }
    }
    return max;
  };
  f.toString = function () {
    var s = ['Maximum of '];
    for (var i = 0, length = percentiles.length; i < length; i++) {
      if (i > 0 && length > 2) {
        s.push(', ');
      }
      if (i === length - 1) {
        s.push(length == 2 ? ' and ' : 'and ');
      }
      s.push(percentiles[i]);
    }
    s.push(' percentiles');
    return s.join('');
  };
  return f;
};

morpheus.CountIf = function (vector, criteria) {
  if (!/[<>=!]/.test(criteria)) {
    criteria = '=="' + criteria + '"';
  }
  var matches = 0;
  for (var i = 0, size = vector.size(); i < size; i++) {
    var value = vector.getValue(i);
    if (eval(value + criteria)) {
      matches++;
    }
  }
  return matches;

};
morpheus.Mean = function (vector) {
  var sum = 0;
  var count = 0;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      sum += val;
      count++;
    }
  }
  return count === 0 ? NaN : sum / count;
};
morpheus.Mean.toString = function () {
  return 'Mean';
};
morpheus.Sum = function (vector) {
  var sum = 0;
  var found = false;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      found = true;
      sum += val;
    }
  }
  return !found ? NaN : sum;
};
morpheus.Sum.toString = function () {
  return 'Sum';
};
morpheus.CountNonNaN = function (vector) {
  var count = 0;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      count++;
    }
  }
  return count;
};
morpheus.CountNonNaN.toString = function () {
  return 'Count non-NaN';
};

morpheus.Max = function (vector) {
  var max = -Number.MAX_VALUE;
  var found = false;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      found = true;
      max = Math.max(max, val);
    }
  }
  return !found ? NaN : max;
};
morpheus.Max.toString = function () {
  return 'Max';
};
morpheus.Min = function (vector) {
  var min = Number.MAX_VALUE;
  var found = false;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      found = true;
      min = Math.min(min, val);
    }
  }
  return !found ? NaN : min;
};
morpheus.Min.toString = function () {
  return 'Min';
};
morpheus.Variance = function (list, mean) {
  if (mean == undefined) {
    mean = morpheus.Mean(list);
  }
  var sum = 0;
  var n = 0;
  for (var j = 0, size = list.size(); j < size; j++) {
    var x = list.getValue(j);
    if (!isNaN(x)) {
      var diff = x - mean;
      diff = diff * diff;
      sum += diff;
      n++;
    }
  }
  if (n <= 1) {
    return NaN;
  }
  n = n - 1;
  if (n < 1) {
    n = 1;
  }
  var variance = sum / n;
  return variance;
};
morpheus.Variance.toString = function () {
  return 'Variance';
};

morpheus.StandardDeviation = function (list, mean) {
  return Math.sqrt(morpheus.Variance(list, mean));
};
morpheus.StandardDeviation.toString = function () {
  return 'Standard deviation';
};

var LOG_10 = Math.log(10);
morpheus.Log10 = function (x) {
  return x <= 0 ? 0 : Math.log(x) / LOG_10;
};
var LOG_2 = Math.log(2);
morpheus.Log2 = function (x) {
  return x <= 0 ? 0 : Math.log(x) / LOG_2;
};

/**
 * Computes the False Discovery Rate using the BH procedure.
 *
 * @param nominalPValues
 *            Array of nominal p-values.
 */
morpheus.FDR_BH = function (nominalPValues) {
  var size = nominalPValues.length;
  var fdr = [];
  var pValueIndices = morpheus.Util.indexSort(nominalPValues, true);
  var ranks = morpheus.Util.rankIndexArray(pValueIndices);

  // check for ties
  for (var i = pValueIndices.length - 1; i > 0; i--) {
    var bigPValue = nominalPValues[pValueIndices[i]];
    var smallPValue = nominalPValues[pValueIndices[i - 1]];
    if (bigPValue == smallPValue) {
      ranks[pValueIndices[i - 1]] = ranks[pValueIndices[i]];
    }
  }
  for (var i = 0; i < size; i++) {
    var rank = ranks[i];
    var p = nominalPValues[i];
    fdr[i] = (p * size) / rank;
  }

  // ensure fdr is monotonically decreasing
  var pIndices = morpheus.Util.indexSort(nominalPValues, false);
  for (var i = 0; i < pIndices.length - 1; i++) {
    var highIndex = pIndices[i];
    var lowIndex = pIndices[i + 1];
    fdr[lowIndex] = Math.min(fdr[lowIndex], fdr[highIndex]);
  }
  for (var i = 0; i < size; i++) {
    fdr[i] = Math.min(fdr[i], 1);
  }
  return fdr;
};

morpheus.FDR_BH.tString = function () {
  return 'FDR(BH)';
};

morpheus.MAD = function (list, median) {
  if (median == null) {
    median = morpheus.Percentile(list, 50);
  }
  var temp = [];
  for (var j = 0, size = list.size(); j < size; j++) {
    var value = list.getValue(j);
    if (!isNaN(value)) {
      temp.push(Math.abs(value - median));
    }
  }
  var r = morpheus.Percentile(new morpheus.Vector('', temp.length)
  .setArray(temp), 50);
  return 1.4826 * r;
};
morpheus.MAD.toString = function () {
  return 'Median absolute deviation';
};
morpheus.CV = function (list) {
  var mean = morpheus.Mean(list);
  var stdev = Math.sqrt(morpheus.Variance(list, mean));
  return stdev / mean;
};
morpheus.CV.toString = function () {
  return 'Coefficient of variation';
};

morpheus.BoxPlotItem = function (list) {
  var values = morpheus.RemoveNaN(list);
  values.sort(function (a, b) {
    return (a === b ? 0 : (a < b ? -1 : 1));
  });
  if (values.length === 0) {
    return {
      median: NaN,
      q1: NaN,
      q3: NaN,
      lowerAdjacentValue: NaN,
      upperAdjacentValue: NaN
    };
  }
  return morpheus.BoxPlotArrayItem(values);
};

morpheus.BoxPlotArrayItem = function (values) {
  var median = morpheus.ArrayPercentile(values, 50, true);
  var q1 = morpheus.ArrayPercentile(values, 25, true);
  var q3 = morpheus.ArrayPercentile(values, 75, true);
  var w = 1.5;
  var upperAdjacentValue = -Number.MAX_VALUE;
  var lowerAdjacentValue = Number.MAX_VALUE;
  // The upper adjacent value (UAV) is the largest observation that is
  // less than or equal to
  // the upper inner fence (UIF), which is the third quartile plus
  // 1.5*IQR.
  //
  // The lower adjacent value (LAV) is the smallest observation that is
  // greater than or equal
  // to the lower inner fence (LIF), which is the first quartile minus
  // 1.5*IQR.
  var upperOutlier = q3 + w * (q3 - q1);
  var lowerOutlier = q1 - w * (q3 - q1);
  var sum = 0;
  for (var i = 0, length = values.length; i < length; i++) {
    var value = values[i];
    if (value <= upperOutlier) {
      upperAdjacentValue = Math.max(upperAdjacentValue, value);
    }
    if (value >= lowerOutlier) {
      lowerAdjacentValue = Math.min(lowerAdjacentValue, value);
    }
    sum += value;
    // if (value > upperOutlier) {
    // upperOutliers.add(new Outlier(i, j, value));
    // }
    // if (value < lowerOutlier) {
    // lowerOutliers.add(new Outlier(i, j, value));
    // }
  }
  var mean = sum / values.length;
  if (lowerAdjacentValue > q1) {
    lowerAdjacentValue = q1;
  }
  if (upperAdjacentValue < q3) {
    upperAdjacentValue = q3;
  }

  return {
    mean: mean,
    median: median,
    q1: q1, // Lower Quartile
    q3: q3, // Upper Quartile
    lowerAdjacentValue: lowerAdjacentValue, // Lower Whisker
    upperAdjacentValue: upperAdjacentValue
    // Upper Whisker
  };

};

morpheus.VectorColorModel = function () {
  this.vectorNameToColorMap = new morpheus.Map();
  this.vectorNameToColorScheme = new morpheus.Map();
  this.colors = morpheus.VectorColorModel.TWENTY_COLORS;
};

morpheus.VectorColorModel.YES_COLOR = '#d8b365';
morpheus.VectorColorModel.FEMALE = '#ff99ff';
morpheus.VectorColorModel.MALE = '#66ccff';

// tableau 20-same as d3 category20
morpheus.VectorColorModel.TWENTY_COLORS = [
  '#1f77b4', '#aec7e8', '#ff7f0e',
  '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd',
  '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f',
  '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];
morpheus.VectorColorModel.CATEGORY_20A = morpheus.VectorColorModel.TWENTY_COLORS;
morpheus.VectorColorModel.CATEGORY_20B = [
  '#393b79', '#5254a3', '#6b6ecf',
  '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31',
  '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b',
  '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];
morpheus.VectorColorModel.CATEGORY_20C = [
  '#3182bd', '#6baed6', '#9ecae1',
  '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354',
  '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc',
  '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];

morpheus.VectorColorModel.CATEGORY_ALL = [].concat(
  morpheus.VectorColorModel.CATEGORY_20A,
  morpheus.VectorColorModel.CATEGORY_20B,
  morpheus.VectorColorModel.CATEGORY_20C);

morpheus.VectorColorModel.TABLEAU10 = [
  '#1f77b4', '#ff7f0e', '#2ca02c',
  '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22',
  '#17becf'];
morpheus.VectorColorModel.STANDARD_COLORS = {
  'na': '#c0c0c0',
  'nan': '#c0c0c0',
  '': '#ffffff',
  'wt': '#ffffff',
  'n': '#ffffff',
  '0': '#ffffff',
  'y': morpheus.VectorColorModel.YES_COLOR,
  '1': morpheus.VectorColorModel.YES_COLOR,
  'male': morpheus.VectorColorModel.MALE,
  'm': morpheus.VectorColorModel.MALE,
  'female': morpheus.VectorColorModel.FEMALE,
  'f': morpheus.VectorColorModel.FEMALE,
  'kd': '#C675A8',
  'oe': '#56b4e9',
  'cp': '#FF9933',
  'pcl': '#003B4A',
  'trt_sh.cgs': '#C675A8',
  'trt_oe': '#56b4e9',
  'trt_cp': '#FF9933',
  'a375': '#1490C1',
  'a549': '#AAC8E9',
  'hcc515': '#1C9C2A',
  'hepg2': '#94DC89',
  'ht29': '#946DBE',
  'mcf7': '#C5B2D5',
  'pc3': '#38C697',
  'asc': '#FF8000',
  'cd34': '#FFBB75',
  'ha1e': '#FB4124',
  'neu': '#FF9A94',
  'npc': '#E57AC6',
  'cancer': '#1490C1',
  'immortalized normal': '#FF8000'
};
morpheus.VectorColorModel.getStandardColor = function (value) {
  if (value == null) {
    return '#ffffff';
  }
  var stringValue = value.toString().toLowerCase();
  return morpheus.VectorColorModel.STANDARD_COLORS[stringValue];

};
morpheus.VectorColorModel.getColorMapForNumber = function (length) {
  var colors;
  if (length < 3) {
    colors = colorbrewer.Set1[3];
  } else {
    colors = colorbrewer.Paired[length];
  }
  return colors ? colors : morpheus.VectorColorModel.TWENTY_COLORS;
};
morpheus.VectorColorModel.prototype = {
  toJSON: function (tracks) {
    var _this = this;
    var json = {};
    tracks.forEach(function (track) {
      if (track.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE)) {
        var colorMap = _this.vectorNameToColorMap.get(track.getName());
        if (colorMap != null) {
          json[track.getName()] = colorMap;
        }
      } else {
        // colorScheme is instanceof morpheus.HeatMapColorScheme
        var colorScheme = _this.vectorNameToColorScheme.get(track.getName());
        if (colorScheme != null) {
          var colorSchemeJSON = morpheus.AbstractColorSupplier.toJSON(colorScheme.getCurrentColorSupplier());
          json[track.getName()] = colorSchemeJSON;
        }
      }
    });
    return json;
  },
  fromJSON: function (json) {
    for (var name in json) {
      var obj = json[name];
      if (obj.colors) {
        obj.scalingMode = 'fixed';
        this.vectorNameToColorScheme.set(name, morpheus.AbstractColorSupplier.fromJSON(obj));
      } else {
        this.vectorNameToColorMap.set(name, morpheus.Map.fromJSON(obj));
      }
    }
  },
  clear: function (vector) {
    this.vectorNameToColorMap.remove(vector.getName());
    this.vectorNameToColorScheme.remove(vector.getName());
  },
  copy: function () {
    var c = new morpheus.VectorColorModel();
    c.colors = this.colors.slice(0);
    this.vectorNameToColorMap.forEach(function (colorMap, name) {
      var newColorMap = new morpheus.Map();
      newColorMap.setAll(colorMap); // copy existing values
      c.vectorNameToColorMap.set(name, newColorMap);
    });
    this.vectorNameToColorScheme.forEach(function (colorScheme, name) {
      c.vectorNameToColorScheme.set(name, colorScheme
        .copy(new morpheus.Project(new morpheus.Dataset({
          name: '',
          rows: 1,
          columns: 1
        }))));
    });
    return c;
  },
  clearAll: function () {
    this.vectorNameToColorMap = new morpheus.Map();
    this.vectorNameToColorScheme = new morpheus.Map();
  },
  containsDiscreteColor: function (vector, value) {
    var metadataValueToColorMap = this.vectorNameToColorMap.get(vector
      .getName());
    if (metadataValueToColorMap === undefined) {
      return false;
    }
    var c = metadataValueToColorMap.get(value);
    return c != null;
  },
  setDiscreteColorMap: function (colors) {
    this.colors = colors;
  },
  getContinuousColorScheme: function (vector) {
    return this.vectorNameToColorScheme.get(vector.getName());
  },
  isContinuous: function (vector) {
    return this.vectorNameToColorScheme.has(vector.getName());
  },
  getDiscreteColorScheme: function (vector) {
    return this.vectorNameToColorMap.get(vector.getName());
  },
  createContinuousColorMap: function (vector) {
    var minMax = morpheus.VectorUtil.getMinMax(vector);
    var min = minMax.min;
    var max = minMax.max;
    var cs = new morpheus.HeatMapColorScheme(new morpheus.Project(
      new morpheus.Dataset({
        name: '',
        rows: 1,
        columns: 1
      })), {
      type: 'fixed',
      map: [
        {
          value: min,
          color: colorbrewer.Greens[3][0]
        }, {
          value: max,
          color: colorbrewer.Greens[3][2]
        }]
    });
    this.vectorNameToColorScheme.set(vector.getName(), cs);
    return cs;

  },
  _getColorForValue: function (value) {
    var color = morpheus.VectorColorModel.getStandardColor(value);
    if (color == null) { // try to reuse existing color map
      var existingMetadataValueToColorMap = this.vectorNameToColorMap
        .values();
      for (var i = 0, length = existingMetadataValueToColorMap.length; i < length; i++) {
        color = existingMetadataValueToColorMap[i].get(value);
        if (color !== undefined) {
          return color;
        }
      }
    }
    return color;
  },
  getContinuousMappedValue: function (vector, value) {
    var cs = this.vectorNameToColorScheme.get(vector.getName());
    if (cs === undefined) {
      cs = this.createContinuousColorMap(vector);
    }
    return cs.getColor(0, 0, value);
  },
  getMappedValue: function (vector, value) {
    var metadataValueToColorMap = this.vectorNameToColorMap.get(vector
      .getName());
    if (metadataValueToColorMap === undefined) {
      metadataValueToColorMap = new morpheus.Map();
      this.vectorNameToColorMap.set(vector.getName(),
        metadataValueToColorMap);
      // set all possible colors
      var values = morpheus.VectorUtil.getValues(vector);
      var ncolors = 0;
      var colors = null;
      if (values.length < 3) {
        colors = colorbrewer.Dark2[3];
      } else {
        colors = colorbrewer.Paired[values.length];
      }

      if (!colors) {
        if (values.length <= 20) {
          colors = d3.scale.category20().range();
        } else {
          colors = morpheus.VectorColorModel.CATEGORY_ALL;
        }
      }

      if (colors) {
        var ncolors = colors.length;
        for (var i = 0, nvalues = values.length; i < nvalues; i++) {
          var color = this._getColorForValue(values[i]);
          if (color == null) {
            color = colors[i % ncolors];
          }
          metadataValueToColorMap.set(values[i], color);
        }
      } else {
        var _this = this;
        _.each(values, function (val) {
          _this.getMappedValue(vector, val);
        });
      }
    }
    var color = metadataValueToColorMap.get(value);
    if (color == null) {
      color = this._getColorForValue(value);
      if (color == null) {
        var index = metadataValueToColorMap.size();
        color = this.colors[index % this.colors.length];
      }
      metadataValueToColorMap.set(value, color);
    }
    return color;
  },
  setMappedValue: function (vector, value, color) {
    var metadataValueToColorMap = this.vectorNameToColorMap.get(vector
      .getName());
    if (metadataValueToColorMap === undefined) {
      metadataValueToColorMap = new morpheus.Map();
      this.vectorNameToColorMap.set(vector.getName(),
        metadataValueToColorMap);
    }
    metadataValueToColorMap.set(value, color);
  }
};

morpheus.VectorFontModel = function () {
  this.vectorNameToMappedValue = new morpheus.Map();
  this.fonts = morpheus.VectorFontModel.FONTS;

};

morpheus.VectorFontModel.FONTS = [{weight: 400}, {weight: 700}, {weight: 900}];
// 400 (normal), 700 (bold), 900 (bolder)

morpheus.VectorFontModel.prototype = {
  toJSON: function (tracks) {
    var _this = this;
    var json = {};
    tracks.forEach(function (track) {
      if (track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) && track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT)) {
        var map = _this.vectorNameToMappedValue.get(track.getName());
        if (map != null) {
          json[track.getName()] = map;
        }
      }
    });
    return json;
  },
  fromJSON: function (json) {
    for (var name in json) {
      var obj = json[name];
      this.vectorNameToMappedValue.set(name, morpheus.Map.fromJSON(obj));
    }
  },
  clear: function (vector) {
    this.vectorNameToMappedValue.remove(vector.getName());
  },
  copy: function () {
    var c = new morpheus.VectorFontModel();
    c.fonts = this.fonts.slice(0);
    this.vectorNameToMappedValue.forEach(function (fontMap, name) {
      var newFontMap = new morpheus.Map();
      newFontMap.setAll(fontMap); // copy existing values
      c.vectorNameToMappedValue.set(name, newFontMap);
    });
    return c;
  },
  clearAll: function () {
    this.vectorNameToMappedValue = new morpheus.Map();
  },
  _getFontForValue: function (value) {
    if (value == null) {
      return morpheus.VectorFontModel.FONTS[0];
    }
    // try to reuse existing map
    var existingMetadataValueToFontMap = this.vectorNameToMappedValue
      .values();
    for (var i = 0, length = existingMetadataValueToFontMap.length; i < length; i++) {
      var font = existingMetadataValueToFontMap[i].get(value);
      if (font !== undefined) {
        return font;
      }
    }
  },
  getMap: function (name) {
    return this.vectorNameToMappedValue.get(name);
  },
  getMappedValue: function (vector, value) {
    var metadataValueToFontMap = this.vectorNameToMappedValue.get(vector
      .getName());
    if (metadataValueToFontMap === undefined) {
      metadataValueToFontMap = new morpheus.Map();
      this.vectorNameToMappedValue.set(vector.getName(),
        metadataValueToFontMap);
      // set all possible values
      var values = morpheus.VectorUtil.getValues(vector);
      for (var i = 0, nvalues = values.length; i < nvalues; i++) {
        var font = this._getFontForValue(values[i]);
        if (font == null) {
          font = this.fonts[0]; // default is normal
        }
        metadataValueToFontMap.set(values[i], font);
      }
    }
    var font = metadataValueToFontMap.get(value);
    if (font == null) {
      font = this._getFontForValue(value);
      if (font == null) {
        font = this.fonts[0]; // default is normal
      }
      metadataValueToFontMap.set(value, font);
    }
    return font;
  },
  setMappedValue: function (vector, value, font) {
    var metadataValueToFontMap = this.vectorNameToMappedValue.get(vector
      .getName());
    if (metadataValueToFontMap === undefined) {
      metadataValueToFontMap = new morpheus.Map();
      this.vectorNameToMappedValue.set(vector.getName(),
        metadataValueToFontMap);
    }
    metadataValueToFontMap.set(value, font);
  }
};

/**
 * An interface for an ordered collection of values.
 *
 * @interface morpheus.VectorInterface
 */

/**
 * Returns the value at the specified index.
 *
 * @function
 * @name morpheus.VectorInterface#getValue
 * @param index the index
 * @return the value
 */

/**
 * Gets the key-value pairs associated with this vector.
 *
 * @function
 * @name morpheus.VectorInterface#getProperties
 * @return {morpheus.Map}
 */

/**
 * Returns the number of elements in this vector.
 *
 * @function
 * @name morpheus.VectorInterface#size
 * @return {number} the size.
 */

/**
 * Returns the name of this vector.
 *
 * @function
 * @name morpheus.VectorInterface#getName
 * @return {string} the name
 */




morpheus.VectorKeys = {};
/** [string] of field names in array */
morpheus.VectorKeys.FIELDS = 'morpheus.fields';
morpheus.VectorKeys.VALUE_TO_INDICES = 'morpheus.valueToIndices';
/** [int] of visible field indices in morpheus.VectorKeys.FIELDS */
morpheus.VectorKeys.VISIBLE_FIELDS = 'morpheus.visibleFields';
morpheus.VectorKeys.DATA_TYPE = 'morpheus.dataType';
/** Function to map an array to a single value for sorting */
morpheus.VectorKeys.ARRAY_SUMMARY_FUNCTION = 'morpheus.arraySummaryFunct';
/** Key for object (e.g. box plot) that summarizes data values */
morpheus.VectorKeys.HEADER_SUMMARY = 'morpheus.headerSummary';
/** Key indicating to show header summary */
morpheus.VectorKeys.SHOW_HEADER_SUMMARY = 'morpheus.showHeaderSummary';

morpheus.VectorKeys.TITLE = 'morpheus.title';
/** Function to compute vector value */
morpheus.VectorKeys.FUNCTION = 'morpheus.funct';

/** Indicates that vector values are dynamically computed based on selection */
morpheus.VectorKeys.SELECTION = 'morpheus.selection';

/** Whether to recompute a function when creating a new heat map (true or false) */
morpheus.VectorKeys.RECOMPUTE_FUNCTION_NEW_HEAT_MAP = 'morpheus.recompute.funct.new.heat.map';

/** Boolean, whether to recompute a function when heat map selection changes */
morpheus.VectorKeys.RECOMPUTE_FUNCTION_SELECTION = 'morpheus.recompute.funct.selection';

/**Number format spec/function */
morpheus.VectorKeys.FORMATTER = 'morpheus.formatter';

/* Indicates that a "fake" vector to show row/column number */
morpheus.VectorKeys.IS_INDEX = 'morpheus.isIndex';

/** Whether vector values should be treated discretely or continuously */
morpheus.VectorKeys.DISCRETE = 'morpheus.discrete';

morpheus.VectorKeys.COPY_IGNORE = new morpheus.Set();
morpheus.VectorKeys.COPY_IGNORE.add(morpheus.VectorKeys.HEADER_SUMMARY);
morpheus.VectorKeys.COPY_IGNORE.add(morpheus.VectorKeys.DATA_TYPE);
morpheus.VectorKeys.COPY_IGNORE.add(morpheus.VectorKeys.VALUE_TO_INDICES);

morpheus.VectorKeys.JSON_WHITELIST = new morpheus.Set();
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.FIELDS);
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.FORMATTER);
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.DATA_TYPE);
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.TITLE);

morpheus.VectorShapeModel = function () {
  this.shapes = morpheus.VectorShapeModel.SHAPES;
  this.vectorNameToMappedValue = new morpheus.Map();
};

morpheus.VectorShapeModel.SHAPES = [
  'circle', 'square', 'plus', 'x',
  'asterisk', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left',
  'triangle-right', 'circle-minus'];

morpheus.VectorShapeModel.FILLED_SHAPES = [
  'circle', 'square', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left',
  'triangle-right'];

morpheus.VectorShapeModel.prototype = {
  toJSON: function (tracks) {
    var _this = this;
    var json = {};
    tracks.forEach(function (track) {
      if (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
        var map = _this.vectorNameToMappedValue.get(track.getName());
        if (map != null) {
          json[track.getName()] = map;
        }
      }
    });
    return json;
  },
  fromJSON: function (json) {
    for (var name in json) {
      var obj = json[name];
      this.vectorNameToMappedValue.set(name, morpheus.Map.fromJSON(obj));
    }
  },
  clear: function (vector) {
    this.vectorNameToMappedValue.remove(vector.getName());
  },
  copy: function () {
    var c = new morpheus.VectorShapeModel();
    c.shapes = this.shapes.slice(0);
    this.vectorNameToMappedValue.forEach(function (shapeMap, name) {
      var newShapeMap = new morpheus.Map();
      newShapeMap.setAll(shapeMap); // copy existing values
      c.vectorNameToMappedValue.set(name, newShapeMap);
    });

    return c;
  },
  clearAll: function () {
    this.vectorNameToMappedValue = new morpheus.Map();
  },
  _getShapeForValue: function (value) {
    if (value == null) {
      return 'none';
    }

    // try to reuse existing map
    var existingMetadataValueToShapeMap = this.vectorNameToMappedValue
      .values();
    for (var i = 0, length = existingMetadataValueToShapeMap.length; i < length; i++) {
      var shape = existingMetadataValueToShapeMap[i].get(value);
      if (shape !== undefined) {
        return shape;
      }
    }

  },
  getMap: function (name) {
    return this.vectorNameToMappedValue.get(name);
  },
  getMappedValue: function (vector, value) {
    var metadataValueToShapeMap = this.vectorNameToMappedValue.get(vector
      .getName());
    if (metadataValueToShapeMap === undefined) {
      metadataValueToShapeMap = new morpheus.Map();
      this.vectorNameToMappedValue.set(vector.getName(),
        metadataValueToShapeMap);
      // set all possible shapes
      var values = morpheus.VectorUtil.getValues(vector);
      for (var i = 0, nvalues = values.length; i < nvalues; i++) {
        var shape = this._getShapeForValue(values[i]);
        if (shape == null) {
          shape = this.shapes[i % this.shapes.length];
        }
        metadataValueToShapeMap.set(values[i], shape);
      }
    }
    var shape = metadataValueToShapeMap.get(value);
    if (shape == null) {
      shape = this._getShapeForValue(value);
      if (shape == null) {
        var index = metadataValueToShapeMap.size();
        shape = this.shapes[index % this.shapes.length];
      }
      metadataValueToShapeMap.set(value, shape);
    }
    return shape;
  },
  setMappedValue: function (vector, value, shape) {
    var metadataValueToShapeMap = this.vectorNameToMappedValue.get(vector
      .getName());
    if (metadataValueToShapeMap === undefined) {
      metadataValueToShapeMap = new morpheus.Map();
      this.vectorNameToMappedValue.set(vector.getName(),
        metadataValueToShapeMap);
    }
    metadataValueToShapeMap.set(value, shape);
  }
};

morpheus.VectorUtil = function () {
};

morpheus.VectorUtil.jsonToFunction = function (vector, key) {
  var f = vector.getProperties().get(key);
  if (typeof f === 'object') {
    // TODO encode other functions
    var binSize = f.binSize;
    var min = f.domain[0];
    var max = f.domain[1];
    var numberOfBins = Math.ceil((max - min) / binSize);
    var percent = f.percent;
    var cumulative = f.cumulative;
    var histogramFunction = function (view, selectedDataset, columnIndex) {
      var total = 0;
      var binNumberToOccurences = new Uint32Array(numberOfBins);
      for (var i = 0, nrows = selectedDataset.getRowCount(); i < nrows; i++) {
        var value = selectedDataset.getValue(i, columnIndex);
        if (!isNaN(value)) {
          if (value >= min && value <= max) {
            var bin = Math.floor(((value - min) / binSize));
            if (bin < 0) {
              bin = 0;
            } else if (bin >= numberOfBins) {
              bin = numberOfBins - 1;
            }
            binNumberToOccurences[bin]++;
          }
          total++;
        }
      }
      if (cumulative) {
        for (var i = numberOfBins - 2; i >= 0; i--) {
          binNumberToOccurences[i] += binNumberToOccurences[i + 1];
        }
      }
      if (percent) {
        var percents = new Float32Array(numberOfBins);
        for (var i = 0; i < numberOfBins; i++) {
          percents[i] = 100 * (binNumberToOccurences[i] / total);
        }
        return percents;
      }
      return binNumberToOccurences;
    };
    vector.getProperties().set(key, histogramFunction);
    var jsonSpec = f;
    f = histogramFunction;
    f.toJSON = function () {
      return jsonSpec;
    };
  }
  return f;
};
morpheus.VectorUtil.createValueToIndexMap = function (vector, splitArrayValues) {
  var map = new morpheus.Map();
  var isArray = splitArrayValues && morpheus.VectorUtil.getDataType(vector)[0] === '[';
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (isArray) {
      if (val != null) {
        for (var k = 0; k < val.length; k++) {
          map.set(val[k], j);
        }
      }
    } else {
      map.set(val, j);
    }
  }
  return map;
};

morpheus.VectorUtil.createValueToIndicesMap = function (vector, splitArrayValues) {
  if (!vector) {
    throw 'vector is null';
  }
  var isArray = splitArrayValues && morpheus.VectorUtil.getDataType(vector)[0] === '[';
  var map = new morpheus.Map();
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (isArray) {
      if (val != null) {
        for (var k = 0; k < val.length; k++) {
          var list = map.get(val[k]);
          if (list === undefined) {
            list = [];
            map.set(val[k], list);
          }
          list.push(j);
        }
      }
    } else {
      var list = map.get(val);
      if (list === undefined) {
        list = [];
        map.set(val, list);
      }
      list.push(j);
    }
  }
  return map;
};

morpheus.VectorUtil.createValueToCountMap = function (vector) {
  if (!vector) {
    throw 'vector is null';
  }
  var map = new morpheus.Map();
  var dataType = morpheus.VectorUtil.getDataType(vector);
  var isArray = dataType[0] === '[';
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (val != null) {
      if (isArray) {
        for (var k = 0; k < val.length; k++) {
          var count = map.get(val[k]) || 0;
          map.set(val[k], count + 1);
        }
      } else {
        var count = map.get(val) || 0;
        map.set(val, count + 1);
      }
    }
  }
  return map;
};

morpheus.VectorUtil.createValuesToIndicesMap = function (vectors) {
  var map = new morpheus.Map();
  var nvectors = vectors.length;
  if (vectors[0] == null) {
    throw 'no vectors found';
  }
  for (var i = 0, nitems = vectors[0].size(); i < nitems; i++) {
    var array = [];
    for (var j = 0; j < nvectors; j++) {
      var vector = vectors[j];
      var val = vector.getValue(i);
      array.push(val);
    }
    var key = new morpheus.Identifier(array);
    var list = map.get(key);
    if (list === undefined) {
      list = [];
      map.set(key, list);
    }
    list.push(i);
  }
  return map;
};
morpheus.VectorUtil.createValuesToIndexMap = function (vectors) {
  var map = new morpheus.Map();
  var nvectors = vectors.length;
  if (vectors[0] == null) {
    throw 'no vectors found';
  }
  for (var i = 0, nitems = vectors[0].size(); i < nitems; i++) {
    var array = [];
    for (var j = 0; j < nvectors; j++) {
      var vector = vectors[j];
      var val = vector.getValue(i);
      array.push(val);
    }
    var key = new morpheus.Identifier(array);
    map.set(key, i);
  }
  return map;
};

morpheus.VectorUtil.createValuesToCountMap = function (vectors) {
  var map = new morpheus.Map();
  var nvectors = vectors.length;
  if (vectors[0] == null) {
    throw 'no vectors found';
  }
  for (var i = 0, nitems = vectors[0].size(); i < nitems; i++) {
    var array = [];
    for (var j = 0; j < nvectors; j++) {
      var vector = vectors[j];
      var val = vector.getValue(i);
      array.push(val);
    }
    var key = new morpheus.Identifier(array);
    var count = map.get(key) || 0;
    map.set(key, count + 1);
  }
  return map;
};

/**
 *
 * @param vector
 * @param excludeNull
 * @returns A sorted array of unique values contained in the vector. Note that array values are
 * not split.
 */
morpheus.VectorUtil.getValues = function (vector, excludeNull) {
  var set = new morpheus.Set();
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (excludeNull && val == null) {
      continue;
    }
    set.add(val);
  }
  var array = set.values();
  array.sort(morpheus.SortKey.ASCENDING_COMPARATOR);
  return array;
};

morpheus.VectorUtil.getSet = function (vector, splitArrayValues) {
  var set = new morpheus.Set();
  var isArray = splitArrayValues && morpheus.VectorUtil.getDataType(vector)[0] === '[';
  for (var j = 0, size = vector.size(); j < size; j++) {
    var value = vector.getValue(j);
    if (isArray) {
      if (value != null) {
        for (var k = 0, nvalues = value.length; k < nvalues; k++) {
          set.add(value[k]);
        }
      }
    } else {
      set.add(value);
    }

  }
  return set;
};
morpheus.VectorUtil.maybeConvertToStringArray = function (vector, delim) {
  var newValues = [];
  var regex = new RegExp(delim);
  var found = false;

  for (var i = 0, nrows = vector.size(); i < nrows; i++) {
    var s = vector.getValue(i);
    if (s != null) {
      if (!s.split) {
        return false;
      }
      var tokens = s.split(regex);
      newValues.push(tokens);
      if (!found && tokens.length > 1) {
        found = true;
      }
    }

  }
  if (found) {
    for (var i = 0, nrows = newValues.length; i < nrows; i++) {
      vector.setValue(i, newValues[i]);
    }
    vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, '[string]');
  }

  return found;
};

morpheus.VectorUtil.maybeConvertStringToNumber = function (vector) {
  var newValues = [];
  var found = false;
  for (var i = 0, nrows = vector.size(); i < nrows; i++) {
    var s = vector.getValue(i);
    if (s != null && s !== '' && s !== 'NA' && s !== 'NaN') {
      if (!$.isNumeric(s)) {
        return false;
      } else {
        found = true;
      }
    }
    newValues.push(parseFloat(s));
  }
  if (!found) {
    return false;
  }
  for (var i = 0, nrows = newValues.length; i < nrows; i++) {
    vector.setValue(i, newValues[i]);
  }
  vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, 'number');
  return true;
};
morpheus.VectorUtil.containsMoreThanOneValue = function (vector) {
  return morpheus.VectorUtil.containsMoreThanNValues(vector, 1);
};
morpheus.VectorUtil.containsMoreThanNValues = function (vector, n) {
  var s = new morpheus.Set();
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    s.add(val);
    if (s.size() > n) {
      return true;
    }
  }
  return false;
};

morpheus.VectorUtil.createSpanMap = function (vector) {
  var previous = vector.getValue(0);
  // find 1st row with different value
  var startIndexToEndIndex = new morpheus.Map();
  var start = 0;
  for (var i = 1, nrows = vector.size(); i < nrows; i++) {
    var val = vector.getValue(i);
    if (previous !== val) {
      previous = val;
      // start inclusive, end exclusive
      startIndexToEndIndex.set(start, i);
      start = i;
    }
  }
  startIndexToEndIndex.set(start, vector.size());
  return startIndexToEndIndex;
};
morpheus.VectorUtil.toArray = function (vector) {
  var array = [];
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    array.push(val);
  }
  return array;
};

morpheus.VectorUtil.arrayAsVector = function (array, name) {
  var v = new morpheus.Vector(name, array.length);
  v.array = array;
  return v;
};
morpheus.VectorUtil.toString = function (vector) {
  var array = [];
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    array.push(val);
  }
  return array.join(', ');
};

morpheus.VectorUtil.getDataType = function (vector) {
  var dataType = vector.getProperties().get(morpheus.VectorKeys.DATA_TYPE);
  if (dataType === undefined) {
    var firstNonNull = morpheus.VectorUtil.getFirstNonNull(vector);
    dataType = morpheus.Util.getDataType(firstNonNull);
    vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, dataType);
  }
  return dataType;

};

morpheus.VectorUtil.getMinMax = function (vector) {
  var min = Number.MAX_VALUE;
  var max = -Number.MAX_VALUE;
  var fields = vector.getProperties().get(morpheus.VectorKeys.FIELDS);
  var isArray = morpheus.VectorUtil.getDataType(vector)[0] === '[';
  if (fields != null) {
    var nvalues = fields.length;
    for (var i = 0, size = vector.size(); i < size; i++) {
      var array = vector.getValue(i);
      if (array) {
        for (var j = 0; j < nvalues; j++) {
          var value = array[j];
          if (!isNaN(value)) {
            min = value < min ? value : min;
            max = value > max ? value : max;
          }
        }
      }
    }
  } else if (isArray) {
    for (var i = 0, size = vector.size(); i < size; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        for (var j = 0, nvalues = array.length; j < nvalues; j++) {
          var value = array[j];
          if (!isNaN(value)) {
            min = value < min ? value : min;
            max = value > max ? value : max;
          }
        }
      }
    }
  } else {
    for (var i = 0, size = vector.size(); i < size; i++) {
      var value = vector.getValue(i);
      if (!isNaN(value)) {
        min = value < min ? value : min;
        max = value > max ? value : max;
      }
    }
  }
  return {
    min: min,
    max: max
  };
}
;
morpheus.VectorUtil.getFirstNonNull = function (vector) {
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (val != null) {
      return val;
    }
  }
  return null;
};
morpheus.VectorUtil.isNumber = function (vector) {
  return morpheus.VectorUtil.getDataType(vector) === 'number';
};

/**
 * An ordered collection of values.
 *
 * Creates a new vector with the given name and size.
 *
 * @param name
 *            the vector name
 * @param size
 *            the number of elements in this vector
 * @constructor
 */
morpheus.Vector = function (name, size) {
  this.array = [];
  morpheus.AbstractVector.call(this, name, size);
};
/**
 * @static
 */
morpheus.Vector.fromArray = function (name, array) {
  var v = new morpheus.Vector(name, array.length);
  v.array = array;
  return v;
};
morpheus.Vector.prototype = {
  /**
   * @ignore
   * @param value
   */
  push: function (value) {
    this.array.push(value);
  },
  /**
   * Sets the value at the specified index.
   *
   * @param index
   *            the index
   * @param value
   *            the value
   */
  setValue: function (index, value) {
    this.array[index] = value;
  },
  getValue: function (index) {
    return this.array[index];
  },
  /**
   * @ignore
   * @param name
   */
  setName: function (name) {
    this.name = name;
  },
  /**
   * @ignore
   * @param array
   * @returns {morpheus.Vector}
   */
  setArray: function (array) {
    this.array = array;
    return this;
  }
};
morpheus.Util.extend(morpheus.Vector, morpheus.AbstractVector);

/**
 *
 * @param pageOptions.el
 * @param pageOptions.tabManager
 * @constructor
 */
morpheus.LandingPage = function (pageOptions) {
  pageOptions = $.extend({}, {
    el: $('#vis')
  }, pageOptions);
  this.pageOptions = pageOptions;
  var _this = this;

  var html = [];
  html.push('<div style="display:none;" class="container-fluid">');
  html.push('<div style="min-height:78vh" class="row">');
  html.push('<div class="col-xs-12 col-md-offset-1 col-md-7"><div' +
    ' data-name="input"></div>');
  html.push('<div class="clearfix"></div>');
  html.push('</div>'); // col
  html.push('<div data-name="desc" class="col-xs-12 col-md-3"><p><img' +
    ' src="https://software.broadinstitute.org/morpheus/css/images/morpheus_landing_img.png" style="width:100%;"></p></div>');
  html.push('</div>'); // row

  html.push('<div class="row"><div class="col-xs-12 morpheus-footer"></div></div>');
  html.push('</div>'); // container

  var $el = $(html.join(''));
  new morpheus.HelpMenu().$el.appendTo($el.find('.morpheus-footer'));
  this.$el = $el;
  var $description = $el.find('[data-name=desc]');
  morpheus.Util.createMorpheusHeader().appendTo($description);
  $('<p>Versatile matrix visualization and analysis software</p><p>View your dataset as a heat' +
    ' map,' +
    ' then explore' +
    ' the' +
    ' interactive tools in Morpheus. Cluster, create new annotations, search, filter, sort, display charts, and more.</p><p style="color:#586069;">30,000+ users <br />100,000+' +
    ' matrices analyzed</p>')
    .appendTo($description);

  var $input = $el.find('[data-name=input]');

  $('<svg width="32px" height="32px"><g><rect x="0" y="0" width="32" height="14" style="fill:#ca0020;stroke:none"/><rect x="0" y="18" width="32" height="14" style="fill:#0571b0;stroke:none"/></g></svg><h2 style="padding-left: 4px; display:inline-block;">Open</h2>')
    .appendTo($input);
  $('<div style="margin-bottom:20px;"><small>All' +
    ' data is' +
    ' processed in the' +
    ' browser and never sent to any server.</small></div>').appendTo($input);

  var filePicker = new morpheus.FilePicker({
    fileCallback: function (file) {
      _this.openFile(file);
    },
    optionsCallback: function (opt) {
      _this.open(opt);
    }
  });
  filePicker.$el.appendTo($input);

  if (pageOptions.tabManager) {
    this.tabManager = pageOptions.tabManager;
  } else {
    this.tabManager = new morpheus.TabManager({landingPage: this});
    this.tabManager.on('change rename add remove', function (e) {
      var title = _this.tabManager.getTabText(_this.tabManager.getActiveTabId());
      if (title == null || title === '') {
        title = 'Morpheus';
      }
      document.title = title;
    });

    this.tabManager.$nav.appendTo($(this.pageOptions.el));
    this.tabManager.$tabContent.appendTo($(this.pageOptions.el));
  }

}
;

morpheus.LandingPage.prototype = {
  open: function (openOptions) {
    this.dispose();
    var optionsArray = _.isArray(openOptions) ? openOptions : [openOptions];
    var _this = this;
    for (var i = 0; i < optionsArray.length; i++) {
      var options = optionsArray[i];
      options.tabManager = _this.tabManager;
      options.focus = i === 0;
      options.standalone = true;
      options.landingPage = _this;
      new morpheus.HeatMap(options);
    }

  },
  dispose: function () {
    this.$el.hide();
  },
  show: function () {
    var _this = this;
    this.$el.show();
    $(window).on('beforeunload.morpheus', function () {
      if (_this.tabManager.getTabCount() > 0) {
        return 'Are you sure you want to close Morpheus?';
      }
    });
  },
  openFile: function (value) {
    var _this = this;
    var fileName = morpheus.Util.getFileName(value);
    if (fileName.toLowerCase().indexOf('.json') === fileName.length - 5) {
      morpheus.Util.getText(value).done(function (text) {
        _this.open(JSON.parse(text));
      }).fail(function (err) {
        morpheus.FormBuilder.showMessageModal({
          title: 'Error',
          message: 'Unable to load session'
        });
      });
    } else {
      var options = {
        dataset: {
          file: value,
          options: {interactive: true}
        }
      };

      morpheus.OpenDatasetTool.fileExtensionPrompt(fileName, function (readOptions) {
        if (readOptions) {
          for (var key in readOptions) {
            options.dataset.options[key] = readOptions[key];
          }
        }
        _this.open(options);
      });
    }
  }
};

morpheus.SampleDatasets = function (options) {
  var _this = this;
  var $el = options.$el;
  this.callback = options.callback;
  $el.on('click', '[name=ccle]', function (e) { // button click
    var $this = $(this);
    var obj = {};
    $this.parents('.collapse').find('input:checked').each(function (i, c) {
      obj[$(c).data('type')] = true;
    });

    _this.openCCLE(obj);
    e.preventDefault();
  });

  $el.on('click', '[name=tcgaLink]', function (e) {
    e.preventDefault();
    var $this = $(this);
    var type = $this.data('disease-type');
    var obj = {};
    $this.parents('.collapse').find('input:checked').each(function (i, c) {
      obj[$(c).data('type')] = true;
    });
    var disease;
    for (var i = 0; i < _this.diseases.length; i++) {
      if (_this.diseases[i].type === type) {
        disease = _this.diseases[i];
        break;
      }
    }
    obj.type = type;
    obj.name = disease.name;
    _this.openTcga(obj);
  });

  $el.on(
    'click',
    '[data-toggle=dataTypeToggle]',
    function (e) {
      var $this = $(this);
      var $button = $this.parents('.collapse').find('button');
      var isDisabled = $this.parents('.collapse').find(
        'input:checked').length === 0;
      $button.prop('disabled', isDisabled);
    });

  fetch('https://software.broadinstitute.org/morpheus/preloaded-datasets/tcga/tcga_index.txt').then(function (response) {
    if (response.ok) {
      return response.text();
    }
  }).then(function (text) {
    var exampleHtml = [];
    var id = _.uniqueId('morpheus');

    exampleHtml.push('<a data-toggle="collapse" href="#' + id + '" aria-expanded="false" aria-controls="' + id +
      '">Cancer Cell Line Encyclopedia (CCLE), Project Achilles</a>');
    exampleHtml.push('<div class="collapse" id="' + id + '">');
    exampleHtml.push('<div style="margin: 6px 0 0 20px;display: inline-block;vertical-align:' +
      ' top;">');
    exampleHtml.push('<label><input type="checkbox" style="margin-left:4px;"' +
      ' data-toggle="dataTypeToggle"' +
      ' data-type="mrna">GENE EXPRESSION</label>');
    exampleHtml.push('<label><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle"' +
      ' data-type="cn">COPY NUMBER BY GENE</label>');
    exampleHtml.push('</div>');

    exampleHtml.push('<div style="margin: 6px 0 0 20px;display: inline-block;vertical-align: top;">');
    exampleHtml.push('<label><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle"' +
      ' data-type="sig_genes">MUTATIONS</label>');
    exampleHtml.push('<label><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle"' +
      ' data-type="ach">GENE ESSENTIALITY</label>');
    exampleHtml.push('</div>');
    exampleHtml.push('<div style="margin: 6px 0 0 20px;display: inline-block;vertical-align: top;">');
    exampleHtml.push('<button disabled type="button" class="btn btn-default" name="ccle">Open</button>');
    exampleHtml.push('</div>');
    exampleHtml.push('</div>');

    exampleHtml.push('<hr>');
    exampleHtml.push(
      '<div>TCGA data <a target="_blank" href="https://confluence.broadinstitute.org/display/GDAC/Dashboard-Stddata">(Broad GDAC 1/28/2016)</a></div><span>Please adhere to the' +
      ' <a target="_blank"' +
      ' href="http://cancergenome.nih.gov/abouttcga/policies/publicationguidelines">TCGA' +
      ' publication guidelines</a></u> when using TCGA data in your publications.</span>');
    exampleHtml.push('<br />');
    // Gene Expression	GISTIC Copy Number	Copy Number By Gene	Mutations	Proteomics	Methylation
    exampleHtml.push('<div data-name="tcga"></div>');
    $(exampleHtml.join('')).appendTo($el);
    if (options.show) {
      $el.css('display', '');
    }
    var lines = text.split('\n');
    var diseases = [];
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (line === '') {
        continue;
      }
      var tokens = line.split('\t');
      var type = tokens[0];
      var dataTypes = tokens[1].split(',');
      var name = morpheus.TcgaUtil.DISEASE_STUDIES[type];
      var disease = {
        mrna: dataTypes.indexOf('mRNAseq_RSEM_normalized_log2.txt') !== -1,
        sig_genes: dataTypes.indexOf('sig_genes.txt') !== -1,
        gistic: dataTypes.indexOf('all_lesions.conf_99.txt') !== -1,
        sample_info: dataTypes.indexOf('All_CDEs.txt') !== -1,
        mutation: dataTypes.indexOf('mutations_merged.maf.txt') !== -1,
        rppa: dataTypes.indexOf('rppa.txt') !== -1,
        methylation: dataTypes.indexOf('meth.by_mean.data.txt') !== -1,
        name: name,
        type: type,
        dataTypes: dataTypes
      };
      if (disease.mrna || disease.gistic
        || disease.sig_genes || disease.rppa
        || disease.methylation) {
        diseases.push(disease);
      }
    }
    diseases.sort(function (a, b) {
      a = a.name.toLowerCase();
      b = b.name.toLowerCase();
      return (a === b ? 0 : (a < b ? -1 : 1));

    });
    var tcga = [];
    _this.diseases = diseases;
    for (var i = 0; i < diseases.length; i++) {
      var id = _.uniqueId('morpheus');
      var disease = diseases[i];
      tcga.push('<div>');
      tcga.push('<a data-toggle="collapse" href="#' + id + '" aria-expanded="false"' +
        ' aria-controls="' + id + '">' + disease.name + ' (' + disease.type + ')</a>');
      tcga.push('<div class="collapse" id="' + id + '">');

      for (var j = 0; j < morpheus.SampleDatasets.TCGA_DISEASE_TYPES_INFO.length; j++) {
        var info = morpheus.SampleDatasets.TCGA_DISEASE_TYPES_INFO[j];
        if (j % 2 === 0) {
          if (j > 0) {
            tcga.push('</div>');
          }
          tcga.push('<div style="margin: 6px 0 0 20px;display: inline-block;vertical-align:top;">');
        }
        tcga.push('<label><input type="checkbox" style="margin-left:4px;"' +
          ' data-toggle="dataTypeToggle"' +
          ' data-type="' + info.type + '"' + (!disease[info.id] ? ' disabled' : '') + '>' + info.name + '</label>');
      }
      tcga.push('</div>');

      tcga.push('<div style="margin: 6px 0 0 20px;display: inline-block;vertical-align:top;">');
      tcga.push('<button disabled type="button" class="btn btn-default" name="tcgaLink"' +
        ' data-disease-type="'
        + disease.type
        + '">Open</button>');
      tcga.push('</div>'); // collapse
      tcga.push('</div>'); // button div
      tcga.push('</div>');
    }
    $(tcga.join('')).appendTo($el.find('[data-name=tcga]'));
  }).catch(function (error) {
    console.log(error);
  });

};

morpheus.SampleDatasets.getTcgaDataset = function (options) {
  var baseUrl = 'https://software.broadinstitute.org/morpheus/preloaded-datasets/tcga/'
    + options.type + '/';
  var datasetOptions = {};
  if (options.mrna) {
    datasetOptions.mrna = baseUrl + 'mRNAseq_RSEM_normalized_log2.txt';
  }

  if (options.methylation) {
    datasetOptions.methylation = baseUrl + 'meth.by_mean.data.txt';
  }
  if (options.sig_genes) {
    datasetOptions.mutation = baseUrl + 'mutations_merged.maf.txt';
    datasetOptions.sigGenes = baseUrl + 'sig_genes.txt';
  }
  // datasetOptions.seg = baseUrl + 'snp.seg.txt';
  if (options.rppa) {
    datasetOptions.rppa = baseUrl + 'rppa.txt';
  }
  if (options.gistic) {
    datasetOptions.gistic = baseUrl + 'all_lesions.conf_99.txt';
  }
  if (options.gisticGene) {
    datasetOptions.gisticGene = baseUrl + 'all_data_by_genes.txt';
  }

  datasetOptions.mrnaClust = baseUrl + 'bestclus.txt';
  datasetOptions.columnAnnotations = [
    {
      file: baseUrl + 'All_CDEs.txt',
      datasetField: 'participant_id',
      fileField: 'patient_id', // e.g. tcga-5l-aat0
      transposed: false
    }];
  return morpheus.TcgaUtil.getDataset(datasetOptions);

};
morpheus.SampleDatasets.getCCLEDataset = function (options) {
  var datasets = [];
  if (options.sig_genes) {
    datasets.push(
      'https://software.broadinstitute.org/morpheus/preloaded-datasets/ccle2maf_081117.maf.txt');
  }
  if (options.cn) {
    datasets.push('https://software.broadinstitute.org/morpheus/preloaded-datasets/CCLE_copynumber_byGene_2013-12-03.gct');
  }

  if (options.mrna) {
    datasets.push('https://software.broadinstitute.org/morpheus/preloaded-datasets/CCLE_expression_081117.rpkm.gct');
  }
  if (options.ach) {
    datasets.push('https://software.broadinstitute.org/morpheus/preloaded-datasets/Achilles_QC_v2.4.3.rnai.Gs.gct');
  }

  var d = $.Deferred();
  var datasetPromise = morpheus.DatasetUtil.readDatasetArray(datasets);
  datasetPromise.done(function (dataset) {
    var idVector = dataset.getColumnMetadata().get(0);
    var siteVector = dataset.getColumnMetadata().add('site');
    for (var j = 0, ncols = siteVector.size(); j < ncols; j++) {
      var id = idVector.getValue(j);
      var index = id.indexOf('_');
      idVector.setValue(j, id.substring(0, index));
      siteVector.setValue(j, id.substring(index + 1));
    }
    d.resolve(dataset);
  }).fail(function (err) {
    d.reject(err);
  });
  return d;
};
morpheus.SampleDatasets.prototype = {

  openTcga: function (options) {
    this.callback({
      name: options.name,
      renderReady: function (heatMap) {
        var whitelist = [
          'age_at_initial_pathologic_diagnosis',
          'breast_carcinoma_estrogen_receptor_status',
          'breast_carcinoma_progesterone_receptor_status',
          'lab_proc_her2_neu_immunohistochemistry_receptor_status',
          'days_to_death', 'ethnicity', 'gender',
          'histological_type', 'pathologic_stage'];

        var columnMetadata = heatMap.getProject().getFullDataset().getColumnMetadata();
        for (var i = 0; i < whitelist.length; i++) {
          if (columnMetadata.getByName(whitelist[i])) {
            heatMap.addTrack(whitelist[i], true, 'color');
          }
        }
        // view in space of mutation sample ids only
        if (options.sig_genes) {
          if (heatMap.getTrackIndex('q_value', false) === -1) {
            heatMap.addTrack('q_value', false, 'text');
          }
        }
      },
      columns: [
        {
          field: 'participant_id',
          display: 'text'
        }, {
          field: 'sample_type',
          display: 'color'
        }, {
          field: 'mutation_summary',
          display: 'stacked_bar'
        }, {
          field: 'mutation_summary_selection',
          display: 'stacked_bar'
        }, {
          field: 'mRNAseq_cluster',
          display: 'color, highlight'
        }],
      dataset: morpheus.SampleDatasets.getTcgaDataset(options)
    });
  },
  openCCLE: function (options) {
    this.callback({
      name: 'CCLE',
      rows: [
        {
          field: 'id',
          display: 'text'
        }, {
          field: 'Description',
          display: 'text, tooltip'
        }, {
          field: 'mutation_summary',
          display: 'stacked_bar'
        }, {
          field: 'Source',
          display: 'color'
        }],
      columns: [
        {
          field: 'id',
          display: 'text,tooltip'
        }, {
          field: 'mutation_summary',
          display: 'stacked_bar'
        }, {
          field: 'site',
          display: 'color, highlight'
        }],
      dataset: morpheus.SampleDatasets.getCCLEDataset(options)
    });
  }
};

morpheus.SampleDatasets.TCGA_DISEASE_TYPES_INFO = [
  {
    id: 'mrna',
    name: 'GENE EXPRESSION',
    type: 'mrna'
  }, {
    id: 'gistic',
    name: 'GISTIC COPY NUMBER',
    type: 'gistic'
  }, {
    id: 'gistic',
    name: 'COPY NUMBER BY GENE',
    type: 'gisticGene'
  }, {
    id: 'sig_genes',
    name: 'MUTATION',
    type: 'sig_genes'
  }, {
    id: 'rppa',
    name: 'PROTEOMICS',
    type: 'rppa'
  }, {
    id: 'methylation',
    name: 'METHYLATION',
    type: 'methylation'
  }];

morpheus.AdjustDataTool = function () {
};
morpheus.AdjustDataTool.prototype = {
  toString: function () {
    return 'Adjust';
  },
  init: function (project, form) {
    var _this = this;
    form.$form.find('[name=scale_column_sum]').on('change', function (e) {
      form.setVisible('column_sum', form.getValue('scale_column_sum'));
    });
    form.setVisible('column_sum', false);

  },
  gui: function () {
    // z-score, robust z-score, log2, inverse log2
    return [{
      name: 'scale_column_sum',
      type: 'checkbox',
      help: 'Whether to scale each column sum to a specified value'
    }, {
      name: 'column_sum',
      type: 'text',
      style: 'max-width:150px;'
    }, {
      name: 'log_2',
      type: 'checkbox'
    }, {
      name: 'inverse_log_2',
      type: 'checkbox'
    }, {
      name: 'quantile_normalize',
      type: 'checkbox'
    }, {
      name: 'z-score',
      type: 'checkbox',
      help: 'Subtract mean, divide by standard deviation'
    }, {
      name: 'robust_z-score',
      type: 'checkbox',
      help: 'Subtract median, divide by median absolute deviation'
    }, {
      name: 'use_selected_rows_and_columns_only',
      type: 'checkbox'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;

    if (options.input.log_2 || options.input.inverse_log_2
      || options.input['z-score'] || options.input['robust_z-score'] || options.input.quantile_normalize || options.input.scale_column_sum) {
      // clone the values 1st
      var sortedFilteredDataset = morpheus.DatasetUtil.copy(project
      .getSortedFilteredDataset());
      var rowIndices = project.getRowSelectionModel()
      .getViewIndices().values().sort(
        function (a, b) {
          return (a === b ? 0 : (a < b ? -1 : 1));
        });
      if (rowIndices.length === 0) {
        rowIndices = null;
      }
      var columnIndices = project.getColumnSelectionModel()
      .getViewIndices().values().sort(
        function (a, b) {
          return (a === b ? 0 : (a < b ? -1 : 1));
        });
      if (columnIndices.length === 0) {
        columnIndices = null;
      }
      var dataset = options.input.use_selected_rows_and_columns_only ? new morpheus.Slice
        : sortedFilteredDataset;
      var rowView = new morpheus.DatasetRowView(dataset);
      var functions = [];
      if (options.input.scale_column_sum) {
        var scaleToValue = parseFloat(options.input.column_sum);
        if (!isNaN(scaleToValue)) {
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            var sum = 0;
            for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
              var value = dataset.getValue(i, j);
              if (!isNaN(value)) {
                sum += value;
              }
            }
            var ratio = scaleToValue / sum;
            for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
              var value = dataset.getValue(i, j);
              dataset.setValue(i, j, value * ratio);
            }
          }
        }
      }
      if (options.input.log_2) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            dataset.setValue(i, j, morpheus.Log2(dataset.getValue(
              i, j)));
          }
        }
      }
      if (options.input.inverse_log_2) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            var value = dataset.getValue(i, j);
            if (value >= 0) {
              dataset.setValue(i, j, Math.pow(2, value));
            }
          }
        }
      }
      if (options.input.quantile_normalize) {
        morpheus.QNorm.execute(dataset);
      }
      if (options.input['z-score']) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          rowView.setIndex(i);
          var mean = morpheus.Mean(rowView);
          var stdev = Math.sqrt(morpheus.Variance(rowView));
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            dataset.setValue(i, j, (dataset.getValue(i, j) - mean)
              / stdev);
          }
        }
      }
      if (options.input['robust_z-score']) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          rowView.setIndex(i);
          var median = morpheus.Median(rowView);
          var mad = morpheus.MAD(rowView, median);
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            dataset.setValue(i, j,
              (dataset.getValue(i, j) - median) / mad);
          }
        }
      }

      return new morpheus.HeatMap({
        name: heatMap.getName(),
        dataset: dataset,
        parent: heatMap,
        symmetric: project.isSymmetric() && dataset.getColumnCount() === dataset.getRowCount()
      });
    }
  }
};

morpheus.AnnotateDendrogramTool = function (isColumns) {
  this._isColumns = isColumns;
};
morpheus.AnnotateDendrogramTool.prototype = {
  toString: function () {
    return 'Annotate Dendrogram';
  },
  gui: function () {
    return [{
      name: 'file',
      value: '',
      type: 'file',
      required: true,
      help: 'an xlsx file or a tab-delimitted text file'
    }];
  },
  execute: function (options) {
    var fileOrUrl = options.input.file;
    var isColumns = this._isColumns;
    var heatMap = options.heatMap;
    var result = morpheus.Util.readLines(fileOrUrl);
    var fileName = morpheus.Util.getFileName(fileOrUrl);
    var dendrogram = isColumns ? heatMap.columnDendrogram
      : heatMap.rowDendrogram;
    var nameToNode = new morpheus.Map();
    morpheus.DendrogramUtil.dfs(dendrogram.tree.rootNode,
      function (node) {
        nameToNode.set(node.name, node);
        return true;
      });
    var tab = /\t/;
    result.done(function (lines) {
      var header = lines[0].split(tab);
      var promptTool = {};
      // node.info = {foo:['a', 'b'], bar:[3]}
      promptTool.execute = function (options) {
        var nodeIdField = options.input.node_id_field;
        var nodeIdIndex = _.indexOf(header, nodeIdField);
        var numberOfMatchingNodes = 0;
        for (var i = 1; i < lines.length; i++) {
          var array = lines[i].split(tab);
          var nodeName = array[nodeIdIndex];
          var node = nameToNode.get(nodeName);
          if (node !== undefined) {
            numberOfMatchingNodes++;
            var info = node.info || (node.info = {});
            for (var j = 0; j < array.length; j++) {
              if (j === nodeIdIndex) {
                continue;
              }
              var vals = info[header[j]];
              if (vals === undefined) {
                vals = [];
                info[header[j]] = vals;
              }
              vals.push(array[j]);
            }
          }
        }
        heatMap.trigger('dendrogramAnnotated', {
          isColumns: isColumns
        });
        dendrogram.setInvalid(true);
        dendrogram.repaint();
      };
      promptTool.toString = function () {
        return 'Select Node Id Field';
      };
      promptTool.gui = function () {
        return [{
          name: 'node_id_field',
          type: 'select',
          options: _.map(header, function (item) {
            return {
              name: item,
              value: item
            };
          }),
          required: true
        }];
      };
      morpheus.HeatMap.showTool(promptTool, heatMap);
    });
  }
};

/**
 * @param chartOptions.heatmap morpheus.HeatMap
 * @param chartOptions.project
 *            morpheus.Project
 */
morpheus.ChartTool = function (chartOptions) {
  var _this = this;
  this.project = chartOptions.project;
  this.heatmap = chartOptions.heatmap;
  var project = this.project;
  this.$el = $('<div class="container-fluid">'
    + '<div class="row">'
    + '<div data-name="configPane" class="col-xs-2"></div>'
    + '<div class="col-xs-10"><div style="position:relative;" data-name="chartDiv"></div></div>'
    + '</div></div>');

  var formBuilder = new morpheus.FormBuilder({
    formStyle: 'vertical'
  });
  this.formBuilder = formBuilder;
  formBuilder.append({
    name: 'chart_type',
    type: 'bootstrap-select',
    options: [
      'boxplot', 'row profile', 'column profile', 'row scatter matrix', 'column scatter' +
      ' matrix']
  });
  var rowOptions = [];
  var columnOptions = [];
  var numericRowOptions = [];
  var numericColumnOptions = [];
  var options = [];
  var numericOptions = [];
  var updateOptions = function () {
    var dataset = project.getFullDataset();
    rowOptions = [
      {
        name: '(None)',
        value: ''
      }];
    columnOptions = [
      {
        name: '(None)',
        value: ''
      }];
    numericRowOptions = [
      {
        name: '(None)',
        value: ''
      }];
    numericColumnOptions = [
      {
        name: '(None)',
        value: ''
      }];
    options = [
      {
        name: '(None)',
        value: ''
      }];
    numericOptions = [
      {
        name: '(None)',
        value: ''
      }];

    morpheus.MetadataUtil.getMetadataNames(dataset.getRowMetadata())
      .forEach(
        function (name) {
          var dataType = morpheus.VectorUtil
            .getDataType(dataset.getRowMetadata()
              .getByName(name));
          if (dataType === 'number'
            || dataType === '[number]') {
            numericRowOptions.push({
              name: name + ' (row)',
              value: name + '_r'
            });
          }
          rowOptions.push({
            name: name + ' (row)',
            value: name + '_r'
          });
        });

    morpheus.MetadataUtil.getMetadataNames(dataset.getColumnMetadata())
      .forEach(
        function (name) {
          var dataType = morpheus.VectorUtil
            .getDataType(dataset.getColumnMetadata()
              .getByName(name));
          if (dataType === 'number'
            || dataType === '[number]') {
            numericColumnOptions.push({
              name: name + ' (column)',
              value: name + '_c'
            });
          }
          columnOptions.push({
            name: name + ' (column)',
            value: name + '_c'
          });
        });

    options = options.concat(rowOptions.slice(1));
    options = options.concat(columnOptions.slice(1));

    numericOptions = numericOptions.concat(numericRowOptions.slice(1));
    numericOptions = numericOptions.concat(numericColumnOptions.slice(1));
  };

  updateOptions();
  formBuilder.append({
    name: 'group_by',
    type: 'bootstrap-select',
    options: options
  });

  formBuilder.append({
    name: 'axis_label',
    type: 'bootstrap-select',
    options: rowOptions
  });
  formBuilder.append({
    name: 'show_outliers',
    type: 'checkbox',
    value: true
  });

  formBuilder.append({
    name: 'color',
    type: 'bootstrap-select',
    options: options
  });

  // formBuilder.append({
  //   name: 'size',
  //   type: 'bootstrap-select',
  //   options: numericOptions
  // });
  formBuilder.append({
    name: 'tooltip',
    type: 'bootstrap-select',
    multiple: true,
    search: true,
    options: options.slice(1)
  });

  formBuilder.append({
    name: 'chart_width',
    type: 'range',
    value: 400,
    min: 60,
    max: 800,
    step: 10
  });
  formBuilder.append({
    name: 'chart_height',
    type: 'range',
    value: 400,
    min: 20,
    max: 800,
    step: 10
  });

  var chartTypeToParameter = {
    'row profile': {
      axis_label: 'columns',
      tooltip: 'columns',
      color: 'rows'
    },
    'column profile': {
      axis_label: 'rows',
      tooltip: 'rows',
      color: 'columns'
    },
    'row scatter matrix': {
      axis_label: 'rows',
      color: 'columns',
      tooltip: 'columns'
    },
    'column scatter matrix': {
      axis_label: 'columns',
      color: 'rows',
      tooltip: 'rows'
    },
    boxplot: {
      group_by: true,
      show_outliers: true,
      tooltip: 'both'
    }
  };

  function setVisibility() {
    var chartType = formBuilder.getValue('chart_type');
    var chartOptions = chartTypeToParameter[chartType];
    if (chartOptions.axis_label != null) {
      formBuilder.setOptions('axis_label',
        chartOptions.axis_label === 'rows' ? rowOptions : columnOptions,
        true);

    }
    formBuilder.setVisible('color', chartOptions.color != null);
    formBuilder.setVisible('axis_label', chartOptions.axis_label != null);
    formBuilder.setVisible('group_by', chartOptions.group_by);
    formBuilder.setVisible('show_outliers', chartOptions.show_outliers);
    formBuilder.setOptions('tooltip', chartOptions.tooltip === 'rows' ? rowOptions.slice(1) : (chartOptions.tooltip === 'columns' ? columnOptions.slice(1) : options));
    formBuilder.setOptions('color', chartOptions.color === 'rows' ? rowOptions : (chartOptions.color === 'columns' ? columnOptions : options));
  }

  this.tooltip = [];
  var draw = function () {
    _.debounce(_this.draw(), 100);
  };
  formBuilder.$form.on('change', 'select,input[type=range]', function (e) {
    if ($(this).attr('name') === 'tooltip') {
      var tooltipVal = _this.formBuilder.getValue('tooltip');
      _this.tooltip.length = 0; // clear array
      if (tooltipVal != null) {
        tooltipVal.forEach(function (tip) {
          _this.tooltip.push(morpheus.ChartTool.getVectorInfo(tip));
        });
      }
    } else {
      setVisibility();
      draw();
    }

  });

  formBuilder.$form.on('click', 'input[type=checkbox]', function (e) {
    draw();

  });
  formBuilder.$form.on('keypress', 'input[type=text]', function (e) {
    if (e.which === 13) {
      draw();
    }
  });

  setVisibility();

  var trackChanged = function () {
    updateOptions();
    setVisibility();
    formBuilder.setOptions('group_by', options, true);
  };

  project.getColumnSelectionModel().on('selectionChanged.chart', draw);
  project.getRowSelectionModel().on('selectionChanged.chart', draw);
  project.on('trackChanged.chart', trackChanged);
  this.$chart = this.$el.find('[data-name=chartDiv]');
  var $dialog = $('<div style="background:white;" title="Chart"></div>');
  var $configPane = this.$el.find('[data-name=configPane]');
  formBuilder.$form.appendTo($configPane);
  this.$el.appendTo($dialog);
  $dialog.dialog({
    dialogClass: 'morpheus',
    close: function (event, ui) {
      project.off('trackChanged.chart', trackChanged);
      project.getRowSelectionModel().off('selectionChanged.chart', draw);
      project.getColumnSelectionModel().off('selectionChanged.chart',
        draw);
      _this.$el.empty();
    },

    resizable: true,
    height: 600,
    width: 900
  });
  this.$dialog = $dialog;
  this.draw();
};

morpheus.ChartTool.getVectorInfo = function (value) {
  var field = value.substring(0, value.length - 2);
  var isColumns = value.substring(value.length - 2) === '_c';
  return {
    field: field,
    isColumns: isColumns
  };
};
morpheus.ChartTool.prototype = {
  /**
   *
   * @param options.dataset
   * @param options.colorByVector
   * @param options.colorModel
   * @param options.transpose
   * @param options.chartWidth
   * @param options.chartHeight
   * @param options.axisLabelVector
   * @private
   */
  _createScatter: function (options) {
    var _this = this;
    var dataset = options.dataset;
    var colorByVector = options.colorByVector;
    var colorModel = options.colorModel;
    var heatmap = this.heatmap;
    var chartWidth = options.chartWidth;
    var chartHeight = options.chartHeight;
    var axisLabelVector = options.axisLabelVector; // for row scatter, row vector
    var transpose = options.transpose;
    var chart = {
      animation: false,
      toolbox: {
        feature: {
          brush: {
            title: {
              rect: 'Rectangle selection',
              polygon: 'Polygon selection',
              clear: 'Clear Selection',
              keep: 'Keep previous selection'
            }
          }
        }
      },
      brush: {
        brushLink: 'all',
        xAxisIndex: [],
        yAxisIndex: [],
        inBrush: {
          opacity: 1
        }
      },
      tooltip: {
        trigger: 'item'
      },
      grid: [],
      xAxis: [],
      yAxis: [],
      series: []
    };
    var index = 0;
    var GAP = 20;
    var BASE_LEFT = 40;
    var BASE_TOP = 40;
    // rowIndexOne on x, rowIndexTwo on y
    for (var rowIndexOne = 1, nrows = dataset.getRowCount(); rowIndexOne < nrows; rowIndexOne++) {
      for (var rowIndexTwo = 0; rowIndexTwo < rowIndexOne; rowIndexTwo++) {
        (function () {
          var data = [];
          var color = [];
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            data.push([dataset.getValue(rowIndexOne, j), dataset.getValue(rowIndexTwo, j), j]);
          }

          if (colorByVector) {
            for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
              var colorByValue = colorByVector.getValue(j);
              color.push(colorModel.getMappedValue(colorByVector,
                colorByValue));
            }
          }
          chart.grid.push({
            left: GAP + (rowIndexOne - 1) * (chartWidth + GAP),
            top: BASE_TOP + rowIndexTwo * (chartHeight + GAP),
            width: chartWidth,
            height: chartHeight
          });

          chart.brush.xAxisIndex && chart.brush.xAxisIndex.push(index);
          chart.brush.yAxisIndex && chart.brush.yAxisIndex.push(index);
          chart.xAxis.push({
            splitNumber: 3,
            position: 'top',
            name: axisLabelVector != null && rowIndexTwo === 0 ? axisLabelVector.getValue(rowIndexOne) : '',
            nameGap: 25,
            nameLocation: 'middle',
            axisLine: {
              show: false,
              onZero: false
            },
            axisTick: {
              show: rowIndexTwo === 0,
              inside: true
            },
            axisLabel: {
              show: rowIndexTwo === 0
            },
            type: 'value',
            gridIndex: index,
            scale: true
          });

          chart.yAxis.push({
            splitNumber: 3,
            nameGap: 50,
            name: axisLabelVector != null && rowIndexOne === nrows - 1 ? axisLabelVector.getValue(rowIndexTwo) : '',
            nameLocation: 'middle',
            position: 'right',
            axisLine: {
              show: false,
              onZero: false
            },
            axisTick: {
              show: rowIndexOne === nrows - 1,
              inside: true
            },
            axisLabel: {
              show: rowIndexOne === nrows - 1
            },
            type: 'value',
            gridIndex: index,
            scale: true
          });

          chart.series.push({
            symbolSize: 4,
            tooltip: {
              formatter: function (obj) {
                var value = obj.value;
                var s = [];
                s.push('x: ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(value[0]));
                s.push('<br>');
                s.push('y ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(value[1]));
                if (transpose) {
                  morpheus.ChartTool.getTooltip({
                    text: s,
                    tooltip: _this.tooltip,
                    dataset: new morpheus.TransposedDatasetView(dataset),
                    rowIndex: value[2],
                    columnIndex: -1
                  });
                } else {
                  morpheus.ChartTool.getTooltip({
                    text: s,
                    tooltip: _this.tooltip,
                    dataset: dataset,
                    rowIndex: -1,
                    columnIndex: value[2]
                  });
                }
                return s.join('');
              }
            },
            itemStyle: {
              normal: {
                color: function (param) {
                  return color.length === 0 ? '#1f78b4' : color[param.dataIndex];
                }
              }
            },
            type: 'scatter',
            xAxisIndex: index,
            yAxisIndex: index,
            data: data
          });
          index++;
        })();

      }
    }
    var myChart = echarts.init(options.el);
    myChart.setOption(chart);

  },
  /**
   *
   * @param options.dataset
   * @param options.colorByVector
   * @param options.colorModel
   * @param options.transpose
   * @param options.chartWidth
   * @param options.chartHeight
   * @param options.axisLabelVector
   * @private
   */
  _createProfile: function (options) {
    var _this = this;
    var dataset = options.dataset;
    var colorByVector = options.colorByVector;
    var colorModel = options.colorModel;
    var heatmap = this.heatmap;
    var chartWidth = options.chartWidth;
    var chartHeight = options.chartHeight;
    var axisLabelVector = options.axisLabelVector; // for row scatter, row vector
    var transpose = options.transpose;
    var axisLabel = [];
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      axisLabel.push(axisLabelVector != null ? axisLabelVector.getValue(j) : '' + j);
    }
    var series = [];
    var colorMap = morpheus.VectorColorModel.getColorMapForNumber(dataset.getRowCount());
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      // each row is a new trace
      var colorByValue = colorByVector != null ? colorByVector.getValue(i) : '' + i;
      var color = colorByVector != null ? colorModel.getMappedValue(colorByVector, colorByValue) : colorMap[i % colorMap.length];
      var data = [];
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        data.push([j, dataset.getValue(i, j), i]);
      }
      series.push({
        name: colorByValue,
        type: 'line',
        data: data,
        tooltip: {
          formatter: function (obj) {
            var value = obj.value;
            var s = [];
            s.push(_this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(value[1]));
            morpheus.ChartTool.getTooltip({
              text: s,
              tooltip: _this.tooltip,
              dataset: dataset,
              rowIndex: value[2],
              columnIndex: value[0]
            });
            return s.join('');
          }
        }
      });
    }

    var chart = {
      legend: {
        orient: 'vertical',
        left: 'right',
        top: 2,
        itemWidth: 14,
        height: dataset.getRowCount() * 20,
        data: series.map(function (s) {
          return s.name;
        })
      },
      animation: false,
      tooltip: {
        trigger: 'item'
      },
      xAxis: {
        type: 'category',
        data: axisLabel
      },
      yAxis: {
        axisLine: {
          show: true,
          onZero: false
        },
        type: 'value',
        name: ''
      },
      grid: {right: 120},
      series: series
    };

    var myChart = echarts.init(options.el);
    myChart.setOption(chart);
  },
  /**
   *
   * @param options.datasets 1-d array of datasets
   * @param options.ids 1-d array of grouping values
   * @param options.showOutliers
   * @param options.el
   * @private
   */
  _createBoxPlot: function (options) {
    var _this = this;
    var showPoints = options.showPoints;
    var datasets = options.datasets;
    var ids = options.ids;
    var heatmap = this.heatmap;
    var size = 6;
    var boxData = [];
    var outliers = [];

    for (var k = 0, ndatasets = datasets.length; k < ndatasets; k++) {
      var dataset = datasets[k];
      var id = ids[k];
      var values = new Float32Array(dataset.getRowCount() * dataset.getColumnCount());
      var counter = 0;
      for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
        for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
          var value = dataset.getValue(i, j);
          if (!isNaN(value)) {
            values[counter] = value;
            counter++;
          }
        }
      }
      if (counter !== values.length) {
        values = values.slice(0, counter);
      }
      values.sort();
      // [min,  Q1,  median,  Q3,  max]
      var item = morpheus.BoxPlotArrayItem(values);
      boxData.push([item.lowerAdjacentValue, item.q1, item.median, item.q3, item.upperAdjacentValue]);
      if (options.showOutliers) {
        var w = 1.5;
        var upperOutlier = item.q3 + w * (item.q3 - item.q1);
        var lowerOutlier = item.q1 - w * (item.q3 - item.q1);
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            var value = dataset.getValue(i, j);
            if (value > upperOutlier || value < lowerOutlier) {
              outliers.push([id, value, i, j]);
            }
          }
        }
      }
    }
    var chart = {
      animation: false,
      tooltip: {
        trigger: 'item'
      },
      xAxis: {
        type: 'category',
        data: ids
      },
      yAxis: {
        axisLine: {
          show: true,
          onZero: false
        },
        type: 'value',
        name: ''
      },
      series: [
        {
          animationDuration: 0,
          hoverAnimation: false,
          name: 'boxplot',
          type: 'boxplot',
          data: boxData,
          tooltip: {
            formatter: function (param) {
              var text = [];
              if (param.name !== '') {
                text.push(param.name);
              }

              text = text.concat([
                'upper: ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(param.data[4]),
                'Q3: ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(param.data[3]),
                'median: ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(param.data[2]),
                'Q1: ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(param.data[1]),
                'lower: ' + _this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(param.data[0])
              ]);
              return text.join('<br/>');
            }
          }
        },
        {
          name: 'outlier',
          type: 'scatter',
          data: outliers,
          symbolSize: 5,
          itemStyle: {
            normal: {
              borderWidth: 1,
              borderColor: 'black',
              opacity: 0.8
            }
          },
          tooltip: {
            formatter: function (obj) {
              var value = obj.value;
              var s = [];
              if (value[0] !== '') {
                s.push(value[0]); // name
                s.push('<br>');
              }
              s.push(_this.heatmap.getHeatMapElementComponent().getDrawValuesFormat()(value[1]));
              morpheus.ChartTool.getTooltip({
                text: s,
                tooltip: _this.tooltip,
                dataset: dataset,
                rowIndex: value[2],
                columnIndex: value[3]
              });
              return s.join('');
            }
          }
        }
      ]
    };

    var myChart = echarts.init(options.el);
    myChart.setOption(chart);
  },
  draw: function () {
    var _this = this;
    this.$chart.empty();
    // 140 to 800
    var gridWidth = parseInt(this.formBuilder.getValue('chart_width'));
    var gridHeight = parseInt(this.formBuilder.getValue('chart_height'));
    var showOutliers = this.formBuilder.getValue('show_outliers');

    var groupBy = this.formBuilder.getValue('group_by');
    var axisLabel = this.formBuilder.getValue('axis_label');

    // var sizeBy = this.formBuilder.getValue('size');
    var chartType = this.formBuilder.getValue('chart_type');

    var dataset = this.project.getSelectedDataset({
      emptyToAll: false
    });

    this.dataset = dataset;
    if (dataset.getRowCount() === 0 && dataset.getColumnCount() === 0) {
      $('<h4>Please select rows and columns in the heat map.</h4>')
        .appendTo(this.$chart);
      return;
    } else if (dataset.getRowCount() === 0) {
      $('<h4>Please select rows in the heat map.</h4>')
        .appendTo(this.$chart);
      return;
    }
    if (dataset.getColumnCount() === 0) {
      $('<h4>Please select columns in the heat map.</h4>')
        .appendTo(this.$chart);
      return;
    }

    var heatmap = this.heatmap;
    // var sizeByInfo = morpheus.ChartTool.getVectorInfo(sizeBy);

    // var sizeByVector = sizeByInfo.isColumns ? dataset.getColumnMetadata().getByName(sizeByInfo.field) : dataset.getRowMetadata().getByName(
    //   sizeByInfo.field);

    var axisLabelInfo = morpheus.ChartTool.getVectorInfo(axisLabel);
    var axisLabelVector = axisLabelInfo.isColumns ? dataset.getColumnMetadata().getByName(axisLabelInfo.field) : dataset.getRowMetadata().getByName(
      axisLabelInfo.field);

    var rowIds = [undefined];
    var columnIds = [undefined];
    var colorBy = this.formBuilder.getValue('color');
    var colorByVector = null;
    var colorModel = null;
    if (colorBy != null) {
      var colorByInfo = morpheus.ChartTool.getVectorInfo(colorBy);
      colorModel = !colorByInfo.isColumns ? this.project.getRowColorModel()
        : this.project.getColumnColorModel();
      colorByVector = colorByInfo.isColumns ? dataset.getColumnMetadata().getByName(colorByInfo.field) : dataset.getRowMetadata().getByName(
        colorByInfo.field);
    }

    if (chartType === 'row profile' || chartType === 'column profile') {
      var transpose = chartType === 'column profile';
      if (transpose) {
        dataset = new morpheus.TransposedDatasetView(dataset);
      }
      if (dataset.getRowCount() > 100) {
        $('<h4>Maximum chart size exceeded.</h4>')
          .appendTo(this.$chart);
        return;
      }
      // add horizontal space for legend
      var $chart = $('<div style="width: ' + (gridWidth + 120) + 'px;height:' + gridHeight + 'px;"></div>');
      $chart.appendTo(this.$chart);
      this._createProfile({
        width: gridWidth,
        el: $chart[0],
        dataset: dataset,
        chartWidth: gridWidth,
        chartHeight: gridHeight,
        transpose: transpose,
        colorModel: colorModel,
        colorByVector: colorByVector,
        axisLabelVector: axisLabelVector
      });
    } else if (chartType === 'row scatter matrix' || chartType === 'column scatter matrix') {
      var transpose = chartType === 'column scatter matrix';

      if (transpose) {
        dataset = new morpheus.TransposedDatasetView(dataset);
      }
      if (dataset.getRowCount() > 20) {
        $('<h4>Maximum chart size exceeded.</h4>')
          .appendTo(this.$chart);
        return;
      }
      var $chart = $('<div style="width:' + (80 + (dataset.getRowCount() - 1) * (gridWidth + 20)) + 'px;height:' + (80 + dataset.getRowCount() * (gridHeight + 20)) +
        'px;"></div>');
      $chart.appendTo(this.$chart);
      this._createScatter({
        el: $chart[0],
        dataset: dataset,
        chartWidth: gridWidth,
        chartHeight: gridHeight,
        transpose: transpose,
        colorModel: colorModel,
        colorByVector: colorByVector,
        axisLabelVector: axisLabelVector
      });
    } else if (chartType === 'boxplot') {
      var datasets = [];//1-d array of datasets
      var ids = []; // 1-d array of grouping values
      if (groupBy) {
        var groupByInfo = morpheus.ChartTool
          .getVectorInfo(groupBy);
        var vector = groupByInfo.isColumns ? dataset
            .getColumnMetadata().getByName(groupByInfo.field)
          : dataset.getRowMetadata().getByName(
            groupByInfo.field);
        var isArray = morpheus.VectorUtil.getDataType(vector)[0] === '[';
        var valueToIndices = morpheus.VectorUtil.createValueToIndicesMap(vector, true);
        valueToIndices.forEach(function (indices, value) {
          datasets.push(new morpheus.SlicedDatasetView(dataset, groupByInfo.isColumns ? null : indices, groupByInfo.isColumns ? indices : null));
          ids.push(value);
        });
      } else {
        datasets.push(dataset);
        ids.push('');
      }
      // sort rows and columns by median
      // if (gridRowCount > 1) {
      //   var summary = [];
      //   for (var i = 0; i < gridRowCount; i++) {
      //     summary[i] = [];
      //     var gridRow = grid[i];
      //     for (var j = 0; j < gridColumnCount; j++) {
      //       var array = gridRow[j];
      //       var values = [];
      //       if (array) {
      //         for (var k = 0, nitems = array.length; k < nitems; k++) {
      //           var item = array[k];
      //           var value = dataset.getValue(item.row, item.column);
      //           if (!isNaN(value)) {
      //             values.push(value);
      //           }
      //
      //         }
      //       }
      //       summary[i][j] = morpheus.Median(morpheus.VectorUtil.arrayAsVector(values));
      //     }
      //   }
      //   // sort rows
      //   var rowMedians = [];
      //   for (var i = 0; i < gridRowCount; i++) {
      //     var values = [];
      //     for (var j = 0; j < gridColumnCount; j++) {
      //       values.push(summary[i][j]);
      //     }
      //     rowMedians.push(morpheus.Median(morpheus.VectorUtil.arrayAsVector(values)));
      //   }
      //
      //   var newRowOrder = morpheus.Util.indexSort(rowMedians, false);
      //   var newRowIds = [];
      //   var newGrid = [];
      //   for (var i = 0; i < gridRowCount; i++) {
      //     newGrid.push(grid[newRowOrder[i]]);
      //     newRowIds.push(rowIds[newRowOrder[i]]);
      //   }
      //   grid = newGrid;
      //   rowIds = newRowIds;
      // }

      var $chartEl = $('<div style="width: ' + gridWidth + 'px;height:' + gridHeight + 'px;"></div>');
      $chartEl.appendTo(this.$chart);
      this._createBoxPlot({
        showOutliers: showOutliers,
        el: $chartEl[0],
        datasets: datasets,
        ids: ids
      });
    }
  }
};

/**
 *
 * @param options.dataset
 * @param options.text
 * @param options.rowIndex
 * @param options.columnIndex
 */
morpheus.ChartTool.getTooltip = function (options) {
  for (var tipIndex = 0; tipIndex < options.tooltip.length; tipIndex++) {
    var tip = options.tooltip[tipIndex];
    var metadata;
    var index;
    if (tip.isColumns) {
      metadata = options.dataset.getColumnMetadata();
      index = options.columnIndex;
    } else {
      metadata = options.dataset.getRowMetadata();
      index = options.rowIndex;
    }
    if (index !== -1) {
      var v = metadata.getByName(tip.field);
      morpheus.HeatMapTooltipProvider.vectorToString(v,
        index, options.text, '<br>');
    }
  }
};


morpheus.CollapseDatasetTool = function () {
};
morpheus.CollapseDatasetTool.Functions = [morpheus.Mean, morpheus.Median,
  new morpheus.MaxPercentiles([25, 75]), morpheus.Min, morpheus.Max, morpheus.Percentile, morpheus.Sum];
morpheus.CollapseDatasetTool.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.CollapseDatasetTool.Functions.length; i++) {
    if (morpheus.CollapseDatasetTool.Functions[i].toString() === s) {
      return morpheus.CollapseDatasetTool.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};
morpheus.CollapseDatasetTool.prototype = {
  toString: function () {
    return 'Collapse';
  },
  init: function (project, form) {
    var setValue = function (val) {
      var isRows = val === 'Rows';
      var names = morpheus.MetadataUtil.getMetadataNames(isRows ? project
      .getFullDataset().getRowMetadata() : project
      .getFullDataset().getColumnMetadata());
      form.setOptions('collapse_to_fields', names);
    };
    form.$form.find('[name=collapse]').on('change', function (e) {
      setValue($(this).val());
    });
    form.setVisible('percentile', false);
    form.$form.find('[name=collapse_method]').on('change', function (e) {
      form.setVisible('percentile', $(this).val() === morpheus.Percentile.toString());
    });

    setValue('Rows');
  },
  gui: function () {
    return [{
      name: 'collapse_method',
      options: morpheus.CollapseDatasetTool.Functions,
      value: morpheus.CollapseDatasetTool.Functions[1].toString(),
      type: 'select'
    }, {
      name: 'percentile',
      value: 75,
      type: 'text'
    }, {
      name: 'collapse',
      options: ['Columns', 'Rows'],
      value: 'Rows',
      type: 'radio'
    }, {
      name: 'collapse_to_fields',
      options: [],
      type: 'select',
      multiple: true
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var f = morpheus.CollapseDatasetTool.Functions
    .fromString(options.input.collapse_method);
    if (f.toString() === morpheus.Percentile.toString()) {
      var p = parseFloat(options.input.percentile);
      f = function (vector) {
        return morpheus.Percentile(vector, p);
      };
    }
    var collapseToFields = options.input.collapse_to_fields;
    if (collapseToFields.length === 0) {
      throw new Error('Please select one or more fields to collapse to');
    }
    var dataset = project.getFullDataset();
    var rows = options.input.collapse == 'Rows';
    if (!rows) {
      dataset = new morpheus.TransposedDatasetView(dataset);
    }
    var allFields = morpheus.MetadataUtil.getMetadataNames(dataset
    .getRowMetadata());
    dataset = morpheus.CollapseDataset(dataset, collapseToFields, f, true);
    if (!rows) {
      dataset = new morpheus.TransposedDatasetView(dataset);
    }
    var set = new morpheus.Map();
    _.each(allFields, function (field) {
      set.set(field, true);
    });
    _.each(collapseToFields, function (field) {
      set.remove(field);
    });
    // hide fields that were not part of collapse to
    set.forEach(function (val, name) {
      heatMap.setTrackVisible(name, false, !rows);
    });
    return new morpheus.HeatMap({
      name: heatMap.getName(),
      dataset: dataset,
      parent: heatMap,
      symmetric: false
    });
  }
};

morpheus.CreateAnnotation = function () {
};
morpheus.CreateAnnotation.prototype = {
  toString: function () {
    return 'Create Calculated Annotation';
  },
  gui: function () {
    return [
      {
        name: 'annotate',
        options: ['Columns', 'Rows'],
        value: 'Rows',
        type: 'radio'
      },
      {
        name: 'annotation_name',
        value: '',
        type: 'text',
        required: true,
        autocomplete: 'off'
      },
      {
        name: 'formula',
        value: '',
        type: 'textarea',
        placeholder: 'e.g MAD()',
        required: true,
        help: 'JavaScript formula. Built-in functions (case-sensitive): COUNTIF(expression),' +
        ' MAD(), MAX(),' +
        ' MEAN(), MEDIAN(), MIN(), PERCENTILE(p), SUM(), VARIANCE(). Refer to a field using FIELD(name)'
      }, {
        name: 'use_selected_rows_and_columns_only',
        type: 'checkbox'
      }];
  },
  execute: function (options) {
    var __project = options.project;
    var isColumns = options.input.annotate == 'Columns';
    var __formula = options.input.formula;
    var __dataset = options.input.use_selected_rows_and_columns_only ? __project
        .getSelectedDataset()
      : __project.getSortedFilteredDataset();
    if (isColumns) {
      __dataset = morpheus.DatasetUtil.transposedView(__dataset);
    }
    var __rowView = new morpheus.DatasetRowView(__dataset);
    var __vector = __dataset.getRowMetadata().add(
      options.input.annotation_name);

    var COUNTIF = function (val) {
      return morpheus.CountIf(__rowView, val);
    };
    var MAD = function () {
      return morpheus.MAD(__rowView);
    };
    var MAX = function () {
      return morpheus.Max(__rowView);
    };
    var MEAN = function () {
      return morpheus.Mean(__rowView);
    };
    var MEDIAN = function (p) {
      return morpheus.Percentile(__rowView, 50);
    };
    var MIN = function () {
      return morpheus.Min(__rowView);
    };
    var PERCENTILE = function (p) {
      return morpheus.Percentile(__rowView, p);
    };
    var SUM = function () {
      return morpheus.Sum(__rowView);
    };
    var VARIANCE = function () {
      return morpheus.Variance(__rowView);
    };
    var __index = 0;
    var FIELD = function (field) {
      var vector = __dataset.getRowMetadata().getByName(field);
      return vector ? vector.getValue(__index) : undefined;
    };

    for (var size = __dataset.getRowCount(); __index < size; __index++) {
      __rowView.setIndex(__index);
      var __val = eval(__formula);
      if (typeof __val === 'function') {
        __val = '';
      }
      __vector.setValue(__index, __val);
    }
    morpheus.VectorUtil.maybeConvertStringToNumber(__vector);
    __project.trigger('trackChanged', {
      vectors: [__vector],
      display: ['text'],
      columns: isColumns
    });
  }
};

morpheus.DendrogramEnrichmentTool = function (isColumns) {
  this.isColumns = isColumns;
};

morpheus.DendrogramEnrichmentTool.prototype = {
  toString: function () {
    return 'Dendrogram Enrichment';
  },
  gui: function (project) {
    var dataset = project.getSortedFilteredDataset();
    var fields = morpheus.MetadataUtil
    .getMetadataNames(this.isColumns ? dataset.getColumnMetadata()
      : dataset.getRowMetadata());
    return [{
      name: 'field',
      options: fields,
      type: 'bootstrap-select',
      multiple: false
    }, {
      name: 'min_p-value_for_enrichment',
      type: 'text',
      value: '0.05'
    }, {
      name: 'minimum_number_of_total_members_in_group',
      type: 'text',
      value: '5'
    }, {
      name: 'minimum_number_of_members_in_group',
      type: 'text',
      value: '3'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var pValue = options.input['min_p-value_for_enrichment'];
    var minTotalGroupSize = options.input.minimum_number_of_total_members_in_group;
    var minGroupSize = options.input.minimum_number_of_members_in_group;
    var dataset = project.getSortedFilteredDataset();
    var dendrogram = this.isColumns ? heatMap.columnDendrogram
      : heatMap.rowDendrogram;
    var vector = this.isColumns ? dataset.getColumnMetadata().getByName(
        options.input.field) : dataset.getRowMetadata().getByName(
        options.input.field);

    var valueToIndices = morpheus.VectorUtil
    .createValueToIndicesMap(vector);
    var valueToGlobalCount = new morpheus.Map();
    var values = [];
    valueToIndices.forEach(function (indices, value) {
      valueToGlobalCount.set(value, indices.length);
      values.push(value);
    });
    var nvalues = values.length;
    var N = vector.size();

    morpheus.DendrogramUtil.dfs(dendrogram.tree.rootNode,
      function (node) {
        delete node.info;
        var valueToCount = new morpheus.Map();
        for (var i = 0; i < nvalues; i++) {
          valueToCount.set(values[i], 0);
        }
        var min = node.minIndex;
        var max = node.maxIndex;
        var n = max - min + 1;
        if (n > 1 && n >= minTotalGroupSize) {
          for (var i = min; i <= max; i++) {
            var value = vector.getValue(i);
            valueToCount
            .set(value, valueToCount.get(value) + 1);
          }
          for (var i = 0; i < nvalues; i++) {
            var K = valueToGlobalCount.get(values[i]);
            var k = valueToCount.get(values[i]);
            if (k >= minGroupSize) {
              var a = k;
              var b = K - k;
              var c = n - k;
              var d = N + k - n - K;
              var p = morpheus.FisherExact.fisherTest(a, b,
                c, d);
              if (p <= pValue) {
                if (!node.info) {
                  node.info = {};
                }
                node.info[values[i]] = p;

              }
            }
          }
        }
        return true;
      });
    dendrogram.setInvalid(true);
    dendrogram.repaint();
  }
};

morpheus.DevAPI = function () {
};
morpheus.DevAPI.prototype = {
  toString: function () {
    return 'API';
  },
  gui: function () {
    return [{
      name: 'code',
      value: '',
      type: 'textarea',
      required: true,
      help: 'Enter your code'
    }];
  },
  execute: function (options) {
    var heatMap = options.heatMap;
    var code = options.input.code;
    eval(code);
    // force a repaint of everything
    heatMap.getProject().setFullDataset(heatMap.getProject().getFullDataset(), true);
  }
};

morpheus.HClusterTool = function () {
};
morpheus.HClusterTool.PRECOMPUTED_DIST = 'Matrix values (for a precomputed distance matrix)';
morpheus.HClusterTool.PRECOMPUTED_SIM = 'Matrix values (for a precomputed similarity matrix)';
morpheus.HClusterTool.Functions = [morpheus.Euclidean, morpheus.Jaccard,
  new morpheus.OneMinusFunction(morpheus.Cosine),
  new morpheus.OneMinusFunction(morpheus.KendallsCorrelation),
  new morpheus.OneMinusFunction(morpheus.Pearson),
  new morpheus.OneMinusFunction(morpheus.Spearman),
  morpheus.HClusterTool.PRECOMPUTED_DIST,
  morpheus.HClusterTool.PRECOMPUTED_SIM];
morpheus.HClusterTool.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.HClusterTool.Functions.length; i++) {
    if (morpheus.HClusterTool.Functions[i].toString() === s) {
      return morpheus.HClusterTool.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};

morpheus.HClusterTool.createLinkageMethod = function (linkageString) {
  var linkageMethod;
  if (linkageString === 'Average') {
    linkageMethod = morpheus.AverageLinkage;
  } else if (linkageString === 'Complete') {
    linkageMethod = morpheus.CompleteLinkage;
  } else if (linkageString === 'Single') {
    linkageMethod = morpheus.SingleLinkage;
  } else {
    throw new Error('Unknown linkage method ' + linkageString);
  }
  return linkageMethod;
};

morpheus.HClusterTool.execute = function (dataset, input) {
  // note: in worker here
  var linkageMethod = morpheus.HClusterTool
  .createLinkageMethod(input.linkage_method);
  var f = morpheus.HClusterTool.Functions.fromString(input.metric);
  if (f === morpheus.HClusterTool.PRECOMPUTED_DIST) {
    f = 0;
  } else if (f === morpheus.HClusterTool.PRECOMPUTED_SIM) {
    f = 1;
  }
  var rows = input.cluster == 'Rows' || input.cluster == 'Rows and columns';
  var columns = input.cluster == 'Columns'
    || input.cluster == 'Rows and columns';
  var doCluster = function (d, groupByFields) {
    return (groupByFields && groupByFields.length > 0) ? new morpheus.HClusterGroupBy(
      d, groupByFields, f, linkageMethod)
      : new morpheus.HCluster(morpheus.HCluster
      .computeDistanceMatrix(d, f), linkageMethod);
  };

  var rowsHcl;
  var columnsHcl;

  if (rows) {
    rowsHcl = doCluster(
      input.selectedColumnsToUseForClusteringRows ? new morpheus.SlicedDatasetView(dataset,
        null, input.selectedColumnsToUseForClusteringRows) : dataset,
      input.group_rows_by);
  }
  if (columns) {
    columnsHcl = doCluster(
      morpheus.DatasetUtil
      .transposedView(input.selectedRowsToUseForClusteringColumns ? new morpheus.SlicedDatasetView(
        dataset, input.selectedRowsToUseForClusteringColumns, null)
        : dataset), input.group_columns_by);

  }
  return {
    rowsHcl: rowsHcl,
    columnsHcl: columnsHcl
  };
};
morpheus.HClusterTool.prototype = {
  toString: function () {
    return 'Hierarchical Clustering';
  },
  init: function (project, form) {
    form.setOptions('group_rows_by', morpheus.MetadataUtil
    .getMetadataNames(project.getFullDataset().getRowMetadata()));
    form
    .setOptions('group_columns_by', morpheus.MetadataUtil
    .getMetadataNames(project.getFullDataset()
    .getColumnMetadata()));
    form.setVisible('group_rows_by', false);
    form
    .setVisible('cluster_rows_in_space_of_selected_columns_only',
      false);
    form.$form.find('[name=cluster]').on(
      'change',
      function (e) {
        var val = $(this).val();
        var showGroupColumns = false;
        var showGroupRows = false;
        if (val === 'Columns') {
          showGroupColumns = true;
        } else if (val === 'Rows') {
          showGroupRows = true;
        } else {
          showGroupColumns = true;
          showGroupRows = true;
        }
        form.setVisible('group_columns_by', showGroupColumns);
        form.setVisible('group_rows_by', showGroupRows);
        form.setVisible(
          'cluster_columns_in_space_of_selected_rows_only',
          showGroupColumns);
        form.setVisible(
          'cluster_rows_in_space_of_selected_columns_only',
          showGroupRows);
      });
  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.HClusterTool.Functions,
      value: morpheus.HClusterTool.Functions[4].toString(),
      type: 'select'
    }, {
      name: 'linkage_method',
      options: ['Average', 'Complete', 'Single'],
      value: 'Average',
      type: 'select'
    }, {
      name: 'cluster',
      options: ['Columns', 'Rows', 'Rows and columns'],
      value: 'Columns',
      type: 'select'
    }, {
      name: 'group_columns_by',
      options: [],
      type: 'bootstrap-select',
      multiple: true
    }, {
      name: 'group_rows_by',
      options: [],
      type: 'bootstrap-select',
      multiple: true
    }, {
      name: 'cluster_columns_in_space_of_selected_rows_only',
      type: 'checkbox'
    }, {
      name: 'cluster_rows_in_space_of_selected_columns_only',
      type: 'checkbox'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatmap = options.heatMap;
    var selectedRowsToUseForClusteringColumns = options.input.cluster_columns_in_space_of_selected_rows_only ? project
    .getRowSelectionModel().getViewIndices().values()
      : null;
    if (selectedRowsToUseForClusteringColumns != null && selectedRowsToUseForClusteringColumns.length === 0) {
      selectedRowsToUseForClusteringColumns = null;
    }
    var selectedColumnsToUseForClusteringRows = options.input.cluster_rows_in_space_of_selected_columns_only ? project
    .getColumnSelectionModel().getViewIndices().values()
      : null;
    if (selectedColumnsToUseForClusteringRows != null && selectedColumnsToUseForClusteringRows.length === 0) {
      selectedColumnsToUseForClusteringRows = null;
    }
    var rows = options.input.cluster == 'Rows'
      || options.input.cluster == 'Rows and columns';
    var columns = options.input.cluster == 'Columns'
      || options.input.cluster == 'Rows and columns';
    options.input.selectedRowsToUseForClusteringColumns = selectedRowsToUseForClusteringColumns;
    options.input.selectedColumnsToUseForClusteringRows = selectedColumnsToUseForClusteringRows;
    var dataset = project.getSortedFilteredDataset();
    if (options.input.background === undefined) {
      options.input.background = true;
    }
    options.input.background = options.input.background && typeof Worker !== 'undefined';
    var rowModelOrder;
    var columnModelOrder;
    if (rows) {
      rowModelOrder = [];
      for (var i = 0; i < dataset.getRowCount(); i++) {
        rowModelOrder[i] = project.convertViewRowIndexToModel(i);
      }
    }
    if (columns) {
      columnModelOrder = [];
      for (var i = 0; i < dataset.getColumnCount(); i++) {
        columnModelOrder[i] = project.convertViewColumnIndexToModel(i);
      }
    }
    if (options.input.background === false) {
      var result = morpheus.HClusterTool.execute(dataset, options.input);
      if (result.rowsHcl) {
        var modelOrder = [];
        for (var i = 0; i < result.rowsHcl.reorderedIndices.length; i++) {
          modelOrder[i] = rowModelOrder[result.rowsHcl.reorderedIndices[i]];
        }
        heatmap.setDendrogram(result.rowsHcl.tree, false,
          modelOrder);
      }
      if (result.columnsHcl) {
        var modelOrder = [];
        for (var i = 0; i < result.columnsHcl.reorderedIndices.length; i++) {
          modelOrder[i] = columnModelOrder[result.columnsHcl.reorderedIndices[i]];
        }
        heatmap.setDendrogram(result.columnsHcl.tree, true, modelOrder);
      }
    } else {


      var blob = new Blob(
        ['self.onmessage = function(e) {'
        + 'importScripts(e.data.scripts);'
        + 'self.postMessage(morpheus.HClusterTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
        + '}']);

      var url = window.URL.createObjectURL(blob);
      var worker = new Worker(url);

      worker.postMessage({
        scripts: morpheus.Util.getScriptPath(),
        dataset: morpheus.Dataset.toJSON(dataset, {
          columnFields: options.input.group_columns_by || [],
          rowFields: options.input.group_rows_by || [],
          seriesIndices: [0]
        }),
        input: options.input
      });

      worker.onmessage = function (e) {
        var result = e.data;
        if (result.rowsHcl) {
          var modelOrder = [];
          for (var i = 0; i < result.rowsHcl.reorderedIndices.length; i++) {
            modelOrder[i] = rowModelOrder[result.rowsHcl.reorderedIndices[i]];
          }
          heatmap.setDendrogram(result.rowsHcl.tree, false,
            modelOrder);
        }
        if (result.columnsHcl) {
          var modelOrder = [];
          for (var i = 0; i < result.columnsHcl.reorderedIndices.length; i++) {
            modelOrder[i] = columnModelOrder[result.columnsHcl.reorderedIndices[i]];
          }
          heatmap.setDendrogram(result.columnsHcl.tree, true,
            modelOrder);
        }
        worker.terminate();
        window.URL.revokeObjectURL(url);
      };
      return worker;
    }

  }
};

morpheus.KMeansTool = function () {
};

morpheus.KMeansTool.execute = function (dataset, input) {
  // note: in worker here
  var f = morpheus.HClusterTool.Functions.fromString(input.metric);
  if (f === morpheus.HClusterTool.PRECOMPUTED_DIST) {
    f = 0;
  } else if (f === morpheus.HClusterTool.PRECOMPUTED_SIM) {
    f = 1;
  }
  var rows = input.cluster == 'Rows' || input.cluster == 'Rows and columns';
  var columns = input.cluster == 'Columns'
    || input.cluster == 'Rows and columns';

  var doCluster = function (d) {
    var kmeans = new morpheus.KMeansPlusPlusClusterer(input.number_of_clusters, input.maximum_iterations, f);
    var vectors = [];
    for (var i = 0; i < d.getRowCount(); i++) {
      vectors.push(new morpheus.DatasetRowView(d).setIndex(i));
    }
    var clusters = kmeans.execute(vectors);
    // need to return in JSON
    var assignments = [];
    for (var i = 0; i < clusters.length; i++) {
      clusters[i].getPoints().forEach(function (p) {
        assignments[p.i] = i + 1;
      });
    }
    return assignments;
  };
  var rowAssignments;
  var columnAssignments;
  if (rows) {
    rowAssignments = doCluster(
      input.selectedColumnsToUseForClusteringRows ? new morpheus.SlicedDatasetView(dataset,
        null, input.selectedColumnsToUseForClusteringRows) : dataset);
  }
  if (columns) {
    columnAssignments = doCluster(
      morpheus.DatasetUtil
      .transposedView(input.selectedRowsToUseForClusteringColumns ? new morpheus.SlicedDatasetView(
        dataset, input.selectedRowsToUseForClusteringColumns, null)
        : dataset));

  }

  return {
    rowAssignments: rowAssignments,
    columnAssignments: columnAssignments
  };
};
morpheus.KMeansTool.prototype = {
  toString: function () {
    return 'KMeans Clustering';
  },
  init: function (project, form) {
    form
    .setVisible('cluster_rows_in_space_of_selected_columns_only',
      false);
    form.$form.find('[name=cluster]').on(
      'change',
      function (e) {
        var val = $(this).val();
        var val = $(this).val();
        var showGroupColumns = false;
        var showGroupRows = false;
        if (val === 'Columns') {
          showGroupColumns = true;
        } else if (val === 'Rows') {
          showGroupRows = true;
        } else {
          showGroupColumns = true;
          showGroupRows = true;
        }
        form.setVisible(
          'cluster_columns_in_space_of_selected_rows_only',
          showGroupColumns);
        form.setVisible(
          'cluster_rows_in_space_of_selected_columns_only',
          showGroupRows);
      });
  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.HClusterTool.Functions,
      value: morpheus.HClusterTool.Functions[4].toString(),
      type: 'select'
    }, {
      name: 'cluster',
      options: ['Columns', 'Rows', 'Rows and columns'],
      value: 'Columns',
      type: 'select'
    }, {
      name: 'number_of_clusters',
      value: '2',
      type: 'text'
    }, {
      name: 'cluster_columns_in_space_of_selected_rows_only',
      type: 'checkbox'
    }, {
      name: 'cluster_rows_in_space_of_selected_columns_only',
      type: 'checkbox'
    }, {
      name: 'maximum_iterations',
      value: '1000',
      type: 'text'
    },];
  },
  execute: function (options) {
    var project = options.project;
    var heatmap = options.heatMap;
    options.input.number_of_clusters = parseInt(options.input.number_of_clusters);
    options.input.maximum_iterations = parseInt(options.input.maximum_iterations);
    var selectedRowsToUseForClusteringColumns = options.input.cluster_columns_in_space_of_selected_rows_only ? project
    .getRowSelectionModel().getViewIndices().values()
      : null;
    if (selectedRowsToUseForClusteringColumns != null && selectedRowsToUseForClusteringColumns.length === 0) {
      selectedRowsToUseForClusteringColumns = null;
    }
    var selectedColumnsToUseForClusteringRows = options.input.cluster_rows_in_space_of_selected_columns_only ? project
    .getColumnSelectionModel().getViewIndices().values()
      : null;
    if (selectedColumnsToUseForClusteringRows != null && selectedColumnsToUseForClusteringRows.length === 0) {
      selectedColumnsToUseForClusteringRows = null;
    }
    var rows = options.input.cluster == 'Rows'
      || options.input.cluster == 'Rows and columns';
    var columns = options.input.cluster == 'Columns'
      || options.input.cluster == 'Rows and columns';
    options.input.selectedRowsToUseForClusteringColumns = selectedRowsToUseForClusteringColumns;
    options.input.selectedColumnsToUseForClusteringRows = selectedColumnsToUseForClusteringRows;
    var dataset = project.getSortedFilteredDataset();

    options.input.background = options.input.background && typeof Worker !== 'undefined';
    function addAssignments(d, assignments, k) {
      var v = d.getColumnMetadata().add('k_means_' + k);
      for (var i = 0; i < assignments.length; i++) {
        v.setValue(i, assignments[i]);
      }
    }

    if (options.input.background === false) {
      var result = morpheus.KMeansTool.execute(dataset, options.input);
      if (result.columnAssignments) {
        addAssignments(dataset, result.columnAssignments, options.input.number_of_clusters);
        heatmap.addTrack('k_means_' + options.input.number_of_clusters, true, {
          highlightMatchingValues: true,
          discreteAutoDetermined: true,
          display: ['color']
        });
      }
      if (result.rowAssignments) {
        addAssignments(new morpheus.TransposedDatasetView(dataset), result.rowAssignments, options.input.number_of_clusters);
        heatmap.addTrack('k_means_' + options.input.number_of_clusters, false, {
          highlightMatchingValues: true,
          discreteAutoDetermined: true,
          display: ['color']
        });
      }
      heatmap.revalidate();
    } else {
      var blob = new Blob(
        ['self.onmessage = function(e) {'
        + 'importScripts(e.data.scripts);'
        + 'self.postMessage(morpheus.KMeansTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
        + '}']);

      var url = window.URL.createObjectURL(blob);
      var worker = new Worker(url);
      worker.postMessage({
        scripts: morpheus.Util.getScriptPath(),
        dataset: morpheus.Dataset.toJSON(dataset, {
          columnFields: [],
          rowFields: [],
          seriesIndices: [0]
        }),
        input: options.input
      });

      worker.onmessage = function (e) {
        var result = e.data;
        if (result.columnAssignments) {
          addAssignments(dataset, result.columnAssignments, options.input.number_of_clusters);
          heatmap.addTrack('k_means_' + options.input.number_of_clusters, true, {
            highlightMatchingValues: true,
            discrete: true,
            display: ['color']
          });
        }
        if (result.rowAssignments) {
          addAssignments(new morpheus.TransposedDatasetView(dataset), result.rowAssignments, options.input.number_of_clusters);
          heatmap.addTrack('k_means_' + options.input.number_of_clusters, false, {
            highlightMatchingValues: true,
            discrete: true,
            display: ['color']
          });
        }
        heatmap.revalidate();
        worker.terminate();
        window.URL.revokeObjectURL(url);
      };
      return worker;
    }

  }
};

morpheus.MarkerSelection = function () {

};

/**
 * @private
 */
morpheus.MarkerSelection.Functions = [
  morpheus.FisherExact,
  morpheus.FoldChange, morpheus.MeanDifference, morpheus.SignalToNoise,
  morpheus.createSignalToNoiseAdjust(), morpheus.TTest];

morpheus.MarkerSelection.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.MarkerSelection.Functions.length; i++) {
    if (morpheus.MarkerSelection.Functions[i].toString() === s) {
      return morpheus.MarkerSelection.Functions[i];
    }
  }
  throw s + ' not found';
};
morpheus.MarkerSelection.execute = function (dataset, input) {
  var aIndices = [];
  var bIndices = [];
  for (var i = 0; i < input.numClassA; i++) {
    aIndices[i] = i;
  }
  for (var i = input.numClassA; i < dataset.getColumnCount(); i++) {
    bIndices[i] = i;
  }

  var f = morpheus.MarkerSelection.Functions.fromString(input.metric);
  var permutations = new morpheus.PermutationPValues(dataset, aIndices,
    bIndices, input.npermutations, f);
  return {
    rowSpecificPValues: permutations.rowSpecificPValues,
    k: permutations.k,
    fdr: permutations.fdr,
    scores: permutations.scores
  };
};
morpheus.MarkerSelection.prototype = {
  toString: function () {
    return 'Marker Selection';
  },
  init: function (project, form) {
    var _this = this;
    var updateAB = function (fieldNames) {
      var ids = [];
      if (fieldNames != null) {
        var vectors = morpheus.MetadataUtil.getVectors(project
          .getFullDataset().getColumnMetadata(), fieldNames);
        var idToIndices = morpheus.VectorUtil
          .createValuesToIndicesMap(vectors);
        idToIndices.forEach(function (indices, id) {
          ids.push(id);
        });
      }
      ids.sort();
      form.setOptions('class_a', ids);
      form.setOptions('class_b', ids);

    };
    var $field = form.$form.find('[name=field]');
    $field.on('change', function (e) {
      updateAB($(this).val());
    });

    if ($field[0].options.length > 0) {
      $field.val($field[0].options[0].value);
    }
    updateAB($field.val());
    var $metric = form.$form.find('[name=metric]');
    $metric.on('change', function (e) {
      var isFishy = $(this).val() === 'Fisher Exact Test';
      form.setVisible('grouping_value', isFishy);
      form.setVisible('permutations', !isFishy);
      form.setVisible('number_of_markers', !isFishy);

    });
    form.setVisible('grouping_value', false);

  },
  gui: function (project) {
    var dataset = project.getSortedFilteredDataset();
    var fields = morpheus.MetadataUtil.getMetadataNames(dataset
      .getColumnMetadata());
    return [
      {
        name: 'metric',
        options: morpheus.MarkerSelection.Functions,
        value: morpheus.SignalToNoise.toString(),
        type: 'select',
        help: ''
      },
      {
        name: 'grouping_value',
        value: '1',
        help: 'Class values are categorized into two groups based on whether dataset values are greater than or equal to this value'
      },
      {
        name: 'field',
        options: fields,
        type: 'select',
        multiple: true
      },
      {
        name: 'class_a',
        title: 'Class A',
        options: [],
        value: '',
        type: 'checkbox-list',
        multiple: true
      },
      {
        name: 'class_b',
        title: 'Class B',
        options: [],
        value: '',
        type: 'checkbox-list',
        multiple: true
      },
      {
        name: 'number_of_markers',
        value: '100',
        type: 'text',
        help: 'The initial number of markers to show in each direction.'
      }, {
        name: 'permutations',
        value: '0',
        type: 'text'
      }];
  },
  execute: function (options) {

    var project = options.project;
    // classA and classB are arrays of Identifiers if run via user
    // interface. If run via JSON, will be string arrays
    var classA = options.input.class_a;
    var classB = options.input.class_b;
    if (classA.length === 0 && classB.length === 0) {
      throw 'No samples in class A and class B';
    }

    if (classA.length === 0) {
      throw 'No samples in class A';
    }
    if (classB.length === 0) {
      throw 'No samples in class B';
    }
    for (var i = 0; i < classA.length; i++) {
      var val = classA[i];
      if (!(val instanceof morpheus.Identifier)) {
        classA[i] = new morpheus.Identifier(
          morpheus.Util.isArray(val) ? val : [val]);
      }
    }

    for (var i = 0; i < classB.length; i++) {
      var val = classB[i];
      if (!(val instanceof morpheus.Identifier)) {
        classB[i] = new morpheus.Identifier(
          morpheus.Util.isArray(val) ? val : [val]);
      }
    }
    var npermutations = parseInt(options.input.permutations);
    var dataset = project.getSortedFilteredDataset();

    var fieldNames = options.input.field;
    if (!morpheus.Util.isArray(fieldNames)) {
      fieldNames = [fieldNames];
    }

    var vectors = morpheus.MetadataUtil.getVectors(dataset
      .getColumnMetadata(), fieldNames);
    var idToIndices = morpheus.VectorUtil.createValuesToIndicesMap(vectors);
    var aIndices = [];
    var bIndices = [];
    classA.forEach(function (id) {
      var indices = idToIndices.get(id);
      if (indices === undefined) {
        throw new Error(id + ' not found in ' + idToIndices.keys());
      }
      aIndices = aIndices.concat(indices);
    });
    classB.forEach(function (id) {
      var indices = idToIndices.get(id);
      if (indices === undefined) {
        throw new Error(id + ' not found in ' + idToIndices.keys());
      }
      bIndices = bIndices.concat(indices);
    });

    var f = morpheus.MarkerSelection.Functions
      .fromString(options.input.metric);

    var classASet = {};
    for (var i = 0; i < aIndices.length; i++) {
      classASet[aIndices[i]] = true;
    }
    for (var i = 0; i < bIndices.length; i++) {
      if (classASet[bIndices[i]]) {
        throw 'The sample was found in class A and class B';
      }
    }
    var isFishy = f.toString() === morpheus.FisherExact.toString();
    if ((aIndices.length === 1 || bIndices.length === 1)
      && !isFishy && f.toString() !== morpheus.MeanDifference.toString()) {
      f = morpheus.FoldChange;
    }
    var list1 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
      dataset, null, aIndices));
    var list2 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
      dataset, null, bIndices));
    // remove
    // other
    // marker
    // selection
    // fields
    var markerSelectionFields = morpheus.MarkerSelection.Functions.map(
      function (f) {
        return f.toString();
      }).concat(['odds_ratio', 'FDR(BH)', 'p_value']);
    markerSelectionFields.forEach(function (name) {
      var index = morpheus.MetadataUtil.indexOf(dataset.getRowMetadata(),
        name);
      if (index !== -1) {
        dataset.getRowMetadata().remove(index);
        options.heatMap.removeTrack(name, false);
      }
    });
    var v = dataset.getRowMetadata().add(f.toString());
    var vectors = [v];
    var comparisonVector = dataset.getColumnMetadata().add('Comparison');

    for (var i = 0; i < aIndices.length; i++) {
      comparisonVector.setValue(aIndices[i], 'A');
    }
    for (var i = 0; i < bIndices.length; i++) {
      comparisonVector.setValue(bIndices[i], 'B');
    }

    function done(result) {
      if (result) {
        var pvalueVector = dataset.getRowMetadata().add('p_value');
        var fdrVector = dataset.getRowMetadata().add('FDR(BH)');
        var kVector = dataset.getRowMetadata().add('k');
        for (var i = 0, size = pvalueVector.size(); i < size; i++) {
          pvalueVector.setValue(i, result.rowSpecificPValues[i]);
          fdrVector.setValue(i, result.fdr[i]);
          kVector.setValue(i, result.k[i]);
          v.setValue(i, result.scores[i]);
        }
        kVector.getProperties().set(morpheus.VectorKeys.FORMATTER, {pattern: 'i'});
        vectors.push(pvalueVector);
        vectors.push(fdrVector);
        vectors.push(kVector);
      }
      if (project.getRowFilter().getFilters().length > 0) {
        project.getRowFilter().setAnd(true, true);
      }
      var rowFilters = project.getRowFilter().getFilters();
      // remove existing top n filters
      for (var i = 0; i < rowFilters.length; i++) {
        if (rowFilters[i] instanceof morpheus.TopNFilter) {
          project.getRowFilter().remove(i, true);
          i--;
        }
      }
      if (!isFishy) {
        project.getRowFilter().add(
          new morpheus.TopNFilter(
            parseInt(options.input.number_of_markers),
            morpheus.TopNFilter.TOP_BOTTOM, vectors[0]
              .getName()), true);
      }

      project.setRowFilter(project.getRowFilter(), true);
      project.setRowSortKeys([
        new morpheus.SortKey(vectors[0].getName(),
          isFishy ? morpheus.SortKey.SortOrder.ASCENDING
            : morpheus.SortKey.SortOrder.DESCENDING)], true);
      // select samples used in comparison
      var selectedColumnIndices = new morpheus.Set();
      aIndices.forEach(function (index) {
        selectedColumnIndices.add(index);
      });
      bIndices.forEach(function (index) {
        selectedColumnIndices.add(index);
      });
      project.getColumnSelectionModel().setViewIndices(selectedColumnIndices, true);

      project.setColumnSortKeys([
        new morpheus.SortKey(comparisonVector
          .getName(), morpheus.SortKey.SortOrder.ASCENDING)], true);

      project.trigger('trackChanged', {
        vectors: vectors,
        display: vectors.map(function () {
          return 'text';
        }),
        columns: false
      });
      project.trigger('trackChanged', {
        vectors: [comparisonVector],
        display: ['color'],
        columns: true
      });
    }

    if (isFishy) {
      var groupingValue = parseFloat(options.input.grouping_value);
      var oddsRatioVector = dataset.getRowMetadata().add('odds_ratio');
      var fdrVector = dataset.getRowMetadata().add('FDR(BH)');
      var contingencyTableVector = dataset.getRowMetadata().add(
        'contingency_table');
      var pvalues = [];
      for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
        var abcd = morpheus.createContingencyTable(list1.setIndex(i),
          list2.setIndex(i), groupingValue);
        contingencyTableVector.setValue(i, '[[' + abcd[0] + ', '
          + abcd[1] + '], [' + abcd[2] + ', ' + abcd[3] + ']]');
        var ratio = (abcd[0] * abcd[3]) / (abcd[1] * abcd[2]);
        if (isNaN(ratio) || ratio === Number.POSITIVE_INFINITY) {
          ratio = 0;
        }
        oddsRatioVector.setValue(i, ratio);
        v.setValue(i, morpheus.FisherExact.fisherTest(abcd[0], abcd[1],
          abcd[2], abcd[3]));
        pvalues.push(v.getValue(i));
      }
      var fdr = morpheus.FDR_BH(pvalues);
      for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
        fdrVector.setValue(i, fdr[i]);
      }
      vectors.push(oddsRatioVector);
      vectors.push(fdrVector);
      vectors.push(contingencyTableVector);
      done();
    } else {
      if (npermutations > 0) {
        var subset = new morpheus.SlicedDatasetView(dataset, null,
          aIndices.concat(bIndices));

        options.input.background = options.input.background && typeof Worker !== 'undefined';
        options.input.numClassA = aIndices.length;
        options.input.npermutations = npermutations;
        if (options.input.background) {
          var blob = new Blob(
            [
              'self.onmessage = function(e) {'
              + 'importScripts(e.data.scripts);'
              + 'self.postMessage(morpheus.MarkerSelection.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
              + '}']);

          var url = window.URL.createObjectURL(blob);
          var worker = new Worker(url);
          worker.postMessage({
            scripts: morpheus.Util.getScriptPath(),
            dataset: morpheus.Dataset.toJSON(subset, {
              columnFields: [],
              rowFields: [],
              seriesIndices: [0]
            }),
            input: options.input
          });

          worker.onmessage = function (e) {
            done(e.data);
            worker.terminate();
            window.URL.revokeObjectURL(url);
          };
          return worker;
        } else {
          done(morpheus.MarkerSelection.execute(subset, options.input));
        }
      } else {
        for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
          v.setValue(i, f(list1.setIndex(i), list2.setIndex(i)));
        }
        // no permutations, compute asymptotic p-value if t-test
        if (f.toString() === morpheus.TTest.toString() && typeof jStat !== 'undefined') {
          var pvalueVector = dataset.getRowMetadata().add('p_value');
          var fdrVector = dataset.getRowMetadata().add('FDR(BH)');
          var rowSpecificPValues = new Float32Array(dataset.getRowCount());
          for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
            list1.setIndex(i);
            list2.setIndex(i);
            var m1 = morpheus.Mean(list1);
            var m2 = morpheus.Mean(list2);
            var v1 = morpheus.Variance(list1, m1);
            var v2 = morpheus.Variance(list2, m2);
            var n1 = morpheus.CountNonNaN(list1);
            var n2 = morpheus.CountNonNaN(list2);
            var df = morpheus.DegreesOfFreedom(v1, v2, n1, n2);
            var t = v.getValue(i);
            var p = 2.0 * (1 - jStat.studentt.cdf(Math.abs(t), df));
            rowSpecificPValues[i] = p;
            pvalueVector.setValue(i, p);
          }
          vectors.push(pvalueVector);
          var fdr = morpheus.FDR_BH(rowSpecificPValues);
          for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
            fdrVector.setValue(i, fdr[i]);
          }
          vectors.push(fdrVector);
        }

        done();
      }
    }

  }
};

morpheus.NearestNeighbors = function () {
};
morpheus.NearestNeighbors.Functions = [
  morpheus.Cosine, morpheus.Euclidean,
  morpheus.Jaccard, morpheus.KendallsCorrelation, morpheus.Pearson, morpheus.Spearman,
  morpheus.WeightedMean];
morpheus.NearestNeighbors.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.NearestNeighbors.Functions.length; i++) {
    if (morpheus.NearestNeighbors.Functions[i].toString() === s) {
      return morpheus.NearestNeighbors.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};

morpheus.NearestNeighbors.execute = function (dataset, input) {
  var f = morpheus.NearestNeighbors.Functions.fromString(input.metric);
  var permutations = new morpheus.PermutationPValues(dataset, null, null, input.npermutations, f,
    morpheus.Vector.fromArray('', input.listValues));
  return {
    rowSpecificPValues: permutations.rowSpecificPValues,
    k: permutations.k,
    fdr: permutations.fdr,
    scores: permutations.scores
  };
};
morpheus.NearestNeighbors.prototype = {
  toString: function () {
    return 'Nearest Neighbors';
  },
  init: function (project, form) {
    var $selectedOnly = form.$form.find('[name=use_selected_only]').parent();
    form.$form.find('[name=compute_nearest_neighbors_of]').on(
      'change',
      function (e) {
        var val = $(this).val();
        if (val === 'selected rows' || val === 'column annotation') {
          $($selectedOnly.contents()[1]).replaceWith(
            document.createTextNode(' Use selected columns only'));
        } else {
          $($selectedOnly.contents()[1]).replaceWith(
            document.createTextNode(' Use selected rows only'));
        }
        form.setVisible('annotation', false);
        if (val === 'column annotation' || val === 'row annotation') {
          var metadata = val === 'column annotation'
            ? project.getFullDataset().getColumnMetadata()
            : project.getFullDataset().getRowMetadata();
          var names = [];
          // get numeric columns only
          for (var i = 0; i < metadata.getMetadataCount(); i++) {
            var v = metadata.get(i);
            if (morpheus.VectorUtil.getDataType(v) === 'number') {
              names.push(v.getName());
            }
          }
          names.sort(function (a, b) {
            a = a.toLowerCase();
            b = b.toLowerCase();
            return (a < b ? -1 : (a === b ? 0 : 1));
          });
          form.setOptions('annotation', names);
          form.setVisible('annotation', true);
        }
      });
    $($selectedOnly.contents()[1]).replaceWith(
      document.createTextNode(' Use selected columns only'));
    form.setVisible('annotation', false);
  },
  gui: function () {
    return [
      {
        name: 'metric',
        options: morpheus.NearestNeighbors.Functions,
        value: morpheus.Pearson.toString(),
        type: 'select'
      }, {
        name: 'compute_nearest_neighbors_of',
        options: ['selected rows', 'selected columns', 'column annotation', 'row annotation'],
        value: 'selected rows',
        type: 'radio'
      }, {
        name: 'use_selected_only',
        type: 'checkbox'
      }, {
        name: 'annotation',
        type: 'bootstrap-select'
      }, {
        name: 'permutations',
        value: '0',
        type: 'text'
      }];
  },
  execute: function (options) {
    var project = options.project;
    var isColumns = options.input.compute_nearest_neighbors_of == 'selected columns' ||
      options.input.compute_nearest_neighbors_of == 'row annotation';
    var isAnnotation = options.input.compute_nearest_neighbors_of == 'column annotation' ||
      options.input.compute_nearest_neighbors_of == 'row annotation';
    var heatMap = options.heatMap;
    var f = morpheus.NearestNeighbors.Functions.fromString(options.input.metric);
    var dataset = project.getSortedFilteredDataset();

    if (isColumns) {
      // compute the nearest neighbors of row, so need to transpose
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var selectedIndices = (isColumns ? project.getColumnSelectionModel()
      : project.getRowSelectionModel()).getViewIndices().values();
    if (!isAnnotation && selectedIndices.length === 0) {
      throw new Error('No ' + (isColumns ? 'columns' : 'rows')
        + ' selected');
    }
    var spaceIndices = null;
    if (options.input.use_selected_only) {
      spaceIndices = (!isColumns ? project.getColumnSelectionModel()
        : project.getRowSelectionModel()).getViewIndices().values();
      dataset = morpheus.DatasetUtil.slicedView(dataset, null,
        spaceIndices);
    }
    var d1 = morpheus.DatasetUtil.slicedView(dataset, selectedIndices, null);
    var nearestNeighborsList;
    if (isAnnotation) {
      nearestNeighborsList = dataset.getColumnMetadata().getByName(options.input.annotation);
      if (!nearestNeighborsList) {
        throw new Error('No annotation selected.');
      }
    } else {
      if (d1.getRowCount() > 1) {
        // collapse each column in the dataset to a single value
        var columnView = new morpheus.DatasetColumnView(d1);
        var newDataset = new morpheus.Dataset({
          name: '',
          rows: 1,
          columns: d1.getColumnCount()
        });
        for (var j = 0, ncols = d1.getColumnCount(); j < ncols; j++) {
          var v = morpheus.Percentile(columnView.setIndex(j), 50);
          newDataset.setValue(0, j, v);
        }
        d1 = newDataset;
      }
      nearestNeighborsList = new morpheus.DatasetRowView(d1);
    }

    var npermutations = parseInt(options.input.permutations);
    var scoreVector = dataset.getRowMetadata().add(f.toString());
    if (npermutations > 0) {

      if (options.input.background === undefined) {
        options.input.background = true;
      }
      options.input.background = options.input.background && typeof Worker !== 'undefined';
      options.input.npermutations = npermutations;

      var done = function (result) {
        var pvalueVector = dataset.getRowMetadata().add('p_value');
        var fdrVector = dataset.getRowMetadata().add('FDR(BH)');
        var kVector = dataset.getRowMetadata().add('k');

        for (var i = 0, size = pvalueVector.size(); i < size; i++) {
          pvalueVector.setValue(i, result.rowSpecificPValues[i]);
          fdrVector.setValue(i, result.fdr[i]);
          kVector.setValue(i, result.k[i]);
          scoreVector.setValue(i, result.scores[i]);
        }
        kVector.getProperties().set(morpheus.VectorKeys.FORMATTER, {pattern: 'i'});
        var vectors = [pvalueVector, fdrVector, kVector, scoreVector];
        project.trigger('trackChanged', {
          vectors: vectors,
          display: ['text'],
          columns: isColumns
        });
      };

      var listValues = new Float32Array(nearestNeighborsList.size());
      for (var i = 0, size = listValues.length; i < size; i++) {
        listValues[i] = nearestNeighborsList.getValue(i);
      }
      options.input.listValues = listValues;
      if (options.input.background) {
        var blob = new Blob(
          [
            'self.onmessage = function(e) {'
            + 'importScripts(e.data.scripts);'
            +
            'self.postMessage(morpheus.NearestNeighbors.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
            + '}']);

        var url = window.URL.createObjectURL(blob);
        var worker = new Worker(url);

        worker.postMessage({
          scripts: morpheus.Util.getScriptPath(),
          dataset: morpheus.Dataset.toJSON(dataset, {
            columnFields: [],
            rowFields: [],
            seriesIndices: [0]
          }),
          input: options.input
        });

        worker.onmessage = function (e) {
          done(e.data);
          worker.terminate();
          window.URL.revokeObjectURL(url);
        };
        return worker;
      } else {
        done(morpheus.NearestNeighbors.execute(dataset, options.input));
      }

    } else {
      var datasetRowView = new morpheus.DatasetRowView(dataset);

      for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
        scoreVector.setValue(i, f(nearestNeighborsList, datasetRowView.setIndex(i)));
      }
      if (!isColumns) {
        project.setRowSortKeys([
          new morpheus.SortKey(f.toString(),
            morpheus.SortKey.SortOrder.DESCENDING)], true);
      } else {
        project.setColumnSortKeys([
          new morpheus.SortKey(f.toString(),
            morpheus.SortKey.SortOrder.DESCENDING)], true);
      }
      project.trigger('trackChanged', {
        vectors: [scoreVector],
        display: ['text'],
        columns: isColumns
      });
    }

  }
};

morpheus.NewHeatMapTool = function () {
};
morpheus.NewHeatMapTool.prototype = {
  toString: function () {
    return 'New Heat Map';
  },
  // gui : function() {
  // return [ {
  // name : 'name',
  // type : 'text'
  // }, {
  // name : 'include_selected_rows',
  // type : 'checkbox',
  // value : true
  // }, {
  // name : 'include_selected_columns',
  // type : 'checkbox',
  // value : true
  // } ];
  // },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var dataset = project.getSelectedDataset({
      selectedRows: true,
      selectedColumns: true
    });
    morpheus.DatasetUtil.shallowCopy(dataset);

    // TODO see if we can subset dendrograms
    // only handle contiguous selections for now
    // if (heatMap.columnDendrogram != null) {
    // var indices = project.getColumnSelectionModel().getViewIndices()
    // .toArray();
    // morpheus.DendrogramUtil.leastCommonAncestor();
    // }
    // if (heatMap.rowDendrogram != null) {
    //
    // }
    var heatmap = new morpheus.HeatMap({
      name: heatMap.getName(),
      dataset: dataset,
      parent: heatMap,
      symmetric: project.isSymmetric() && dataset.getColumnCount() === dataset.getRowCount()
    });

  }
};

morpheus.OpenDatasetTool = function () {
};

morpheus.OpenDatasetTool.prototype = {
  toString: function () {
    return 'Open Dataset';
  },
  _read: function (options, deferred) {
    var _this = this;
    var project = options.project;
    var heatMap = options.heatMap;
    var file = options.input.file;
    var action = options.input.open_file_action;
    var dataset = project.getSortedFilteredDataset();
    deferred.fail(function (err) {
      var message = [
        'Error opening ' + morpheus.Util.getFileName(file)
        + '.'];
      if (err.message) {
        message.push('<br />Cause: ');
        message.push(err.message);
      }
      morpheus.FormBuilder.showInModal({
        title: 'Error',
        html: message.join(''),
        focus: document.activeElement
      });
    });
    deferred
      .done(function (newDataset) {

        var extension = morpheus.Util.getExtension(morpheus.Util
          .getFileName(file));
        var filename = morpheus.Util.getBaseFileName(morpheus.Util
          .getFileName(file));
        if (action === 'append' || action === 'append columns') {

          // "append": append rows to current dataset
          var appendRows = action === 'append';
          // rename fields?
          _.each(heatMap.options.rows, function (item) {
            if (item.renameTo) {
              var v = newDataset.getRowMetadata().getByName(
                item.field);
              if (v) {
                v.setName(item.renameTo);
              }
            }
          });
          _.each(heatMap.options.columns, function (item) {
            if (item.renameTo) {
              var v = newDataset.getColumnMetadata()
                .getByName(item.field);
              if (v) {
                v.setName(item.renameTo);
              }
            }
          });

          if (heatMap.options.datasetReady) {
            heatMap.options.datasetReady(newDataset);
          }
          var currentDatasetMetadataNames = morpheus.MetadataUtil
            .getMetadataNames(!appendRows ? dataset
              .getRowMetadata() : dataset
              .getColumnMetadata());
          var newDatasetMetadataNames = morpheus.MetadataUtil
            .getMetadataNames(!appendRows ? newDataset
              .getRowMetadata() : newDataset
              .getColumnMetadata());

          if (currentDatasetMetadataNames.length > 1
            || newDatasetMetadataNames.length > 1) {

            _this
              ._matchAppend(
                newDatasetMetadataNames,
                currentDatasetMetadataNames,
                heatMap,
                function (appendOptions) {
                  heatMap
                    .getProject()
                    .setFullDataset(
                      appendRows ? new morpheus.JoinedDataset(
                        dataset,
                        newDataset,
                        appendOptions.current_dataset_annotation_name,
                        appendOptions.new_dataset_annotation_name)
                        : new morpheus.TransposedDatasetView(
                        new morpheus.JoinedDataset(
                          new morpheus.TransposedDatasetView(
                            dataset),
                          new morpheus.TransposedDatasetView(
                            newDataset),
                          appendOptions.current_dataset_annotation_name,
                          appendOptions.new_dataset_annotation_name)),
                      true);

                  if (heatMap.options.renderReady) {
                    heatMap.options
                      .renderReady(heatMap);
                    heatMap.updateDataset();
                  }
                  if (appendRows) {
                    heatMap
                      .getHeatMapElementComponent()
                      .getColorScheme()
                      .setSeparateColorSchemeForRowMetadataField(
                        'Source');

                    var sourcesSet = morpheus.VectorUtil
                      .getSet(heatMap
                        .getProject()
                        .getFullDataset()
                        .getRowMetadata()
                        .getByName(
                          'Source'));
                    sourcesSet
                      .forEach(function (source) {
                        heatMap
                          .autoDisplay({
                            extension: morpheus.Util
                              .getExtension(source),
                            filename: source
                          });
                      });
                  }

                  heatMap.tabManager
                    .setTabTitle(
                      heatMap.tabId,
                      heatMap
                        .getProject()
                        .getFullDataset()
                        .getRowCount()
                      + ' row'
                      + morpheus.Util
                        .s(heatMap
                          .getProject()
                          .getFullDataset()
                          .getRowCount())
                      + ' x '
                      + heatMap
                        .getProject()
                        .getFullDataset()
                        .getColumnCount()
                      + ' column'
                      + morpheus.Util
                        .s(heatMap
                          .getProject()
                          .getFullDataset()
                          .getColumnCount()));
                  heatMap.revalidate();
                });
          } else { // no need to prompt
            heatMap
              .getProject()
              .setFullDataset(
                appendRows ? new morpheus.JoinedDataset(
                  dataset,
                  newDataset,
                  currentDatasetMetadataNames[0],
                  newDatasetMetadataNames[0])
                  : new morpheus.TransposedDatasetView(
                  new morpheus.JoinedDataset(
                    new morpheus.TransposedDatasetView(
                      dataset),
                    new morpheus.TransposedDatasetView(
                      newDataset),
                    currentDatasetMetadataNames[0],
                    newDatasetMetadataNames[0])),
                true);
            if (heatMap.options.renderReady) {
              heatMap.options.renderReady(heatMap);
              heatMap.updateDataset();
            }
            if (appendRows) {
              heatMap
                .getHeatMapElementComponent()
                .getColorScheme()
                .setSeparateColorSchemeForRowMetadataField(
                  'Source');
              var sourcesSet = morpheus.VectorUtil
                .getSet(heatMap.getProject()
                  .getFullDataset()
                  .getRowMetadata().getByName(
                    'Source'));
              sourcesSet.forEach(function (source) {
                heatMap.autoDisplay({
                  extension: morpheus.Util
                    .getExtension(source),
                  filename: source
                });
              });
            }
            heatMap.tabManager.setTabTitle(heatMap.tabId,
              heatMap.getProject().getFullDataset()
                .getRowCount()
              + ' row'
              + morpheus.Util.s(heatMap
                .getProject()
                .getFullDataset()
                .getRowCount())
              + ' x '
              + heatMap.getProject()
                .getFullDataset()
                .getColumnCount()
              + ' column'
              + morpheus.Util.s(heatMap
                .getProject()
                .getFullDataset()
                .getColumnCount()));
            heatMap.revalidate();
          }

        } else if (action === 'overlay') {
          _this
            ._matchOverlay(
              morpheus.MetadataUtil
                .getMetadataNames(newDataset
                  .getColumnMetadata()),
              morpheus.MetadataUtil
                .getMetadataNames(dataset
                  .getColumnMetadata()),
              morpheus.MetadataUtil
                .getMetadataNames(newDataset
                  .getRowMetadata()),
              morpheus.MetadataUtil
                .getMetadataNames(dataset
                  .getRowMetadata()),
              heatMap,
              function (appendOptions) {
                morpheus.DatasetUtil.overlay({
                  dataset: dataset,
                  newDataset: newDataset,
                  rowAnnotationName: appendOptions.current_dataset_row_annotation_name,
                  newRowAnnotationName: appendOptions.new_dataset_row_annotation_name,
                  columnAnnotationName: appendOptions.current_dataset_column_annotation_name,
                  newColumnAnnotationName: appendOptions.new_dataset_column_annotation_name
                });
              });
        } else if (action === 'open') { // new tab
          console.log('open');
          new morpheus.HeatMap({
            dataset: newDataset,
            parent: heatMap,
            inheritFromParent: false
          });
        } else {
          console.log('Unknown action: ' + action);
        }
        if (action !== 'open') {
          heatMap.revalidate();
        }
      });
  },
  execute: function (options) {
    var file = options.input.file;
    var _this = this;
    var d = $.Deferred();
    morpheus.OpenDatasetTool
      .fileExtensionPrompt(file,
        function (readOptions) {
          if (!readOptions) {
            readOptions = {};
          }
          readOptions.interactive = true;
          var deferred = morpheus.DatasetUtil.read(file,
            readOptions);
          deferred.always(function () {
            d.resolve();
          });
          _this._read(options, deferred);

        });
    return d;

  }, // prompt for metadata field name in dataset and in file
  _matchAppend: function (newDatasetMetadataNames,
                          currentDatasetMetadataNames, heatMap, callback) {
    var tool = {};
    tool.execute = function (options) {
      return options.input;
    };
    tool.toString = function () {
      return 'Select Fields';
    };
    tool.gui = function () {
      var items = [
        {
          name: 'current_dataset_annotation_name',
          options: currentDatasetMetadataNames,
          type: 'select',
          value: 'id',
          required: true
        }];
      items.push({
        name: 'new_dataset_annotation_name',
        type: 'select',
        value: 'id',
        options: newDatasetMetadataNames,
        required: true
      });
      return items;
    };
    morpheus.HeatMap.showTool(tool, heatMap, callback);
  },
  _matchOverlay: function (newDatasetColumnMetadataNames,
                           currentDatasetColumnMetadataNames, newDatasetRowMetadataNames,
                           currentDatasetRowMetadataNames, heatMap, callback) {
    var tool = {};
    tool.execute = function (options) {
      return options.input;
    };
    tool.toString = function () {
      return 'Select Fields';
    };
    tool.gui = function () {
      var items = [];
      items.push({
        name: 'current_dataset_column_annotation_name',
        options: currentDatasetColumnMetadataNames,
        type: 'select',
        value: 'id',
        required: true
      });
      items.push({
        name: 'new_dataset_column_annotation_name',
        type: 'select',
        value: 'id',
        options: newDatasetColumnMetadataNames,
        required: true
      });
      items.push({
        name: 'current_dataset_row_annotation_name',
        options: currentDatasetRowMetadataNames,
        type: 'select',
        value: 'id',
        required: true
      });
      items.push({
        name: 'new_dataset_row_annotation_name',
        type: 'select',
        value: 'id',
        options: newDatasetRowMetadataNames,
        required: true
      });
      return items;
    };
    morpheus.HeatMap.showTool(tool, heatMap, callback);
  }
};

morpheus.OpenDatasetTool.fileExtensionPrompt = function (file, callback) {
  var ext = morpheus.Util.getExtension(morpheus.Util.getFileName(file));
  var deferred;
  if (ext === 'seg' || ext === 'segtab') {
    this._promptSegtab(function (regions) {
      callback(regions);
    });

  } else {
    callback(null);
  }

};
morpheus.OpenDatasetTool._promptMaf = function (promptCallback) {
  var formBuilder = new morpheus.FormBuilder();
  formBuilder
    .append({
      name: 'MAF_gene_symbols',
      value: '',
      type: 'textarea',
      required: true,
      help: 'Enter one gene symbol per line to filter genes. Leave blank to show all genes.'
    });
  morpheus.FormBuilder
    .showInModal({
      title: 'Gene Symbols',
      html: formBuilder.$form,
      close: 'OK',
      onClose: function () {
        var text = formBuilder.getValue('MAF_gene_symbols');
        var lines = morpheus.Util.splitOnNewLine(text);
        var mafGeneFilter = new morpheus.Map();
        for (var i = 0, nlines = lines.length, counter = 0; i < nlines; i++) {
          var line = lines[i];
          if (line !== '') {
            mafGeneFilter.set(line, counter++);
          }
        }
        var readOptions = mafGeneFilter.size() > 0 ? {
          mafGeneFilter: mafGeneFilter
        } : null;
        promptCallback(readOptions);
      }
    });
};
morpheus.OpenDatasetTool._promptSegtab = function (promptCallback) {
  var formBuilder = new morpheus.FormBuilder();
  formBuilder
    .append({
      name: 'regions',
      value: '',
      type: 'textarea',
      required: true,
      help: 'Define the regions over which you want to define the CNAs. Enter one region per line. Each line should contain region_id, chromosome, start, and end separated by a tab. Leave blank to use all unique segments in the segtab file as regions.'
    });
  morpheus.FormBuilder
    .showInModal({
      title: 'Regions',
      html: formBuilder.$form,
      close: 'OK',
      onClose: function () {
        var text = formBuilder.getValue('regions');
        var lines = morpheus.Util.splitOnNewLine(text);
        var regions = [];
        var tab = /\t/;
        for (var i = 0, nlines = lines.length, counter = 0; i < nlines; i++) {
          var line = lines[i];

          if (line !== '') {
            var tokens = line.split(tab);
            if (tokens.length >= 4) {
              regions.push({
                id: tokens[0],
                chromosome: tokens[1],
                start: parseInt(tokens[2]),
                end: parseInt(tokens[3])
              });
            }
          }
        }
        var readOptions = regions.length > 0 ? {
          regions: regions
        } : null;
        promptCallback(readOptions);
      }
    });
};

morpheus.OpenDendrogramTool = function (file) {
  this._file = file;
};
morpheus.OpenDendrogramTool.prototype = {
  toString: function () {
    return 'Open Dendrogram';
  },
  init: function (project, form) {
    var setValue = function (val) {
      var isRows = val === 'Rows';
      var names = morpheus.MetadataUtil.getMetadataNames(isRows ? project
      .getFullDataset().getRowMetadata() : project
      .getFullDataset().getColumnMetadata());
      names.unshift('Newick file does not contain node ids');
      form.setOptions('match_leaf_node_ids_to', names);
    };
    form.$form.find('[name=orientation]').on('change', function (e) {
      setValue($(this).val());
    });
    setValue('Columns');
  },
  gui: function () {
    return [{
      name: 'orientation',
      options: ['Columns', 'Rows'],
      value: 'Columns',
      type: 'radio'
    }, {
      name: 'match_leaf_node_ids_to',
      options: [],
      type: 'select'
    }];
  },
  execute: function (options) {
    var fileOrUrl = this._file;
    var isColumns = options.input.orientation === 'Columns';
    var dendrogramField = options.input.match_leaf_node_ids_to;
    if (dendrogramField == '' || dendrogramField === 'Newick file does not contain node ids') {
      dendrogramField = null;
    }
    var heatMap = options.heatMap;
    var dendrogramDeferred = morpheus.Util.getText(fileOrUrl);
    dendrogramDeferred
    .done(function (text) {
      var dataset = options.project.getSortedFilteredDataset();
      if (isColumns) {
        dataset = morpheus.DatasetUtil.transposedView(dataset);
      }
      var tree = morpheus.DendrogramUtil.parseNewick(text);
      if (tree.leafNodes.length !== dataset.getRowCount()) {
        throw new Error('# leaf nodes in dendrogram '
          + tree.leafNodes.length + ' != '
          + dataset.getRowCount());
      }
      var modelIndices = [];
      if (dendrogramField != null) {
        var vector = dataset.getRowMetadata().getByName(
          dendrogramField);
        var valueToIndex = morpheus.VectorUtil.createValueToIndexMap(vector);
        for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
          var newickId = tree.leafNodes[i].name;
          var index = valueToIndex.get(newickId);
          if (index === undefined) {
            throw new Error('Unable to find dendrogram id '
              + tree.leafNodes[i].name
              + ' in annotations');
          }
          modelIndices.push(index);
        }
      } else {
        // see if leaf node ids are indices
        for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
          var newickId = tree.leafNodes[i].name;
          newickId = parseInt(newickId);
          if (!isNaN(newickId)) {
            modelIndices.push(newickId);
          } else {
            break;
          }
        }

        if (modelIndices.length !== tree.leafNodes.length) {
          modelIndices = [];
          for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
            modelIndices.push(i);
          }
        }
      }
      heatMap.setDendrogram(tree, isColumns, modelIndices);
    });
  }
};

morpheus.OpenFileTool = function (options) {
  this.options = options || {};
};

morpheus.OpenFileTool.OPEN_FILE_ACTION_OPTIONS = [
  {
    name: 'Open session',
    value: 'Open session'
  }, {
    name: 'Open dataset in new tab',
    value: 'open'
  }, {
    name: 'Append rows to current dataset',
    value: 'append'
  }, {
    name: 'Append columns to current dataset',
    value: 'append columns'
  }, {
    name: 'Overlay onto current dataset',
    value: 'overlay'
  }, {divider: true}, {
    name: 'Annotate columns',
    value: 'Annotate Columns'
  }, {
    name: 'Annotate rows',
    value: 'Annotate Rows'
  }, {
    divider: true
  }, {
    name: 'Open dendrogram',
    value: 'Open dendrogram'
  }];

morpheus.OpenFileTool.prototype = {
  toString: function () {
    return 'Open' + (this.options.file != null ? (' - ' + this.options.file.name) : '');
  },
  gui: function () {
    var params = [
      {
        name: 'open_file_action',
        value: 'open',
        type: 'bootstrap-select',
        options: morpheus.OpenFileTool.OPEN_FILE_ACTION_OPTIONS
      }];

    if (this.options.file == null) { // pick file and action
      params.options = {
        size: 'modal-lg',
        cancel: false,
        ok: false
      };
    } else {
      var extension = morpheus.Util.getExtension(
        morpheus.Util.getFileName(this.options.file));
      if (extension === 'json') { // TODO no gui needed
        params[0].options = params[0].options.filter(function (opt) {
          return opt.value != null &&
            ( opt.value === 'Open session' || opt.value === 'open' ||
              opt.value === 'overlay' || opt.value.indexOf('append') !== -1);
        });
      } else if (extension === 'gct') {
        params[0].options = params[0].options.filter(function (opt) {
          return opt.value != null &&
            (opt.value === 'open' || opt.value === 'overlay' ||
              opt.value.indexOf('append') !== -1);
        });
      }
    }
    return params;
  },
  init: function (project, form, initOptions) {
    var _this = this;

    if (this.options.file == null) {

      form.setVisible('open_file_action', false);
      var $div = $('<div></div>');
      var $ok = $(
        '<div style="display:none;padding:15px;text-align:right;"><button name="action-selected" type="button" class="btn' +
        ' btn-default">OK</button></div>');
      $ok.find('[name=action-selected]').on('click', function () {
        _this.ok();
      });
      var filePicker = new morpheus.FilePicker({
        fileCallback: function (fileOrUrl) {
          $div.hide();
          $ok.show();
          _this.options.file = fileOrUrl;
          // if it's a file, check file type and update choices
          var extension = morpheus.Util.getExtension(
            morpheus.Util.getFileName(_this.options.file));
          if (extension === 'json') { // TODO no gui needed
            form.setOptions('open_file_action',
              morpheus.OpenFileTool.OPEN_FILE_ACTION_OPTIONS.filter(
                function (opt) {
                  return opt.value != null &&
                    (opt.value === 'Open session' || opt.value === 'open' ||
                      opt.value === 'overlay' ||
                      opt.value.indexOf('append') !== -1);
                }));
          } else if (extension === 'gct') {
            form.setOptions('open_file_action',
              morpheus.OpenFileTool.OPEN_FILE_ACTION_OPTIONS.filter(
                function (opt) {
                  return opt.value != null &&
                    (opt.value === 'open' || opt.value === 'overlay' ||
                      opt.value.indexOf('append') !== -1);
                }));
          }
          form.setVisible('open_file_action', true);
        },
        optionsCallback: function (heatMapOptions) {
          $div.hide();
          $ok.show();
          _this.options.file = heatMapOptions.dataset;
          form.setVisible('open_file_action', true);
          form.setOptions('open_file_action',
            morpheus.OpenFileTool.OPEN_FILE_ACTION_OPTIONS.filter(
              function (opt) {
                return opt.value != null &&
                  (opt.value === 'open' || opt.value === 'overlay' ||
                    opt.value.indexOf('append') !== -1);
              }));
        }
      });
      filePicker.$el.appendTo($div);
      $ok.appendTo(form.$form);
      $div.appendTo(form.$form);
    }
  },

  execute: function (options) {
    var _this = this;
    var isInteractive = this.options.file == null;
    var heatMap = options.heatMap;
    if (!isInteractive) {
      options.input.file = this.options.file;
    }

    var project = options.project;
    if (options.input.open_file_action === 'Open session') {
      return morpheus.Util.getText(options.input.file).done(function (text) {
        var options = JSON.parse(text);
        options.tabManager = heatMap.getTabManager();
        options.focus = true;
        options.inheritFromParent = false;
        options.landingPage = heatMap.options.landingPage;
        new morpheus.HeatMap(options);
      }).fail(function (err) {
        morpheus.FormBuilder.showMessageModal({
          title: 'Error',
          message: 'Unable to load session',
          focus: document.activeElement
        });
      });
    } else if (options.input.open_file_action === 'append columns'
      || options.input.open_file_action === 'append'
      || options.input.open_file_action === 'open'
      || options.input.open_file_action === 'overlay') {
      return new morpheus.OpenDatasetTool().execute(options);
    } else if (options.input.open_file_action === 'Open dendrogram') {
      morpheus.HeatMap.showTool(new morpheus.OpenDendrogramTool(
        options.input.file), options.heatMap);
    } else { // annotate rows or columns
      var d = $.Deferred();
      var isAnnotateColumns = options.input.open_file_action ==
        'Annotate Columns';
      var fileOrUrl = options.input.file;
      var dataset = project.getFullDataset();
      var fileName = morpheus.Util.getFileName(fileOrUrl);
      if (morpheus.Util.endsWith(fileName, '.cls')) {
        var result = morpheus.Util.readLines(fileOrUrl);
        result.always(function () {
          d.resolve();
        });
        result.done(function (lines) {
          _this.annotateCls(heatMap, dataset, fileName,
            isAnnotateColumns, lines);
        });
      } else if (morpheus.Util.endsWith(fileName, '.gmt')) {
        morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (
          err,
          buf) {
          d.resolve();
          if (err) {
            throw new Error('Unable to read ' + fileOrUrl);
          }
          var sets = new morpheus.GmtReader().read(
            new morpheus.ArrayBufferReader(new Uint8Array(
              buf)));
          _this.promptSets(dataset, heatMap, isAnnotateColumns,
            sets, morpheus.Util.getBaseFileName(
              morpheus.Util.getFileName(fileOrUrl)));
        });

      } else {
        var result = morpheus.Util.readLines(fileOrUrl);
        result.done(function (lines) {
          _this.prompt(lines, dataset, heatMap, isAnnotateColumns);
        }).always(function () {
          d.resolve();
        });
        return d;
      }

    }
  },
  annotateCls: function (heatMap, dataset, fileName, isColumns, lines) {
    if (isColumns) {
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var assignments = new morpheus.ClsReader().read(lines);
    if (assignments.length !== dataset.getRowCount()) {
      throw new Error(
        'Number of samples in cls file does not match dataset.');
    }
    var vector = dataset.getRowMetadata().add(
      morpheus.Util.getBaseFileName(fileName));
    for (var i = 0; i < assignments.length; i++) {
      vector.setValue(i, assignments[i]);
    }
    if (heatMap) {
      heatMap.getProject().trigger('trackChanged', {
        vectors: [vector],
        display: ['color'],
        columns: isColumns
      });
    }
  },

  annotateSets: function (dataset, isColumns, sets,
                          datasetMetadataName, setSourceFileName) {
    if (isColumns) {
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var vector = dataset.getRowMetadata().getByName(datasetMetadataName);
    var idToIndices = morpheus.VectorUtil.createValueToIndicesMap(vector);
    var setVector = dataset.getRowMetadata().add(setSourceFileName);
    sets.forEach(function (set) {
      var name = set.name;
      var members = set.ids;
      members.forEach(function (id) {
        var indices = idToIndices.get(id);
        if (indices !== undefined) {
          for (var i = 0, nIndices = indices.length; i < nIndices; i++) {
            var array = setVector.getValue(indices[i]);
            if (array === undefined) {
              array = [];
            }
            array.push(name);
            setVector.setValue(indices[i], array);
          }
        }
      });
    });
    return setVector;
  },
  /**
   *
   * @param lines
   *            Lines of text in annotation file or null if a gmt file
   * @param dataset
   *            Current dataset
   * @param isColumns
   *            Whether annotating columns
   * @param sets
   *            Sets if a gmt file or null
   * @param metadataName
   *            The dataset metadata name to match on
   * @param fileColumnName
   *            The metadata file name to match on
   * @param fileColumnNamesToInclude
   *            An array of column names to include from the metadata file or
   *            null to include all
   * @param tranposed For text/Excel files only. If <code>true</code>, different annotations are on each row.
   */
  annotate: function (lines, dataset, isColumns, sets, metadataName,
                      fileColumnName, fileColumnNamesToInclude, transposed) {
    if (isColumns) {
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var vector = dataset.getRowMetadata().getByName(metadataName);
    if (!vector) {
      throw new Error('vector ' + metadataName + ' not found.');
    }
    var fileColumnNamesToIncludeSet = null;
    if (fileColumnNamesToInclude) {
      fileColumnNamesToIncludeSet = new morpheus.Set();
      fileColumnNamesToInclude.forEach(function (name) {
        fileColumnNamesToIncludeSet.add(name);
      });
    }
    var vectors = [];
    var idToIndices = morpheus.VectorUtil.createValueToIndicesMap(vector);
    if (!lines) {
      _.each(
        sets,
        function (set) {
          var name = set.name;
          var members = set.ids;

          var v = dataset.getRowMetadata().add(name);
          vectors.push(v);
          _.each(
            members,
            function (id) {
              var indices = idToIndices.get(id);
              if (indices !== undefined) {
                for (var i = 0, nIndices = indices.length; i < nIndices; i++) {
                  v.setValue(
                    indices[i],
                    name);
                }
              }
            });
        });
    } else {
      var tab = /\t/;
      if (!transposed) {
        var header = lines[0].split(tab);
        var fileMatchOnColumnIndex = _.indexOf(header, fileColumnName);
        if (fileMatchOnColumnIndex === -1) {
          throw new Error(fileColumnName + ' not found in header:'
            + header);
        }
        var columnIndices = [];
        var nheaders = header.length;
        for (var j = 0; j < nheaders; j++) {
          var name = header[j];
          if (j === fileMatchOnColumnIndex) {
            continue;
          }
          if (fileColumnNamesToIncludeSet
            && !fileColumnNamesToIncludeSet.has(name)) {
            continue;
          }
          var v = dataset.getRowMetadata().getByName(name);
          if (!v) {
            v = dataset.getRowMetadata().add(name);
          }
          columnIndices.push(j);
          vectors.push(v);
        }
        var nheaders = columnIndices.length;
        for (var i = 1, nrows = lines.length; i < nrows; i++) {
          var line = lines[i].split(tab);
          var id = line[fileMatchOnColumnIndex];
          var indices = idToIndices.get(id);
          if (indices !== undefined) {
            var nIndices = indices.length;
            for (var j = 0; j < nheaders; j++) {
              var token = line[columnIndices[j]];
              var v = vectors[j];
              for (var r = 0; r < nIndices; r++) {
                v.setValue(indices[r], token);
              }
            }
          }
        }
      }
      else {
        // transposed
        var splitLines = [];
        var matchOnLine;
        for (var i = 0, nrows = lines.length; i < nrows; i++) {
          var line = lines[i].split(tab);
          var name = line[0];
          if (fileColumnName === name) {
            matchOnLine = line;
          } else {
            if (fileColumnNamesToIncludeSet
              && !fileColumnNamesToIncludeSet.has(name)) {
              continue;
            }
            splitLines.push(line);
            var v = dataset.getRowMetadata().getByName(name);
            if (!v) {
              v = dataset.getRowMetadata().add(name);
            }
            vectors.push(v);
          }
        }
        if (matchOnLine == null) {
          throw new Error(fileColumnName + ' not found in header.');
        }

        for (var fileColumnIndex = 1, ncols = matchOnLine.length; fileColumnIndex < ncols; fileColumnIndex++) {
          var id = matchOnLine[fileColumnIndex];
          var indices = idToIndices.get(id);
          if (indices !== undefined) {
            var nIndices = indices.length;
            for (var j = 0; j < splitLines.length; j++) {
              var token = splitLines[j][fileColumnIndex];
              var v = vectors[j];
              for (var r = 0; r < nIndices; r++) {
                v.setValue(indices[r], token);
              }
            }
          }

        }
      }
    }
    for (var i = 0; i < vectors.length; i++) {
      morpheus.VectorUtil.maybeConvertStringToNumber(vectors[i]);
    }
    return vectors;
  },
  // prompt for metadata field name in dataset
  promptSets: function (dataset, heatMap, isColumns, sets, setSourceFileName) {
    var promptTool = {};
    var _this = this;
    promptTool.execute = function (options) {
      var metadataName = options.input.dataset_field_name;
      var vector = _this.annotateSets(dataset, isColumns, sets,
        metadataName, setSourceFileName);

      heatMap.getProject().trigger('trackChanged', {
        vectors: [vector],
        display: ['text'],
        columns: isColumns
      });
    };
    promptTool.toString = function () {
      return 'Select Fields To Match On';
    };
    promptTool.gui = function () {
      return [
        {
          name: 'dataset_field_name',
          options: morpheus.MetadataUtil.getMetadataNames(
            isColumns ? dataset.getColumnMetadata() : dataset.getRowMetadata()),
          type: 'select',
          value: 'id',
          required: true
        }];

    };
    morpheus.HeatMap.showTool(promptTool, heatMap);

  },
  prompt: function (lines, dataset, heatMap, isColumns) {
    var promptTool = {};
    var _this = this;
    var header = lines != null ? lines[0].split('\t') : null;
    promptTool.execute = function (options) {
      var metadataName = options.input.dataset_field_name;
      var fileColumnName = options.input.file_field_name;
      var vectors = _this.annotate(lines, dataset, isColumns, null,
        metadataName, fileColumnName);

      var nameToIndex = new morpheus.Map();
      var display = [];
      for (var i = 0; i < vectors.length; i++) {
        display.push(isColumns ? 'color' : 'text');
        nameToIndex.set(vectors[i].getName(), i);
      }
      if (lines.colors) {
        var colorModel = isColumns
          ? heatMap.getProject().getColumnColorModel()
          : heatMap.getProject().getRowColorModel();
        lines.colors.forEach(function (item) {
          var index = nameToIndex.get(item.header);
          var vector = vectors[index];
          display[index] = 'color';
          colorModel.setMappedValue(vector, item.value, item.color);
        });
      }
      heatMap.getProject().trigger('trackChanged', {
        vectors: vectors,
        display: display,
        columns: isColumns
      });
    };
    promptTool.toString = function () {
      return 'Select Fields To Match On';
    };
    promptTool.gui = function () {
      var items = [
        {
          name: 'dataset_field_name',
          options: morpheus.MetadataUtil.getMetadataNames(
            isColumns ? dataset.getColumnMetadata() : dataset.getRowMetadata()),
          type: 'select',
          required: true
        }];
      if (lines) {
        items.push({
          name: 'file_field_name',
          type: 'select',
          options: _.map(header, function (item) {
            return {
              name: item,
              value: item
            };
          }),
          required: true
        });
      }
      return items;
    };
    morpheus.HeatMap.showTool(promptTool, heatMap);
  }
};

morpheus.SaveDatasetTool = function () {
};
morpheus.SaveDatasetTool.prototype = {
  toString: function () {
    return 'Save Dataset';
  },
  init: function (project, form) {
    form.find('file_name').prop('autofocus', true).focus();
    var seriesNames = [];
    var dataset = project.getFullDataset();
    for (var i = 0, nseries = dataset.getSeriesCount(); i < nseries; i++) {
      seriesNames.push(dataset.getName(i)); // TODO check data type
    }
    form.setOptions('series', seriesNames.length > 1 ? seriesNames : null);
    form.setVisible('series', seriesNames.length > 1);
  },
  gui: function () {
    return [
      {
        name: 'file_name',
        type: 'text',
        help: '<a target="_blank" href="http://support.lincscloud.org/hc/en-us/articles/202105453-GCT-Gene-Cluster-Text-Format-">GCT 1.3</a>'
        + ' or <a target="_blank" href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT 1.2</a> file name',
        required: true
      }, {
        name: 'file_format',
        type: 'radio',
        options: [{
          name: 'GCT version 1.2',
          value: '1.2'
        }, {
          name: 'GCT version 1.3',
          value: '1.3'
        }],
        value: '1.3',
      }, {
        name: 'series',
        type: 'select',
        options: [],
        required: true
      }, {
        name: 'save_selection_only',
        type: 'checkbox',
        required: true
      }];
  },
  execute: function (options) {
    var project = options.project;
    var format = options.input.file_format;
    var fileName = options.input.file_name;
    if (fileName === '') {
      fileName = 'dataset';
    }
    var series = options.input.series;
    var heatMap = options.heatMap;
    var dataset = options.input.save_selection_only ? project.getSelectedDataset() : project.getSortedFilteredDataset();
    var writer;
    if (format === '1.2') {
      writer = new morpheus.GctWriter12();
    } else if (format === '1.3') {
      writer = new morpheus.GctWriter();
    }

    if (series != null) {
      var seriesIndex = morpheus.DatasetUtil.getSeriesIndex(dataset, series);
      if (seriesIndex === -1) {
        seriesIndex = 0;
      }
      dataset = seriesIndex === 0 ? dataset : new morpheus.DatasetSeriesView(dataset, [seriesIndex]);
    }
    var ext = writer.getExtension ? writer.getExtension() : '';
    if (ext !== '' && !morpheus.Util.endsWith(fileName.toLowerCase(), '.' + ext)) {
      fileName += '.' + ext;
    }
    writer.setNumberFormat(heatMap.getHeatMapElementComponent().getDrawValuesFormat());
    var blobs = [];
    var textArray = [];
    var proxy = {
      push: function (text) {
        textArray.push(text);
        if (textArray.length === 10000) {
          var blob = new Blob([textArray.join('')], {type: 'text/plain;charset=charset=utf-8'});
          textArray = [];
          blobs.push(blob);
        }
      },
      join: function () {
        if (textArray.length > 0) {
          var blob = new Blob([textArray.join('')], {type: 'text/plain;charset=charset=utf-8'});
          blobs.push(blob);
          textArray = [];
        }

        var blob = new Blob(blobs, {type: 'text/plain;charset=charset=utf-8'});
        saveAs(blob, fileName, true);
      }
    };
    writer.write(dataset, proxy);
  }
};

morpheus.SaveImageTool = function () {

};
morpheus.SaveImageTool.prototype = {

  toString: function () {
    return 'Save Image';
  },
  init: function (project, form) {
    form.find('file_name').prop('autofocus', true).focus();
  },
  gui: function () {
    return [
      {
        name: 'file_name',
        type: 'text',
        required: true
      }, {
        name: 'format',
        type: 'radio',
        options: ['PDF', 'PNG', 'SVG'],
        value: 'PNG',
        required: true
      }];
  },
  execute: function (options) {
    var fileName = options.input.file_name;
    if (fileName === '') {
      fileName = 'image';
    }
    var format = options.input.format.toLowerCase();
    if (!morpheus.Util.endsWith(fileName.toLowerCase(), '.' + format)) {
      fileName += '.' + format;
    }
    var heatMap = options.heatMap;
    heatMap.saveImage(fileName, format);
  }
};

morpheus.SaveSessionTool = function () {
};
morpheus.SaveSessionTool.prototype = {
  toString: function () {
    return 'Save Session';
  },
  init: function (project, form) {
    form.find('file_name').prop('autofocus', true).focus();
  },
  gui: function () {
    return [
      {
        name: 'file_name',
        type: 'text',
        required: true
      }];
  },
  execute: function (options) {
    var fileName = options.input.file_name;
    if (fileName === '') {
      fileName = 'session.json';
    }
    if (!morpheus.Util.endsWith(fileName.toLowerCase(), '.json')) {
      fileName += '.json';
    }
    var heatMap = options.heatMap;
    // var options = {dataset: options.input.include_dataset};
    var options = {dataset: true};
    var json = heatMap.toJSON(options);
    var nativeArrayToArray = Array.from || function (typedArray) {
        var normalArray = Array.prototype.slice.call(typedArray);
        normalArray.length === typedArray.length;
        normalArray.constructor === Array;
      };
    var blob = new Blob([JSON.stringify(json, function (key, value) {
      if (morpheus.Util.isArray(value)) {
        return value instanceof Array ? value : nativeArrayToArray(value);
      }
      return value;
    })], {type: 'application/json;charset=charset=utf-8'});
    saveAs(blob, fileName, true);
  }
};

morpheus.SimilarityMatrixTool = function () {
};

morpheus.SimilarityMatrixTool.Functions = [morpheus.Euclidean,
  morpheus.Jaccard, morpheus.Cosine, morpheus.KendallsCorrelation, morpheus.Pearson, morpheus.Spearman];
morpheus.SimilarityMatrixTool.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.SimilarityMatrixTool.Functions.length; i++) {
    if (morpheus.SimilarityMatrixTool.Functions[i].toString() === s) {
      return morpheus.SimilarityMatrixTool.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};
morpheus.SimilarityMatrixTool.execute = function (dataset, input) {
  var isColumnMatrix = input.compute_matrix_for == 'Columns';
  var f = morpheus.SimilarityMatrixTool.Functions.fromString(input.metric);
  return morpheus.HCluster.computeDistanceMatrix(
    isColumnMatrix ? new morpheus.TransposedDatasetView(dataset)
      : dataset, f);
};
morpheus.SimilarityMatrixTool.prototype = {
  toString: function () {
    return 'Similarity Matrix';
  },
  init: function (project, form) {

  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.SimilarityMatrixTool.Functions,
      value: morpheus.SimilarityMatrixTool.Functions[4].toString(),
      type: 'select'
    }, {
      name: 'compute_matrix_for',
      options: ['Columns', 'Rows'],
      value: 'Columns',
      type: 'radio'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var isColumnMatrix = options.input.compute_matrix_for == 'Columns';
    var f = morpheus.SimilarityMatrixTool.Functions
    .fromString(options.input.metric);
    var dataset = project.getSortedFilteredDataset();
    var blob = new Blob(
      ['self.onmessage = function(e) {'
      + 'importScripts(e.data.scripts);'
      + 'self.postMessage(morpheus.SimilarityMatrixTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
      + '}']);

    var url = window.URL.createObjectURL(blob);
    var worker = new Worker(url);

    worker.postMessage({
      scripts: morpheus.Util.getScriptPath(),
      dataset: morpheus.Dataset.toJSON(dataset, {
        columnFields: [],
        rowFields: [],
        seriesIndices: [0]
      }),
      input: options.input
    });

    worker.onmessage = function (e) {
      var name = heatMap.getName();
      var matrix = e.data;
      var n = isColumnMatrix ? dataset.getColumnCount() : dataset
      .getRowCount();
      var d = new morpheus.Dataset({
        name: name,
        rows: n,
        columns: n
      });
      // set the diagonal
      var isDistance = f.toString() === morpheus.Euclidean.toString()
        || f.toString() === morpheus.Jaccard.toString();
      for (var i = 1; i < n; i++) {
        for (var j = 0; j < i; j++) {
          var value = matrix[i][j];
          d.setValue(i, j, value);
          d.setValue(j, i, value);
        }
      }
      // no need to set diagonal if not distance as array already
      // initialized to 0
      if (!isDistance) {
        for (var i = 0; i < n; i++) {
          d.setValue(i, i, 1);
        }
      }
      var metadata = isColumnMatrix ? dataset.getColumnMetadata()
        : dataset.getRowMetadata();
      d.rowMetadataModel = morpheus.MetadataUtil.shallowCopy(metadata);
      d.columnMetadataModel = morpheus.MetadataUtil.shallowCopy(metadata);
      var colorScheme;
      if (!isDistance) {
        colorScheme = {
          type: 'fixed',
          map: [{
            value: -1,
            color: 'blue'
          }, {
            value: 0,
            color: 'white'
          }, {
            value: 1,
            color: 'red'
          }]
        };
      } else {
        colorScheme = {
          type: 'fixed',
          map: [{
            value: 0,
            color: 'white'
          }, {
            value: morpheus.DatasetUtil.max(d),
            color: 'red'
          }]
        };
      }
      new morpheus.HeatMap({
        colorScheme: colorScheme,
        name: name,
        dataset: d,
        parent: heatMap,
        inheritFromParentOptions: {
          rows: !isColumnMatrix,
          columns: isColumnMatrix
        }
      });
      worker.terminate();
      window.URL.revokeObjectURL(url);
    };
    return worker;
  }
};

morpheus.TransposeTool = function () {
};
morpheus.TransposeTool.prototype = {
  toString: function () {
    return 'Transpose';
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var dataset = new morpheus.TransposedDatasetView(project
    .getSortedFilteredDataset());
    // make a shallow copy of the dataset, metadata is immutable via the UI
    var rowMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getRowMetadata());
    var columnMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getColumnMetadata());
    dataset.getRowMetadata = function () {
      return rowMetadataModel;
    };
    dataset.getColumnMetadata = function () {
      return columnMetadataModel;
    };

    // TODO see if we can subset dendrograms
    // only handle contiguous selections for now
    // if (heatMap.columnDendrogram != null) {
    // var indices = project.getColumnSelectionModel().getViewIndices()
    // .toArray();
    // morpheus.DendrogramUtil.leastCommonAncestor();
    // }
    // if (heatMap.rowDendrogram != null) {
    //
    // }
    var name = options.input.name || heatMap.getName();
    new morpheus.HeatMap({
      name: name,
      dataset: dataset,
      inheritFromParentOptions: {
        transpose: true
      },
      parent: heatMap
    });

  }
};

morpheus.TsneTool = function () {
};

morpheus.TsneTool.execute = function (dataset, input) {
  // note: in worker here
  var matrix = [];
  var rows = input.project == 'Rows';
  if (!rows) {
    dataset = new morpheus.TransposedDatasetView(dataset);
  }
  var N = dataset.getRowCount();
  var f = morpheus.HClusterTool.Functions.fromString(input.metric);
  if (f === morpheus.TsneTool.PRECOMPUTED_DIST) {
    for (var i = 0; i < N; i++) {
      matrix.push([]);
      for (var j = i + 1; j < N; j++) {
        matrix[i][j] = dataset.getValue(i, j);
      }
    }
  } else if (f === morpheus.TsneTool.PRECOMPUTED_SIM) {
    var max = morpheus.DatasetUtil.max(dataset);
    for (var i = 0; i < N; i++) {
      matrix.push([]);
      for (var j = i + 1; j < N; j++) {
        matrix[i][j] = max - dataset.getValue(i, j);
      }
    }
  } else {
    var list1 = new morpheus.DatasetRowView(dataset);
    var list2 = new morpheus.DatasetRowView(dataset);
    for (var i = 0; i < N; i++) {
      matrix.push([]);
      list1.setIndex(i);
      for (var j = i + 1; j < N; j++) {
        var d = f(list1, list2.setIndex(j));
        matrix[i][j] = d;
      }
    }
  }
  var opt = {};
  opt.epsilon = input.epsilon;
  opt.perplexity = input.perplexity;
  opt.dim = 2;
  var tsne = new tsnejs.tSNE(opt);
  tsne.initDataDist(matrix);
  for (var k = 0; k < 1000; k++) {
    tsne.step();
  }
  var Y = tsne.getSolution();
  return {solution: Y};

}
;
morpheus.TsneTool.prototype = {
  toString: function () {
    return 't-SNE';
  },
  init: function (project, form) {

  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.HClusterTool.Functions,
      value: morpheus.HClusterTool.Functions[3].toString(),
      type: 'select'
    }, {
      name: 'project',
      options: ['Columns', 'Rows'],
      value: 'Columns',
      type: 'select'
    }, {
      name: 'epsilon',
      value: '10',
      type: 'text',
      help: 'learning rate'
    }, {
      name: 'perplexity',
      value: '30',
      type: 'text',
      help: 'number of effective nearest neighbors'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var rows = options.input.project == 'Rows';
    var dataset = project.getSortedFilteredDataset();
    options.input.epsilon = parseInt(options.input.epsilon);
    options.input.perplexity = parseInt(options.input.perplexity);
    var blob = new Blob(
      ['self.onmessage = function(e) {'
      + 'e.data.scripts.forEach(function (s) { importScripts(s); });'
      + 'self.postMessage(morpheus.TsneTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
      + '}']);

    var url = URL.createObjectURL(blob);
    var worker = new Worker(url);

    worker.postMessage({
      scripts: [morpheus.Util.getScriptPath()],
      dataset: morpheus.Dataset.toJSON(dataset, {
        columnFields: [],
        rowFields: [],
        seriesIndices: [0]
      }),
      input: options.input
    });

    worker.onmessage = function (e) {
      if (rows) {
        dataset = new morpheus.TransposedDatasetView(dataset);
      }
      var result = e.data.solution;

      var newDataset = new morpheus.Dataset({
        name: 't-SNE',
        rows: dataset.getColumnCount(),
        columns: 2
      });

      for (var i = 0; i < result.length; i++) {
        newDataset.setValue(i, 0, result[i][0]);
        newDataset.setValue(i, 1, result[i][1]);
      }
      var idVector = newDataset.getColumnMetadata().add('id');
      idVector.setValue(0, 'P1');
      idVector.setValue(1, 'P2');
      newDataset.setRowMetadata(morpheus.MetadataUtil.shallowCopy(dataset.getColumnMetadata()));
      var min = morpheus.DatasetUtil.min(newDataset);
      var max = morpheus.DatasetUtil.max(newDataset);
      new morpheus.HeatMap({
        inheritFromParentOptions: {transpose: !rows},
        name: 't-SNE',
        dataset: newDataset,
        parent: heatMap,
        columns: [{
          field: 'id',
          display: 'text'
        }],
        colorScheme: {
          type: 'fixed',
          map: [{
            value: min,
            color: colorbrewer.Greens[3][0]
          }, {
            value: max,
            color: colorbrewer.Greens[3][2]
          }]
        }
      });
      worker.terminate();
      window.URL.revokeObjectURL(url);
    };
    return worker;
  }
};

morpheus.AbstractCanvas = function (offscreen) {
  this.canvas = morpheus.CanvasUtil.createCanvas();
  this.lastClip = null;
  if (offscreen) {
    this.offscreenCanvas = morpheus.CanvasUtil.createCanvas();
  }
  this.offset = {
    x: 0,
    y: 0
  };
};

morpheus.AbstractCanvas.prototype = {
  visible: true,
  invalid: true,
  scrollX: 0,
  scrollY: 0,
  prefWidth: undefined,
  prefHeight: undefined,
  getCanvas: function () {
    return this.canvas;
  },
  scrollTop: function (pos) {
    if (pos === undefined) {
      return this.offset.y;
    }
    this.offset.y = pos;
  },
  appendTo: function ($el) {
    // if (this.offscreenCanvas) {
    // $(this.offscreenCanvas).appendTo($el);
    // }
    $(this.canvas).appendTo($el);
  },
  scrollLeft: function (pos) {
    if (pos === undefined) {
      return this.offset.x;
    }
    this.offset.x = pos;
  },
  dispose: function () {
    $(this.canvas).remove();
    this.offscreenCanvas = undefined;
  },
  getPrefWidth: function () {
    return this.prefWidth;
  },
  /**
   * Tells this canvas to invalidate any offscreen cached images
   */
  setInvalid: function (invalid) {
    this.invalid = invalid;
  },
  setBounds: function (bounds) {
    var backingScale = morpheus.CanvasUtil.BACKING_SCALE;
    var canvases = [this.canvas];
    if (this.offscreenCanvas) {
      canvases.push(this.offscreenCanvas);
    }
    if (bounds.height != null) {
      _.each(canvases, function (canvas) {
        canvas.height = bounds.height * backingScale;
        canvas.style.height = bounds.height + 'px';
      });
    }
    if (bounds.width != null) {
      _.each(canvases, function (canvas) {
        canvas.width = bounds.width * backingScale;
        canvas.style.width = bounds.width + 'px';
      });
    }
    if (bounds.left != null) {
      _.each(canvases, function (canvas) {
        canvas.style.left = bounds.left + 'px';
      });
    }
    if (bounds.top != null) {
      _.each(canvases, function (canvas) {
        canvas.style.top = bounds.top + 'px';
      });
    }
  },
  /**
   * Paint this canvas using the specified clip.
   */
  paint: function (clip) {
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    morpheus.CanvasUtil.resetTransform(context);
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    context.clearRect(0, 0, width, height);
    if (this.prePaint) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(this.offset.x, this.offset.y);
      this.prePaint(clip, context);
    }
    morpheus.CanvasUtil.resetTransform(context);
    if (this.offscreenCanvas) {
      if (this.invalid) {
        var oc = this.offscreenCanvas.getContext('2d');
        morpheus.CanvasUtil.resetTransform(oc);
        context.translate(this.offset.x, this.offset.y);
        oc.clearRect(0, 0, width, height);
        this.draw(clip, oc);
      }
      if (width>0 && height>0) {
        context.drawImage(this.offscreenCanvas, 0, 0, width, height);
      }
    } else {
      this.draw(clip, context);
    }
    if (this.postPaint) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(this.offset.x, this.offset.y);
      this.postPaint(clip, context);
    }
    this.lastClip = clip;
    this.invalid = false;
  },
  repaint: function () {
    if (!this.lastClip) {
      this.lastClip = {
        x: 0,
        y: 0,
        width: this.getUnscaledWidth(),
        height: this.getUnscaledHeight()
      };
    }
    this.paint(this.lastClip);
  },
  /**
   * Draw this canvas into the specified context.
   */
  draw: function (clip, context) {
    console.log('Not implemented');
  },
  getPrefHeight: function () {
    return this.prefHeight;
  },
  setPrefWidth: function (prefWidth) {
    this.prefWidth = prefWidth;
  },
  setPrefHeight: function (prefHeight) {
    this.prefHeight = prefHeight;
  },
  isVisible: function () {
    return this.visible;
  },
  setVisible: function (visible) {
    if (this.visible !== visible) {
      this.visible = visible;
      this.canvas.style.display = visible ? '' : 'none';
    }
  },
  getUnscaledWidth: function () {
    return this.canvas.width / morpheus.CanvasUtil.BACKING_SCALE;
  },
  getUnscaledHeight: function () {
    return this.canvas.height / morpheus.CanvasUtil.BACKING_SCALE;
  },
  getWidth: function () {
    return this.canvas.width;
  },
  getHeight: function () {
    return this.canvas.height;
  }
};

morpheus.AbstractColorSupplier = function () {
  this.fractions = [0, 0.5, 1];
  this.colors = ['#0000ff', '#ffffff', '#ff0000'];
  this.names = null; // optional color stop names
  this.min = 0;
  this.max = 1;
  this.missingColor = '#c0c0c0';
  this.scalingMode = morpheus.HeatMapColorScheme.ScalingMode.RELATIVE;
  this.stepped = false;
  this.sizer = new morpheus.HeatMapSizer();
  this.conditions = new morpheus.HeatMapConditions();
  this.transformValues = 0;// z-score, robust z-score
};
morpheus.AbstractColorSupplier.Z_SCORE = 1;
morpheus.AbstractColorSupplier.ROBUST_Z_SCORE = 2;

morpheus.AbstractColorSupplier.toJSON = function (cs) {
  var json = {
    fractions: cs.fractions,
    colors: cs.colors,
    min: cs.min,
    max: cs.max,
    missingColor: cs.missingColor,
    scalingMode: cs.scalingMode,
    stepped: cs.stepped,
    transformValues: cs.transformValues
  };
  if (cs.names) {
    json.names = cs.names;
  }
  if (cs.conditions && cs.conditions.array.length > 0) {
    json.conditions = cs.conditions.array;
  }
  if (cs.sizer && cs.sizer.seriesName != null) {
    json.size = {
      seriesName: cs.sizer.seriesName,
      min: cs.sizer.min,
      max: cs.sizer.max
    };
  }
  return json;
};
morpheus.AbstractColorSupplier.fromJSON = function (json) {
  var cs = json.stepped ? new morpheus.SteppedColorSupplier()
    : new morpheus.GradientColorSupplier();

  if (json.scalingMode == null && json.type != null) {
    json.scalingMode = json.type; // old
  }
  if (json.scalingMode === 'relative' || json.scalingMode === 0) {
    json.scalingMode = 0;
  } else if (json.scalingMode === 'fixed' || json.scalingMode === 1) {
    json.scalingMode = 1;
  } else { // default to relative
    json.scalingMode = 0;
  }
  cs.setScalingMode(json.scalingMode);
  if (json.min != null) {
    cs.setMin(json.min);
  }
  if (json.max != null) {
    cs.setMax(json.max);
  }
  if (json.missingColor != null) {
    cs.setMissingColor(json.missingColor);
  }
  if (morpheus.HeatMapColorScheme.ScalingMode.RELATIVE !== json.scalingMode) {
    cs.setTransformValues(json.transformValues);
  }

  if (json.map) { // old
    json.values = json.map.map(function (item) {
      return item.value;
    });
    json.colors = json.map.map(function (item) {
      return item.color;
    });
  }
  var fractions = json.fractions;
  if (json.values) { // map values to fractions
    fractions = [];
    var values = json.values;
    var min = Number.MAX_VALUE;
    var max = -Number.MAX_VALUE;
    for (var i = 0; i < values.length; i++) {
      var value = values[i];
      min = Math.min(min, value);
      max = Math.max(max, value);
    }
    var valueToFraction = d3.scale.linear().domain(
      [min, max]).range(
      [0, 1]).clamp(true);

    for (var i = 0; i < values.length; i++) {
      fractions.push(valueToFraction(values[i]));
    }
    if (json.min == null) {
      cs.setMin(min);
    }
    if (json.max == null) {
      cs.setMax(max);
    }
  }
  if (json.colors != null && json.colors.length > 0) {
    cs.setFractions({
      colors: json.colors,
      fractions: fractions,
      names: json.names
    });
  }
  if (json.size) {
    cs.getSizer().setSeriesName(json.size.seriesName);
    cs.getSizer().setMin(json.size.min);
    cs.getSizer().setMax(json.size.max);
  }

  if (json.conditions && _.isArray(json.conditions)) {
    // load conditions
    json.conditions.forEach(function (condition) {
      var gtf = function () {
        return true;
      };
      var ltf = function () {
        return true;
      };
      if (condition.seriesName == null) {
        condition.seriesName = condition.series; // series is deprecated
      }
      if (condition.v1 != null && !isNaN(condition.v1)) {
        gtf = condition.v1Op === 'gt' ? function (val) {
          return val > condition.v1;
        } : function (val) {
          return val >= condition.v1;
        };
      }

      if (condition.v2 != null && !isNaN(condition.v2)) {
        ltf = condition.v2Op === 'lt' ? function (val) {
          return val < condition.v2;
        } : function (val) {
          return val <= condition.v2;
        };
      }
      condition.accept = function (val) {
        return gtf(val) && ltf(val);
      };
    });
    cs.conditions.array = json.conditions;
  }
  return cs;
};

morpheus.AbstractColorSupplier.prototype = {
  getTransformValues: function () {
    return this.transformValues;
  },
  setTransformValues: function (transformValues) {
    this.transformValues = transformValues;
  },
  getSizer: function () {
    return this.sizer;
  },
  getConditions: function () {
    return this.conditions;
  },
  createInstance: function () {
    throw 'not implemented';
  },
  copy: function () {
    var c = this.createInstance();
    c.stepped = this.stepped;
    c.setFractions({
      fractions: this.fractions.slice(0),
      colors: this.colors.slice(0)
    });
    if (this.names != null) {
      c.names = this.names.slice(0);
    }
    if (this.sizer) {
      c.sizer = this.sizer.copy();
    }
    if (this.conditions) {
      c.conditions = this.conditions.copy();
    }
    c.scalingMode = this.scalingMode;
    c.min = this.min;
    c.max = this.max;
    c.missingColor = this.missingColor;
    if (this.scalingMode !== morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      c.transformValues = this.transformValues;
    }

    return c;
  },
  setMissingColor: function (missingColor) {
    this.missingColor = missingColor;
  },
  getMissingColor: function () {
    return this.missingColor;
  },
  getScalingMode: function () {
    return this.scalingMode;
  },
  setScalingMode: function (scalingMode) {
    if (scalingMode !== this.scalingMode) {
      if (scalingMode === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
        this.min = 0;
        this.max = 1;
      }
      this.scalingMode = scalingMode;
    }
  },
  isStepped: function () {
    return false;
  },
  getColor: function (row, column, value) {
    throw 'not implemented';
  },
  getColors: function () {
    return this.colors;
  },
  getNames: function () {
    return this.names;
  },
  getFractions: function () {
    return this.fractions;
  },
  getMin: function () {
    return this.min;
  },
  getMax: function () {
    return this.max;
  },
  setMin: function (min) {
    this.min = min;
  },
  setMax: function (max) {
    // the min and max are set by heat map color scheme for each row
    this.max = max;
  },
  /**
   *
   * @param options.fractions
   *            Array of stop fractions
   * @param options.colors
   *            Array of stop colors
   * @param options.names
   *            Array of stop names
   */
  setFractions: function (options) {
    var index = morpheus.Util.indexSort(options.fractions, true);
    this.fractions = morpheus.Util.reorderArray(options.fractions, index);
    this.colors = morpheus.Util.reorderArray(options.colors, index);
    this.names = options.names ? morpheus.Util.reorderArray(options.names,
      index) : null;
  }
};

morpheus.AbstractComponent = function () {
  this.lastClip = null;
  var c = document.createElement('div');
  c.setAttribute('tabindex', '0');
  c.style.outline = 0;
  c.style.overflow = 'hidden';
  c.style.position = 'absolute';
  this.el = c;
  this.$el = $(c);
};
morpheus.AbstractComponent.prototype = {
  visible: true,
  invalid: true,
  prefWidth: undefined,
  prefHeight: undefined,
  appendTo: function ($el) {
    $(this.el).appendTo($el);
  },
  dispose: function () {
    $(this.el).remove();
  },
  getPrefWidth: function () {
    return this.prefWidth;
  },
  /**
   * Tells this component to invalidate
   */
  setInvalid: function (invalid) {
    this.invalid = invalid;
  },
  setBounds: function (bounds) {
//		if (bounds.height != null) {
//			this.el.style.height = bounds.height + 'px';
//		}
//		if (bounds.width != null) {
//			this.el.style.width = bounds.width + 'px';
//		}
    if (bounds.left != null) {
      this.$el.css('left', bounds.left + 'px');
    }
    if (bounds.top != null) {
      this.$el.css('top', bounds.top + 'px');
    }
  },
  /**
   * Paint this canvas using the specified clip.
   */
  paint: function (clip) {
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    this.draw(clip);
    this.lastClip = clip;
    this.invalid = false;
  },
  repaint: function () {
    if (!this.lastClip) {
      this.lastClip = {
        x: 0,
        y: 0,
        width: this.getUnscaledWidth(),
        height: this.getUnscaledHeight()
      };
    }
    this.paint(this.lastClip);
  },
  /**
   * Draw this canvas into the specified context.
   */
  draw: function (clip) {
  },
  getPrefHeight: function () {
    return this.prefHeight;
  },
  setPrefWidth: function (prefWidth) {
    this.prefWidth = prefWidth;
  },
  setPrefHeight: function (prefHeight) {
    this.prefHeight = prefHeight;
  },
  isVisible: function () {
    return this.visible;
  },
  setVisible: function (visible) {
    if (this.visible !== visible) {
      this.visible = visible;
      this.el.style.display = visible ? '' : 'none';
    }
  },
  getUnscaledWidth: function () {
    return this.$el.width();
  },
  getUnscaledHeight: function () {
    return this.$el.height();
  },
  getWidth: function () {
    return this.$el.width();
  },
  getHeight: function () {
    return this.$el.height();
  }
};

/*
 *
 * @param tree An object with maxHeight, rootNode, leafNodes, nLeafNodes. Each node has an id
 * (integer), name (string), children, depth, height, minIndex, maxIndex, parent. Leaf nodes also
 * have an index.
 The root has the largest height, leaves the smallest height.

 */
morpheus.AbstractDendrogram = function (heatMap, tree, positions, project,
                                        type) {
  morpheus.AbstractCanvas.call(this, true);

  this._overviewHighlightColor = '#d8b365';
  this._searchHighlightColor = '#e41a1c';
  this._selectedNodeColor = type === morpheus.AbstractDendrogram.Type.COLUMN ? '#377eb8'
    : '#984ea3';
  this.tree = tree;
  this.type = type;
  this.squishEnabled = false;
  this.heatMap = heatMap;
  this.positions = positions;
  this.project = project;
  var $label = $('<span></span>');
  $label.addClass('label label-info');
  $label.css('position', 'absolute');
  this.$label = $label;
  var $squishedLabel = $('<span></span>');
  $squishedLabel.addClass('label label-default');
  $squishedLabel.css('position', 'absolute').css('top', 18);
  this.$squishedLabel = $squishedLabel;
  this.$label = $label;
  this.cutHeight = this.tree.maxHeight;
  this.drawLeafNodes = true;
  this.lineWidth = 0.7;
  this.selectedNodeIds = {};
  this.selectedRootNodeIdToNode = {};
  this.nodeIdToHighlightedPathsToRoot = {};
  var _this = this;
  this.defaultStroke = 'rgb(0,0,0)';
  this.mouseMoveNodes = null;
  var mouseMove = function (event) {
    if (!morpheus.CanvasUtil.dragging) {
      var position = morpheus.CanvasUtil.getMousePosWithScroll(
        event.target, event, _this.lastClip.x, _this.lastClip.y);
      if (_this.isDragHotSpot(position)) { // dendrogram cutter
        _this.canvas.style.cursor = _this.getResizeCursor();
      } else {
        var nodes;
        if (_this.getNodes) {
          nodes = _this.getNodes(position);
        } else {
          var node = _this.getNode(position);
          if (node) {
            nodes = [node];
          }
        }
        _this.mouseMoveNodes = nodes;
        if (nodes != null) {
          nodes.sort(function (a, b) {
            return a.name < b.name;
          });
          var tipOptions = {
            event: event
          };
          tipOptions[type === morpheus.AbstractDendrogram.Type.COLUMN ? 'columnNodes'
            : 'rowNodes'] = nodes;
          _this.heatMap.setToolTip(-1, -1, tipOptions);
          _this.canvas.style.cursor = 'pointer';
        } else {
          _this.heatMap.setToolTip(-1, -1);
          _this.canvas.style.cursor = 'default';
        }
      }
    }
  };
  var mouseExit = function (e) {
    if (!morpheus.CanvasUtil.dragging) {
      _this.mouseMoveNodes = null;
      _this.canvas.style.cursor = 'default';
    }
  };
  if (type !== morpheus.AbstractDendrogram.Type.RADIAL) {

    $(this.canvas).on(
      'contextmenu',
      function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        var position = morpheus.CanvasUtil.getMousePosWithScroll(e.target,
          e, _this.lastClip.x,
          _this.lastClip.y);
        var selectedNode = _this.getNode(position);
        morpheus.Popup.showPopup(
          [
            {
              name: 'Flip',
              disabled: selectedNode == null
            }, {
            name: 'Branch Color',
            disabled: selectedNode == null
          }, {
            separator: true
          },
            {
              name: 'Annotate...'
            }, {
            name: 'Save'
          }, {
            separator: true
          }, {
            name: 'Enrichment...'
          }, {
            separator: true
          }, {
            name: 'Squish Singleton Clusters',
            checked: _this.squishEnabled
          }, {
            separator: true
          }, {
            name: 'Delete'
          }],
          {
            x: e.pageX,
            y: e.pageY
          },
          e.target,
          function (menuItem, item) {
            if (item === 'Save') {
              var formBuilder = new morpheus.FormBuilder();
              formBuilder.append({
                name: 'file_name',
                type: 'text',
                required: true
              });
              formBuilder.append({
                name: 'leaf_node_id_field',
                type: 'bootstrap-select',
                required: true,
                options: morpheus.MetadataUtil.getMetadataNames(
                  type === morpheus.AbstractDendrogram.Type.COLUMN
                    ? project.getFullDataset().getColumnMetadata()
                    : project.getFullDataset().getRowMetadata())
              });
              morpheus.FormBuilder.showOkCancel({
                title: 'Save Dendrogram',
                content: formBuilder.$form,
                focus: document.activeElement,
                okCallback: function () {
                  var fileName = formBuilder.getValue('file_name');
                  if (fileName === '') {
                    fileName = 'dendrogram.txt';
                  }
                  var leafNodeIdField = formBuilder.getValue('leaf_node_id_field');
                  var out = [];
                  var vector = type === morpheus.AbstractDendrogram.Type.COLUMN
                    ? project.getFullDataset().getColumnMetadata().getByName(leafNodeIdField)
                    : project.getFullDataset().getRowMetadata().getByName(leafNodeIdField);
                  var leafNodeToString = function (n) {
                    return vector.getValue(n.index);
                  };
                  morpheus.DendrogramUtil.writeNewick(tree.rootNode, out, leafNodeToString);
                  var blob = new Blob([out.join('')], {type: 'text/plain;charset=charset=utf-8'});
                  saveAs(blob, fileName, true);
                }
              });
            } else if (item === 'Flip') {
              if (selectedNode != null) {
                var isColumns = morpheus.AbstractDendrogram.Type.COLUMN === _this.type;
                var min = selectedNode.minIndex;
                var max = selectedNode.maxIndex;

                // morpheus.DendrogramUtil.dfs(selectedNode, function (n) {
                //   if (n.children) {
                //     n.children.reverse();
                //   }
                //   return true;
                // });

                var leafNodes = tree.leafNodes;
                for (var i = min, index = max; i <= max; i++, index--) {
                  var n = leafNodes[i];
                  n.index = index;
                  n.maxIndex = index;
                  n.minIndex = index;
                }

                leafNodes.sort(function (a, b) {
                  return (a.index < b.index ? -1 : 1);
                });
                var setIndex = function (n) {
                  if (n.children != null && n.children.length > 0) {
                    for (var i = 0; i < n.children.length; i++) {
                      setIndex(n.children[i]);
                    }
                    var sum = 0;
                    for (var i = 0; i < n.children.length; i++) {
                      sum += n.children[i].index;
                    }
                    n.index = sum / n.children.length;
                    var maxIndex = -Number.MAX_VALUE;
                    var minIndex = Number.MAX_VALUE;
                    for (var i = 0; i < n.children.length; i++) {
                      maxIndex = Math.max(maxIndex, n.children[i].maxIndex);
                      minIndex = Math.min(minIndex, n.children[i].minIndex);
                    }
                    n.minIndex = minIndex;
                    n.maxIndex = maxIndex;
                  }
                };

                setIndex(selectedNode);

                var currentOrder = [];
                var count = isColumns ? heatMap.getProject().getSortedFilteredDataset().getColumnCount() : heatMap.getProject()
                  .getSortedFilteredDataset()
                  .getRowCount();
                for (var i = 0; i < count; i++) {
                  currentOrder.push(isColumns ? project.convertViewColumnIndexToModel(i) : project.convertViewRowIndexToModel(i));
                }
                for (var i = min, j = max; i < j; i++, j--) {
                  var tmp = currentOrder[j];
                  currentOrder[j] = currentOrder[i];
                  currentOrder[i] = tmp;
                }
                var key = new morpheus.SpecifiedModelSortOrder(currentOrder, currentOrder.length, 'dendrogram', isColumns);
                key.setPreservesDendrogram(true);
                key.setLockOrder(2);
                key.setUnlockable(false);
                if (isColumns) {
                  heatMap.getProject().setColumnSortKeys([key], true);
                } else {
                  heatMap.getProject().setRowSortKeys([key], true);
                }
                heatMap.revalidate();
              }

            } else if (item === 'Branch Color') {
              if (selectedNode != null) {
                var formBuilder = new morpheus.FormBuilder();
                formBuilder.append({
                  name: 'color',
                  type: 'color',
                  value: selectedNode.color,
                  required: true,
                  style: 'max-width:50px;'
                });
                formBuilder.find('color').on(
                  'change',
                  function () {
                    var color = $(this).val();
                    morpheus.DendrogramUtil.dfs(selectedNode, function (n) {
                      n.color = color;
                      return true;
                    });
                    _this.setSelectedNode(null);
                  });
                morpheus.FormBuilder.showInModal({
                  title: 'Color',
                  close: 'Close',
                  html: formBuilder.$form,
                  focus: document.activeElement
                });

              }
            } else if (item === 'Annotate...') {
              morpheus.HeatMap.showTool(
                new morpheus.AnnotateDendrogramTool(
                  type === morpheus.AbstractDendrogram.Type.COLUMN),
                _this.heatMap);
            } else if (item === 'Enrichment...') {
              morpheus.HeatMap.showTool(
                new morpheus.DendrogramEnrichmentTool(
                  type === morpheus.AbstractDendrogram.Type.COLUMN),
                _this.heatMap);
            } else if (item === 'Squish Singleton Clusters') {
              _this.squishEnabled = !_this.squishEnabled;
              if (!_this.squishEnabled) {
                _this.positions.setSquishedIndices(null);
              }
            } else if (item === 'Delete') {
              _this.resetCutHeight();
              _this.heatMap.setDendrogram(
                null,
                type === morpheus.AbstractDendrogram.Type.COLUMN);
            }
          });
        return false;
      });

    $(this.canvas).on('mousemove', _.throttle(mouseMove, 100)).on(
      'mouseout', _.throttle(mouseExit, 100)).on('mouseenter',
      _.throttle(mouseMove, 100));
  }
  var dragStartScaledCutHeight = 0;
  this.cutTreeHotSpot = false;
  if (type !== morpheus.AbstractDendrogram.Type.RADIAL) {
    this.hammer = morpheus.Util.hammer(this.canvas, ['pan', 'tap']).on(
      'tap',
      this.tap = function (event) {
        if (!morpheus.CanvasUtil.dragging) {
          var position = morpheus.CanvasUtil.getMousePosWithScroll(event.target,
            event, _this.lastClip.x,
            _this.lastClip.y);
          _this.cutTreeHotSpot = _this.isDragHotSpot(position);
          if (_this.cutTreeHotSpot) {
            return;
          }
          var node = _this.getNode(position);
          if (node != null && node.parent === undefined) {
            node = null; // can't select root
          }
          var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
            : event.srcEvent.ctrlKey;
          _this.setSelectedNode(node,
            event.srcEvent.shiftKey || commandKey);
        }
      }).on('panend', this.panend = function (event) {
      morpheus.CanvasUtil.dragging = false;
      _this.canvas.style.cursor = 'default';
      _this.cutTreeHotSpot = true;
    }).on(
      'panstart',
      this.panstart = function (event) {
        var position = morpheus.CanvasUtil.getMousePosWithScroll(event.target, event,
          _this.lastClip.x, _this.lastClip.y,
          true);
        _this.cutTreeHotSpot = _this.isDragHotSpot(position);
        if (_this.cutTreeHotSpot) { // make sure start event
          // was on hotspot
          morpheus.CanvasUtil.dragging = true;
          _this.canvas.style.cursor = _this.getResizeCursor();
          dragStartScaledCutHeight = _this.scale(_this.cutHeight);
        }
      }).on(
      'panmove',
      this.panmove = function (event) {
        if (_this.cutTreeHotSpot) {
          var cutHeight;
          if (_this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
            var delta = event.deltaY;
            cutHeight = Math.max(
              0,
              Math.min(
                _this.tree.maxHeight,
                _this.scale.invert(dragStartScaledCutHeight
                  + delta)));
          } else if (_this.type === morpheus.AbstractDendrogram.Type.ROW) {
            var delta = event.deltaX;
            cutHeight = Math.max(
              0,
              Math.min(
                _this.tree.maxHeight,
                _this.scale.invert(dragStartScaledCutHeight
                  + delta)));
          } else {
            var point = morpheus.CanvasUtil.getMousePos(event.target, event);
            point.x = _this.radius - point.x;
            point.y = _this.radius - point.y;
            var radius = Math.sqrt(point.x * point.x
              + point.y * point.y);
            if (radius <= 4) {
              cutHeight = _this.tree.maxHeight;
            } else {
              cutHeight = Math.max(0, Math.min(
                _this.tree.maxHeight,
                _this.scale.invert(radius)));
            }
          }
          if (cutHeight >= _this.tree.maxHeight) {
            _this.resetCutHeight();
          } else {
            _this.setCutHeight(cutHeight);
          }
          event.preventDefault();
        }
      });
  }
};
morpheus.AbstractDendrogram.Type = {
  COLUMN: 0,
  ROW: 1,
  RADIAL: 2
};
morpheus.AbstractDendrogram.prototype = {
  setSelectedNode: function (node, add) {
    var _this = this;
    var viewIndices;
    var selectionModel = this.type === morpheus.AbstractDendrogram.Type.COLUMN ? this.project.getColumnSelectionModel()
      : this.project.getRowSelectionModel();
    if (node == null) {
      // clear selection
      _this.selectedNodeIds = {};
      _this.selectedRootNodeIdToNode = {};
      viewIndices = new morpheus.Set();
    } else {
      if (add) { // add to selection
        viewIndices = selectionModel.getViewIndices();
      } else {
        viewIndices = new morpheus.Set();
        _this.selectedNodeIds = {};
        _this.selectedRootNodeIdToNode = {};
      }
      if (node != null) {
        if (node.children === undefined) { // leaf node
          var contains = _this.nodeIdToHighlightedPathsToRoot[node.id];
          if (!add) {
            _this.nodeIdToHighlightedPathsToRoot = {};
          }
          if (contains) {
            delete _this.nodeIdToHighlightedPathsToRoot[node.id];
            // toggle
          } else {
            _this.nodeIdToHighlightedPathsToRoot[node.id] = node;
          }
        } else {
          _this.selectedRootNodeIdToNode[node.id] = node;
          morpheus.DendrogramUtil.dfs(node, function (d) {
            _this.selectedNodeIds[d.id] = true;
            return true;
          });
        }
        for (var i = node.minIndex; i <= node.maxIndex; i++) {
          viewIndices.add(i);
        }
      }
    }
    _this.trigger('nodeSelectionChanged', _this.selectedRootNodeIdToNode);
    selectionModel.setViewIndices(viewIndices, true);
    _this.repaint();
  },
  getPathStroke: function (node) {
    if (this.selectedNodeIds[node.id]) {
      return this._selectedNodeColor;
    }
    if (node.color !== undefined) {
      return node.color;
    }
    // if (node.search) {
    // return this._searchHighlightColor;
    // }
    return this.defaultStroke;
  },
  /**
   *
   * @param node
   * @return The color, if any, to draw a circle for a node in the dendrogram
   */
  getNodeFill: function (node) {
    if (this.selectedRootNodeIdToNode[node.id]) {
      return this._selectedNodeColor;
    }
    if (node.search) {
      return this._searchHighlightColor;
    }
    if (node.info !== undefined) {
      return this._overviewHighlightColor;
    }

  },
  resetCutHeight: function () {
    this.positions.setSquishedIndices(null);
    if (this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
      this.project.setGroupColumns([], true);
    } else {
      this.project.setGroupRows([], true);
    }
    this.$label.text('');
    this.$squishedLabel.text('');
    var dataset = this.project.getSortedFilteredDataset();
    var clusterIdVector = this.type === morpheus.AbstractDendrogram.Type.COLUMN ? dataset.getColumnMetadata().getByName('dendrogram_cut')
      : dataset.getRowMetadata().getByName('dendrogram_cut');
    if (clusterIdVector) {
      for (var i = 0, size = clusterIdVector.size(); i < size; i++) {
        clusterIdVector.setValue(i, NaN);
      }
    }
  },
  setCutHeight: function (height) {
    this.cutHeight = height;
    var squishedIndices = {};
    var clusterNumber = 0;
    var nsquished = 0;

    var squishEnabled = this.squishEnabled;
    var roots = morpheus.DendrogramUtil.cutAtHeight(this.tree.rootNode,
      this.cutHeight);
    var dataset = this.project.getSortedFilteredDataset();
    var clusterIdVector = this.type === morpheus.AbstractDendrogram.Type.COLUMN ? dataset.getColumnMetadata().add('dendrogram_cut')
      : dataset.getRowMetadata().add('dendrogram_cut');
    for (var i = 0, nroots = roots.length; i < nroots; i++) {
      var root = roots[i];
      var minChild = morpheus.DendrogramUtil.getDeepestChild(root,
        true);
      var maxChild = morpheus.DendrogramUtil.getDeepestChild(root,
        false);
      var clusterId;
      if (squishEnabled && minChild.index === maxChild.index) {
        squishedIndices[minChild.index] = true;
        clusterId = -2;
        nsquished++;
      } else {
        clusterNumber++;
        clusterId = clusterNumber;
      }
      for (var j = minChild.index; j <= maxChild.index; j++) {
        clusterIdVector.setValue(j, clusterId);
      }

    }
    this.$label.text((clusterNumber) + ' cluster'
      + morpheus.Util.s(clusterNumber));
    if (nsquished > 0) {
      this.$squishedLabel.text(nsquished + ' squished');
    } else {
      this.$squishedLabel.text('');
    }
    if (squishEnabled) {
      this.positions.setSquishedIndices(squishedIndices);
    }
    if (this.heatMap.getTrackIndex(clusterIdVector.getName(),
        this.type === morpheus.AbstractDendrogram.Type.COLUMN) === -1) {
      var settings = {
        discrete: true,
        discreteAutoDetermined: true,
        display: ['color']
      };

      this.heatMap.addTrack(clusterIdVector.getName(),
        this.type === morpheus.AbstractDendrogram.Type.COLUMN,
        settings);
    }

    if (this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
      this.project.setGroupColumns([new morpheus.SortKey(clusterIdVector.getName(), morpheus.SortKey.SortOrder.UNSORTED)], true);
    } else {
      this.project.setGroupRows([new morpheus.SortKey(clusterIdVector.getName(), morpheus.SortKey.SortOrder.UNSORTED)], true);
    }
  },
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.$label.remove();
    this.$squishedLabel.remove();
    this.hammer.off('panend', this.panend).off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap);
    this.hammer.destroy();
    this.$label = null;
    this.$squishedLabel = null;
  },
  isCut: function () {
    return this.cutHeight < this.tree.maxHeight;
  },
  getMinIndex: function () {
    return 0;
  },
  getMaxIndex: function () {
    return this.positions.getLength() - 1;
  },
  getNode: function (p) {
    var _this = this;
    if (this.lastNode) {
      var xy = _this.toPix(this.lastNode);
      if (Math.abs(xy[0] - p.x) < 4 && Math.abs(xy[1] - p.y) < 4) {
        return this.lastNode;
      }
    }
    this.lastNode = this._getNode(p);
    return this.lastNode;
  },
  // getNode : function(p) {
  // var x = p.x;
  // var y = p.y;
  // var leafIndex = this.positions.getIndex(x, true);
  // if (leafIndex >= 0 && leafIndex < leafNodeIds.length) {
  // leafid = leafNodeIds[leafIndex];
  // } else {
  // return null;
  // }
  // var n = leafNodes.get(leafid);
  // if (n != null) {
  // while (!n.isRoot()) {
  // var parent = n.getParent();
  // getNodePosition(parent, p);
  // if (Math.abs(p.x - x) < 4 && Math.abs(p.y - y) < 4) {
  // return parent;
  // }
  // n = parent;
  // }
  // }
  // return null;
  // },
  _getNode: function (p) {
    var _this = this;
    // brute force search
    var hit = null;
    try {
      morpheus.DendrogramUtil.dfs(this.tree.rootNode, function (node) {
        var xy = _this.toPix(node);
        if (Math.abs(xy[0] - p.x) < 4 && Math.abs(xy[1] - p.y) < 4) {
          hit = node;
          throw 'break';
        }
        return hit === null;
      });
    }
    catch (x) {
      // break of out dfs
    }
    return hit;
  },
  getResizeCursor: function () {
    if (this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
      return 'ns-resize';
    } else if (this.type === morpheus.AbstractDendrogram.Type.ROW) {
      return 'ew-resize';
    }
    return 'nesw-resize';
  },
  isDragHotSpot: function (p) {
    return false;
  },
  preDraw: function (context, clip) {
  },
  postDraw: function (context, clip) {
  },
  prePaint: function (clip, context) {
    this.scale = this.createScale();
    var min = this.getMinIndex(clip);
    var max = this.getMaxIndex(clip);
    if (min !== this.lastMinIndex || max !== this.lastMinIndex) {
      this.lastMinIndex = min;
      this.lastMaxIndex = max;
    }
    this.invalid = true;
  },
  draw: function (clip, context) {
    context.translate(-clip.x, -clip.y);
    context.strokeStyle = 'black';
    context.fillStyle = 'black';
    this.scale = this.createScale();
    var min = this.lastMinIndex;
    var max = this.lastMaxIndex;
    context.lineWidth = this.lineWidth;
    this.preDraw(context, clip);
    context.strokeStyle = this.defaultStroke;
    context.fillStyle = 'rgba(166,206,227,0.5)';
    this.drawDFS(context, this.tree.rootNode, min, max, 0);
    context.strokeStyle = 'black';
    context.fillStyle = 'black';
    this.postDraw(context, clip);
  },
  /**
   * @abstract
   */
  drawCutSlider: function () {
    throw new Error();
  },
  postPaint: function (clip, context) {
    context.strokeStyle = 'black';
    this.paintMouseOver(clip, context);
    this.drawCutSlider(clip, context);
    // this.drawHighlightedPathsToRoot(context, this.lastMinIndex,
    // this.lastMaxIndex);
  },
  // drawHighlightedPathsToRoot : function(context, minIndex, maxIndex) {
  // context.lineWidth = 1;
  // context.strokeStyle = 'black';
  // context.textAlign = 'left';
  // var i = 0;
  // for ( var key in this.nodeIdToHighlightedPathsToRoot) {
  // context.fillStyle = '#99d594';
  // context.strokeStyle = context.fillStyle;
  // var node = this.nodeIdToHighlightedPathsToRoot[key];
  // if (node.collapsed) {
  // for (var node = node.parent; node.collapsedChildren != null; node =
  // node.parent) {
  // node = node.parent;
  // }
  // }
  // // var pix = this.toPix(node);
  // // context.globalAlpha = 0.5;
  // // context.beginPath();
  // // context.arc(pix[0], pix[1], 8, Math.PI * 2, false);
  // // context.fill();
  // // context.globalAlpha = 1;
  // for (var root = node; root.parent !== undefined; root = root.parent) {
  // this
  // .drawPathFromNodeToParent(context, root, minIndex,
  // maxIndex);
  // }
  // i++;
  // }
  // },
  getNodeRadius: function (node) {
    // if (this._nodeRadiusScaleField != null) {
    // var vals = node.info[this._nodeRadiusScaleField];
    // if (vals === undefined) {
    // return 4;
    // }
    // // TODO get max or min
    // return this._nodeRadiusScale(vals[0]) * 8;
    // }
    return 4;
  },

  drawNode: function (context, node) {
  },
  drawDFS: function (context, node, minIndex, maxIndex) {
    if (this.type !== morpheus.AbstractDendrogram.Type.RADIAL) {
      if ((node.maxIndex < minIndex) || (node.minIndex > maxIndex)) {
        return;
      }
    }
    var nodeFill = this.getNodeFill(node);
    if (nodeFill !== undefined) {
      context.fillStyle = nodeFill;
      this.drawNode(context, node);
    }
    context.strokeStyle = this.getPathStroke(node);
    var children = node.children;
    if (children !== undefined) {
      this.drawNodePath(context, node, minIndex, maxIndex);
      for (var i = 0, nchildren = children.length; i < nchildren; i++) {
        this.drawDFS(context, children[i], minIndex, maxIndex);
      }

    }
  }
};

morpheus.Util.extend(morpheus.AbstractDendrogram, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.AbstractDendrogram, morpheus.Events);

/**
 * Action object contains
 * @param options.which Array of key codes
 * @param options.shift Whether shift key is required
 * @param options.commandKey Whether command key is required
 * @param options.name Shortcut name
 * @param options.cb Function callback
 * @param options.accept Additional function to test whether to accept shortcut
 * @param options.icon Optional icon to display
 */
morpheus.ActionManager = function () {
  this.actionNameToAction = new morpheus.Map();
  this.actions = [];
  // TODO copy all row/column metadata
  // pin/unpin tab,
  // header stuff-display, delete.
  this.add({
    ellipsis: true,
    name: 'Sort/Group',
    cb: function (options) {
      new morpheus.SortDialog(options.heatMap.getProject());
    },
    icon: 'fa fa-sort-alpha-asc'
  });

  var $filterModal = null;
  this.add({
    name: 'Filter',
    ellipsis: true,
    cb: function (options) {
      if ($filterModal == null) {
        var filterModal = [];
        var filterLabelId = _.uniqueId('morpheus');
        filterModal
          .push('<div class="modal" tabindex="1" role="dialog" aria-labelledby="'
            + filterLabelId + '">');
        filterModal.push('<div class="modal-dialog" role="document">');
        filterModal.push('<div class="modal-content">');
        filterModal.push('<div class="modal-header">');
        filterModal
          .push('<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>');
        filterModal.push('<h4 class="modal-title" id="' + filterLabelId
          + '">Filter</h4>');
        filterModal.push('</div>');
        filterModal.push('<div class="modal-body"></div>');
        filterModal.push('<div class="modal-footer"><button type="button" class="btn btn-default" data-dismiss="modal">Close</button></div>');
        filterModal.push('</div>');
        filterModal.push('</div>');
        filterModal.push('</div>');
        $filterModal = $(filterModal.join(''));
        $filterModal.on('mousewheel', function (e) {
          e.stopPropagation();
        });
        var $filter = $('<div style="padding-bottom:30px;"></div>');
        $filter.appendTo($filterModal.find('.modal-body'));
        var filterHtml = [];
        filterHtml
          .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="rows" checked>Rows</label></div> ');
        filterHtml
          .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="columns">Columns</label></div>');

        var $filterChooser = $(filterHtml.join(''));
        $filterChooser.appendTo($filter);
        var columnFilterUI = new morpheus.FilterUI(options.heatMap.getProject(), true);
        var rowFilterUI = new morpheus.FilterUI(options.heatMap.getProject(), false);
        // options.heatMap.getProject().getRowFilter().on('focus', function (e) {
        //   $filterChooser.find('[value=rows]').prop('checked', true);
        //   columnFilterUI.$div.hide();
        //   rowFilterUI.$div.show();
        //   $filterModal.modal('show');
        //   morpheus.Util.trackEvent({
        //     eventCategory: '',
        //     eventAction: 'rowFilter'
        //   });
        //
        // });
        // options.heatMap.getProject().getColumnFilter().on('focus', function (e) {
        //   $filterChooser.find('[value=columns]').prop('checked', true);
        //   columnFilterUI.$div.show();
        //   rowFilterUI.$div.hide();
        //   $filterModal.modal('show');
        //   morpheus.Util.trackEvent({
        //     eventCategory: '',
        //     eventAction: 'columnFilter'
        //   });
        // });
        rowFilterUI.$div.appendTo($filter);
        columnFilterUI.$div.appendTo($filter);
        columnFilterUI.$div.css('display', 'none');
        var $filterRadio = $filterChooser.find('[name=rowsOrColumns]');
        $filterRadio.on('change', function (e) {
          var val = $filterRadio.filter(':checked').val();
          if (val === 'columns') {
            columnFilterUI.$div.show();
            rowFilterUI.$div.hide();
          } else {
            columnFilterUI.$div.hide();
            rowFilterUI.$div.show();
          }
          e.preventDefault();
        });
        $filterModal.appendTo(options.heatMap.$content);
        $filterModal.on('hidden.bs.modal', function () {
          options.heatMap.focus();
        });
      }
      $filterModal.modal('show');
    },
    icon: 'fa fa-filter'
  });

  this.add({
    name: 'Options',
    ellipsis: true,
    cb: function (options) {
      options.heatMap.showOptions();
    },
    icon: 'fa fa-cog'
  });

  this.add({
    which: [191], // slash
    commandKey: true,
    global: true,
    name: 'Toggle Search',
    cb: function (options) {
      options.heatMap.getToolbar().toggleSearch();
    }
  });

  //
  this.add({
    name: 'Copy Image',
    icon: 'fa fa-clipboard',
    cb: function (options) {
      var bounds = options.heatMap.getTotalSize();
      var height = bounds.height;
      var width = bounds.width;
      var canvas = $('<canvas></canvas>')[0];
      var backingScale = morpheus.CanvasUtil.BACKING_SCALE;
      canvas.height = backingScale * height;
      canvas.style.height = height + 'px';
      canvas.width = backingScale * width;
      canvas.style.width = width + 'px';
      var context = canvas.getContext('2d');
      morpheus.CanvasUtil.resetTransform(context);
      options.heatMap.snapshot(context);
      var url = canvas.toDataURL();
      // canvas.toBlob(function (blob) {
      // 	url = URL.createObjectURL(blob);
      // 	event.clipboardData
      // 	.setData(
      // 		'text/html',
      // 		'<img src="' + url + '">');
      // });

      morpheus.Util.setClipboardData([
        {
          format: 'text/html',
          data: '<img src="' + url + '">'
        }], true);
    }
  });

  //
  this.add({
    name: 'Close Tab',
    cb: function (options) {
      options.heatMap.getTabManager().remove(options.heatMap.tabId);
    }
  });
  this.add({
    name: 'Rename Tab',
    ellipsis: true,
    cb: function (options) {
      options.heatMap.getTabManager().rename(options.heatMap.tabId);
    }
  });

  this.add({
    which: [88], // x
    commandKey: true,
    name: 'New Heat Map',
    accept: function (options) {
      return (!options.isInputField || window.getSelection().toString() === '');
    },

    cb: function (options) {
      morpheus.HeatMap.showTool(new morpheus.NewHeatMapTool(),
        options.heatMap);
    }
  });

  this.add({
    which: [67], // C
    commandKey: true,
    name: 'Copy'
  });

  this.add({
    which: [86], // V
    commandKey: true,
    name: 'Paste Dataset'
  });

  this.add({
    global: true,
    name: 'Open',
    ellipsis: true,
    cb: function (options) {
      morpheus.HeatMap.showTool(new morpheus.OpenFileTool(), options.heatMap);
    },
    which: [79],
    commandKey: true,
    icon: 'fa fa-folder-open-o'
  });

  this.add({
    ellipsis: true,
    name: 'Save Image',
    gui: function () {
      return new morpheus.SaveImageTool();
    },
    cb: function (options) {
      morpheus.HeatMap.showTool(this.gui(),
        options.heatMap);
    },
    which: [83],
    commandKey: true,
    global: true,
    icon: 'fa fa-file-image-o'
  });

  this.add({
    ellipsis: true,
    name: 'Save Dataset',
    gui: function () {
      return new morpheus.SaveDatasetTool();
    },
    cb: function (options) {
      morpheus.HeatMap.showTool(this.gui(),
        options.heatMap);
    },
    // shiftKey: true,
    // which: [83],
    // commandKey: true,
    // global: true,
    icon: 'fa fa-floppy-o'
  });

  this.add({
    ellipsis: true,
    name: 'Save Session',
    gui: function () {
      return new morpheus.SaveSessionTool();
    },
    cb: function (options) {
      morpheus.HeatMap.showTool(this.gui(), options.heatMap);
    },
    icon: 'fa fa-anchor'
  });

  if (typeof echarts !== 'undefined') {
    this.add({
      name: 'Chart',
      cb: function (options) {
        new morpheus.ChartTool({
          project: options.heatMap.getProject(),
          heatmap: options.heatMap,
          getVisibleTrackNames: _.bind(
            options.heatMap.getVisibleTrackNames, options.heatMap)
        });
      },
      icon: 'fa fa-line-chart'
    });
  }

  this.add({
    name: 'Zoom In',
    cb: function (options) {
      options.heatMap.zoom(true);
    },
    which: [107, 61, 187]
  });
  this.add({
    name: 'Zoom Out',
    cb: function (options) {
      options.heatMap.zoom(false);
    },
    which: [173, 189, 109]
  });

  this.add({
    name: 'Fit To Window',
    cb: function (options) {
      options.heatMap.fitToWindow({fitRows: true, fitColumns: true, repaint: true});
    },
    which: [48], // zero
    commandKey: true,
    icon: 'fa fa-compress'
  });
  this.add({
    name: 'Fit Columns To Window',
    cb: function (options) {
      options.heatMap.fitToWindow({fitRows: false, fitColumns: true, repaint: true});
    }
  });
  this.add({
    name: 'Fit Rows To Window',
    cb: function (options) {
      options.heatMap.fitToWindow({fitRows: true, fitColumns: false, repaint: true});
    }
  });
  this.add({
    name: '100%',
    cb: function (options) {
      options.heatMap.resetZoom();
    },
    button: '100%'
  });

  this.add({
    which: [35],
    name: 'Go To End',
    cb: function (options) {
      options.heatMap.scrollLeft(options.heatMap.heatmap.getPreferredSize().width);
      options.heatMap.scrollTop(options.heatMap.heatmap.getPreferredSize().height);
    }
  });
  this.add({
    which: [36], // home key
    name: 'Go To Start',
    cb: function (options) {
      options.heatMap.scrollLeft(0);
      options.heatMap.scrollTop(0);
    }
  });
  this.add({
    which: [34], // page down
    commandKey: true,
    name: 'Go To Bottom',
    cb: function (options) {
      options.heatMap
        .scrollTop(options.heatMap.heatmap.getPreferredSize().height);
    }
  });
  this.add({
    which: [34], // page down
    commandKey: false,
    name: 'Scroll Page Down',
    cb: function (options) {
      var pos = options.heatMap.scrollTop();
      options.heatMap.scrollTop(pos + options.heatMap.heatmap.getUnscaledHeight()
        - 2);
    }
  });

  this.add({
    which: [33], // page up
    commandKey: true,
    name: 'Go To Top',
    cb: function (options) {
      options.heatMap
        .scrollTop(0);
    }
  });
  this.add({
    which: [33], // page up
    commandKey: false,
    name: 'Scroll Page Up',
    cb: function (options) {
      var pos = options.heatMap.scrollTop();
      options.heatMap.scrollTop(pos - options.heatMap.heatmap.getUnscaledHeight()
        + 2);
    }
  });

  this.add({
    which: [38], // up arrow
    commandKey: true,
    name: 'Zoom Out Rows',
    cb: function (options) {
      options.heatMap.zoom(false, {
        columns: false,
        rows: true
      });
    }
  });
  this.add({
    which: [38], // up arrow
    commandKey: false,
    name: 'Scroll Up',
    cb: function (options) {
      options.heatMap.scrollTop(options.heatMap.scrollTop() - 8);
    }
  });

  this.add({
    which: [40], // down arrow
    commandKey: true,
    name: 'Zoom In Rows',
    cb: function (options) {
      options.heatMap.zoom(true, {
        columns: false,
        rows: true
      });
    }
  });
  this.add({
    which: [40], // down arrow
    commandKey: false,
    name: 'Scroll Down',
    cb: function (options) {
      options.heatMap.scrollTop(options.heatMap.scrollTop() + 8);
    }
  });

  this.add({
    which: [37], // left arrow
    commandKey: true,
    name: 'Zoom Out Columns',
    cb: function (options) {
      options.heatMap.zoom(false, {
        columns: true,
        rows: false
      });
    }
  });
  this.add({
    which: [37], // left arrow
    commandKey: false,
    name: 'Scroll Left',
    cb: function (options) {
      options.heatMap.scrollLeft(options.heatMap.scrollLeft() - 8);
    }
  });

  this.add({
    which: [39], // right arrow
    commandKey: true,
    name: 'Zoom In Columns',
    cb: function (options) {
      options.heatMap.zoom(true, {
        columns: true,
        rows: false
      });
    }
  });
  this.add({
    which: [39], // right arrow
    commandKey: false,
    name: 'Scroll Right',
    cb: function (options) {
      options.heatMap.scrollLeft(options.heatMap.scrollLeft() + 8);
    }
  });
  this.add({
    name: 'Tutorial',
    cb: function () {
      window
        .open('https://software.broadinstitute.org/morpheus/tutorial.html');
    }
  });
    this.add({
        name: 'ICV Tutorial',
        cb: function () {
            window
                .open('/icv-tutorial');
        }
    });
  this.add({
    icon: 'fa fa-code',
    name: 'Source Code',
    cb: function () {
      window.open('https://github.com/cmap/morpheus.js');
    }
  });
  var $findModal;
  var $search;

  this.add({
    which: [65],
    ellipsis: true,
    shiftKey: true,
    commandKey: true,
    name: 'Search Menus',
    cb: function (options) {
      if ($findModal == null) {
        var findModal = [];
        var id = _.uniqueId('morpheus');
        findModal
          .push('<div class="modal" tabindex="1" role="dialog" aria-labelledby="'
            + id + '">');
        findModal.push('<div class="modal-dialog" role="document">');
        findModal.push('<div class="modal-content">');
        findModal.push('<div class="modal-header">');
        findModal
          .push('<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>');
        findModal.push('<h4 class="modal-title" id="' + id
          + '">Enter action</h4>');
        findModal.push('</div>');
        findModal.push('<div class="modal-body ui-front"><input class="form-control input-sm"></div>');
        findModal.push('</div>');
        findModal.push('</div>');
        findModal.push('</div>');
        $findModal = $(findModal.join(''));
        $findModal.appendTo(options.heatMap.$content);
        var allActions = options.heatMap.getActionManager().getActions();
        $search = $findModal.find('input');
        $search.on('keyup', function (e) {
          if (e.which === 13) {
            var text = $search.val().trim();
            if (text !== '') {
              var action = _this.getAction(text);
              if (action) {
                $findModal.modal('hide');
                _this.execute(text, {event: e});
              }
            }
          }
        });
        morpheus.Util.autosuggest({
          $el: $search,
          multi: false,
          suggestWhenEmpty: false,
          //  history: options.history,
          filter: function (tokens, response) {
            var token = tokens[0].trim();
            var matches = [];
            var replaceRegex = new RegExp('(' + morpheus.Util.escapeRegex(token) + ')', 'i');
            for (var i = 0; i < allActions.length; i++) {
              if (allActions[i].cb) {
                var name = allActions[i].name;
                if (replaceRegex.test(name)) {
                  matches.push({
                    clear: true,
                    value: name,
                    label: '<span style="margin-left: 10px">'
                    + name.replace(replaceRegex, '<b>$1</b>') + '</span>'
                  });
                }
              }
            }
            response(matches);

          },
          select: function () {
            setTimeout(function () {
              var text = $search.val().trim();
              if (text !== '') {
                var action = _this.getAction(text);
                if (action) {
                  $findModal.modal('hide');
                  _this.execute(text);
                }
              }
            }, 20);

          }
        });
        $findModal.on('hidden.bs.modal', function () {
          options.heatMap.focus();
        });
      }
      $findModal.modal('show');
      $search.focus();
    }
  });
  this.add({
    name: 'Keyboard Shortcuts',
    cb: function (options) {
      new morpheus.HeatMapKeyListener(options.heatMap).showKeyMapReference();
    }
  });

  this.add({
    name: 'Configuration',
    cb: function () {
      window
        .open('https://software.broadinstitute.org/morpheus/configuration.html');
    }
  });
  this.add({
    name: 'Contact',
    icon: 'fa fa-envelope-o',
    cb: function (options) {
      morpheus.FormBuilder.showInModal({
        title: 'Contact',
        html: 'Please email us at morpheus@broadinstitute.org',
        focus: options.heatMap.getFocusEl()
      });
    }
  });

  this.add({
    which: [65], // a
    commandKey: true,
    name: 'Select All',
    accept: function (options) {
      var active = options.heatMap.getActiveComponent();
      return (active === 'rowTrack' || active === 'columnTrack');
    },
    cb: function (options) {
      var active = options.heatMap.getActiveComponent();
      var selectionModel = active === 'rowTrack' ? options.heatMap.getProject()
        .getRowSelectionModel() : options.heatMap.getProject()
        .getColumnSelectionModel();
      var count = active === 'rowTrack' ? options.heatMap.getProject()
        .getSortedFilteredDataset().getRowCount() : options.heatMap
        .getProject().getSortedFilteredDataset()
        .getColumnCount();
      var indices = new morpheus.Set();
      for (var i = 0; i < count; i++) {
        indices.add(i);
      }
      selectionModel.setViewIndices(indices, true);
    }
  });

  var invertAction = function (options, isColumns) {
    var model = isColumns ? options.heatMap.getProject().getColumnSelectionModel() : options.heatMap.getProject().getRowSelectionModel();
    var viewIndices = model.getViewIndices();
    var inverse = new morpheus.Set();
    var n = n = isColumns ? options.heatMap.getProject().getSortedFilteredDataset().getColumnCount() : options.heatMap.getProject().getSortedFilteredDataset().getRowCount();
    for (var i = 0; i < n; i++) {
      if (!viewIndices.has(i)) {
        inverse.add(i);
      }
    }
    model.setViewIndices(inverse, true);
  };
  this.add({
    name: 'Invert Selected Rows',
    cb: function (options) {
      invertAction(options, false);
    }
  });
  this.add({
    name: 'Invert Selected Columns',
    cb: function (options) {
      invertAction(options, true);
    }
  });
  var clearAction = function (options, isColumns) {
    var model = isColumns ? options.heatMap.getProject()
      .getColumnSelectionModel() : options.heatMap.getProject()
      .getRowSelectionModel();
    model.setViewIndices(new morpheus.Set(), true);
  };
  this.add({
    name: 'Clear Selected Rows',
    cb: function (options) {
      clearAction(options, false);
    }
  });
  this.add({
    name: 'Clear Selected Columns',
    cb: function (options) {
      clearAction(options, true);
    }
  });

  var moveToTop = function (options, isColumns) {
    var project = options.heatMap.getProject();
    var selectionModel = !isColumns ? project.getRowSelectionModel()
      : project
        .getColumnSelectionModel();
    var viewIndices = selectionModel.getViewIndices().values();
    if (viewIndices.length === 0) {
      return;
    }
    viewIndices.sort(function (a, b) {
      return (a === b ? 0 : (a < b ? -1 : 1));
    });
    var converter = isColumns ? project.convertViewColumnIndexToModel
      : project.convertViewRowIndexToModel;
    converter = _.bind(converter, project);
    var modelIndices = [];
    for (var i = 0, n = viewIndices.length; i < n; i++) {
      modelIndices.push(converter(viewIndices[i]));
    }
    var sortKey = new morpheus.MatchesOnTopSortKey(project, modelIndices, 'selection on top', isColumns);
    sortKey.setLockOrder(1);
    sortKey.setUnlockable(false);
    if (isColumns) {
      project
        .setColumnSortKeys(
          morpheus.SortKey
            .keepExistingSortKeys(
              [sortKey],
              project
                .getColumnSortKeys().filter(function (key) {
                return !(key instanceof morpheus.MatchesOnTopSortKey && key.toString() === sortKey.toString());
              })),
          true);
    } else {
      project
        .setRowSortKeys(
          morpheus.SortKey
            .keepExistingSortKeys(
              [sortKey],
              project
                .getRowSortKeys().filter(function (key) {
                return !(key instanceof morpheus.MatchesOnTopSortKey && key.toString() === sortKey.toString());
              })),
          true);
    }
  };
  this.add({
    name: 'Move Selected Rows To Top',
    cb: function (options) {
      moveToTop(options, false);
    }
  });
  this.add({
    name: 'Move Selected Columns To Top',
    cb: function (options) {
      moveToTop(options, true);
    }
  });
  var selectAll = function (options, isColumns) {
    var project = options.heatMap.getProject();
    var selectionModel = !isColumns ? project.getRowSelectionModel()
      : project
        .getColumnSelectionModel();
    var count = !isColumns ? project
      .getSortedFilteredDataset()
      .getRowCount() : project
      .getSortedFilteredDataset()
      .getColumnCount();
    var indices = new morpheus.Set();
    for (var i = 0; i < count; i++) {
      indices.add(i);
    }
    selectionModel.setViewIndices(indices, true);
  };
  this.add({
    name: 'Select All Rows',
    cb: function (options) {
      selectAll(options, false);
    }
  });
  this.add({
    name: 'Select All Columns',
    cb: function (options) {
      selectAll(options, true);
    }
  });
  var copySelection = function (options, isColumns) {
    var project = options.heatMap.getProject();
    var dataset = project
      .getSortedFilteredDataset();
    var activeTrackName = options.heatMap.getSelectedTrackName(isColumns);
    var v;
    if (activeTrackName == null) {
      v = isColumns ? dataset.getColumnMetadata()
        .get(0) : dataset
        .getRowMetadata().get(0);
    } else {
      v = isColumns ? dataset.getColumnMetadata()
        .getByName(activeTrackName) : dataset
        .getRowMetadata().getByName(activeTrackName);
    }

    var selectionModel = isColumns ? project
      .getColumnSelectionModel() : project
      .getRowSelectionModel();
    var text = [];
    var toStringFunction = morpheus.VectorTrack.vectorToString(v);
    selectionModel.getViewIndices().forEach(
      function (index) {
        text.push(toStringFunction(v
          .getValue(index)));
      });
    morpheus.Util.setClipboardData([
      {
        format: 'text/plain',
        data: text.join('\n')
      }]);
  };
  this.add({
    name: 'Copy Selected Rows',
    cb: function (options) {
      copySelection(options, false);
    }
  });
  this.add({
    name: 'Copy Selected Columns',
    cb: function (options) {
      copySelection(options, true);
    }
  });

  var annotateSelection = function (options, isColumns) {

    var project = options.heatMap.getProject();
    var selectionModel = isColumns ? project
        .getColumnSelectionModel()
      : project
        .getRowSelectionModel();
    if (selectionModel.count() === 0) {
      morpheus.FormBuilder
        .showMessageModal({
          title: 'Annotate Selection',
          html: 'No ' + (isColumns ? 'columns' : 'rows') + ' selected.',
          focus: options.heatMap.getFocusEl()
        });
      return;
    }
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'annotation_name',
      type: 'text',
      required: true
    });
    formBuilder.append({
      name: 'annotation_value',
      type: 'text',
      required: true
    });
    morpheus.FormBuilder
      .showOkCancel({
        title: 'Annotate',
        content: formBuilder.$form,
        focus: options.heatMap.getFocusEl(),
        okCallback: function () {
          var value = formBuilder
            .getValue('annotation_value');
          var annotationName = formBuilder
            .getValue('annotation_name');
          var dataset = project
            .getSortedFilteredDataset();
          var fullDataset = project
            .getFullDataset();
          if (isColumns) {
            dataset = morpheus.DatasetUtil
              .transposedView(dataset);
            fullDataset = morpheus.DatasetUtil
              .transposedView(fullDataset);
          }

          var existingVector = fullDataset
            .getRowMetadata()
            .getByName(
              annotationName);
          var v = dataset
            .getRowMetadata().add(
              annotationName);

          selectionModel
            .getViewIndices()
            .forEach(
              function (index) {
                v
                  .setValue(
                    index,
                    value);
              });
          morpheus.VectorUtil
            .maybeConvertStringToNumber(v);
          project
            .trigger(
              'trackChanged',
              {
                vectors: [v],
                display: existingVector != null ? []
                  : [morpheus.VectorTrack.RENDER.TEXT],
                columns: isColumns
              });
        }
      });
  };
  this.add({
    ellipsis: true,
    name: 'Annotate Selected Rows',
    cb: function (options) {
      annotateSelection(options, false);
    }
  });
  this.add({
    ellipsis: true,
    name: 'Annotate Selected Columns',
    cb: function (options) {
      annotateSelection(options, true);
    }
  });
  this.add({
    name: 'Copy Selected Dataset',
    cb: function (options) {
      var project = options.heatMap.getProject();
      var dataset = project.getSelectedDataset({
        emptyToAll: false
      });
      var columnMetadata = dataset
        .getColumnMetadata();
      var rowMetadata = dataset.getRowMetadata();
      // only copy visible tracks
      var visibleColumnFields = options.heatMap
        .getVisibleTrackNames(true);
      var columnFieldIndices = [];
      _.each(visibleColumnFields, function (name) {
        var index = morpheus.MetadataUtil.indexOf(
          columnMetadata, name);
        if (index !== -1) {
          columnFieldIndices.push(index);
        }
      });
      columnMetadata = new morpheus.MetadataModelColumnView(
        columnMetadata, columnFieldIndices);
      var rowMetadata = dataset.getRowMetadata();
      // only copy visible tracks
      var visibleRowFields = options.heatMap
        .getVisibleTrackNames(false);
      var rowFieldIndices = [];
      _.each(visibleRowFields, function (name) {
        var index = morpheus.MetadataUtil.indexOf(
          rowMetadata, name);
        if (index !== -1) {
          rowFieldIndices.push(index);
        }
      });
      rowMetadata = new morpheus.MetadataModelColumnView(
        rowMetadata, rowFieldIndices);

      var text = new morpheus.GctWriter()
        .write(dataset);
      morpheus.Util.setClipboardData([
        {
          format: 'text/plain',
          data: text
        }]);

    }
  });
  var _this = this;
  [
    new morpheus.HClusterTool(), new morpheus.KMeansTool(), new morpheus.MarkerSelection(), new morpheus.NearestNeighbors(), new morpheus.AdjustDataTool(),
    new morpheus.CollapseDatasetTool(), new morpheus.CreateAnnotation(), new morpheus.SimilarityMatrixTool(), new morpheus.TransposeTool(), new morpheus.TsneTool(),
    new morpheus.DevAPI()].forEach(function (tool) {
    _this.add({
      ellipsis: true,
      name: tool.toString(),
      gui: function () {
        return tool;
      },
      cb: function (options) {
        morpheus.HeatMap.showTool(tool, options.heatMap);
      }
    });
  });
  this.add({
    name: 'Edit Fonts',
    ellipse: true,
    cb: function (options) {
      var trackInfo = options.heatMap.getLastSelectedTrackInfo();
      var project = options.heatMap.getProject();
      var model = trackInfo.isColumns ? project
        .getColumnFontModel() : project
        .getRowFontModel();
      var chooser = new morpheus.FontChooser({fontModel: model, track: options.heatMap.getTrack(trackInfo.name, trackInfo.isColumns), heatMap: options.heatMap});
      morpheus.FormBuilder.showInModal({
        title: 'Edit Fonts',
        html: chooser.$div,
        close: 'Close',
        focus: options.heatMap.getFocusEl()
      });
    }
  });

};
morpheus.ActionManager.prototype = {
  getActions: function () {
    return this.actions;
  },
  getAction: function (name) {
    return this.actionNameToAction.get(name);
  },
  execute: function (name, args) {
    var action = this.getAction(name);
    if (args == null) {
      args = {};
    }

    args.heatMap = this.heatMap;
    action.cb(args);

    morpheus.Util.trackEvent({
      eventCategory: 'Tool',
      eventAction: name
    });
  },
  add: function (action) {
    this.actions.push(action);
    this.actionNameToAction.set(action.name, action);
  }
};

morpheus.CanvasUtil = function () {
};
morpheus.CanvasUtil.dragging = false;

morpheus.CanvasUtil.FONT_NAME = '"Helvetica Neue",Helvetica,Arial,sans-serif';
morpheus.CanvasUtil.FONT_COLOR = 'rgb(0, 0, 0)';
morpheus.CanvasUtil.getFontFamily = function (context) {
  // older versions of Adobe choke when a font family contains a font that is not installed
  return (typeof C2S !== 'undefined' && context instanceof C2S) || (typeof canvas2pdf !== 'undefined' && context instanceof canvas2pdf.PdfContext)
    ? 'Helvetica'
    : morpheus.CanvasUtil.FONT_NAME;
};
morpheus.CanvasUtil.getPreferredSize = function (c) {
  var size = c.getPreferredSize();
  var prefWidth = c.getPrefWidth();
  var prefHeight = c.getPrefHeight();
  // check for override override
  if (prefWidth !== undefined) {
    size.widthSet = true;
    size.width = prefWidth;
  }
  if (prefHeight !== undefined) {
    size.heightSet = true;
    size.height = prefHeight;
  }
  return size;
};
morpheus.CanvasUtil.BACKING_SCALE = 1;
if (typeof window !== 'undefined' && 'devicePixelRatio' in window) {
  if (window.devicePixelRatio > 1) {
    morpheus.CanvasUtil.BACKING_SCALE = window.devicePixelRatio;
  }
}

morpheus.CanvasUtil.setBounds = function (canvas, bounds) {
  var backingScale = morpheus.CanvasUtil.BACKING_SCALE;

  if (bounds.height != null) {
    canvas.height = bounds.height * backingScale;
    canvas.style.height = bounds.height + 'px';
  }
  if (bounds.width != null) {
    canvas.width = bounds.width * backingScale;
    canvas.style.width = bounds.width + 'px';
  }
  if (bounds.left != null) {
    canvas.style.left = bounds.left + 'px';
  }
  if (bounds.top != null) {
    canvas.style.top = bounds.top + 'px';
  }
};

morpheus.CanvasUtil.drawShape = function (context, shape, x, y, size2, isFill) {
  if (size2 < 0) {
    return;
  }
  else if (size2 > 4) {
        size2 = size2*0.6;
    }
  context.beginPath();
  if (shape === 'circle-minus') {
    context.arc(x, y, size2, 0, 2 * Math.PI, false);
    context.moveTo(x - size2, y);
    context.lineTo(x + size2, y);
  } else if (shape === 'circle') {
    context.arc(x, y, size2, 0, 2 * Math.PI, false);
  } else if (shape === 'square') {
    context.rect(x - size2, y - size2, size2 * 2, size2 * 2);
  } else if (shape === 'plus') {
    // vertical line
    context.moveTo(x, y - size2);
    context.lineTo(x, y + size2);
    // horizontal line
    context.moveTo(x - size2, y);
    context.lineTo(x + size2, y);
  } else if (shape === 'x') {
    context.moveTo(x - size2, y - size2);
    context.lineTo(x + size2, y + size2);
    context.moveTo(x + size2, y - size2);
    context.lineTo(x - size2, y + size2);
  } else if (shape === 'asterisk') {
    // x with vertical line
    context.moveTo(x - size2, y - size2);
    context.lineTo(x + size2, y + size2);
    context.moveTo(x + size2, y - size2);
    context.lineTo(x - size2, y + size2);

    context.moveTo(x, y - size2);
    context.lineTo(x, y + size2);
  } else if (shape === 'diamond') {
    // start at middle top
    context.moveTo(x, y - size2);
    // right
    context.lineTo(x + size2, y);
    // bottom
    context.lineTo(x, y + size2);
    // left
    context.lineTo(x - size2, y);
    // top
    context.lineTo(x, y - size2);
  } else if (shape === 'triangle-up') {
    // top
    context.moveTo(x, y - size2);
    // right
    context.lineTo(x + size2, y + size2);
    // left
    context.lineTo(x - size2, y + size2);
    context.lineTo(x, y - size2);
  } else if (shape === 'triangle-down') {
    // bottom
    context.moveTo(x, y + size2);
    // left
    context.lineTo(x - size2, y - size2);
    // right
    context.lineTo(x + size2, y - size2);
    context.lineTo(x, y + size2);
  } else if (shape === 'triangle-left') {
    // left
    context.moveTo(x - size2, y);
    // top
    context.lineTo(x + size2, y - size2);
    // bottom
    context.lineTo(x + size2, y + size2);
    context.lineTo(x - size2, y);
  } else if (shape === 'triangle-right') {
    // right
    context.moveTo(x + size2, y);
    // lower left
    context.lineTo(x - size2, y + size2);

    // upper left
    context.lineTo(x - size2, y - size2);
    context.lineTo(x + size2, y);
  }
  isFill ? context.fill() : context.stroke();

};
morpheus.CanvasUtil.drawLine = function (context, x1, y1, x2, y2) {
  context.beginPath();
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
  context.stroke();
};
morpheus.CanvasUtil.resetTransform = function (context) {
  context.setTransform(1, 0, 0, 1, 0, 0);
  if (morpheus.CanvasUtil.BACKING_SCALE !== 1) {
    context.scale(morpheus.CanvasUtil.BACKING_SCALE,
      morpheus.CanvasUtil.BACKING_SCALE);
  }
};
morpheus.CanvasUtil.bezierCurveTo = function (context, start, end) {
  var m1 = (start[1] + end[1]) / 2;
  context.beginPath();
  context.moveTo(start[0], start[1]);
  // context.lineTo(leftp[0], leftp[1]);
  context.bezierCurveTo(start[0], m1, end[0], m1, end[0], end[1]);
  context.stroke();
};
morpheus.CanvasUtil.createCanvas = function () {
  var $c = $('<canvas></canvas>');
  $c.attr('tabindex', '0');
  $c.css({
    cursor: 'default',
    outline: 0,
    overflow: 'hidden',
    position: 'absolute',
    'z-index': 1
  });
  return $c[0];
};
morpheus.CanvasUtil.getHeaderStringWidth = function (context, s) {
  context.font = '14px ' + morpheus.CanvasUtil.getFontFamily(context);
  return context.measureText(s).width + 18;
};

morpheus.CanvasUtil.forceSubPixelRendering = function (context) {
  context.getImageData(0, 0, 1, 1);
};
morpheus.CanvasUtil.getVectorStringWidth = function (context, vector, positions,
                                                     end) {
  if (positions.getSize() < 6) {
    return 0;
  }
  var fontSize = Math.min(morpheus.VectorTrack.MAX_FONT_SIZE, positions.getSize() - 2);
  if (fontSize <= 0) {
    return 0;
  }
  context.font = fontSize + 'px ' + morpheus.CanvasUtil.getFontFamily(context);
  var toString = morpheus.VectorTrack.vectorToString(vector);
  var maxWidth = 0;
  // var maxWidth2 = 0;
  var n = end <= 0 ? vector.size() : Math.min(end, vector.size());
  for (var i = 0; i < n; i++) {
    var value = vector.getValue(i);
    if (value != null && value != '') {
      value = toString(value);
    } else {
      continue;
    }
    var width = context.measureText(value).width;
    if (width > maxWidth) {
      maxWidth = width;
    }
    // if (width > maxWidth2 && width < maxWidth) {
    // maxWidth2 = width;
    // }
  }
  return maxWidth === 0 ? maxWidth : (maxWidth + 2);
};
morpheus.CanvasUtil.clipString = function (context, string, availTextWidth) {
  var textWidth = context.measureText(string).width;
  if (textWidth <= availTextWidth) {
    return string;
  }
  var clipString = '...';
  availTextWidth -= context.measureText(clipString).width;
  if (availTextWidth <= 0) {
    // can not fit any characters
    return clipString;
  }
  var width = 0;
  for (var nChars = 0, stringLength = string.length; nChars < stringLength; nChars++) {
    width += context.measureText(string[nChars]).width;
    if (width > availTextWidth) {
      string = string.substring(0, nChars);
      break;
    }
  }
  return string + clipString;
};
morpheus.CanvasUtil.toSVG = function (drawable, file) {
  var totalSize = {
    width: drawable.getWidth(),
    height: drawable.getHeight()
  };
  var context = new C2S(totalSize.width, totalSize.height);
  context.save();
  drawable.draw({
    x: 0,
    y: 0,
    width: totalSize.width,
    height: totalSize.height
  }, context);
  context.restore();
  var svg = context.getSerializedSvg();
  var blob = new Blob([svg], {
    type: 'text/plain;charset=utf-8'
  });
  saveAs(blob, file);
};
morpheus.CanvasUtil.getMousePos = function (element, event, useDelta) {
  return morpheus.CanvasUtil.getMousePosWithScroll(element, event, 0, 0,
    useDelta);
};

morpheus.CanvasUtil.getClientXY = function (event, useDelta) {
  var clientX;
  var clientY;
  if (event.pointers) {
    if (event.pointers.length > 0) {
      clientX = event.pointers[0].clientX - (useDelta ? event.deltaX : 0);
      clientY = event.pointers[0].clientY - (useDelta ? event.deltaY : 0);
    } else {
      clientX = event.srcEvent.clientX - (useDelta ? event.deltaX : 0);
      clientY = event.srcEvent.clientY - (useDelta ? event.deltaY : 0);
    }
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }
  return {
    x: clientX,
    y: clientY
  };
};
morpheus.CanvasUtil.getMousePosWithScroll = function (element, event, scrollX,
                                                      scrollY, useDelta) {
  return morpheus.CanvasUtil._getMousePosWithScroll(element, scrollX,
    scrollY, morpheus.CanvasUtil.getClientXY(event, useDelta));
};

morpheus.CanvasUtil._getMousePosWithScroll = function (element, scrollX,
                                                       scrollY, clientXY) {
  var rect = element.getBoundingClientRect();
  return {
    x: clientXY.x - rect.left + scrollX,
    y: clientXY.y - rect.top + scrollY
  };
};

/**
 * @param {morpheus.Set} [] -
 *            options.set set of selected items
 * @see morpheus.Table
 */
morpheus.CheckBoxList = function (options) {
  var _this = this;
  var set = options.set || new morpheus.Set();
  options = $.extend(true, {}, {
    height: '150px',
    showHeader: false,
    select: false,
    search: true,
    checkBoxSelectionOnTop: false,
    rowHeader: function (item) {
      var header = [];
      // header
      // .push('<div style="overflow: hidden;text-overflow: ellipsis;"
      // class="morpheus-hover">');
      header.push('<span><input name="toggle" type="checkbox" '
        + (set.has(_this.getter(item)) ? ' checked' : '') + '/> ');
      header.push('</span>');
      // header
      // .push('<button
      // style="background-color:inherit;position:absolute;top:0;right:0;line-height:inherit;padding:0px;margin-top:4px;"
      // class="btn btn-link morpheus-hover-show">only</button>');
      // header.push('</div>');
      return header.join('');
      // return '<span><input name="toggle"
      // type="checkbox" '
      // + (set.has(_this.getter(item)) ? ' checked' : '')
      // + '/> </span>'
    }
  }, options);
  options = morpheus.Table.createOptions(options);
  if (options.columns.length === 1) {
    options.maxWidth = 583;
  }
  var idColumn = options.columns[0];
  for (var i = 0; i < options.columns.length; i++) {
    if (options.columns[i].idColumn) {
      idColumn = options.columns[i];
      break;
    }
  }

  this.getter = idColumn.getter;
  var html = [];

  var table = new morpheus.Table(options);
  if (options.columns.length === 1) {
    options.$el.find('.slick-table-header').find('[name=right]').remove();
  }
  this.table = table;
  var html = [];

  html.push('<div style="display:inline;">');
  html.push('<div style="display:inline;" class="dropdown">');
  html.push('<button class="btn btn-default dropdown-toggle row-selector-btn" type="button"' +
    ' data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">');
  html.push('<i data-name="checkbox" class="fa fa-square-o"' +
    ' aria-hidden="true"></i>');
  html.push(' <span class="fa fa-caret-down"></span>');
  html.push('</button>');
  html.push('<ul style="font-size:12px;" class="dropdown-menu">');
  html.push('<li><a name="selectAll" href="#">Select All</a></li>');
  html.push('<li><a name="selectNone" href="#">Select None</a></li>');
  html.push('<li><a name="invertSel" href="#">Invert Selection</a></li>');

  html.push('</ul>');
  html.push('</div>');
  html.push('<span data-name="available" style="font-size:12px;padding-left:6px;"></span>');
  html.push('</div>');
  var $checkBoxEl = $(html.join(''));
  table.$header.find('[name=left]').html($checkBoxEl);
  var $selection = $checkBoxEl.find('[data-name=available]');
  var $selectAll = $checkBoxEl.find('[name=selectAll]');
  var $selectNone = $checkBoxEl.find('[name=selectNone]');
  var $cb = $checkBoxEl.find('[data-name=checkbox]');
  var updateLabel = function () {
    var label = [];
    label.push('selected ');
    label.push(morpheus.Util.intFormat(set.size()));
    label.push(' of ');
    label.push(morpheus.Util.intFormat(table.getAllItemCount()));
    if (table.getFilteredItemCount() !== table.getAllItemCount()) {
      label.push(', ');
      label.push(morpheus.Util.intFormat(table.getFilteredItemCount()));
      label.push(table.getFilteredItemCount() === 1 ? ' match' : ' matches');
    }
    $selection.html(label.join(''));

  };
  table.grid.on('filter', function (e) {
    updateLabel();
  });
  $cb.on('click', function (e) {
    if ($cb.hasClass('fa-square-o')) {
      var items = table.getItems(); // select all
      for (var i = 0; i < items.length; i++) {
        set.add(_this.getter(items[i]));
      }
    } else { // select none
      var items = table.getItems();
      for (var i = 0; i < items.length; i++) {
        set.remove(_this.getter(items[i]));
      }
    }
    table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });
    e.preventDefault();
    e.stopPropagation();

  });
  $selectAll.on('click', function (e) {
    var items = table.getItems();
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      set.add(_this.getter(items[i]));
    }
    _this.table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });
    e.preventDefault();
    _this.table.redraw();
  });
  $checkBoxEl.find('[name=invertSel]').on('click', function (e) {
    // selected become unselected, unselected become selected
    var items = table.getItems();
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      var val = _this.getter(items[i]);
      if (set.has(val)) {
        set.remove(val);
      } else {
        set.add(val);
      }

    }
    _this.table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });
    e.preventDefault();
    _this.table.redraw();
  });
  $selectNone.on('click', function (e) {
    var items = table.getItems();
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      set.remove(_this.getter(items[i]));
    }
    _this.table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });

    e.preventDefault();
    _this.table.redraw();
  });

  this.set = set;
  this.table = table;
  updateLabel();

  var priorCount = 0;
  this.table.on('checkBoxSelectionChanged', function () {
    if (set.size() === 0) {
      $cb.attr('class', 'fa fa-square-o');
    } else {
      var items = table.getItems();
      var count = 0;
      var found = false;
      var notFound = false;
      for (var i = 0; i < items.length; i++) {
        if (set.has(_this.getter(items[i]))) {
          count++;
          found = true;
          if (notFound) {
            break;
          }
        } else {
          notFound = true;
          if (found) {
            break;
          }
        }
      }
      if (count === 0) {
        $cb.attr('class', 'fa fa-square-o');
      } else if (count === items.length) {
        $cb.attr('class', 'fa fa-check-square-o');
      } else {
        $cb.attr('class', 'fa fa-minus-square-o');
      }
    }

    updateLabel();

    _this.table.redraw();
  });

  table.on('click',
    function (e) {
      var $target = $(e.target);
      var item = table.getItems()[e.row];
      var value = _this.getter(item);
      if ($target.is('.morpheus-hover-show')) { // only
        set.clear();
        set.add(value);
        _this.table.trigger('checkBoxSelectionChanged', {
          source: _this,
          set: set
        });
      } else if (!options.select
        || ($target.is('[type=checkbox]') && $target
        .attr('name') === 'toggle')) {
        if (set.has(value)) {
          set.remove(value);
        } else {
          set.add(value);
        }
        _this.table.trigger('checkBoxSelectionChanged', {
          source: _this,
          set: set
        });
      }

    });

};
morpheus.CheckBoxList.prototype = {
  searchWithPredicates: function (predicates) {
    this.table.searchWithPredicates(predicates);
  },
  autocomplete: function (tokens, cb) {
    this.table.autocomplete(tokens, cb);
  },
  setHeight: function (height) {
    this.table.setHeight(height);
  },
  resize: function () {
    this.table.resize();
  },
  setSearchVisible: function (visible) {
    this.table.setSearchVisible(visible);
  },
  getSelectedRows: function () {
    return this.table.getSelectedRows();
  },
  getSelectedItems: function () {
    return this.table.getSelectedItems();
  },
  setSelectedRows: function (rows) {
    this.table.setSelectedRows(rows);
  },
  getItems: function (items) {
    return this.table.getItems();
  },
  getAllItemCount: function () {
    return this.table.getAllItemCount();
  },
  getFilteredItemCount: function () {
    return this.table.getFilteredItemCount();
  },
  setFilter: function (f) {
    this.table.setFilter(f);
  },

  redraw: function () {
    this.table.redraw();
  },
  getSelection: function () {
    return this.set;
  },
  clearSelection: function (values) {
    this.set.clear();
    this.table.redraw();
  },
  setValue: function (values) {
    this.setSelectedValues(values);
  },
  setSelectedValues: function (values) {
    this.set.clear();

    if (morpheus.Util.isArray(values)) {
      for (var i = 0; i < values.length; i++) {
        this.set.add(values[i]);
      }
    } else {
      this.set.add(values);
    }
    this.table.redraw();
  },
  val: function () {
    return this.set.values();
  },
  on: function (evtStr, handler) {
    this.table.on(evtStr, handler);
    return this;
  },
  off: function (evtStr, handler) {
    this.table.off(evtStr, handler);
  },
  setItems: function (items) {
    // remove items in selection that are not in new items
    var newItems = new morpheus.Set();
    var getter = this.getter;
    for (var i = 0; i < items.length; i++) {
      newItems.add(getter(items[i]));

    }
    var selection = this.set;
    selection.forEach(function (val) {
      if (!newItems.has(val)) {
        selection.remove(val);
      }
    });

    this.table.setItems(items);
    this.table.trigger('checkBoxSelectionChanged', {
      source: this,
      set: selection
    });
  }
};

/**
 *
 * @param options.colorModel
 * @param options.track
 * @param options.heatMap
 * @constructor
 */
morpheus.ColorSchemeChooser = function (options) {
  var colorModel = options.colorModel;
  var track = options.track;
  var heatMap = options.heatMap;
  // ensure map exists
  colorModel.getMappedValue(track.getVector(track.settings.colorByField), track.getVector(track.settings.colorByField).getValue(0));
  var formBuilder = new morpheus.FormBuilder();
  if (track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)) {
    formBuilder.append({
      value: track.settings.colorByField != null,
      type: 'checkbox',
      name: 'use_another_annotation_to_determine_color'
    });
    var annotationNames = morpheus.MetadataUtil.getMetadataNames(
      track.isColumns ? heatMap.getProject().getFullDataset().getColumnMetadata() : heatMap.getProject().getFullDataset().getRowMetadata());
    annotationNames.splice(annotationNames.indexOf(track.getName()), 1);
    formBuilder.append({
      name: 'annotation_name',
      type: 'bootstrap-select',
      options: annotationNames,
      search: annotationNames.length > 10,
      value: track.settings.colorByField
    });
  }
  formBuilder.append({
    name: 'discrete',
    type: 'checkbox',
    value: track.getVector(track.settings.colorByField).getProperties().get(morpheus.VectorKeys.DISCRETE)
  });
  var dataType = morpheus.VectorUtil.getDataType(track.getVector(track.settings.colorByField));
  var isNumber = dataType === 'number' || dataType === '[number]';
  formBuilder.setVisible('discrete', isNumber);
  formBuilder.setVisible('annotation_name', track.settings.colorByField != null);

  var $chooser = $('<div></div>');
  $chooser.appendTo(formBuilder.$form);
  var updateChooser = function () {
    var colorSchemeChooser;
    var v = track
      .getVector(track.settings.colorByField);
    formBuilder.setValue('discrete', v.getProperties().get(morpheus.VectorKeys.DISCRETE));
    if (v.getProperties().get(morpheus.VectorKeys.DISCRETE)) {
      colorModel.getMappedValue(v, v.getValue(0)); // make sure color map exists
      colorSchemeChooser = new morpheus.DiscreteColorSchemeChooser(
        {
          colorScheme: {
            scale: colorModel
              .getDiscreteColorScheme(track
                .getVector(track.settings.colorByField))
          }
        });
      colorSchemeChooser.on('change', function (event) {
        colorModel.setMappedValue(track
            .getVector(track.settings.colorByField), event.value,
          event.color);
        track.setInvalid(true);
        track.repaint();
      });
    } else {
      colorModel.getContinuousMappedValue(v, v.getValue(0)); // make sure color map exists
      colorSchemeChooser = new morpheus.HeatMapColorSchemeChooser(
        {
          showRelative: false
        });

      colorSchemeChooser
        .setColorScheme(colorModel
          .getContinuousColorScheme(v));
      colorSchemeChooser.on('change', function (event) {
        track.setInvalid(true);
        track.repaint();
      });
    }
    $chooser.html(colorSchemeChooser.$div);
    track.setInvalid();
    track.repaint();
  };
  formBuilder.find('use_another_annotation_to_determine_color').on('change', function () {
    var checked = $(this).prop('checked');
    formBuilder.setValue('annotation_name', null);
    formBuilder.setVisible('annotation_name', checked);
    if (!checked) {
      track.settings.colorByField = null;
      updateChooser();
    } else {
      $chooser.empty();
    }

    formBuilder.setVisible('discrete', false);
  });
  formBuilder.find('annotation_name').on('change', function () {
    var annotationName = $(this).val();
    // ensure map exists
    colorModel.getMappedValue(track.getVector(annotationName), track.getVector(annotationName).getValue(0));
    track.settings.colorByField = annotationName;
    var dataType = morpheus.VectorUtil.getDataType(track.getVector(track.settings.colorByField));
    var isNumber = dataType === 'number' || dataType === '[number]';
    formBuilder.setVisible('discrete', isNumber);
    updateChooser();
    track.setInvalid(true);
    track.repaint();
  });

  formBuilder.find('discrete').on('change', function () {
    track.getVector(track.settings.colorByField).getProperties().set(morpheus.VectorKeys.DISCRETE, $(this).prop('checked'));
    updateChooser();
    track.setInvalid(true);
    track.repaint();
  });
  updateChooser();
  this.$div = formBuilder.$form;
};

morpheus.ColumnDendrogram = function (heatMap, tree, positions, project) {
  morpheus.AbstractDendrogram.call(this, heatMap, tree, positions,
    project, morpheus.AbstractDendrogram.Type.COLUMN);
};
morpheus.ColumnDendrogram.prototype = {
  drawNode: function (context, node) {
    var radius = this.getNodeRadius(node);
    var pix = this.toPix(node);
    context.beginPath();
    context.arc(pix[0], pix[1], 4, Math.PI * 2, false);
    context.fill();
  },
  isDragHotSpot: function (p) {
    return Math.abs(this.scale(this.cutHeight) - p.y) <= 2;
  },
  drawCutSlider: function (clip, context) {
    if (context.setLineDash) {
      context.setLineDash([5]);
    }
    context.strokeStyle = 'black';
    var ny = this.scale(this.cutHeight);
    context.beginPath();
    context.moveTo(clip.x, ny);
    context.lineTo(this.getUnscaledWidth(), ny);
    context.stroke();
    if (context.setLineDash) {
      context.setLineDash([]);
    }
  },
  createScale: function () {
    // root has the largest height, leaves the smallest height
    return d3.scale.linear().domain([this.tree.maxHeight, 0]).range(
      [0, this.getUnscaledHeight()]);
  },
  paintMouseOver: function (clip, context) {
    if (this.project.getHoverColumnIndex() !== -1) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(-clip.x, 0);
      this.drawColumnBorder(context, this.positions, this.project
      .getHoverColumnIndex(), this.getUnscaledWidth());
    }
  },
  drawColumnBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(pix + size, 0);
    context.lineTo(pix + size, gridSize);
    context.stroke();
    context.beginPath();
    context.moveTo(pix, 0);
    context.lineTo(pix, gridSize);
    context.stroke();
  },
  getMaxIndex: function (clip) {
    return morpheus.Positions.getRight(clip, this.positions);
  },
  getMinIndex: function (clip) {
    return morpheus.Positions.getLeft(clip, this.positions);
  },
  getPreferredSize: function (context) {
    return {
      width: Math.ceil(this.positions.getPosition(this.positions
          .getLength() - 1)
        + this.positions
        .getItemSize(this.positions.getLength() - 1)),
      height: 100
    };
  },
  toPix: function (node) {
    var min = this.positions.getPosition(node.minIndex)
      + this.positions.getItemSize(node.minIndex) / 2;
    var max = this.positions.getPosition(node.maxIndex)
      + this.positions.getItemSize(node.maxIndex) / 2;
    return [(min + max) / 2, this.scale(node.height)];
  },
  drawPathFromNodeToParent: function (context, node) {
    var pix = this.toPix(node);
    var parentPix = this.toPix(node.parent);
    context.beginPath();
    context.moveTo(pix[0], pix[1]);
    context.lineTo(pix[0], parentPix[1]);
    context.lineTo(parentPix[0], parentPix[1]);
    context.stroke();
  },
  drawNodePath: function (context, node, minIndex, maxIndex) {
    var children = node.children;
    var left = children[0];
    var right = children[1];
    // set up points for poly line
    var ny = this.scale(node.height);
    var rx = this.toPix(right)[0];
    var ry = this.scale(right.height);
    var lx = this.toPix(left)[0];
    var ly = this.scale(left.height);
    var x, y;
    if (!this.drawLeafNodes) {
      var leftIsLeaf = left.children !== undefined;
      var rightIsLeaf = right.children !== undefined;
      if (leftIsLeaf) {
        ly = ny + 4;
      }
      if (rightIsLeaf) {
        ry = ny + 4;
      }
      x = [rx, rx, lx, lx];
      y = [ry, ny, ny, ly];
    } else {
      x = [rx, rx, lx, lx];
      y = [ry, ny, ny, ly];
    }
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for (var i = 1, length = x.length; i < length; i++) {
      context.lineTo(x[i], y[i]);
    }
    context.stroke();
  }
};
morpheus.Util.extend(morpheus.ColumnDendrogram, morpheus.AbstractDendrogram);

morpheus.ConditionalRenderingUI = function (heatmap) {
  var _this = this;
  this.heatmap = heatmap;
  var $div = $('<div class="container-fluid" style="min-width:180px;"></div>');
  $div.on('click', '[data-name=add]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    // add after
    var index = $row.index();
    var condition = {
      seriesName: null,
      color: 'rgb(0,0,0)',
      shape: null,
      inheritColor: true,
      accept: function (val) {
        return false;
      }

    };

    heatmap.heatmap.getColorScheme().getConditions().insert(index,
      condition);

    $row.after(_this.add(condition));
    e.preventDefault();
  });
  $div.on('click', '[data-name=delete]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    var index = $row.index() - 1;
    heatmap.heatmap.getColorScheme().getConditions().remove(index);
    heatmap.revalidate();
    $row.remove();
    e.preventDefault();
  });
  var html = [];
  html
    .push('<div class="morpheus-entry">');
  html.push('<div class="row">');
  html
    .push('<div style="padding-bottom:20px;" class="col-xs-8"><a class="btn btn-default btn-xs"' +
      ' role="button"' +
      ' data-name="add" href="#">Add Condition</a></div>');

  html.push('</div>');
  html.push('</div>');

  $div.append(html.join(''));
  this.$div = $div;
  heatmap.heatmap.getColorScheme().getConditions().getConditions().forEach(
    function (c) {
      _this.add(c).appendTo($div);
    });

};

morpheus.ConditionalRenderingUI.prototype = {
  add: function (condition) {
    var _this = this;
    // shape: shapes and line
    // color: if no color cell is drawn using this shape, otherwise draw
    // shape on top of cell
    // seriesName name
    // value >= x and <= x
    var html = [];
    html.push('<div style="border-top:1px solid LightGrey;padding-bottom:6px;padding-top:6px;"' +
      ' class="morpheus-entry">');
    html.push('<form class="form-horizontal">');
    // seriesName
    html.push('<div class="form-group">');
    html
      .push('<label class="col-xs-2">Series</label>');
    html.push('<div class="col-xs-6">');
    html
      .push('<select class="form-control morpheus-form-control-inline" name="cond_series">');
    html.push(morpheus.Util.createOptions(morpheus.DatasetUtil
      .getSeriesNames(this.heatmap.getProject().getFullDataset())));
    html.push('</select>');
    html.push('</div>');
    html.push('</div>');

    // condition
    html.push('<div class="form-group">');
    html.push('<label class="col-xs-2">Condition</label>');
    html.push('<div class="col-xs-6">');
    html
      .push('<select class="form-control morpheus-form-control-inline" name="lower"><option value="gte">&gt;=</option><option value="gt">&gt;</option></select>');
    html
      .push('<input class="form-control morpheus-form-control-inline" name="v1" size="5" type="text">');
    html.push('<span style="margin-right:1em;">and</span>');
    html
      .push('<select class="form-control morpheus-form-control-inline" name="upper"><option value="lte">&lt;=</option><option value="lt">&lt;</option></select>');
    html
      .push('<input class="form-control morpheus-form-control-inline" name="v2" size="5" type="text">');
    html.push('</div>');
    html.push('</div>');

    // shape
    html.push('<div class="form-group">');
    html.push('<label class="col-xs-2">Shape</label>');
    var shapeField = new morpheus.ShapeField({shapes: morpheus.VectorShapeModel.FILLED_SHAPES, showNone: false});
    html.push('<div class="col-xs-4">');
    html.push('<div style="display:inline;" data-name="shapeHolder"></div>');
    html.push('</div>');
    html.push('</div>');

    // color
    html.push('<div class="form-group">');
    html.push('<label class="col-xs-offset-2 col-xs-4"><input name="inherit_color"' +
      ' type="checkbox" checked> Inherit' +
      ' color</label>');
    html.push('</div>');

    html.push('<div class="form-group">');
    html.push('<label class="col-xs-2">Color</label>');
    html.push('<div class="col-xs-4">');
    html
      .push('<input class="form-control" type="color" name="color" style="display:inline;' +
        ' width:6em;" disabled>');
    html.push('</div>');
    html.push('</div>');

    html.push('<div class="row"><div class="col-xs-11">');
    html
      .push('<a class="btn btn-default btn-xs" role="button" data-name="delete"' +
        ' href="#">Delete Condition</a>');
    html.push('</div></div>');
    html.push('</div>'); // morpheus-entry
    var $el = $(html.join(''));
    console.log($el.find('form').length);
    $el.find('form').on('submit', function (e) {
      e.preventDefault();
    });
    shapeField.$el.appendTo($el.find('[data-name=shapeHolder]'));
    var $color = $el.find('[name=color]');
    var $series = $el.find('[name=cond_series]');
    var $v1 = $el.find('[name=v1]');
    var $v2 = $el.find('[name=v2]');
    var $v1Op = $el.find('[name=lower]');
    var $v2Op = $el.find('[name=upper]');
    var $inherit_color = $el.find('[name=inherit_color]');
    $color.prop('disabled', condition.inheritColor);
    $color.val(condition.color);
    $series.val(condition.seriesName);
    shapeField.setShapeValue(condition.shape);
    if (condition.v1 != null && !isNaN(condition.v1)) {
      $v1.val(condition.v1);
    }
    if (condition.v2 != null && !isNaN(condition.v2)) {
      $v2.val(condition.v2);
    }
    $v1Op.val(condition.v1Op);
    $v2Op.val(condition.v2Op);

    function updateAccept() {
      var v1 = parseFloat($($v1).val());
      var v2 = parseFloat($($v2).val());
      var v1Op = $v1Op.val();
      var v2Op = $v2Op.val();
      condition.v1 = v1;
      condition.v2 = v2;
      condition.v1Op = v1Op;
      condition.v2Op = v2Op;
      var gtf = function () {
        return true;
      };
      var ltf = function () {
        return true;
      };
      if (!isNaN(v1)) {
        gtf = v1Op === 'gt' ? function (val) {
          return val > v1;
        } : function (val) {
          return val >= v1;
        };
      }

      if (!isNaN(v2)) {
        ltf = v2Op === 'lt' ? function (val) {
          return val < v2;
        } : function (val) {
          return val <= v2;
        };
      }
      condition.accept = function (val) {
        return gtf(val) && ltf(val);
      };
      _this.heatmap.revalidate();
    }

    $v1Op.on('change', function (e) {
      updateAccept();

    });
    $v2Op.on('change', function (e) {
      updateAccept();
    });
    $v1.on('keyup', _.debounce(function (e) {
      updateAccept();
    }, 100));
    $v2.on('keyup', _.debounce(function (e) {
      updateAccept();
    }, 100));
    $inherit_color.on('click', function (e) {
      condition.inheritColor = $(this).prop('checked');
      $color.prop('disabled', condition.inheritColor);
      _this.heatmap.revalidate();
    });
    $color.on('change', function (e) {
      condition.color = $(this).val();
      _this.heatmap.revalidate();
    });
    shapeField.on('change', function (e) {
      condition.shape = e.shape;
      _this.heatmap.revalidate();
    });
    $series.on('change', function (e) {
      condition.seriesName = $(this).val();
      _this.heatmap.revalidate();
    });
    condition.seriesName = $series.val();
    return $el;

  }
};

morpheus.DendrogramUtil = {};
morpheus.DendrogramUtil.setIndices = function (root, counter) {
  counter = counter || 0;
  var setIndex = function (node) {
    var children = node.children;
    var maxIndex = children[0].maxIndex;
    var minIndex = children[0].minIndex;
    var sum = children[0].index;
    for (var i = 1, length = children.length; i < length; i++) {
      var child = children[i];
      sum += child.index;
      minIndex = Math.min(minIndex, child.minIndex);
      maxIndex = Math.max(maxIndex, child.maxIndex);
    }
    node.minIndex = minIndex;
    node.maxIndex = maxIndex;
    node.index = sum / children.length;
    node.children.sort(function (a, b) {
      return (a.index === b.index ? 0 : (a.index < b.index ? -1 : 1));
    });
  };

  var visit = function (node, callback) {
    var children = node.children;
    var n;
    if (children && (n = children.length)) {
      var i = -1;
      while (++i < n) {
        visit(children[i], callback);
      }
    }
    callback(node);
  };
  visit(root, function (n) {
    if (n.children === undefined) {
      n.minIndex = counter;
      n.maxIndex = counter;
      n.index = counter;
      counter++;
    } else {
      setIndex(n);
    }
    return true;
  });
};
morpheus.DendrogramUtil.convertEdgeLengthsToHeights = function (rootNode) {
  var maxHeight = 0;

  function setHeights(node, height) {
    var newHeight = height;
    if (node.length !== undefined) {
      newHeight += node.length;
    }
    node.height = newHeight;
    maxHeight = Math.max(maxHeight, node.height);
    if (node.children != null) {
      node.children.forEach(function (child) {
        setHeights(child, newHeight);
      });
    }
  }

  setHeights(rootNode, 0);
  var counter = 0;
  morpheus.DendrogramUtil.dfs(rootNode, function (node) {
    node.id = counter;
    counter++;
    node.height = maxHeight - node.height;
    return true;
  });
  return {
    maxHeight: maxHeight,
    n: counter
  };
};
morpheus.DendrogramUtil.writeNewick = function (node, out, leafNodeIdFunction) {
  if (node.children != null && node.children.length > 0) {
    // indent
    out.push('(');
    for (var i = 0; i < node.children.length; i++) {
      if (i > 0) {
        out.push(',');
      }
      morpheus.DendrogramUtil.writeNewick(node.children[i], out, leafNodeIdFunction);
    }
    out.push(')');
  }
  out.push(node.index != null ? leafNodeIdFunction(node) : ''); // leaf nodes have index
  out.push(':');
  var parentHeight = node.parent ? node.parent.height : node.height;
  out.push(parentHeight - node.height);

};
morpheus.DendrogramUtil.parseNewick = function (text) {
  var rootNode = Newick.parse(text);
  var counter = 0;
  var leafNodes = [];

  function visit(node) {
    var children = node.children;
    if (children !== undefined) {
      var left = children[0];
      var right = children[1];
      left.parent = node;
      right.parent = node;
      visit(left);
      visit(right);
    } else { // leaf node
      node.minIndex = counter;
      node.maxIndex = counter;
      node.index = counter;
      leafNodes.push(node);
      counter++;
    }
  }

  visit(rootNode);
  var maxHeight = morpheus.DendrogramUtil.convertEdgeLengthsToHeights(rootNode).maxHeight;
  morpheus.DendrogramUtil.setNodeDepths(rootNode);
  morpheus.DendrogramUtil.setIndices(rootNode);
  return {
    maxHeight: rootNode.height,
    rootNode: rootNode,
    leafNodes: leafNodes,
    nLeafNodes: leafNodes.length
  };
};
morpheus.DendrogramUtil.cutAtHeight = function (rootNode, h) {
  var roots = [];
  morpheus.DendrogramUtil.dfs(rootNode, function (node) {
    if (node.height < h) {
      roots.push(node);
      return false;
    }
    return true;
  });
  roots.sort(function (a, b) {
    return (a.index < b.index ? -1 : (a.index == b.index ? 0 : 1));
  });
  return roots;
};
morpheus.DendrogramUtil.getDeepestChild = function (node, isMin) {
  while (true) {
    if (node.children === undefined) {
      return node;
    }
    var index;
    if (isMin) {
      index = node.children[0].index < node.children[node.children.length - 1].index ? 0
        : node.children.length - 1;
    } else {
      index = node.children[0].index > node.children[node.children.length - 1].index ? 0
        : node.children.length - 1;
    }

    node = node.children[index];
  }
};
/**
 * Pre-order depth first traversal 1. Visit the root. 2. Traverse the left
 * subtree. 3. Traverse the right subtree.
 */
morpheus.DendrogramUtil.dfs = function (node, callback, childrenAccessor) {
  if (childrenAccessor === undefined) {
    childrenAccessor = function (n) {
      return n.children;
    };
  }
  if (callback(node)) {
    var children = childrenAccessor(node);
    var n;
    if (children && (n = children.length)) {
      var i = -1;
      while (++i < n) {
        morpheus.DendrogramUtil.dfs(children[i], callback,
          childrenAccessor);
      }
    }
  }
};
morpheus.DendrogramUtil.copyTree = function (tree) {
  var counter = 0;

  function recurse(node) {
    var children = node.children;
    if (children !== undefined) {
      var newChildren = [];
      for (var i = 0, n = children.length; i < n; i++) {
        var copy = $.extend({}, children[i]);
        copy.parent = node;
        newChildren.push(copy);
      }
      node.children = newChildren;
      for (var i = 0, n = newChildren.length; i < n; i++) {
        recurse(newChildren[i]);
      }
    } else {
      node.index = counter;
      node.minIndex = counter;
      node.maxIndex = counter;
      counter++;
    }
  }

  var rootNode = $.extend({}, tree.rootNode);
  rootNode.parent = undefined;
  recurse(rootNode);
  return {
    nLeafNodes: tree.nLeafNodes,
    maxDepth: tree.maxDepth,
    rootNode: rootNode
  };
};
morpheus.DendrogramUtil.collapseAtDepth = function (rootNode, maxDepth) {
  // restore collapsed children
  morpheus.DendrogramUtil.dfs(rootNode, function (d) {
    if (d.collapsedChildren) {
      d.children = d.collapsedChildren;
      d.collapsedChildren = undefined;
    }
    return true;
  });
  // collapse nodes below specified depth
  morpheus.DendrogramUtil.dfs(rootNode, function (d) {
    var depth = d.depth;
    if (depth > maxDepth) {
      d.collapsedChildren = d.children;
      d.children = undefined;
      return false;
    }
    return true;
  });
};
morpheus.DendrogramUtil.setNodeDepths = function (rootNode) {
  var max = 0;

  function recurse(node, depth) {
    var children = node.children;
    node.depth = depth;
    max = Math.max(depth, max);
    if (children !== undefined) {
      var i = -1;
      var j = depth + 1;
      var n = children.length;
      while (++i < n) {
        var d = recurse(children[i], j);
      }
    }
    return node;
  }

  recurse(rootNode, 0);
  return max;
};
morpheus.DendrogramUtil.sortDendrogram = function (root, vectorToSortBy,
                                                   project, summaryFunction) {
  summaryFunction = summaryFunction || function (array) {
    var min = Number.MAX_VALUE;
    for (var i = 0; i < array.length; i++) {
      // sum += array[i].weight;
      min = Math.min(min, array[i].weight);
    }
    return min;
  };
  var setWeights = function (node) {
    if (node.children !== undefined) {
      var children = node.children;
      for (var i = 0; i < children.length; i++) {
        setWeights(children[i]);
      }
      node.weight = summaryFunction(children);
    } else {
      node.weight = vectorToSortBy.getValue(node.index);
    }
  };
  setWeights(root);
  // sort children by weight
  var nodeIdToModelIndex = {};
  var leafNodes = morpheus.DendrogramUtil.getLeafNodes(root);
  _.each(leafNodes, function (node) {
    nodeIdToModelIndex[node.id] = project.convertViewColumnIndexToModel(node.index);
  });
  morpheus.DendrogramUtil.dfs(root, function (node) {
    if (node.children) {
      node.children.sort(function (a, b) {
        return (a.weight === b.weight ? 0 : (a.weight < b.weight ? -1
          : 1));
      });
    }
    return true;
  });
  morpheus.DendrogramUtil.setIndices(root);
  var sortOrder = [];
  _.each(leafNodes, function (node) {
    var oldModelIndex = nodeIdToModelIndex[node.id];
    var newIndex = node.index;
    sortOrder[newIndex] = oldModelIndex;
  });
  return sortOrder;
};
morpheus.DendrogramUtil.leastCommonAncestor = function (leafNodes) {
  function getPathToRoot(node) {
    var path = new morpheus.Map();
    while (node != null) {
      path.set(node.id, node);
      node = node.parent;
    }
    return path;
  }

  var path = getPathToRoot(leafNodes[0]);
  for (var i = 1; i < leafNodes.length; i++) {
    var path2 = getPathToRoot(leafNodes[i]);
    path.forEach(function (node, id) {
      if (!path2.has(id)) {
        path.remove(id);
      }
    });
    // keep only those in path that are also in path2
  }
  var max = -Number.MAX_VALUE;
  var maxNode;
  path.forEach(function (n, id) {
    if (n.depth > max) {
      max = n.depth;
      maxNode = n;
    }
  });
  return maxNode;
};
// morpheus.DendrogramUtil.computePositions = function(rootNode, positions)
// {
// if (rootNode == null) {
// return;
// }
// morpheus.DendrogramUtil._computePositions(rootNode, positions);
// };
// /**
// * position is (left+right)/2
// */
// morpheus.DendrogramUtil._computePositions = function(node, positions) {
// if (node.children !== undefined) {
// var children = node.children;
// var left = children[0];
// var right = children[1];
// morpheus.DendrogramUtil._computePositions(left, positions);
// morpheus.DendrogramUtil._computePositions(right, positions);
// morpheus.DendrogramUtil.setIndex(node);
// node.position = (left.position + right.position) / 2;
// } else {
// node.position = positions.getItemSize(node.index) / 2
// + positions.getPosition(node.index);
// }
// };

/**
 *
 * @param options.rootNode Dendrogram root node
 * @param options.text Search text
 * @param options.defaultMatchMode
 *            'exact' or 'contains'
 * @param options.matchAllPredicates Whether to match all predicates
 */
morpheus.DendrogramUtil.search = function (options) {
  var searchText = options.text;
  var rootNode = options.rootNode;
  var tokens = morpheus.Util.getAutocompleteTokens(searchText);
  var predicates;
  var nmatches = 0;
  var matchAllPredicates = options.matchAllPredicates === true;

  if (tokens == null || tokens.length == 0) {
    morpheus.DendrogramUtil.dfs(rootNode, function (node) {
      node.search = false;
      return true;
    });
    nmatches = -1;
  } else {
    predicates = morpheus.Util.createSearchPredicates({
      tokens: tokens,
      defaultMatchMode: options.defaultMatchMode
    });
    var npredicates = predicates.length;
    morpheus.DendrogramUtil.dfs(
      rootNode,
      function (node) {
        var matches = false;
        if (node.info) {
          searchLabel:
            if (!matchAllPredicates) { // at least one predicate matches
              for (var p = 0; p < npredicates; p++) {
                var predicate = predicates[p];
                var filterColumnName = predicate.getField();
                if (filterColumnName != null) {
                  var vals = node.info[filterColumnName];
                  for (var i = 0, nvals = vals.length; i < nvals; i++) {
                    if (predicate.accept(vals[i])) {
                      matches = true;
                      break searchLabel;
                    }
                  }
                } else {
                  for (var name in node.info) {
                    var vals = node.info[name];
                    for (var i = 0, nvals = vals.length; i < nvals; i++) {
                      if (predicate.accept(vals[i])) {
                        matches = true;
                        break searchLabel;
                      }
                    }
                  }

                }
              }
            } else { // all predicates must match
              matches = true;
              for (var p = 0; p < npredicates; p++) {
                var predicate = predicates[p];
                var filterColumnName = predicate.getField();
                if (filterColumnName != null) {
                  var vals = node.info[filterColumnName];
                  for (var i = 0, nvals = vals.length; i < nvals; i++) {
                    if (!predicate.accept(vals[i])) {
                      matches = false;
                      break searchLabel;
                    }
                  }
                } else {
                  for (var name in node.info) {
                    var vals = node.info[name];
                    for (var i = 0, nvals = vals.length; i < nvals; i++) {
                      if (!predicate.accept(vals[i])) {
                        matches = false;
                        break searchLabel;
                      }
                    }
                  }

                }
              }
            }
        }
        node.search = matches;
        if (matches) {
          nmatches++;
        }
        return true;
      }
    );

  }
  return nmatches;
}
;
morpheus.DendrogramUtil.squishNonSearchedNodes = function (
  heatMap,
  isColumns) {
  if (isColumns) {
    heatMap.getHeatMapElementComponent().getColumnPositions().setSize(13);
  } else {
    heatMap.getHeatMapElementComponent().getRowPositions().setSize(13);
  }
  var expandedLeafNodes = {};
  var dendrogram = isColumns ? heatMap.columnDendrogram
    : heatMap.rowDendrogram;
  morpheus.DendrogramUtil.dfs(dendrogram.tree.rootNode, function (node) {
    for (var i = node.minIndex; i <= node.maxIndex; i++) {
      if (node.search) {
        expandedLeafNodes[i] = true;
      }
    }
    return true;
  });
  var clusterIds = [];
  var previous = expandedLeafNodes[0];
  var squishedIndices = {};
  if (!previous) {
    squishedIndices[0] = true;
  }
  var clusterNumber = 0;
  clusterIds.push(clusterNumber);
  for (var i = 1, nleaves = dendrogram.tree.leafNodes.length; i < nleaves; i++) {
    var expanded = expandedLeafNodes[i];
    if (expanded !== previous) {
      clusterNumber++;
      previous = expanded;
    }
    if (!expanded) {
      squishedIndices[i] = true;
    }
    clusterIds.push(clusterNumber);
  }
  if (isColumns) {
    heatMap.getHeatMapElementComponent().getColumnPositions().setSquishedIndices(squishedIndices);
    heatMap.getProject().setGroupColumns(
      [new morpheus.SpecifiedGroupByKey(clusterIds)], false);
  } else {
    heatMap.getHeatMapElementComponent().getRowPositions().setSquishedIndices(squishedIndices);
    heatMap.getProject().setGroupRows(
      [new morpheus.SpecifiedGroupByKey(clusterIds)], false);
  }
};
morpheus.DendrogramUtil.getLeafNodes = function (rootNode) {
  var leafNodes = [];
  morpheus.DendrogramUtil.dfs(rootNode, function (node) {
    if (node.children === undefined) {
      leafNodes.push(node);
    }
    return true;
  });
  return leafNodes;
};

morpheus.DiscreteColorSchemeChooser = function (options) {
  var formBuilder = new morpheus.FormBuilder();
  var map = options.colorScheme.scale;

  formBuilder.append({
    name: 'selected_value',
    type: 'bootstrap-select',
    options: map.keys()
  });
  var $select = formBuilder.find('selected_value');
  formBuilder.append({
    style: 'max-width:50px;',
    name: 'selected_color',
    type: 'color'
  });
  var selectedVal = $select.val();
  var _this = this;
  var $color = formBuilder.find('selected_color');
  $color.val(map.get(selectedVal));
  $color.on('change', function (e) {
    var color = $(this).val();
    map.set(selectedVal, color);
    _this.trigger('change', {
      value: selectedVal,
      color: color
    });
  });
  $select.on('change', function () {
    selectedVal = $select.val();
    var c = map.get(selectedVal);
    $color.val(c);
  });
  this.$div = formBuilder.$form;
};
morpheus.DiscreteColorSchemeChooser.prototype = {};
morpheus.Util.extend(morpheus.DiscreteColorSchemeChooser, morpheus.Events);

morpheus.DiscreteColorSupplier = function () {
  this.colorMap = new morpheus.Map();
  this.hiddenValue = 0;
  this.hiddenValues = new morpheus.Set();
  morpheus.AbstractColorSupplier.call(this);
  this.scalingMode = morpheus.HeatMapColorScheme.ScalingMode.FIXED;
};

morpheus.DiscreteColorSupplier.prototype = {
  createInstance: function () {
    return new morpheus.DiscreteColorSupplier();
  },
  /**
   * @param.array Array of name, value, color pairs
   */
  setColorMap: function (array) {
    this.colorMap = new morpheus.Map();
    this.colors = [];
    this.fractions = [];
    this.names = [];
    this.min = Number.MAX_VALUE;
    this.max = -Number.MAX_VALUE;
    for (var i = 0; i < array.length; i++) {
      this.colorMap.set(array[i].value, array[i].color);
      this.fractions.push(array[i].value);
      this.names.push(array[i].name);
      this.colors.push(array[i].color);
      this.min = Math.min(this.min, array[i].value);
      this.max = Math.max(this.max, array[i].value);
    }
  },
  copy: function () {
    var c = this.createInstance();
    c.names = this.names.slice(0);
    c.colorMap = new morpheus.Map();
    this.colorMap.forEach(function (color, value) {
      c.colorMap.set(value, color);
    });
    c.colors = this.colors.slice(0);
    c.fractions = this.fractions.slice(0);
    this.hiddenValues.forEach(function (val) {
      c.hiddenValues.add(val);
    });

    c.missingColor = this.missingColor;
    return c;
  },

  isStepped: function () {
    return true;
  },
  getColor: function (row, column, value) {
    if (this.hiddenValues.has(value)) {
      value = this.hiddenValue;
    }

    if (isNaN(value)) {
      return this.missingColor;
    }
    return this.colorMap.get(value);
  }
};
morpheus.Util.extend(morpheus.DiscreteColorSupplier,
  morpheus.AbstractColorSupplier);

morpheus.Divider = function (vertical) {
  morpheus.AbstractCanvas.call(this, false);
  this.vertical = vertical;
  var that = this;
  var canvas = this.canvas;
  canvas.style.cursor = vertical ? 'ew-resize' : 'ns-resize';

  if (vertical) {
    this.setBounds({
      height: 15,
      width: 4
    });

  } else {
    this.setBounds({
      height: 4,
      width: 15
    });
  }
  this.hammer = morpheus.Util.hammer(canvas, ['pan']).on('panstart',
    this.panstart = function (event) {
      that.trigger('resizeStart');
      morpheus.CanvasUtil.dragging = true;
    }).on('panmove', this.panmove = function (event) {
    if (that.vertical) {
      that.trigger('resize', {
        delta: event.deltaX
      });
    } else {
      that.trigger('resize', {
        delta: event.deltaY
      });
    }
  }).on('panend', this.panend = function (event) {
    morpheus.CanvasUtil.dragging = false;
    that.trigger('resizeEnd');
  });
  this.paint();

};
morpheus.Divider.prototype = {
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.hammer.off('panstart', this.panstart).off('panmove', this.panmove).off('panend', this.panend);
    this.hammer.destroy();
  },
  getPreferredSize: function () {
    return {
      width: 3,
      height: this.getUnscaledHeight()
    };
  },
  draw: function (clip, context) {
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    context.clearRect(0, 0, width, height);
    context.strokeStyle = '#ddd';
    if (!this.vertical) {// horizontal line at top
      context.beginPath();
      context.moveTo(0, 1.5);
      context.lineTo(width, 1.5);
      context.stroke();
    } else { // vertical line at left
      context.beginPath();
      context.moveTo(0, 0);
      context.lineTo(0, height);
      context.stroke();
    }
  }
};
morpheus.Util.extend(morpheus.Divider, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.Divider, morpheus.Events);

morpheus.DualList = function (leftOptions, rightOptions) {
  var html = [];
  html.push('<div class="container-fluid">');
  html.push('<div class="row">');
  html.push('<div class="col-xs-4"><label>Available Fields</label></div>');
  html.push('<div class="col-xs-2"></div>');
  html.push('<div class="col-xs-4"><label>Selected Fields</label></div>');
  html.push('</div>'); // row
  html.push('<div class="row">');
  html
  .push('<div class="col-xs-4"><select class="form-control" name="left" multiple></select></div>');
  html
  .push('<div class="col-xs-2"><div class="btn-group-vertical" role="group">'
    + '<button name="add" type="button" class="btn btn-xs btn-default">Add</button>'
    + '<button name="remove" type="button" class="btn btn-xs btn-default">Remove</button>'
    + '<button name="up" type="button" class="btn btn-xs btn-default">Move Up</button>'
    + '<button name="down" type="button" class="btn btn-xs btn-default">Move Down</button>'
    + '</div></div>');
  html
  .push('<div class="col-xs-4"><select class="form-control" name="right" multiple></select></div>');
  html.push('</div>'); // row
  html.push('</div>');
  this.$el = $(html.join(''));
  var _this = this;
  this.$el.find('[name=add]').on('click', function () {
    _this.addSelected();
  });
  this.$el.find('[name=remove]').on('click', function () {
    _this.removeSelected();
  });
  this.$el.find('[name=up]').on('click', function () {
    _this.moveUp();
  });
  this.$el.find('[name=down]').on('click', function () {
    _this.moveDown();
  });
  this.left = this.$el.find('[name=left]')[0];
  this.right = this.$el.find('[name=right]')[0];
  for (var i = 0; i < leftOptions.length; i++) {
    this.left.options[i] = leftOptions[i];
  }
  for (var i = 0; i < rightOptions.length; i++) {
    this.right.options[i] = rightOptions[i];
  }
};

morpheus.DualList.prototype = {
  addSelected: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < left.options.length; i++) {
      if (left.options[i].selected) {
        var opt = left.options[i];
        right.options[right.options.length] = new Option(opt.innerHTML,
          opt.value);
        left.options[i] = null;
        i--;
      }
    }
  },
  addAll: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < left.options.length; i++) {
      var opt = left.options[i];
      right.options[right.options.length] = new Option(opt.innerHTML,
        opt.value);
    }
    left.options.length = 0;
  },
  removeSelected: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < right.options.length; i++) {
      if (right.options[i].selected) {
        var opt = right.options[i];
        left.options[left.options.length] = new Option(opt.innerHTML,
          opt.value);
        right.options[i] = null;
        i--;
      }
    }
  },
  getOptions: function (isLeft) {
    var sel = isLeft ? this.left : this.right;
    var options = [];
    for (var i = 0; i < sel.options.length; i++) {
      options.push(sel.options[i].value);
    }
    return options;
  },
  removeAll: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < right.options.length; i++) {
      var opt = right.options[i];
      left.options[left.options.length] = new Option(opt.innerHTML,
        opt.value);
    }
    right.options.length = 0;
  },
  moveUp: function () {
    var right = this.right;
    var selectedOptions = right.selectedOptions;
    var indices = [];
    for (var i = 0; i < selectedOptions.length; i++) {
      indices.push(selectedOptions[i].index);
    }
    var index = morpheus.Util.indexSort(indices, false);
    for (var i = 0; i < selectedOptions.length; i++) {
      var sel = selectedOptions[index[i]].index;
      var optHTML = right.options[sel].innerHTML;
      var optVal = right.options[sel].value;
      var opt1HTML = right.options[sel - 1].innerHTML;
      var opt1Val = right.options[sel - 1].value;
      right.options[sel] = new Option(opt1HTML, opt1Val);
      right.options[sel - 1] = new Option(optHTML, optVal);
      right.options.selectedIndex = sel - 1;
    }

  },
  moveDown: function () {
    var right = this.right;
    var selectedOptions = right.selectedOptions;
    var indices = [];
    for (var i = 0; i < selectedOptions.length; i++) {
      indices.push(selectedOptions[i].index);
    }
    var index = morpheus.Util.indexSort(indices, false);
    for (var i = 0; i < selectedOptions.length; i++) {
      var sel = selectedOptions[index[i]].index;
      var optHTML = right.options[sel].innerHTML;
      var optVal = right.options[sel].value;
      var opt1HTML = right.options[sel + 1].innerHTML;
      var opt1Val = right.options[sel + 1].value;
      right.options[sel] = new Option(opt1HTML, opt1Val);
      right.options[sel + 1] = new Option(optHTML, optVal);
      right.options.selectedIndex = sel + 1;
    }
  }
};

/**
 *
 * @param options.fileCallback Callback when file is selected
 * @param options.optionsCallback Callback when preloaded option is selected
 * @constructor
 */
morpheus.FilePicker = function (options) {
  var html = [];
  html.push('<div>');
  var myComputer = _.uniqueId('morpheus');
  var url = _.uniqueId('morpheus');
  var googleId = _.uniqueId('morpheus');
  var dropbox = _.uniqueId('morpheus');
  var preloaded = _.uniqueId('morpheus');
  html.push('<ul style="margin-bottom:10px;" class="nav nav-pills morpheus">');
  html.push('<li role="presentation" class="active"><a href="#' + myComputer + '"' +
    ' aria-controls="' + myComputer + '" role="tab" data-toggle="tab"><i class="fa fa-desktop"></i>' +
    ' My Computer</a></li>');
  html.push('<li role="presentation"><a href="#' + url + '"' +
    ' aria-controls="' + url + '" role="tab" data-toggle="tav"><i class="fa fa-link"></i>' +
    ' URL</a></li>');

  if (typeof gapi !== 'undefined') {
    html.push('<li role="presentation"><a href="#' + googleId + '"' +
      ' aria-controls="' + googleId + '" role="tab" data-toggle="tab"><i class="fa' +
      ' fa-google"></i>' +
      ' Google</a></li>');
  }
  if (typeof Dropbox !== 'undefined') {
    html.push('<li role="presentation"><a href="#' + dropbox + '"' +
      ' aria-controls="' + dropbox + '" role="tab" data-toggle="tab"><i class="fa fa-dropbox"></i>' +
      ' Dropbox</a></li>');
  }

  var $sampleDatasetsEl = $('<div class="morpheus-preloaded"></div>');
  if (navigator.onLine) {
    html.push('<li role="presentation"><a href="#' + preloaded + '"' +
      ' aria-controls="' + preloaded + '" role="tab" data-toggle="tab"><i class="fa fa-database"></i>' +
      ' Preloaded Datasets</a></li>');

    // lazy load
    new morpheus.SampleDatasets({
      $el: $sampleDatasetsEl,
      show: true,
      callback: function (heatMapOptions) {
        options.optionsCallback(heatMapOptions);
      }
    });
  }

  html.push('</ul>');

  html.push('<div class="tab-content"' +
    ' style="text-align:center;cursor:pointer;height:300px;">');

  html.push('<div role="tabpanel" class="tab-pane active" id="' + myComputer + '">');
  html.push('<div data-name="drop" class="morpheus-file-drop morpheus-landing-panel">');
  html.push('<button class="btn btn-default"><span class="fa-stack"><i' +
    ' class="fa fa-file-o' +
    ' fa-stack-2x"></i> <i class="fa fa-plus fa-stack-1x"></i></span> Select File</button>' +
    ' <div style="padding-top:10px;">or Copy and Paste Clipboard Data, <span' +
    ' class="morpheus-drag-text">Drag and' +
    ' Drop</span></div>');
  html.push('<input name="hiddenFile" style="display:none;" type="file">');
  html.push('</div>');
  html.push('</div>');

  html.push('<div role="tabpanel" class="tab-pane" id="' + url + '">');
  html.push('<div class="morpheus-landing-panel">');
  html.push('<input name="url" placeholder="Enter a URL" class="form-control"' +
    ' style="display:inline;max-width:400px;' +
    ' type="text"><button name="openUrl" class="btn btn-default"' +
    ' type="button">Go</button>');
  html.push('</div>');
  html.push('</div>');

  if (typeof Dropbox !== 'undefined') {
    html.push('<div role="tabpanel" class="tab-pane" id="' + dropbox + '">');
    html.push('<div class="morpheus-landing-panel">');
    html.push('<button name="dropbox" class="btn btn-default">Browse Dropbox</button>');
    html.push('</div>');
    html.push('</div>');
  }
  if (typeof gapi !== 'undefined') {
    html.push('<div role="tabpanel" class="tab-pane" id="' + googleId + '">');
    html.push('<div class="morpheus-landing-panel">');
    html.push('<button name="google" class="btn btn-default">Browse Google Drive</button>');
    html.push('</div>');
    html.push('</div>');
  }
  if (navigator.onLine) {
    html.push('<div role="tabpanel" class="tab-pane" id="' + preloaded + '">');
    html.push('<div class="morpheus-landing-panel">');
    html.push('</div>');
    html.push('</div>');
  }
  html.push('</div>'); // tab-content
  html.push('</div>');
  var $el = $(html.join(''));
  $sampleDatasetsEl.appendTo($el.find('#' + preloaded + ' > .morpheus-landing-panel'));
  this.$el = $el;

  var $file = $el.find('[name=hiddenFile]');
  var $myComputer = $el.find('[id=' + myComputer + ']');
  this.$el.find('.nav').on('click', 'li > a', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });

  var $url = $el.find('[name=url]');
  $url.on('keyup', function (evt) {
    if (evt.which === 13) {
      var text = $.trim($(this).val());
      if (text !== '') {
        options.fileCallback(text);
      }
    }
  });
  $el.find('[name=openUrl]').on('click', function (evt) {
    var text = $.trim($url.val());
    if (text !== '') {
      options.fileCallback(text);
    }
  });

  var $dropbox = $el.find('[name=dropbox]');
  $dropbox.on('click', function (e) {
    Dropbox.choose({
      success: function (results) {
        var val = results[0].link;
        options.fileCallback(val);
      },
      linkType: 'direct',
      multiselect: false

    });
  });

  var $google = $el.find('[name=google]');
  $google.on('click', function () {
    var developerKey = 'AIzaSyBCRqn5xgdUsJZcC6oJnIInQubaaL3aYvI';
    var clientId = '936482190815-85k6k06b98ihv272n0b7f7fm33v5mmfa.apps.googleusercontent.com';
    var scope = ['https://www.googleapis.com/auth/drive'];
    var oauthToken;
    var pickerApiLoaded = false;
    var oauthToken;

    // Use the API Loader script to load google.picker and gapi.auth.
    function onApiLoad() {
      gapi.load('auth', {'callback': onAuthApiLoad});
      gapi.load('picker', {'callback': onPickerApiLoad});
    }

    function onAuthApiLoad() {
      window.gapi.auth.authorize(
        {
          'client_id': clientId,
          'scope': scope,
          'immediate': false
        },
        handleAuthResult);
    }

    function onPickerApiLoad() {
      pickerApiLoaded = true;
      createPicker();
    }

    function handleAuthResult(authResult) {
      if (authResult && !authResult.error) {
        oauthToken = authResult.access_token;
        createPicker();
      }
    }

    // Create and render a Picker object for picking user Photos.
    function createPicker() {
      if (pickerApiLoaded && oauthToken) {
        var picker = new google.picker.PickerBuilder().addView(google.picker.ViewId.DOCS)
          .setOAuthToken(oauthToken)
          .setDeveloperKey(developerKey)
          .setCallback(pickerCallback)
          .build();
        picker.setVisible(true);
        $('.picker-dialog-bg').css('z-index', 1052); // make it appear above modals
        $('.picker-dialog').css('z-index', 1053);
      }
    }

    function pickerCallback(data) {
      if (data.action == google.picker.Action.PICKED) {
        var file = data.docs[0];
        var fileName = file.name;
        var accessToken = gapi.auth.getToken().access_token;
        var xhr = new XMLHttpRequest();
        var url = new String('https://www.googleapis.com/drive/v3/files/' + file.id + '?alt=media');
        url.name = fileName;
        url.headers = {'Authorization': 'Bearer ' + accessToken};
        options.fileCallback(url);
      }

    }

    onApiLoad();
  });
  $file.on('change', function (evt) {
    var files = evt.target.files; // FileList object
    for (var i = 0; i < files.length; i++) {
      options.fileCallback(files[i]);
    }
  });

  $(window).on('paste.morpheus', this.paste = function (e) {
    if ($myComputer.is(':visible')) {
      var text = e.originalEvent.clipboardData.getData('text/plain');
      if (text != null && text.length > 0) {
        e.preventDefault();
        e.stopPropagation();
        var url;
        if (text.indexOf('http') === 0) {
          url = text;
        } else {
          var blob = new Blob([text]);
          url = new String(window.URL.createObjectURL(blob));
          url.name = 'clipboard';
        }
        options.fileCallback(url);
      }
    }
  });
  var $drop = $el.find('[data-name=drop]');
  var _this = this;
  $el.on('remove', function () {
    $(window).off(_this.paste).off(_this.dragover).off(_this.dragenter).off(_this.dragleave).off(_this.drop);
  });
  var clicking = false;
  $drop.on('click', function (e) {
    if (!clicking) {
      clicking = true;
      $file.click();
      clicking = false;
    }
    // e.preventDefault();
  });
  $(window).on(
    'dragover',
    this.dragover = function (e) {
      if ($myComputer.is(':visible')) {
        $drop.addClass('drag');
        e.preventDefault();
        e.stopPropagation();
      }
    }).on(
    'dragenter',
    this.dragenter = function (e) {
      if ($myComputer.is(':visible')) {
        $drop.addClass('drag');
        e.preventDefault();
        e.stopPropagation();
      }
    }).on('dragleave', this.dragleave = function (e) {
    if ($myComputer.is(':visible')) {
      $drop.removeClass('drag');
      e.preventDefault();
      e.stopPropagation();
    }
  }).on('drop', this.drop = function (e) {
    if ($myComputer.is(':visible')) {
      $drop.removeClass('drag');
      if (e.originalEvent.dataTransfer) {
        if (e.originalEvent.dataTransfer.files.length) {
          e.preventDefault();
          e.stopPropagation();
          var files = e.originalEvent.dataTransfer.files;
          for (var i = 0; i < files.length; i++) {
            options.fileCallback(files[i]);
          }
        } else {
          var url = e.originalEvent.dataTransfer.getData('URL');
          options.fileCallback(url);
          e.preventDefault();
          e.stopPropagation();
        }
      }
    }
  });
};

morpheus.FilterUI = function (project, isColumns) {
  var _this = this;
  this.project = project;
  this.isColumns = isColumns;
  var $div = $('<div style="min-width:180px;"></div>');
  this.$div = $div;
  $div.append(this.addBase());
  var $filterMode = $div.find('[name=filterMode]');
  $filterMode.on('change', function (e) {
    var isAndFilter = $filterMode.prop('checked');
    (isColumns ? project.getColumnFilter() : project.getRowFilter())
    .setAnd(isAndFilter);
    isColumns ? _this.project.setColumnFilter(_this.project
    .getColumnFilter(), true) : _this.project.setRowFilter(
      _this.project.getRowFilter(), true);
    e.preventDefault();
  });

  $div.on('click', '[data-name=add]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    // add after
    var index = $row.index();
    var newFilter = new morpheus.AlwaysTrueFilter();
    (isColumns ? project.getColumnFilter() : project.getRowFilter())
    .insert(index, newFilter);
    $row.after(_this.add(newFilter));
    e.preventDefault();
  });
  $div.on('click', '[data-name=delete]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    var index = $row.index() - 1;
    (isColumns ? project.getColumnFilter() : project.getRowFilter())
    .remove(index);
    $row.remove();
    isColumns ? _this.project.setColumnFilter(_this.project
    .getColumnFilter(), true) : _this.project.setRowFilter(
      _this.project.getRowFilter(), true);
    e.preventDefault();
  });
  $div.on('submit', 'form', function (e) {
    var $this = $(this);
    e.preventDefault();
  });
  $div.on('change', '[name=by]', function (e) {
    var $this = $(this);
    var fieldName = $this.val();
    var $row = $this.closest('.morpheus-entry');
    var index = $row.index() - 1;
    if (fieldName == '') {
      $row.find('[data-name=ui]').empty();
    } else {
      _this.createFilter({
        fieldName: fieldName,
        $div: $this
      });
    }

    isColumns ? _this.project.setColumnFilter(_this.project
    .getColumnFilter(), true) : _this.project.setRowFilter(
      _this.project.getRowFilter(), true);
  });
  // show initial filters
  var combinedFilter = (isColumns ? project.getColumnFilter() : project
  .getRowFilter());
  var filters = combinedFilter.getFilters ? combinedFilter.getFilters() : [];
  for (var i = 0; i < filters.length; i++) {
    this.createFilter({
      filter: filters[i]
    });
  }
  if (combinedFilter.on) {
    combinedFilter.on('add', function (e) {
      _this.createFilter({
        filter: e.filter
      });
    });
    combinedFilter.on('remove', function (e) {
      // offset of 1 for header
      var $row = $div.find('.morpheus-entry')[1 + e.index].remove();
    });
    combinedFilter.on('and', function (e) {
      $filterMode.prop('checked', e.source.isAnd());
    });

  }
};

morpheus.FilterUI.rangeFilter = function (project, name, isColumns, $ui, filter) {
  $ui.empty();
  var html = [];
  html.push('<label>Range of values</label><br />');
  html
  .push('<label>>= </label> <input style="max-width:200px;" class="form-control input-sm" name="min" type="text" />');
  html
  .push('<label> and <= </label> <input style="max-width:200px;" class="form-control input-sm" name="max" type="text" />');
  html.push('<br /><a data-name="switch" href="#">Switch to top filter</a>');
  var $form = $(html.join(''));
  $form.appendTo($ui);
  $ui.find('[data-name=switch]')
  .on(
    'click',
    function (e) {
      e.preventDefault();
      var newFilter = morpheus.FilterUI.topFilter(project,
        name, isColumns, $ui);
      var index = -1;
      var filters = isColumns ? project.getColumnFilter()
      .getFilters() : project.getRowFilter()
      .getFilters();
      for (var i = 0; i < filters.length; i++) {
        if (filters[i] === filter) {
          index = i;
          break;
        }
      }
      if (index === -1) {
        throw new Error('Filter not found.');
      }
      (isColumns ? project.getColumnFilter() : project
      .getRowFilter()).set(index, newFilter);
      isColumns ? project.setColumnFilter(project
      .getColumnFilter(), true) : project
      .setRowFilter(project.getRowFilter(), true);
    });
  var $min = $ui.find('[name=min]');
  var $max = $ui.find('[name=max]');
  if (!filter) {
    filter = new morpheus.RangeFilter(-Number.MAX_VALUE, Number.MAX_VALUE,
      name, isColumns);
  } else {
    $min.val(filter.min);
    $max.val(filter.max);
  }

  $min.on('keyup', _.debounce(function (e) {
    filter.setMin(parseFloat($.trim($(this).val())));
    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);

  }, 500));
  $max.on('keyup', _.debounce(function (e) {
    filter.setMax(parseFloat($.trim($(this).val())));
    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);

  }, 500));

  return filter;

};
morpheus.FilterUI.topFilter = function (project, name, isColumns, $ui, filter) {
  $ui.empty();
  var html = [];
  html.push('<label>Top</label><br />');
  html
  .push('<select style="width:auto;" class="form-control input-sm" name="direction"><option value="Top">Top</option><option value="Bottom">Bottom</option><option value="TopBottom">Top/Bottom</option></select>');
  html
  .push(' <label>N </label> <input style="max-width:200px;" class="form-control input-sm" name="n" type="text" />');
  html.push('<br /><a data-name="switch" href="#">Switch to range filter</a>');
  var $form = $(html.join(''));
  $form.appendTo($ui);
  var $n = $ui.find('[name=n]');
  var $direction = $ui.find('[name=direction]');
  $ui.find('[data-name=switch]')
  .on(
    'click',
    function (e) {
      e.preventDefault();
      var newFilter = morpheus.FilterUI.rangeFilter(project,
        name, isColumns, $ui);
      var index = -1;
      var filters = isColumns ? project.getColumnFilter()
      .getFilters() : project.getRowFilter()
      .getFilters();
      for (var i = 0; i < filters.length; i++) {
        if (filters[i] === filter) {
          index = i;
          break;
        }
      }
      if (index === -1) {
        throw new Error('Filter not found.');
      }
      (isColumns ? project.getColumnFilter() : project
      .getRowFilter()).set(index, newFilter);
      isColumns ? project.setColumnFilter(project
      .getColumnFilter(), true) : project
      .setRowFilter(project.getRowFilter(), true);
    });
  if (!filter) {
    filter = new morpheus.TopNFilter(NaN, morpheus.TopNFilter.TOP, name, isColumns);
  } else {
    var dirVal;
    if (filter.direction === morpheus.TopNFilter.TOP) {
      dirVal = 'Top';
    } else if (filter.direction === morpheus.TopNFilter.BOTTOM) {
      dirVal = 'Bottom';
    } else {
      dirVal = 'TopBottom';
    }
    $direction.val(dirVal);
    $n.val(filter.n);
  }

  $direction.on('change', function () {
    var dir = $(this).val();
    var dirVal;
    if (dir === 'Top') {
      dirVal = morpheus.TopNFilter.TOP;
    } else if (dir === 'Bottom') {
      dirVal = morpheus.TopNFilter.BOTTOM;
    } else {
      dirVal = morpheus.TopNFilter.TOP_BOTTOM;
    }
    filter.setDirection(dirVal);

    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);
  });
  $n.on('keyup', _.debounce(function (e) {
    filter.setN(parseInt($.trim($(this).val())));
    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);

  }, 500));

  return filter;
};
morpheus.FilterUI.prototype = {
  /**
   *
   * @param options
   *            options.$div div to add filter to or null to add to end
   *            options.filter Pre-existing filter or null to create filter
   *            options.fieldName Field name to filter on
   */
  createFilter: function (options) {
    var index = -1;
    var $div = options.$div;
    var isColumns = this.isColumns;
    var filter = options.filter;
    var project = this.project;
    var fieldName = filter ? filter.name : options.fieldName;
    var $ui;
    if (!$div) {
      // add filter to end
      var $add = $(this.add(filter));
      $add.appendTo(this.$div);
      $ui = $add.find('[data-name=ui]');
    } else { // existing $div
      var $row = $div.closest('.morpheus-entry');
      index = $row.index() - 1;
      $ui = $row.find('[data-name=ui]');
    }

    $ui.empty();
    var vector = (isColumns ? this.project.getFullDataset()
    .getColumnMetadata() : this.project.getFullDataset()
    .getRowMetadata()).getByName(fieldName);

    if (filter instanceof morpheus.RangeFilter) {
      morpheus.FilterUI.rangeFilter(project, fieldName, isColumns, $ui,
        filter);
    } else if (filter instanceof morpheus.TopNFilter) {
      morpheus.FilterUI.topFilter(project, fieldName, isColumns, $ui,
        filter);
    } else if (filter == null && morpheus.VectorUtil.isNumber(vector)
      && morpheus.VectorUtil.containsMoreThanNValues(vector, 9)) {
      filter = morpheus.FilterUI.rangeFilter(project, fieldName,
        isColumns, $ui, filter);
    } else {
      var set = morpheus.VectorUtil.getSet(vector);
      var array = set.values();
      array.sort(morpheus.SortKey.ASCENDING_COMPARATOR);
      if (!filter) {
        filter = new morpheus.VectorFilter(new morpheus.Set(), set
        .size(), fieldName, isColumns);
      } else {
        filter.maxSetSize = array.length;
      }

      var checkBoxList = new morpheus.CheckBoxList({
        responsive: false,
        $el: $ui,
        items: array,
        set: filter.set
      });
      checkBoxList.on('checkBoxSelectionChanged', function () {
        isColumns ? project.setColumnFilter(project.getColumnFilter(),
          true) : project.setRowFilter(project.getRowFilter(),
          true);

      });
    }
    if (index !== -1) {
      // set the filter index
      if (fieldName !== '') {
        (isColumns ? project.getColumnFilter() : project.getRowFilter())
        .set(index, filter);
      } else {
        (isColumns ? project.getColumnFilter() : project.getRowFilter())
        .set(index, new morpheus.AlwaysTrueFilter());
      }
    }
    return filter;
  },

  addBase: function () {
    var html = [];
    html
    .push('<div style="padding-bottom:2px;border-bottom:1px solid #eee" class="morpheus-entry">');
    html.push('<div class="row">');
    html
    .push('<div class="col-xs-12">'
      + '<div class="checkbox"><label><input type="checkbox" name="filterMode">Pass all filters</label></div> '

      + '</div>');
    html.push('</div>');
    html.push('<div class="row">');
    html
    .push('<div class="col-xs-8"><a class="btn btn-default btn-xs" role="button"' +
      ' data-name="add" href="#">Add</a></div>');

    html.push('</div>');
    html.push('</div>');
    return html.join('');
  },
  add: function (filter) {
    var project = this.project;
    var isColumns = this.isColumns;
    var fields = morpheus.MetadataUtil.getMetadataNames(isColumns ? project
    .getFullDataset().getColumnMetadata() : project
    .getFullDataset().getRowMetadata());
    var html = [];
    html.push('<div class="morpheus-entry">');

    html.push('<div class="form-group">');
    html.push('<label>Field</label>');
    // field

    html
    .push('<select style="max-width:160px;overflow-x:hidden;" name="by" class="form-control input-sm">');
    html.push('<option value=""></option>');
    var filterField = filter ? filter.toString() : null;

    _.each(fields, function (field) {
      html.push('<option value="' + field + '"');
      if (field === filterField) {
        html.push(' selected');
      }
      html.push('>');
      html.push(field);
      html.push('</option>');
    });
    html.push('</select>');
    html.push('</div>');
    html.push('<div class="row">');
    // filter ui
    html.push('<div data-name="ui" class="col-xs-12"></div>');
    html.push('</div>');

    // end filter ui

    // add/delete
    html
    .push('<div style="padding-bottom:6px; border-bottom:1px solid #eee" class="row">');

    html.push('<div class="col-xs-11">');

    html
    .push('<a class="btn btn-default btn-xs" role="button" data-name="delete"' +
      ' href="#">Remove</a>');
    html.push('</div>');

    html.push('</div>'); // row
    html.push('</div>'); // morpheus-entry
    return html.join('');
  }
};

/**
 *
 * @param options.fontModel
 * @param options.track
 * @param options.heatMap
 * @constructor
 */
morpheus.FontChooser = function (options) {
  var _this = this;
  var fontModel = options.fontModel;
  var track = options.track;
  var heatMap = options.heatMap;
  // ensure map exists
  fontModel.getMappedValue(track.getVector(track.settings.fontField), track.getVector(track.settings.fontField).getValue(0));
  var formBuilder = new morpheus.FormBuilder();
  formBuilder.append({
    value: track.settings.fontField != null,
    type: 'checkbox',
    name: 'use_another_annotation_to_determine_font'
  });
  var annotationNames = morpheus.MetadataUtil.getMetadataNames(
    track.isColumns ? heatMap.getProject().getFullDataset().getColumnMetadata() : heatMap.getProject().getFullDataset().getRowMetadata());
  annotationNames.splice(annotationNames.indexOf(track.getName()), 1);
  formBuilder.append({
    name: 'annotation_name',
    type: 'bootstrap-select',
    options: annotationNames,
    search: annotationNames.length > 10,
    value: track.settings.fontField
  });
  formBuilder.setVisible('annotation_name', track.settings.fontField != null);
  formBuilder.append({
    name: 'selected_value',
    type: 'bootstrap-select',
    search: true,
    options: fontModel.getMap(track.settings.fontField != null ? track.settings.fontField : track.getName()).keys()
  });
  var $selectedValue = formBuilder.find('selected_value');
  formBuilder.append({
    name: 'selected_font',
    type: 'bootstrap-select',
    options: [{name: 'normal', value: 400}, {name: 'bold', value: 700}, {name: 'bolder', value: 900}]
  });

  var repaint = function () {
    track.setInvalid(true);
    track.repaint();
  };
  formBuilder.find('use_another_annotation_to_determine_font').on('change', function () {
    var checked = $(this).prop('checked');
    formBuilder.setValue('annotation_name', null);
    formBuilder.setValue('selected_value', null);
    formBuilder.setVisible('annotation_name', checked);
    if (!checked) {
      track.settings.fontField = null;
    }
    repaint();
  });
  formBuilder.find('annotation_name').on('change', function () {
    var annotationName = $(this).val();
    fontModel.getMappedValue(track.getVector(annotationName), track.getVector(annotationName).getValue(0));
    track.settings.fontField = annotationName;
    // ensure map exists
    formBuilder.setOptions('selected_value', fontModel.getMap(track.settings.fontField != null ? track.settings.fontField : track.getName()).keys());
    formBuilder.setValue('selected_value', null);
    repaint();
  });

  var $selectedFont = formBuilder.find('selected_font');
  $selectedFont.on('change', function (e) {
    fontModel.setMappedValue(track.getVector(track.settings.fontField), $selectedValue.val(), {weight: $(this).val()});
    repaint();
  });

  var updateMappedValue = function () {
    var selectedVal = $selectedValue.val();
    var mappedValue = fontModel.getMappedValue(track.getVector(track.settings.fontField), selectedVal);
    formBuilder.setValue('selected_font', mappedValue.weight);
  };
  $selectedValue.on('change', function () {
    // update displayed value
    updateMappedValue();
  });
  updateMappedValue();
  this.$div = formBuilder.$form;

};
morpheus.Util.extend(morpheus.FontChooser, morpheus.Events);

morpheus.FormBuilder = function (options) {
  var _this = this;
  this.prefix = _.uniqueId('form');
  this.$form = $('<form></form>');
  this.$form.attr('role', 'form').attr('id', this.prefix);
  this.formStyle = options == null || options.formStyle == null ? 'horizontal' : options.formStyle;
  this.$form.addClass('morpheus');
  if (this.formStyle === 'horizontal') {
    this.titleClass = 'col-xs-12 control-label';
    this.labelClass = 'col-xs-4 control-label';
    this.$form.addClass('form-horizontal');
  } else if (this.formStyle === 'vertical') {
    this.labelClass = 'control-label';
    this.titleClass = 'control-label';
  } else if (this.formStyle === 'inline') {
    this.titleClass = '';
    this.labelClass = '';
    this.$form.addClass('form-inline');
  }
  this.$form.on('submit', function (e) {
    e.preventDefault();
  });
  this.$form.on(
    'dragover',
    function (e) {
      var node = $(e.originalEvent.srcElement).parent().parent()
        .prev();
      if (node.is('select') && node.hasClass('file-input')) {
        $(e.originalEvent.srcElement).parent().css('border',
          '1px solid black');
        e.preventDefault();
        e.stopPropagation();
      }
    }).on(
    'dragenter',
    function (e) {
      var node = $(e.originalEvent.srcElement).parent().parent()
        .prev();
      if (node.is('select') && node.hasClass('file-input')) {
        $(e.originalEvent.srcElement).parent().css('border',
          '1px solid black');
        e.preventDefault();
        e.stopPropagation();
      }
    }).on('dragleave', function (e) {
    var node = $(e.originalEvent.srcElement).parent().parent().prev();
    if (node.is('select') && node.hasClass('file-input')) {
      $(e.originalEvent.srcElement).parent().css('border', '');
      e.preventDefault();
      e.stopPropagation();
    }
  }).on('drop', function (e) {
    var node = $(e.originalEvent.srcElement).parent().parent().prev();
    if (node.is('select') && node.hasClass('file-input')) {
      var isMultiple = node.data('multiple'); // multiple files?
      $(e.originalEvent.srcElement).parent().css('border', '');
      var name = node.attr('name');
      name = name.substring(0, name.length - '_picker'.length);
      if (e.originalEvent.dataTransfer) {
        if (e.originalEvent.dataTransfer.files.length) {
          e.preventDefault();
          e.stopPropagation();
          var files = e.originalEvent.dataTransfer.files;
          _this.setValue(name, isMultiple ? files : files[0]);
          _this.trigger('change', {
            name: name,
            value: files[0]
          });
        } else {
          var url = e.originalEvent.dataTransfer.getData('URL');
          e.preventDefault();
          e.stopPropagation();
          _this.setValue(name, isMultiple ? [url] : url);
          _this.trigger('change', {
            name: name,
            value: url
          });
        }
      }
    }
  });
  // this.labelColumnDef = '4';
  // this.fieldColumnDef = '8';
};

morpheus.FormBuilder.showProgressBar = function (options) {
  var content = [];
  content.push('<div class="container-fluid">');
  content.push('<div class="row">');
  content.push('<div class="col-xs-8">');
  content
    .push(
      '<div class="progress progress-striped active"><div class="progress-bar" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" style="width: 100%"></div></div>');
  content.push('</div>'); // col
  content.push('<div class="col-xs-2">');
  content
    .push('<input class="btn btn-default" type="button" name="stop" value="Cancel">');
  content.push('</div>'); // col
  content.push('</div>'); // row
  if (options.subtitle) {
    content.push('<div class="row"><div class="col-xs-8">');
    content.push('<p class="text-muted">');
    content.push(options.subtitle);
    content.push('</p>');
    content.push('</div></div>');
  }
  content.push('</div>');
  var $content = $(content.join(''));
  $content.find('[name=stop]').on('click', function (e) {
    options.stop();
    e.preventDefault();
  });
  return morpheus.FormBuilder.showInDraggableDiv({
    title: options.title,
    $content: $content
  });
};
morpheus.FormBuilder.showInDraggableDiv = function (options) {
  var width = options.width || '300px';
  var html = [];
  html
    .push('<div style="z-index: 1050; top: 100px; position:absolute; padding-left:10px; padding-right:10px; width:'
      + width
      + ' ; background:white; box-shadow: 0 5px 15px rgba(0,0,0,0.5); border: 1px solid rgba(0,0,0,0.2); border-radius: 6px;">');

  if (options.title != null) {
    html
      .push('<h4 style="cursor:move; border-bottom: 1px solid #e5e5e5;" name="header">'
        + options.title + '</h4>');
  }
  html.push('<div name="content"></div>');
  html.push('</div>');

  var $div = $(html.join(''));
  var $content = $div.find('[name=content]');
  $div.find('[name=header]').on('dblclick', function () {
    if ($content.css('display') === 'none') {
      $content.css('display', '');
    } else {
      $content.css('display', 'none');
    }
  });

  options.$content.appendTo($content);
  $div.css('left', ($(window).width() / 2) - $content.outerWidth() / 2);
  $div.draggable({
    //handle: '[name=header]',
    containment: 'document'
  });
  // $div.resizable();
  $div.appendTo(options.appendTo != null ? options.appendTo : $(document.body));
  return $div;
};

morpheus.FormBuilder.showMessageModal = function (options) {
  var $div = morpheus.FormBuilder
    ._showInModal({
      modalClass: options.modalClass,
      title: options.title,
      html: options.html,
      footer: ('<button type="button" class="btn btn-default"' +
        ' data-dismiss="modal">OK</button>'),
      backdrop: options.backdrop,
      size: options.size,
      focus: options.focus,
      appendTo: options.appendTo
    });
  $div.find('button').focus();
  return $div;

  // if (options.draggable) {
  // $div.draggable({
  // handle : $div.find(".modal-header")
  // });
  // }
};

morpheus.FormBuilder._showInModal = function (options) {
  var html = [];
  options = $.extend({}, {
    size: '',
    close: true,
    modalClass: ''
  }, options);
  html.push('<div tabindex="-1" class="modal' + (options.modalClass ? (' ' + options.modalClass) : '') + '" role="dialog"' +
    ' aria-hidden="false"');
  if (options.z) {
    html.push(' style="z-index: ' + options.z + ' !important;"');
  }
  html.push('>');
  html.push('<div class="modal-dialog ' + options.size + '">');
  html.push('<div class="modal-content">');
  html.push(' <div class="modal-header">');
  if (options.close) {
    html
      .push('  <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button>');
  }
  if (options.title != null) {
    html.push('<h4 class="modal-title">' + options.title + '</h4>');
  }
  html.push('</div>');
  html.push('<div class="modal-body">');
  html.push('</div>');
  if (options.footer) {
    html.push('<div class="modal-footer">');
    html.push(options.footer);
  }
  html.push('</div>');
  html.push('</div>');
  html.push('</div>');
  html.push('</div>');
  var $div = $(html.join(''));
  $div.on('mousewheel', function (e) {
    e.stopPropagation();
  });
  $div.find('.modal-body').html(options.html);
  $div.prependTo(options.appendTo != null ? options.appendTo : $(document.body));
  $div.modal({
    keyboard: true,
    backdrop: options.backdrop === true ? true : false
  }).on('hidden.bs.modal', function (e) {
    $div.remove();
    if (options.onClose) {
      options.onClose();
    }
    if (options.focus) {
      $(options.focus).focus();
    }
  });

  return $div;
};
/**
 *
 * @param options.z Modal z-index
 * @param options.title Modal title
 * @param options.html Model content
 * @param options.close Whether to show a close button in the footer
 * @param options.onClose {Function} Funtion to invoke when modal is hidden
 * @param options.backdrop Whether to show backdrop
 * @param.options Modal size
 * @param options.focus Element to return focus to when modal is hidden
 * @param options.modalClass
 */
morpheus.FormBuilder.showInModal = function (options) {
  return morpheus.FormBuilder
    ._showInModal({
      modalClass: options.modalClass,
      title: options.title,
      html: options.html,
      footer: options.close ? ('<button type="button" class="btn btn-default" data-dismiss="modal">'
        + options.close + '</button>')
        : null,
      onClose: options.onClose,
      appendTo: options.appendTo,
      backdrop: options.backdrop,
      size: options.size,
      focus: options.focus
    });
  // if (options.draggable) {
  // $div.draggable({
  // handle : $div.find(".modal-header")
  // });
  // }
};

/**
 *
 * @param options.ok
 * @param options.cancel
 * @param options.apply
 * @param options.title
 * @param options.content
 * @param options.okCallback
 * @param options.cancelCallba
 * @param options.okFocus
 *
 */
morpheus.FormBuilder.showOkCancel = function (options) {
  options = $.extend({}, {
    ok: true,
    cancel: true
  }, options);
  var footer = [];
  if (options.ok) {
    footer
      .push('<button name="ok" type="button" class="btn btn-default">OK</button>');
  }
  if (options.apply) {
    footer
      .push('<button name="apply" type="button" class="btn btn-default">Apply</button>');
  }
  if (options.cancel) {
    footer
      .push('<button name="cancel" type="button" data-dismiss="modal" class="btn btn-default">Cancel</button>');
  }
  var $div = morpheus.FormBuilder._showInModal({
    title: options.title,
    html: options.content,
    footer: footer.join(''),
    size: options.size,
    close: options.close,
    onClose: options.onClose,
    focus: options.focus,
    appendTo: options.appendTo
  });
  // if (options.align === 'right') {
  // $div.css('left', $(window).width()
  // - $div.find('.modal-content').width() - 60);
  // }

  var $ok = $div.find('[name=ok]');
  $ok.on('click', function (e) {
    if (options.okCallback) {
      options.okCallback();
    }
    $div.modal('hide');
  });
  $div.find('[name=cancel]').on('click', function (e) {
    if (options.cancelCallback) {
      options.cancelCallback();
    }
    $div.modal('hide');
  });
  if (options.okFocus) {
    $ok.focus();
  }

  if (options.draggable) {
    $div.draggable({
      handle: '.modal-header',
      containment: 'document'
    });
  }
  return $div;
};

morpheus.FormBuilder.hasChanged = function (object, keyToUIElement) {
  var keys = _.keys(keyToUIElement);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = object[key];
    var $element = keyToUIElement[key];
    if (value !== morpheus.FormBuilder.getValue($element)) {
      return true;
    }
  }
  return false;
};
morpheus.FormBuilder.getValue = function ($element) {
  var list = $element.data('morpheus.checkbox-list');
  if (list != null) {
    return list.val();
  }
  if ($element.attr('type') === 'radio') {
    return $element.filter(':checked').val();
  }
  if ($element.data('type') === 'file') {
    return $element.data('files');
  }
  return $element.attr('type') === 'checkbox' ? $element.prop('checked') : $element.val();
};

morpheus.FormBuilder.prototype = {
  appendContent: function ($content) {
    this.$form.append($content);
  },
  addSeparator: function () {
    var html = [];
    html.push('<div class="form-group">');
    if (this.formStyle === 'horizontal') {
      html.push('<div class="col-xs-12">');
    }
    html.push('<hr />');
    if (this.formStyle === 'horizontal') {
      html.push('</div>');
    }
    html.push('</div>');
    this.$form.append(html.join(''));
  },
  _append: function (html, field, isFieldStart) {
    var _this = this;
    var required = field.required;
    var name = field.name;
    var type = field.type;
    if (type == 'separator') {
      if (this.formStyle === 'horizontal') {
        html.push('<div class="col-xs-12">');
      } else {
        html.push('<div class="form-group">');
      }

      html.push('<hr />');
      html.push('</div>');
      return;
    }
    var title = field.title;
    var disabled = field.disabled;
    var help = field.help;
    var value = field.value;
    var showLabel = field.showLabel;
    var style = field.style || '';
    var col = '';
    var labelColumn = '';
    if (this.formStyle === 'horizontal') {
      col = field.col || 'col-xs-8';
    }

    if (showLabel === undefined) {
      showLabel = 'checkbox' !== type && 'button' !== type
        && 'radio' !== type;
      showLabel = showLabel || field.options !== undefined;
    }
    var id = _this.prefix + '_' + name;
    if (title === undefined) {
      title = name.replace(/_/g, ' ');
      title = title[0].toUpperCase() + title.substring(1);
    }
    var endingDiv = false;
    if (showLabel) {
      html.push('<label for="' + id + '" class="' + this.labelClass
        + '">');
      html.push(title);
      html.push('</label>');
      if (isFieldStart && this.formStyle !== 'inline') {
        html.push('<div class="' + col + '">');
        endingDiv = true;
      }
    } else if (isFieldStart && this.formStyle === 'horizontal') { // no label
      html.push('<div class="col-xs-offset-4 ' + col + '">');
      endingDiv = true;
    }
    if ('radio' === type) {
      if (field.options) {
        _.each(field.options,
          function (choice) {
            var isChoiceObject = _.isObject(choice)
              && choice.value !== undefined;
            var optionValue = isChoiceObject ? choice.value
              : choice;
            var optionText = isChoiceObject ? choice.name
              : choice;
            var selected = value === optionValue;
            html.push('<div class="radio"><label>');
            html.push('<input style="' + style + '" value="' + optionValue
              + '" name="' + field.name
              + '" type="radio"');
            if (selected) {
              html.push(' checked');
            }
            html.push('> ');
            if (choice.icon) {
              html.push('<span class="' + choice.icon
                + '"></span> ');
            }
            optionText = optionText[0].toUpperCase()
              + optionText.substring(1);
            html.push(optionText);
            html.push('</label></div>');
          });
      } else {
        html.push('<div class="radio"><label>');
        html.push('<input style="' + style + '" value="' + value + '" name="' + name
          + '" id="' + id + '" type="radio"');
        if (field.checked) {
          html.push(' checked');
        }
        html.push('> ');
        html.push(value[0].toUpperCase() + value.substring(1));
        html.push('</label></div>');
      }
    } else if ('checkbox' === type) {
      html.push('<div class="checkbox"><label>');
      html.push('<input style="' + style + '" name="' + name + '" id="' + id
        + '" type="checkbox"');
      if (value) {
        html.push(' checked');
      }
      if (disabled) {
        html.push(' disabled');
      }
      html.push('> ');
      html.push(title);
      html.push('</label></div>');
    } else if ('checkbox-list' === type) {
      html.push('<div name="' + name + '" class="checkbox-list"><div>');
    } else if ('select' == type || type == 'bootstrap-select') {
      // if (field.multiple) {
      // field.type = 'bootstrap-select';
      // type = 'bootstrap-select';
      // }
      if (type == 'bootstrap-select') {
        html.push('<select style="' + style + '" data-live-search="' + (field.search ? true : false) + '" data-selected-text-format="count" name="'
          + name + '" id="' + id
          + '" data-actions-box="' + (field.selectAll ? true : false) + '" class="selectpicker' + (this.formStyle !== 'inline' ? ' form-control' : '') + '"');
      } else {
        html.push('<select style="' + style + '" name="' + name + '" id="' + id
          + '" class="form-control"');
      }
      if (disabled) {
        html.push(' disabled');
      }
      if (field.multiple) {
        html.push(' multiple');
      }
      html.push('>');
      _.each(field.options, function (choice) {
        if (choice && choice.divider) {
          html.push('<option data-divider="true"></option>');
        } else {
          html.push('<option value="');
          var isChoiceObject = _.isObject(choice)
            && choice.value !== undefined;
          var optionValue = isChoiceObject ? choice.value : choice;
          var optionText = isChoiceObject ? choice.name : choice;
          html.push(optionValue);
          html.push('"');
          var selected = false;
          if (_.isObject(value)) {
            selected = value[optionValue];
          } else if (_.isArray(value)) {
            selected = value.indexOf(optionValue) !== -1;
          } else {
            selected = value == optionValue;
          }
          if (selected) {
            html.push(' selected');
          }
          html.push('>');
          html.push(optionText);
          html.push('</option>');
        }
      });
      html.push('</select>');
      if (field.type == 'bootstrap-select' && field.toggle) {
        html.push('<p class="help-block"><a data-name="' + name
          + '_all" href="#">All</a>&nbsp;|&nbsp;<a data-name="' + name
          + '_none" href="#">None</a></p>');
        _this.$form.on('click', '[data-name=' + name + '_all]',
          function (evt) {
            evt.preventDefault();
            var $select = _this.$form
              .find('[name=' + name + ']');
            $select.selectpicker('val', $.map($select
              .find('option'), function (o) {
              return $(o).val();
            }));
            $select.trigger('change');
          });
        _this.$form.on('click', '[data-name=' + name + '_none]',
          function (evt) {
            evt.preventDefault();
            var $select = _this.$form
              .find('[name=' + name + ']');
            $select.selectpicker('val', []);
            $select.trigger('change');
          });
      }
    } else if ('textarea' == type) {
      html.push('<textarea style="' + style + '" id="' + id + '" class="form-control" name="'
        + name + '"');
      if (required) {
        html.push(' required');
      }
      if (field.placeholder) {
        html.push(' placeholder="' + field.placeholder + '"');
      }
      if (disabled) {
        html.push(' disabled');
      }
      html.push('>');
      if (value != null) {
        html.push(value);
      }
      html.push('</textarea>');
    } else if ('button' == type) {
      html.push('<button style="' + style + '" id="' + id + '" name="' + name
        + '" type="button" class="btn btn-default btn-sm">');
      if (field.icon) {
        html.push('<span class="' + field.icon + '"></span> ');
      }
      html.push(value ? value : title);
      html.push('</button>');
    } else if ('custom' === type) {
      html.push(value);
    } else if ('file' === type) {
      var isMultiple = field.multiple == null ? false : field.multiple;
      html
        .push('<select data-multiple="'
          + isMultiple
          + '" data-type="file" title="'
          + (field.placeholder || (isMultiple ? 'Choose one or more files...'
            : 'Choose a file...'))
          + '" name="'
          + name
          + '_picker" data-width="35%" class="file-input selectpicker form-control">');
      var options = [];

      if (field.options) {
        options = options.concat(field.options);

      }
      // data types are file, dropbox, url, and predefined
      options.push('My Computer');
      options.push('URL');
      if (typeof Dropbox !== 'undefined') {
        options.push('Dropbox');
      }
      if (field.text != null) {
        options.push(field.text);
      }
      _.each(options, function (choice, index) {
        var isChoiceObject = _.isObject(choice)
          && choice.value !== undefined;
        var optionValue = isChoiceObject ? choice.value : choice;
        var optionText = isChoiceObject ? choice.name : choice;
        html.push('<option value="');
        html.push(optionValue);
        html.push('"');
        if (isChoiceObject && choice.disabled) {
          html.push(' disabled');
        }
        if (optionValue === 'Dropbox') {
          html.push(' data-icon="fa fa-dropbox"');
        } else if (optionValue === 'My Computer') {
          html.push(' data-icon="fa fa-desktop"');
        } else if (optionValue === 'URL') {
          html.push(' data-icon="fa fa-external-link"');
        }
        html.push('>');
        html.push(optionText);
        html.push('</option>');
      });
      html.push('</select>');

      html.push('<div>');

      html
        .push('<input placeholder="'
          + (isMultiple ? 'Enter one or more URLs'
            : 'Enter a URL')
          + '" class="form-control" style="width:50%; display:none;" type="text" name="'
          + name + '_url">');

      if (field.text) {
        html
          .push('<input class="form-control" style="width:50%; display:none;" type="text" name="'
            + name + '_text">');
      }

      html.push('</div>');

      html.push('<input style="display:none;" type="file" name="' + name
        + '_file"' + (isMultiple ? ' multiple' : '') + '>');
      // browse button clicked
      // select change
      _this.$form
        .on(
          'change',
          '[name=' + name + '_picker]',
          function (evt) {
            var $this = $(this);
            var val = $this.val();
            var showUrlInput = val === 'URL';
            var showTextInput = val === field.text;
            if ('Dropbox' === val) {
              var options = {
                success: function (results) {
                  var val = !isMultiple ? results[0].link
                    : results.map(function (result) {
                      return result.link;
                    });
                  _this.setValue(name, val);
                  _this.trigger('change', {
                    name: name,
                    value: val
                  });
                },
                linkType: 'direct',
                multiselect: isMultiple
              };
              Dropbox.choose(options);
              _this.$form.find('[name=' + name + '_picker]').selectpicker('val', '');
            } else if ('My Computer' === val) {
              _this.$form.find('[name=' + name + '_file]')
                .click();
              _this.$form.find('[name=' + name + '_picker]').selectpicker('val', '');
            }

            _this.$form.find('[name=' + name + '_url]')
              .css('display',
                showUrlInput ? '' : 'none');
            _this.$form.find('[name=' + name + '_text]')
              .css('display',
                showTextInput ? '' : 'none');
          });
      // URL
      _this.$form.on('keyup', '[name=' + name + '_url]', function (evt) {
        var text = $.trim($(this).val());
        if (isMultiple) {
          text = text.split(',').filter(function (t) {
            t = $.trim(t);
            return t !== '';
          });
        }
        _this.setValue(name, text);
        if (evt.which === 13) {
          _this.trigger('change', {
            name: name,
            value: text
          });
        }
      });
      _this.$form.on('keyup', '[name=' + name + '_text]', function (evt) {
        var text = $.trim($(this).val());
        _this.setValue(name, text);
        if (evt.which === 13) {
          _this.trigger('change', {
            name: name,
            value: text
          });
        }
      });
      // browse file selected
      _this.$form.on('change', '[name=' + name + '_file]', function (evt) {

        var files = evt.target.files; // FileList object
        _this.setValue(name, isMultiple ? files : files[0]);
        _this.trigger('change', {
          name: name,
          value: isMultiple ? files : files[0]
        });
      });
    } else {
      type = type == null ? 'text' : type;
      if (type === 'div') {
        html.push('<div name="' + name + '" id="' + id + '"');
      } else {
        html.push('<input style="' + style + '" type="' + type
          + '" class="form-control" name="' + name + '" id="'
          + id + '"');
      }
      if (value != null) {
        html.push(' value="' + value + '"');
      }
      if (field.placeholder) {
        html.push(' placeholder="' + field.placeholder + '"');
      }
      if (field.min != null) {
        html.push(' min="' + field.min + '"');
      }
      if (field.max != null) {
        html.push(' max="' + field.max + '"');
      }
      if (field.step) {
        html.push(' step="' + field.step + '"');
      }
      if (required) {
        html.push(' required');
      }
      if (disabled) {
        html.push(' disabled');
      }
      if (field.autocomplete != null) {
        html.push(' autocomplete="' + field.autocomplete + '"');
      }

      html.push('>');
      if (type === 'div') {
        html.push('</div>');
      }
    }
    if (help !== undefined) {
      html.push('<span data-name="' + name + '_help" class="help-block">');
      html.push(help);
      html.push('</span>');
    }
    return endingDiv;
  },
  append: function (fields) {
    var html = [];
    var _this = this;
    var isArray = morpheus.Util.isArray(fields);
    if (!isArray) {
      fields = [fields];
    }
    html.push('<div class="form-group">');
    var endingDiv = false;
    _.each(fields, function (field, index) {
      endingDiv || _this._append(html, field, index === 0);
    });

    html.push('</div>');
    if (endingDiv) {
      html.push('</div>');
    }
    var $div = $(html.join(''));
    this.$form.append($div);
    var checkBoxLists = $div.find('.checkbox-list');
    if (checkBoxLists.length > 0) {
      var checkBoxIndex = 0;
      _.each(fields, function (field) {
        // needs to already be in dom
        if (field.type === 'checkbox-list') {
          var list = new morpheus.CheckBoxList({
            responsive: false,
            $el: $(checkBoxLists[checkBoxIndex]),
            items: field.options
          });

          $(checkBoxLists[checkBoxIndex]).data(
            'morpheus.checkbox-list', list);
          checkBoxIndex++;
        }
      });
    }
    $div.find('.selectpicker').selectpicker({
      iconBase: 'fa',
      tickIcon: 'fa-check',
      style: 'btn-default btn-sm'
    });
  },
  clear: function () {
    this.$form.empty();
  },
  getValue: function (name) {
    var $v = this.$form.find('[name=' + name + ']');
    if ($v.length === 0) {
      $v = this.$form.find('[name=' + name + '_picker]');
    }
    return morpheus.FormBuilder.getValue($v);
  },
  setOptions: function (name, options, selectFirst) {
    var $select = this.$form.find('[name=' + name + ']');
    var checkBoxList = $select.data('morpheus.checkbox-list');
    if (checkBoxList) {
      checkBoxList.setItems(options);
    } else {
      var html = [];
      var selection = $select.val();
      _.each(options, function (choice) {
        html.push('<option value="');
        var isChoiceObject = _.isObject(choice)
          && choice.value !== undefined;
        var optionValue = isChoiceObject ? choice.value : choice;
        var optionText = isChoiceObject ? choice.name : choice;
        html.push(optionValue);
        html.push('"');

        html.push('>');
        html.push(optionText);
        html.push('</option>');
      });
      $select.html(html.join(''));
      $select.val(selection);
      if (selectFirst && $select.val() == null) {
        if ($select[0].options.length > 0) {
          $select.val($select[0].options[0].value);
        }

      }
      if ($select.hasClass('selectpicker')) {
        $select.selectpicker('refresh');
        $select.selectpicker('render');
      }
    }
  },
  find: function (name) {
    return this.$form.find('[name=' + name + ']');
  },
  setHelpText: function (name, value) {
    var v = this.$form.find('[data-name=' + name + '_help]');
    v.html(value);
  },
  setValue: function (name, value) {
    var v = this.$form.find('[name=' + name + ']');
    if (v.length === 0) {
      v = this.$form.find('[name=' + name + '_picker]');
      if (v.data('type') === 'file') {
        v.val(value);
        v.selectpicker('render');
        v.data('files', value);
        return;
      }
    }
    var type = v.attr('type');
    var list = v.data('morpheus.checkbox-list');
    if (list) {
      list.setValue(value);
    } else {
      if (type === 'radio') {
        v.filter('[value=' + value + ']').prop('checked', true);
      } else if (type === 'checkbox') {
        v.prop('checked', value);
      } else {
        v.val(value);
      }
      if (v.hasClass('selectpicker')) {
        v.selectpicker('render');
      }
    }

  },
  setVisible: function (name, visible) {
    var $div = this.$form.find('[name=' + name + ']')
      .parents('.form-group');
    if (visible) {
      $div.show();
    } else {
      $div.hide();
    }
  },
  remove: function (name) {
    var $div = this.$form.find('[name=' + name + ']')
      .parents('.form-group');
    $div.remove();
  },
  setEnabled: function (name, enabled) {
    var $div = this.$form.find('[name=' + name + ']');
    $div.attr('disabled', !enabled);
    if (!enabled) {
      $div.parents('.form-group').find('label').addClass('text-muted');
    } else {
      $div.parents('.form-group').find('label').removeClass('text-muted');
    }
  }
};
morpheus.Util.extend(morpheus.FormBuilder, morpheus.Events);

morpheus.GradientColorSupplier = function () {
  morpheus.AbstractColorSupplier.call(this);
  this._updateScale();
};
morpheus.GradientColorSupplier.prototype = {
  createInstance: function () {
    return new morpheus.GradientColorSupplier();
  },
  getColor: function (row, column, value) {
    if (isNaN(value)) {
      return this.missingColor;
    }
    var min = this.min;
    var max = this.max;
    var colors = this.colors;
    if (value <= min) {
      return colors[0];
    } else if (value >= max) {
      return colors[colors.length - 1];
    }
    var fraction = morpheus.SteppedColorSupplier.linearScale(value, min,
        max, 0, 100) / 100;
    return this.colorScale(fraction);
  },
  setFractions: function (options) {
    morpheus.AbstractColorSupplier.prototype.setFractions.call(this,
      options);
    this._updateScale();
  },
  _updateScale: function () {
    this.colorScale = d3.scale.linear().domain(this.fractions).range(
      this.colors).clamp(true);
  }
};
morpheus.Util.extend(morpheus.GradientColorSupplier,
  morpheus.AbstractColorSupplier);

morpheus.Grid = function (options) {
  this.options = options;
  var _this = this;
  var grid;
  this.items = options.items;
  /**
   * Maps from model index to view index. Note that not all model indices are
   * contained in the map because they might have been filtered from the view.
   */
  this.modelToView = null;
  /** view order in model space */
  this.viewOrder = null;
  function getItemColumnValue(item, column) {
    return column.getter(item);
  }

  this.filter = new morpheus.CombinedGridFilter();
  var model = {
    getLength: function () {
      return _this.viewOrder != null ? _this.viewOrder.length
        : _this.items.length;
    },
    getItem: function (index) {
      return _this.items[_this.viewOrder != null ? _this.viewOrder[index]
        : index];
    }
  };
  this.$el = options.$el;

  var gridOptions = $.extend({}, {
    select: true,
    headerRowHeight: 0,
    showHeaderRow: false,
    multiColumnSort: true,
    multiSelect: false,
    topPanelHeight: 0,
    enableColumnReorder: false,
    enableTextSelectionOnCells: true,
    forceFitColumns: true,
    dataItemColumnValueExtractor: getItemColumnValue,
    defaultFormatter: function (row, cell, value, columnDef, dataContext) {
      if (_.isNumber(value)) {
        return morpheus.Util.nf(value);
      } else if (morpheus.Util.isArray(value)) {
        var s = [];
        for (var i = 0, length = value.length; i < length; i++) {
          if (i > 0) {
            s.push(', ');
          }
          var val = value[i];
          s.push(value[i]);
        }
        return s.join('');
      } else {
        return value;
      }
    }
  }, options.gridOptions || {});

  grid = new Slick.Grid(options.$el, model, options.columns, gridOptions);
  this.grid = grid;
  grid.registerPlugin(new morpheus.AutoTooltips2());

  grid.onCellChange.subscribe(function (e, args) {
    _this.trigger('edit', args);
  });

  if (gridOptions.select) {
    grid.setSelectionModel(new Slick.RowSelectionModel({
      selectActiveRow: true,
      multiSelect: gridOptions.multiSelect
    }));
    grid.getSelectionModel().onSelectedRangesChanged.subscribe(function (e) {
      var nitems = grid.getDataLength();
      _this.trigger('selectionChanged', {
        selectedRows: grid.getSelectedRows().filter(function (row) {
          return row >= 0 && row <= nitems;
        })
      });
    });
  }

  grid.onSort.subscribe(function (e, args) {
    _this.sortCols = args.sortCols;
    _this._updateMappings();
    grid.invalidate();
  });

  options.$el.on('click', function (e) {
    var cell = grid.getCellFromEvent(e);
    if (cell) {
      _this.trigger('click', {
        row: cell.row,
        target: e.target
      });
    }
  });
  options.$el.on('dblclick', function (e) {
    var cell = grid.getCellFromEvent(e);
    if (cell) {
      _this.trigger('dblclick', {
        row: cell.row,
        target: e.target
      });
    }
  });
  if (options.sort) {
    var gridSortColumns = [];
    var gridColumns = grid.getColumns();
    var sortCols = [];
    options.sort.forEach(function (c) {
      var column = null;
      for (var i = 0; i < gridColumns.length; i++) {
        if (gridColumns[i].name === c.name) {
          column = gridColumns[i];
          break;
        }
      }
      if (column != null) {

        gridSortColumns.push({
          columnId: column.id,
          sortAsc: c.sortAsc
        });
      } else {
        console.log(c.name + ' not found.');
      }
    });
    this.setSortColumns(gridSortColumns);
  }

  this.grid.invalidate();

};
morpheus.Grid.prototype = {
  columnsAutosized: false,
  setSortColumns: function (gridSortColumns) {
    this.grid.setSortColumns(gridSortColumns);
    this.sortCols = [];
    for (var i = 0; i < gridSortColumns.length; i++) {
      var column = this.grid.getColumns()[this.grid.getColumnIndex(gridSortColumns[i].columnId)];
      if (column == null) {
        throw 'Unable to find column ' + gridSortColumns[i];
      }
      this.sortCols.push({
        sortCol: column,
        sortAsc: gridSortColumns[i].sortAsc
      });
    }

    this._updateMappings();
    this.grid.invalidate();
  },
  setColumns: function (columns) {
    this.grid.setColumns(columns);
    this.grid.resizeCanvas();
    this.grid.invalidate();
  },
  getColumns: function () {
    return this.grid.getColumns();
  },
  getSelectedRows: function () {
    var nitems = this.grid.getDataLength();
    return this.grid.getSelectedRows().filter(function (row) {
      return row >= 0 && row <= nitems;
    });
  },
  getSelectedItems: function () {
    var rows = this.grid.getSelectedRows();
    var selection = [];
    for (var i = 0, nrows = rows.length; i < nrows; i++) {
      selection.push(this.items[this.convertViewIndexToModel(rows[i])]);
    }
    return selection;
  },
  getSelectedItem: function () {
    var rows = this.grid.getSelectedRows();
    if (rows.length === 1) {
      return this.items[this.convertViewIndexToModel(rows[0])];
    }
    return null;
  },
  /**
   * Gets the sorted, visible items
   */
  getItems: function () {
    var items = [];
    for (var i = 0, length = this.getFilteredItemCount(); i < length; i++) {
      items.push(this.items[this.convertViewIndexToModel(i)]);
    }
    return items;
  },
  getAllItemCount: function () {
    return this.items.length;
  },
  getAllItems: function () {
    return this.items;
  },
  getFilteredItemCount: function () {
    return this.viewOrder ? this.viewOrder.length : this.items.length;
  },
  redraw: function () {
    this.grid.invalidate();
  },
  redrawRows: function (rows) {
    this.grid.invalidateRows(rows);
    this.grid.render();
  },
  setItems: function (items) {
    // clear the selection
    this.items = items;
    if (this.grid.getSelectionModel()) {
      this.grid.setSelectedRows([]);
    }
    this.setFilter(this.filter);
    this.maybeAutoResizeColumns();
  },
  maybeAutoResizeColumns: function () {
    if (!this.columnsAutosized) {
      this.autosizeColumns();
    }
  },
  convertModelIndexToView: function (modelIndex) {
    if (this.modelToView !== null) {
      var index = this.modelToView.get(modelIndex);
      return index !== undefined ? index : -1;
    }
    return modelIndex;
  },
  convertViewIndexToModel: function (viewIndex) {
    return this.viewOrder != null ? (viewIndex < this.viewOrder.length
      && viewIndex >= 0 ? this.viewOrder[viewIndex] : -1) : viewIndex;
  },
  _updateMappings: function () {
    var selectedViewIndices = this.grid.getSelectionModel() != null ? this.grid
      .getSelectedRows()
      : null;
    var selectedModelIndices = [];
    if (selectedViewIndices) {
      for (var i = 0, length = selectedViewIndices.length; i < length; i++) {
        selectedModelIndices.push(this
        .convertViewIndexToModel(selectedViewIndices[i]));
      }
    }
    this.viewOrder = null;
    if (this.filter != null) {
      this.filter.init();
      if (!this.filter.isEmpty()) {
        this.viewOrder = [];
        for (var i = 0, length = this.items.length; i < length; i++) {
          if (this.filter.accept(this.items[i])) {
            this.viewOrder.push(i);
          }
        }
      }
    }
    var cols = this.sortCols;
    if (cols && cols.length > 0) {
      if (this.viewOrder == null) {
        this.viewOrder = [];
        for (var i = 0, length = this.items.length; i < length; i++) {
          this.viewOrder.push(i);
        }
      }
      var ncols = cols.length;
      var items = this.items;
      // nulls always go at end

      this.viewOrder.sort(function (index1, index2) {
        for (var i = 0; i < ncols; i++) {
          var getter = cols[i].sortCol.getter;
          var comparator = cols[i].sortAsc ? morpheus.SortKey.ASCENDING_COMPARATOR : morpheus.SortKey.DESCENDING_COMPARATOR;
          var value1 = getter(items[index1]);
          var value2 = getter(items[index2]);
          var result = comparator(value1, value2);
          if (result !== 0) {
            return result;
          }
        }
        return 0;
      });
    }
    if (this.viewOrder != null) {
      this.modelToView = new morpheus.Map();
      for (var i = 0, length = this.viewOrder.length; i < length; i++) {
        this.modelToView.set(this.viewOrder[i], i);
      }
    } else {
      this.modelToView = null;
    }
    if (this.grid.getSelectionModel() != null) {
      var newSelectedViewIndices = [];
      for (var i = 0, length = selectedModelIndices.length; i < length; i++) {
        var index = this
        .convertModelIndexToView(selectedModelIndices[i]);
        if (index !== undefined) {
          newSelectedViewIndices.push(index);
        }
      }
      this.grid.setSelectedRows(newSelectedViewIndices);
    }
  },
  setSelectedRows: function (rows) {
    this.grid.setSelectedRows(rows);
  },
  setFilter: function (filter) {
    this.filter = filter;
    this._updateMappings();
    this.grid.invalidate();
    this.trigger('filter');
  },
  getFilter: function () {
    return this.filter;
  },
  autosizeColumns: function () {
    var columns = this.grid.getColumns();
    var items = this.getItems();

    if (!items || items.length === 0 || !columns || columns.length === 0) {
      return;
    }
    var gridWidth = this.options.$el.width() - 30;
    if (gridWidth <= 0) {
      return;
    }
    this.columnsAutosized = true;
    if (columns.length > -1) {
      var div = document.createElement('div');
      document.body.appendChild(div);
      var $d = $(div);
      $d.css({
        position: 'absolute',
        left: -1000,
        top: -1000
      });

      var $row = $('<div class="slick-table">'
        + '<div class="ui-state-default slick-header-column slick-header-sortable ui-sortable-handle"></div>'
        + '<div class="ui-widget-content slick-row"><div class="slick-cell selected"></div></div>'
        + '</div>');
      var $cell = $row.find('.slick-cell');
      var $header = $row.find('.slick-header-column');
      $row.appendTo($d);

      var maxWidth = Math.min(parseInt(gridWidth / 2), 400);
      var getColumnWidth = function (column) {
        var w = $header.html(column.name).outerWidth() + 13; // leave space for sort indicator

        if (column.prototypeValue) {
          $cell.html(column.prototypeValue);
          w = Math.max($cell.outerWidth(), w);
        } else {
          for (var i = 0, nrows = Math.min(items.length, 10); i < nrows; i++) {
            var html = column.formatter(i, null, column
            .getter(items[i]), column, items[i]);
            var $html = $(html);
            $html.find('.slick-cell-wrapper').attr('class', '');
            $cell.html($html);
            w = Math.max($cell.outerWidth(), w);
          }
        }
        column.width = parseInt(Math.min(maxWidth, w));

      };
      var totalWidth = 0;
      for (var i = 0; i < columns.length; i++) {
        getColumnWidth(columns[i]);
        totalWidth += columns[i].width;
      }

      if (totalWidth < gridWidth) {
        // grow columns
        // var delta = parseInt((gridWidth - totalWidth) / columns.length);
        // for (var i = 0; i < columns.length; i++) {
        // //columns[i].width += delta;
        // }

      } else if (totalWidth > gridWidth) {
        // shrink
        //columns[columns.length - 1].width -= (totalWidth - gridWidth);
        // shrink last column
      }

      $d.remove();
      this.grid.resizeCanvas();
    }

  }
};

morpheus.Util.extend(morpheus.Grid, morpheus.Events);

/**
 * AutoTooltips2 plugin to show/hide tooltips when columns are too narrow to fit
 * content.
 *
 * @constructor
 */
morpheus.AutoTooltips2 = function (options) {
  var _grid;
  var _self = this;
  var tip;

  /**
   * Initialize plugin.
   */
  function init(grid) {
    _grid = grid;

    $(_grid.getCanvasNode()).on('mouseover', '.slick-row', showToolTip);
    $(_grid.getCanvasNode()).on('mouseout', '.slick-row', hideToolTip);
    $(_grid.getCanvasNode()).on('mouseup', hideAll);

    // $(_grid.getContainerNode()).on('mouseover', '.slick-header-column',
    // showHeaderToolTip);
    // $(_grid.getContainerNode()).on('mouseout', '.slick-header-column',
    // hideHeaderToolTip);

  }

  /**
   * Destroy plugin.
   */
  function destroy() {
    $(_grid.getCanvasNode()).off('mouseover', showToolTip);
    $(_grid.getCanvasNode()).off('mouseout', hideToolTip);
    $(_grid.getCanvasNode()).off('mouseup', hideAll);
    // $(_grid.getContainerNode()).off('mouseover', '.slick-header-column',
    // showHeaderToolTip);
    // $(_grid.getContainerNode()).off('mouseout', '.slick-header-column',
    // hideHeaderToolTip);

  }

  /**
   * Handle mouse entering grid cell to add/remove tooltip.
   *
   * @param {jQuery.Event}
   *            e - The event
   */
  function hideToolTip(e) {
    var cell = _grid.getCellFromEvent(e);
    if (cell) {
      var $node = $(_grid.getCellNode(cell.row, cell.cell));
      if ($node.data('bs.tooltip')) {
        $node.tooltip('hide');
      }
    }
  }

  function hideAll() {
    $(_grid.getCanvasNode()).find('[data-original-title]').attr(
      'data-original-title', '').tooltip('hide');

  }

  function hideHeaderToolTip(e) {
    var $node = $(e.target);
    if ($node.data('bs.tooltip')) {
      $node.tooltip('hide');
    }
  }

  function showHeaderToolTip(e) {
    var show = false;
    var $node = $(e.target);

    if (($node[0].scrollWidth > $node[0].offsetWidth)) {
      show = true;
      var $name = $node.find('.slick-column-name');
      if (!$node.data('bs.tooltip')) {
        $node.tooltip({
          placement: 'auto',
          html: true,
          container: 'body',
          trigger: 'manual'
        });
      }
      $node.attr('data-original-title', $name.text());
      if (show) {
        $node.tooltip('show');
      } else {
        $node.tooltip('hide');
      }
    }
  }

  function showToolTip(e) {
    var cell = _grid.getCellFromEvent(e);
    if (cell) {
      var $node = $(_grid.getCellNode(cell.row, cell.cell));
      var text = '';
      var c = _grid.getColumns()[cell.cell];
      var show = false;
      var $checkNode = $node.find('.slick-cell-wrapper');
      if (c.alwaysShowTooltip
        || ($checkNode[0].scrollWidth > $checkNode[0].offsetWidth)) {
        var item = _grid.getDataItem(cell.row);
        text = c.tooltip(item, c.getter(item));
        show = true;
      }
      $node.attr('data-original-title', text);
      var hasTip = $node.data('bs.tooltip');
      if (!hasTip) {
        $node.tooltip({
          placement: 'auto',
          html: true,
          container: 'body',
          trigger: 'manual'
        });
      }
      if (show) {
        $node.tooltip('show');
      } else if (hasTip) {
        $node.tooltip('hide');
      }
    }
  }

  /**
   * Handle mouse entering header cell to add/remove tooltip.
   *
   * @param {jQuery.Event}
   *            e - The event
   * @param {object}
   *            args.column - The column definition
   */
  function handleHeaderMouseEnter(e, args) {
    var column = args.column, $node = $(e.target).closest(
      '.slick-header-column');
    if (!column.toolTip) {
      $node.attr('title',
        ($node.innerWidth() < $node[0].scrollWidth) ? column.name
          : '');
    }
  }

  // Public API
  $.extend(this, {
    'init': init,
    'destroy': destroy
  });

};

morpheus.CombinedGridFilter = function () {
  this.filters = [];
};
morpheus.CombinedGridFilter.prototype = {
  add: function (filter) {
    this.filters.push(filter);
  },
  getFilters: function () {
    return this.filters;
  },
  get: function (index) {
    return this.filters[index];
  },
  set: function (index, f) {
    this.filters[index] = f;
  },
  init: function () {
    for (var i = 0; i < this.filters.length; i++) {
      this.filters[i].init();
    }

    this.activeFilters = this.filters.filter(function (f) {
      return !f.isEmpty();
    });
    this.nActiveFilters = this.activeFilters.length;
  },
  accept: function (item) {
    for (var i = 0; i < this.nActiveFilters; i++) {
      if (!this.activeFilters[i].accept(item)) {
        return false;
      }
    }
    return true;
  },
  isEmpty: function () {
    return this.activeFilters.length === 0;
  }
};

morpheus.HeatMapColorSchemeChooser = function (options) {
  var _this = this;
  this.$div = $('<div></div>');
  this.currentValue = null;
  this.legend = new morpheus.LegendWithStops();
  this.colorScheme = options.colorScheme || new morpheus.HeatMapColorScheme(new morpheus.Project(new morpheus.Dataset({
      rows: 0,
      columns: 0
    })));
  this.legend.on('added', function (e) {
    var fractions = _this.colorScheme.getFractions();
    fractions.push(e.fraction);
    var colors = _this.colorScheme.getColors();
    colors.push('black');
    _this.colorScheme.setFractions({
      fractions: fractions,
      colors: colors
    });
    var newIndex = _this.getFractionIndex(e.fraction, 'black');
    _this.setSelectedIndex(newIndex);
    _this.fireChanged();
  }).on('selectedIndex', function (e) {
    _this.setSelectedIndex(e.selectedIndex);
  }).on('delete', function (index) {
    _this.deleteSelectedStop();
  }).on(
    'moved',
    function (e) {
      var fraction = e.fraction;
      var fractions = _this.colorScheme.getFractions();
      fractions[_this.legend.selectedIndex] = fraction;
      var color = _this.colorScheme.getColors()[_this.legend.selectedIndex];
      _this.colorScheme.setFractions({
        fractions: fractions,
        colors: _this.colorScheme.getColors()
      });
      _this.legend.selectedIndex = _this.getFractionIndex(e.fraction, color);
      var fractionToValue = d3.scale.linear().domain([0, 1])
      .range(
        [_this.colorScheme.getMin(),
          _this.colorScheme.getMax()])
      .clamp(true);
      _this.formBuilder.setValue('selected_value',
        fractionToValue(fractions[_this.legend.selectedIndex]));
      _this.fireChanged();
    });
  var $row = $('<div></div>');
  $row.css('height', '50px').css('width', '300px').css('margin-left', 'auto')
  .css('margin-right', 'auto');
  $row.appendTo(this.$div);

  $(this.legend.canvas).appendTo($row);
  var formBuilder = new morpheus.FormBuilder();
  var items = [];
  items = items.concat({
    name: 'selected_color',
    type: 'color',
    style: 'max-width: 50px;'
  }, {
    name: 'selected_value',
    type: 'text',
    style: 'max-width: 100px;'
  }, [{
    name: 'delete',
    type: 'button',
    value: 'Delete Selected Color Stop',
  }, {
    name: 'add',
    type: 'button',
    value: 'Add Color Stop'
  }], {
    name: 'minimum',
    type: 'text',
    style: 'max-width: 100px;'
  }, {
    name: 'maximum',
    type: 'text',
    style: 'max-width: 100px;'
  });
  if (options.showRelative) {
    items = items.concat({
      name: 'relative_color_scheme',
      type: 'checkbox',
      help: 'A relative color scheme uses the minimum and maximum values in each row' +
      ' to convert values to colors'
    });
    items = items.concat({
      name: 'transform_values',
      type: 'select',
      value: 0,
      options: [{
        name: 'None',
        value: 0
      }, {
        name: 'Subtract row mean, divide by row standard deviation',
        value: morpheus.AbstractColorSupplier.Z_SCORE
      }, {
        name: 'Subtract row median, divide by row median absolute deviation',
        value: morpheus.AbstractColorSupplier.ROBUST_Z_SCORE
      }]
    });
  }

  items = items.concat({
    name: 'missing_color',
    type: 'color',
    style: 'max-width: 50px;'
  });
  items
  .push({
    name: 'stepped_colors',
    type: 'checkbox',
    value: false,
    help: 'Intervals include left end point and exclude right end point, except for the highest interval'
  });
  _.each(items, function (item) {
    formBuilder.append(item);
  });
  this.getFractionIndex = function (fraction, color) {
    var fractions = _this.colorScheme.getFractions();
    var colors = _this.colorScheme.getColors();
    for (var i = 0, len = fractions.length; i < len; i++) {
      if (fractions[i] === fraction && colors[i] === color) {
        return i;
      }
    }
    return -1;
  };
  this.$div.append(formBuilder.$form);
  formBuilder.$form.find('[name^=selected],[name=delete]').prop('disabled',
    true);
  formBuilder.$form.find('[name=add]').on('click', function (e) {
    var fractions = _this.colorScheme.getFractions();
    var val = 0.5;
    while (val >= 0 && _.indexOf(fractions, val) !== -1) {
      val -= 0.1;
    }
    val = Math.max(0, val);
    fractions.push(val);
    var colors = _this.colorScheme.getColors();
    colors.push('black');
    _this.colorScheme.setFractions({
      fractions: fractions,
      colors: colors
    });
    var newIndex = _this.getFractionIndex(e.fraction, 'black');
    _this.setSelectedIndex(newIndex);
    _this.fireChanged();
  });
  formBuilder.$form.find('[name=delete]').on('click', function (e) {
    _this.deleteSelectedStop();
  });
  formBuilder.$form.find('[name=transform_values]').on('change', function (e) {
    _this.colorScheme.setTransformValues(parseInt(formBuilder.getValue('transform_values')));
    _this.fireChanged();
  });
  formBuilder.$form.on('keyup', '[name=selected_value]', _.debounce(function (e) {
    var val = parseFloat($(this).val());
    if (!isNaN(val)) {
      _this.setSelectedValue(val);
      _this.fireChanged();
    }
  }, 100));
  formBuilder.$form.on('change', '[name=selected_color]', function (e) {
    var colors = _this.colorScheme.getColors();
    colors[_this.legend.selectedIndex] = $(this).val();
    _this.colorScheme.setFractions({
      fractions: _this.colorScheme.getFractions(),
      colors: colors
    });
    _this.fireChanged();
  });
  formBuilder.$form.on('change', '[name=missing_color]', function (e) {
    var color = $(this).val();
    _this.colorScheme.setMissingColor(color);
    _this.fireChanged(false);
  });
  formBuilder.$form.on('change', '[name=stepped_colors]', function (e) {
    _this.colorScheme.setStepped($(this).prop('checked'));
    _this.fireChanged();
  });
  formBuilder.$form.on('keyup', '[name=minimum]', _.debounce(function (e) {
    var val = parseFloat($(this).val());
    if (!isNaN(val)) {
      _this.colorScheme.setMin(val);
      _this.setSelectedIndex(_this.legend.selectedIndex);
      _this.fireChanged(false);
    }
  }, 100));
  formBuilder.$form.on('keyup', '[name=maximum]', _.debounce(function (e) {
    var val = parseFloat($(this).val());
    if (!isNaN(val)) {
      _this.colorScheme.setMax(val);
      _this.setSelectedIndex(_this.legend.selectedIndex);
      _this.fireChanged(false);
    }

  }, 100));
  formBuilder.$form
  .on(
    'change',
    '[name=relative_color_scheme]',
    _
    .throttle(
      function (e) {
        _this.legend.selectedIndex = -1;
        // FIXME set fixed min and max
        var scalingMode = $(this).prop('checked') ? morpheus.HeatMapColorScheme.ScalingMode.RELATIVE
          : morpheus.HeatMapColorScheme.ScalingMode.FIXED;
        _this.colorScheme
        .setScalingMode(scalingMode);
        _this.setColorScheme(_this.colorScheme);
        _this.fireChanged();
      }, 100));
  this.formBuilder = formBuilder;
  // selection: delete, color, value
  // general: add, min, max, relative or global
};
morpheus.HeatMapColorSchemeChooser.prototype = {
  deleteSelectedStop: function () {
    var fractions = this.colorScheme.getFractions();
    fractions.splice(this.legend.selectedIndex, 1);
    var colors = this.colorScheme.getColors();
    colors.splice(this.legend.selectedIndex, 1);
    this.colorScheme.setFractions({
      fractions: fractions,
      colors: colors
    });
    this.formBuilder.$form.find('[name^=selected],[name=delete]').prop(
      'disabled', true);
    this.legend.setSelectedIndex(-1);
    this.fireChanged();
  },
  setSelectedValue: function (val) {
    var valueToFraction = d3.scale.linear().domain(
      [this.colorScheme.getMin(), this.colorScheme.getMax()])
    .range([0, 1]).clamp(true);
    var fractions = this.colorScheme.getFractions();
    var fraction = valueToFraction(val);
    fractions[this.legend.selectedIndex] = fraction;
    var color = this.colorScheme.getColors()[this.legend.selectedIndex];
    this.colorScheme.setFractions({
      fractions: fractions,
      colors: this.colorScheme.getColors()
    });
    this.legend.selectedIndex = this.getFractionIndex(fraction, color);
  },
  setSelectedIndex: function (index) {
    var fractions = this.colorScheme.getFractions();
    if (index >= fractions.length) {
      index = -1;
    }
    this.legend.setSelectedIndex(index);
    var formBuilder = this.formBuilder;
    formBuilder.$form.find('[name^=selected],[name=delete]').prop(
      'disabled', this.legend.selectedIndex === -1);
    if (this.legend.selectedIndex !== -1) {
      var fractionToValue = d3.scale.linear().domain([0, 1]).range(
        [this.colorScheme.getMin(), this.colorScheme.getMax()])
      .clamp(true);
      formBuilder.setValue('selected_value',
        fractionToValue(fractions[this.legend.selectedIndex]));
      var context = this.legend.canvas.getContext('2d');
      var colors = this.colorScheme.getColors();
      context.fillStyle = colors[this.legend.selectedIndex];
      formBuilder.setValue('selected_color', context.fillStyle);
    } else {
      formBuilder.setValue('selected_value', '');
    }
    this.draw();
  },
  setMinMax: function () {
    if (this.colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      this.colorScheme.setMin(0);
      this.colorScheme.setMax(1);
    }
  },
  dispose: function () {
    this.off('change');
    this.legend.destroy();
    this.formBuilder.$form.off('keyup', 'input');
    this.formBuilder.$form.off('change', '[name=relative_color_scheme]');
  },
  restoreCurrentValue: function () {
    if (this.colorScheme.setCurrentValue) {
      this.colorScheme.setCurrentValue(this.currentValue);
    }
  },
  setCurrentValue: function (value) {
    this.currentValue = value;
    if (this.colorScheme && this.colorScheme.setCurrentValue) {
      this.colorScheme.setCurrentValue(this.currentValue);
    }
    this.setColorScheme(this.colorScheme);
  },
  setColorScheme: function (colorScheme) {
    this.colorScheme = colorScheme;
    this.setMinMax();
    if (colorScheme.setCurrentValue) {
      colorScheme.setCurrentValue(this.currentValue);
    }
    this.formBuilder
    .setValue(
      'relative_color_scheme',
      colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE ? true
        : false);
    this.formBuilder.setValue('transform_values', colorScheme.getTransformValues());
    this.formBuilder.setEnabled('transform_values', colorScheme.getScalingMode() !== morpheus.HeatMapColorScheme.ScalingMode.RELATIVE);

    this.formBuilder.$form
    .find('[name=minimum],[name=maximum]')
    .prop(
      'disabled',
      colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE);
    this.formBuilder.setValue('minimum', this.colorScheme.getMin());
    this.formBuilder.setValue('maximum', this.colorScheme.getMax());
    this.formBuilder.setValue('stepped_colors', this.colorScheme
    .isStepped());
    this.formBuilder.setValue('missing_color', this.colorScheme
    .getMissingColor());
    this.draw();
  },
  getFractionToStopPix: function () {
    return d3.scale.linear().clamp(true).domain([0, 1]).range(
      [this.legend.border,
        this.legend.getUnscaledWidth() - this.legend.border]);
  },
  fireChanged: function (noreset) {
    this.trigger('change');
    if (noreset !== false) {
      this.setColorScheme(this.colorScheme);
    }
  },
  draw: function () {
    var colorScheme = this.colorScheme;
    if (colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      colorScheme.setMin(0);
      colorScheme.setMax(1);
    }
    var fractions = colorScheme.getFractions();
    var colors = colorScheme.getColors();
    var fractionToStopPix = this.getFractionToStopPix();
    this.legend.draw(fractions, colors, colorScheme.isStepped(),
      fractionToStopPix);
  }
};
morpheus.Util.extend(morpheus.HeatMapColorSchemeChooser, morpheus.Events);

morpheus.HeatMapColorSchemeLegend = function (heatMap, $keyContent) {
  var colorScheme = heatMap.heatmap.getColorScheme();
  var colorByValues = colorScheme.getColorByValues();
  var totalHeight;
  $keyContent.empty();
  var ntracks = colorByValues.length;
  colorByValues
  .forEach(function (value) {
    if (value != null || ntracks === 1) {
      if (value != 'null') { // values are stored as string
        var $label = $('<div style="overflow:hidden;text-overflow:' +
          ' ellipsis;width:250px;max-width:250px;">'
          + value + '</div>');
        $keyContent.append($label);
        totalHeight += $label.height();
      }
      var trackLegend = new morpheus.ColorSupplierLegend(
        colorScheme, value);
      $(trackLegend.canvas).css('position', '');
      trackLegend.repaint();
      trackLegend.on('selectionChanged', function () {
        heatMap.heatmap.setInvalid(true);
        heatMap.heatmap.repaint();
      });
      $keyContent.append($(trackLegend.canvas));
      totalHeight += trackLegend.getUnscaledHeight();
    }
  });
  if (heatMap.options.$key) {
    $keyContent.append(heatMap.options.$key);
    totalHeight += heatMap.options.$key.height();

  }
  var $edit = $('<div style="padding-left:4px; display:inline;"><a data-name="options"' +
    ' href="#">Edit</a></div>');

  $edit.find('[data-name=options]').on('click', function (e) {
    e.preventDefault();
    heatMap.showOptions();
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'options'
    });
  });
  totalHeight += $edit.height();
  $keyContent.append($edit);
  $keyContent.css({
    'text-overflow': 'ellipsis',
    overflow: 'hidden',
    width: 250 + 'px',
    height: totalHeight + 'px'
  });
};

morpheus.HeatMapColorSchemeLegend.drawColorScheme = function (context,
                                                              colorScheme, width, printing, hideText, legendHeight) {
  if (!legendHeight) {
    legendHeight = 12;
  }
  context.font = '11px ' + morpheus.CanvasUtil.getFontFamily(context);
  var names = colorScheme.getNames();
  var hasNames = names != null;
  // if hasNames that we draw vertically to ensure space for names
  if (hasNames) {
    morpheus.HeatMapColorSchemeLegend.drawColorSchemeVertically(context,
      colorScheme, colorScheme.getHiddenValues(), printing);
  } else {
    morpheus.HeatMapColorSchemeLegend.draw(context, colorScheme
      .getFractions(), colorScheme.getColors(), width, legendHeight,
      colorScheme.isStepped());
    context.strokeStyle = 'LightGrey';
    context.strokeRect(0, 0, width, legendHeight);
    if (hideText) {
      return;
    }
    var map = d3.scale.linear().domain([0, 1]).range([0, width]).clamp(
      true);
    var fractionToValue = d3.scale.linear().domain([0, 1]).range(
      [colorScheme.getMin(), colorScheme.getMax()]).clamp(true);
    context.textAlign = 'center';
    context.textBaseline = 'top';
    context.fillStyle = 'black';

    if (colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      context.fillText('row min', 0, 14);
      context.fillText('row max', width, legendHeight + 2);
    } else {
      var fractions = colorScheme.getFractions();
      var lastTextPixEnd = -1;
      // draw from left to middle and then from right to middle to avoid
      // text overlap
      var halfway = parseInt(fractions.length / 2);

      for (var i = 0; i < halfway; i++) {
        var pix = map(fractions[i]);
        var text = '';
        if (hasNames) {
          text = names[i] != '' ? (names[i] + ' ('
          + fractionToValue(fractions[i]) + ')') : names[i];
        } else {
          text = morpheus.Util.nf(fractionToValue(fractions[i]));
        }
        var textWidth = context.measureText(text).width;
        if (pix > lastTextPixEnd) {
          context.fillText(text, pix, legendHeight + 2);
        }
        lastTextPixEnd = pix + textWidth / 2;
      }
      var lastTextPixStart = 10000;
      for (var i = fractions.length - 1; i >= halfway; i--) {
        var pix = map(fractions[i]);
        var text = '';
        if (hasNames) {
          text = names[i] != '' ? (names[i] + ' ('
          + fractionToValue(fractions[i]) + ')') : names[i];
        } else {
          text = morpheus.Util.nf(fractionToValue(fractions[i]));
        }

        var textWidth = context.measureText(text).width;
        var textPixEnd = pix + textWidth / 2;
        if (textPixEnd < lastTextPixStart) {
          context.fillText(text, pix, legendHeight + 2);
          lastTextPixStart = pix - textWidth / 2;
        }
      }
    }
  }
};
morpheus.HeatMapColorSchemeLegend.drawColorSchemeVertically = function (context,
                                                                        colorScheme, hiddenValues, printing) {
  var fractionToValue = d3.scale.linear().domain([0, 1]).range(
    [colorScheme.getMin(), colorScheme.getMax()]).clamp(true);
  context.textAlign = 'left';
  context.textBaseline = 'top';
  context.fillStyle = 'black';
  var fractions = colorScheme.getFractions();
  var colors = colorScheme.getColors();
  var names = colorScheme.getNames();
  context.strokeStyle = 'LightGrey';
  var xpix = 0;
  var ypix = 0;

  context.font = '12px ' + morpheus.CanvasUtil.getFontFamily(context);
  for (var i = 0; i < colors.length; i++) {
    var name = names[i];
    if (name != null) {
      context.fillStyle = colors[i];
      context.fillRect(xpix, ypix, 12, 12);
      context.strokeRect(xpix, ypix, 12, 12);
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      if (hiddenValues && !printing) {
        var value = fractionToValue(fractions[i]);
        context.font = '12px FontAwesome';
        if (!hiddenValues.has(value)) {
          context.fillText('\uf00c', -14, ypix); // checked
        }
        // else {
        // context.fillText("\uf096", -14, ypix); // unchecked
        // }
        context.font = '12px ' + morpheus.CanvasUtil.getFontFamily(context);
      }
      context.fillText(name, xpix + 16, ypix);
    }
    ypix += 14;
  }
};
morpheus.HeatMapColorSchemeLegend.draw = function (context, fractions, colors,
                                                   width, height, stepped) {
  if (!stepped) {
    var gradient = context.createLinearGradient(0, 0, width, height);
    for (var i = 0, length = fractions.length; i < length; i++) {
      gradient.addColorStop(fractions[i], colors[i]);
    }
    context.fillStyle = gradient;
    context.fillRect(0, 0, width, height);
  } else {
    // intervals include left end point, exclude right end point, except for
    // the highest interval
    // TODO right-most endpoint is not shown
    var map = d3.scale.linear().domain([0, 1]).range([0, width]).clamp(
      true);
    for (var i = 0, length = fractions.length; i < length; i++) {
      context.fillStyle = colors[i];
      var x1 = map(fractions[i]);
      var x2 = i === length - 1 ? width : map(fractions[i + 1]);
      context.fillRect(Math.min(x1, x2), 0, Math.abs(x2 - x1), height);
    }
  }
};

morpheus.ColorSupplierLegend = function (colorScheme, value) {
  morpheus.AbstractCanvas.call(this, false);
  var _this = this;
  this.value = value;
  this.colorScheme = colorScheme;
  colorScheme.setCurrentValue(value);
  var hiddenValues = colorScheme.getHiddenValues();

  var names = colorScheme.getNames();
  var hasNames = names != null;
  var legendHeight = hasNames ? names.length * 14 : 30;
  var bounds = {
    width: 250,
    height: legendHeight
  };
  this.hasNames = hasNames;
  this.setBounds(bounds);
  if (hasNames && hiddenValues) {
    $(this.canvas)
    .on(
      'click',
      function (e) {
        e.preventDefault();
        e.stopPropagation();
        var clickedRow = Math
        .floor((e.clientY - _this.canvas
          .getBoundingClientRect().top) / 14);
        var fractionToValue = d3.scale.linear().domain(
          [0, 1]).range(
          [colorScheme.getMin(),
            colorScheme.getMax()]).clamp(true);
        var fractions = colorScheme.getFractions();
        var value = fractionToValue(fractions[clickedRow]);
        if (!hiddenValues.has(value)) {
          hiddenValues.add(value);
        } else {
          hiddenValues.remove(value);

        }
        _this.trigger('selectionChanged');
        _this.repaint();
      });
  }
};

morpheus.ColorSupplierLegend.prototype = {
  draw: function (clip, context) {
    var colorScheme = this.colorScheme;
    colorScheme.setCurrentValue(this.value);
    // context.fillStyle = 'white';
    // context.fillRect(0, 0, this.getUnscaledWidth(), this
    // .getUnscaledHeight());
    context.translate(this.hasNames ? 14
      : (this.getUnscaledWidth() - 200) / 2, 0);
    morpheus.HeatMapColorSchemeLegend.drawColorScheme(context, colorScheme,
      200);

  }

};
morpheus.Util.extend(morpheus.ColorSupplierLegend, morpheus.Events);
morpheus.Util.extend(morpheus.ColorSupplierLegend,
  morpheus.AbstractCanvas);






/**
 * @param type
 *            Either relative or fixed.
 * @param stops
 *            An array of objects with value and color
 */
morpheus.HeatMapColorScheme = function (project, scheme) {
  this.project = project;
  var _this = this;

  this.separateColorSchemeForRowMetadataField = null;
  this.rowValueToColorSupplier = {};
  this.value = null;
  if (scheme) {
    if (scheme.valueToColorScheme) { // json representation
      this.fromJSON(scheme);
    } else {
      this.rowValueToColorSupplier[null] = this.fromJSON(scheme);
      this.currentColorSupplier = this.rowValueToColorSupplier[this.value];
    }
  }
  project
    .on(
      'rowFilterChanged columnFilterChanged rowSortOrderChanged columnSortOrderChanged datasetChanged',
      function () {
        _this.projectUpdated();
      });
  this.projectUpdated();
};
morpheus.HeatMapColorScheme.Predefined = {};

morpheus.HeatMapColorScheme.Predefined.CN = function () {
  return {
    scalingMode: 'fixed',
    values: [-2, -0.1, 0.1, 2],
    colors: ['#0000ff', '#ffffff', '#ffffff', '#ff0000']
  };
};
morpheus.HeatMapColorScheme.Predefined.BINARY = function () {
  return {
    scalingMode: 'fixed',
    values: [0, 1],
    colors: ['#ffffff', 'black']
  };
};
morpheus.HeatMapColorScheme.Predefined.RELATIVE = function () {
  return {
    scalingMode: 'relative'
  };
};
morpheus.HeatMapColorScheme.Predefined.MAF = function () {
  // coMut plot colors
  return {
    scalingMode: 'fixed',
    stepped: true,
    values: [0, 1, 2, 3, 4, 5, 6, 7],
    names: ['', 'Synonymous', 'In Frame Indel', 'Other Non-Synonymous', 'Missense', 'Splice Site', 'Frame Shift', 'Nonsense'],
    colors: ['#ffffff', '#4daf4a', '#ffff33', '#a65628', '#377eb8', '#984ea3', '#ff7f00', '#e41a1c']
  };
};
// morpheus.HeatMapColorScheme.Predefined.MAF_NEW = function() {
// // Synonymous 1
// //In_frame_Indel 2
// //Other_non_syn. 3
// //Missense 4
// //Splice_Site 5
// //Frame_Shift 6
// //Nonsense 7
// return {
// type : 'fixed',
// stepped : true,
// map : [ {
// value : 0,
// color : 'rgb(' + [ 255, 255, 255 ].join(',') + ')',
// name : ''
// }, {
// value : 1,
// color : 'rgb(' + [ 255, 255, 179 ].join(',') + ')',
// name : 'Silent'
// }, {
// value : 2,
// color : 'rgb(' + [ 69, 117, 180 ].join(',') + ')',
// name : 'In Frame Indel'
// }, {
// value : 3,
// color : 'rgb(' + [ 247, 182, 210 ].join(',') + ')',
// name : 'Other Non-Synonymous'
// }, {
// value : 4,
// color : 'rgb(' + [ 1, 133, 113 ].join(',') + ')',
// name : 'Missense'
// }, {
// value : 5,
// color : 'rgb(' + [ 253, 180, 98 ].join(',') + ')',
// name : 'Splice Site'
// }, {
// value : 6,
// color : 'rgb(' + [ 140, 81, 10 ].join(',') + ')',
// name : 'Frame Shift'
// }, {
// value : 7,
// color : 'rgb(' + [ 123, 50, 148 ].join(',') + ')',
// name : 'Nonsense'
// } ]
// };
// };
morpheus.HeatMapColorScheme.Predefined.ZS = function () {
  return {
    scalingMode: 'fixed',
    values: [-10, -2, 2, 10],
    colors: ['#0000ff', '#ffffff', '#ffffff', '#ff0000']
  };
};
morpheus.HeatMapColorScheme.ScalingMode = {
  RELATIVE: 0,
  FIXED: 1
};

morpheus.HeatMapConditions = function () {
  this.array = [];
  // each condition is a object with: seriesName (series is old deprecated field), shape, color and
  // accept(val) function

};
morpheus.HeatMapConditions.prototype = {
  insert: function (index, c) {
    this.array.splice(index, 0, c);
  },
  add: function (c) {
    this.array.push(c);
  },
  getConditions: function () {
    return this.array;
  },
  remove: function (index) {
    this.array.splice(index, 1);
  },
  copy: function () {
    var c = new morpheus.HeatMapConditions();
    this.array.forEach(function (cond) {
      c.array.push(_.clone(cond));
    });
    return c;
  }
};

morpheus.HeatMapColorScheme.prototype = {
  getColors: function () {
    return this.currentColorSupplier.getColors();
  },
  setMissingColor: function (color) {
    this.currentColorSupplier.setMissingColor(color);
  },
  getHiddenValues: function () {
    return this.currentColorSupplier.getHiddenValues ? this.currentColorSupplier
        .getHiddenValues()
      : null;
  },
  getMissingColor: function () {
    return this.currentColorSupplier.getMissingColor();
  },
  getScalingMode: function () {
    return this.currentColorSupplier.getScalingMode();
  },
  getSizer: function () {
    return this.currentColorSupplier.getSizer();
  },
  getConditions: function () {
    return this.currentColorSupplier.getConditions();
  },
  setScalingMode: function (scalingMode) {
    this.currentColorSupplier.setScalingMode(scalingMode);
  },
  getFractions: function () {
    return this.currentColorSupplier.getFractions();
  },
  getNames: function () {
    return this.currentColorSupplier.getNames();
  },
  getMin: function () {
    return this.currentColorSupplier.getMin();
  },
  getMax: function () {
    return this.currentColorSupplier.getMax();
  },
  setMin: function (min) {
    this.currentColorSupplier.setMin(min);
  },
  setMax: function (max) {
    this.currentColorSupplier.setMax(max);
  },
  isStepped: function () {
    return this.currentColorSupplier.isStepped();
  },
  setFractions: function (options) {
    this.currentColorSupplier.setFractions(options);
  },
  setTransformValues: function (options) {
    this.currentColorSupplier.setTransformValues(options);
    this.cachedRowStats.cachedRow = -1;
  },
  getTransformValues: function () {
    return this.currentColorSupplier.getTransformValues();
  },
  setStepped: function (stepped) {
    var oldColorSupplier = this.currentColorSupplier;
    var newColorSupplier = stepped ? new morpheus.SteppedColorSupplier()
      : new morpheus.GradientColorSupplier();
    newColorSupplier.sizer = oldColorSupplier.getSizer();
    newColorSupplier.array = oldColorSupplier.getConditions();
    newColorSupplier.setScalingMode(oldColorSupplier.getScalingMode());
    newColorSupplier.setMin(oldColorSupplier.getMin());
    newColorSupplier.setMax(oldColorSupplier.getMax());
    newColorSupplier.setFractions({
      fractions: oldColorSupplier.getFractions(),
      colors: oldColorSupplier.getColors()
    });
    this.currentColorSupplier = newColorSupplier;
    this.rowValueToColorSupplier[this.value] = this.currentColorSupplier;
  },
  toJSON: function () {
    var json = {};
    var _this = this;
    if (this.separateColorSchemeForRowMetadataField != null) {
      json.separateColorSchemeForRowMetadataField = this.separateColorSchemeForRowMetadataField;
    }
    json.valueToColorScheme = {};
    _.each(_.keys(this.rowValueToColorSupplier), function (key) {
      // save each scheme
      json.valueToColorScheme[key] = morpheus.AbstractColorSupplier.toJSON(_this.rowValueToColorSupplier[key]);
    });

    return json;
  },
  fromJSON: function (json) {
    var _this = this;
    if (json.separateColorSchemeForRowMetadataField) {
      this.separateColorSchemeForRowMetadataField = json.separateColorSchemeForRowMetadataField;
      this.vector = this.project.getSortedFilteredDataset()
        .getRowMetadata().getByName(
          this.separateColorSchemeForRowMetadataField);
    }
    this.rowValueToColorSupplier = {};
    var obj = json.valueToColorScheme || json.colorSchemes;
    if (obj == null) {
      var colorSupplier = morpheus.AbstractColorSupplier
        .fromJSON(json);
      _this.rowValueToColorSupplier['null'] = colorSupplier;
    } else {
      _.each(_.keys(obj), function (key) {
        var colorSupplier = morpheus.AbstractColorSupplier
          .fromJSON(obj[key]);
        _this.rowValueToColorSupplier[key] = colorSupplier;
      });
    }
    this._ensureColorSupplierExists();

  },
  copy: function (project) {
    var _this = this;
    var c = new morpheus.HeatMapColorScheme(project);
    c.separateColorSchemeForRowMetadataField = this.separateColorSchemeForRowMetadataField;
    if (c.separateColorSchemeForRowMetadataField != null) {
      c.vector = project.getSortedFilteredDataset().getRowMetadata()
        .getByName(c.separateColorSchemeForRowMetadataField);

    }
    if (c.vector == null) {
      c.separateColorSchemeForRowMetadataField = null;
    }
    _.each(_.keys(this.rowValueToColorSupplier), function (key) {
      c.rowValueToColorSupplier[key] = _this.rowValueToColorSupplier[key]
        .copy();
    });

    c.value = this.value;
    c.currentColorSupplier = c.rowValueToColorSupplier[c.value];

    return c;
  },
  setSeparateColorSchemeForRowMetadataField: function (separateColorSchemeForRowMetadataField) {
    if (separateColorSchemeForRowMetadataField != this.separateColorSchemeForRowMetadataField) {
      this.separateColorSchemeForRowMetadataField = separateColorSchemeForRowMetadataField;
      this.vector = this.project.getSortedFilteredDataset()
        .getRowMetadata().getByName(
          separateColorSchemeForRowMetadataField);
      var _this = this;
      _.each(_.keys(this.rowValueToColorSupplier), function (key) {
        // remove old color schemes
        delete _this.rowValueToColorSupplier[key];
      });
    }
  },
  getProject: function () {
    return this.project;
  },
  getSeparateColorSchemeForRowMetadataField: function () {
    return this.separateColorSchemeForRowMetadataField;
  },
  getColorByValues: function () {
    return _.keys(this.rowValueToColorSupplier);
  },
  projectUpdated: function () {
    var dataset = this.project.getSortedFilteredDataset();
    if (this.separateColorSchemeForRowMetadataField != null) {
      this.vector = this.project.getSortedFilteredDataset()
        .getRowMetadata().getByName(
          this.separateColorSchemeForRowMetadataField);
    }
    this.cachedRowStats = new morpheus.RowStats(dataset);
  },
  setColorSupplierForCurrentValue: function (colorSupplier) {
    this.rowValueToColorSupplier[this.value] = colorSupplier;
    this.currentColorSupplier = colorSupplier;
  },
  setCurrentValue: function (value) {
    this.value = value;
    this._ensureColorSupplierExists();
  },
  isSizeBy: function () {
    this.currentColorSupplier.isSizeBy();
  },
  getCurrentColorSupplier: function () {
    return this.currentColorSupplier;
  },
  getColor: function (row, column, val) {
    if (this.vector !== undefined) {
      var tmp = this.vector.getValue(row);
      if (this.value !== tmp) {
        this.value = tmp;
        this._ensureColorSupplierExists();
      }
    }
    if (this.currentColorSupplier.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      if (this.cachedRowStats.maybeUpdateRelative(row)) {
        this.currentColorSupplier
          .setMin(this.cachedRowStats.rowCachedMin);
        this.currentColorSupplier
          .setMax(this.cachedRowStats.rowCachedMax);
      }
    } else if (this.currentColorSupplier.getTransformValues() && this.cachedRowStats.cachedRow !== row) {
      this.cachedRowStats.cacheTransformValues(row, this.currentColorSupplier.getTransformValues());
      val = (val - this.cachedRowStats.rowCachedMean) / this.cachedRowStats.rowCachedStandardDeviation;
    }
    return this.currentColorSupplier.getColor(row, column, val);
  },
  /**
   * @private
   */
  _ensureColorSupplierExists: function () {
    this.currentColorSupplier = this.rowValueToColorSupplier[this.value];
    if (this.currentColorSupplier === undefined) {
      var cs = morpheus.AbstractColorSupplier.fromJSON({
        scalingMode: 'relative'
      });
      this.rowValueToColorSupplier[this.value] = cs;
      this.currentColorSupplier = cs;
    }
  }
};
morpheus.RowStats = function (dataset) {
  this.datasetRowView = new morpheus.DatasetRowView(dataset);
  this.cachedRow = -1;
  this.rowCachedMax = 0;
  this.rowCachedMin = 0;
  this.rowCachedStandardDeviation = -1;
  this.rowCachedMean = -1;
};
morpheus.RowStats.prototype = {
  cacheTransformValues: function (row, transform) {
    var meanFunction = transform === morpheus.AbstractColorSupplier.Z_SCORE ? morpheus.Mean : morpheus.Median;
    var stdevFunction = transform === morpheus.AbstractColorSupplier.Z_SCORE ? morpheus.StandardDeviation : morpheus.MAD;
    this.datasetRowView.setIndex(row);
    this.rowCachedMean = meanFunction(this.datasetRowView);
    this.rowCachedStandardDeviation = stdevFunction(this.datasetRowView, this.rowCachedMean);
  },
  maybeUpdateRelative: function (row) {
    if (this.cachedRow !== row) {
      this.cachedRow = row;
      this.datasetRowView.setIndex(row);
      this.rowCachedMax = -Number.MAX_VALUE;
      this.rowCachedMin = Number.MAX_VALUE;
      for (var j = 0, ncols = this.datasetRowView.size(); j < ncols; j++) {
        var d = this.datasetRowView.getValue(j);
        if (!isNaN(d)) {
          this.rowCachedMax = d > this.rowCachedMax ? d
            : this.rowCachedMax;
          this.rowCachedMin = d < this.rowCachedMin ? d
            : this.rowCachedMin;
        }
      }
      if (this.rowCachedMin === this.rowCachedMax) {
        this.rowCachedMin--;
      }
      return true;
    }
    return false;
  }
};

morpheus.HeatMapSynchronizer = function () {
  this.controllers = [];
};
morpheus.HeatMapSynchronizer.prototype = {
  firing: false,
  getProject: function () {
    return this.controllers[0].getProject();
  },
  zoom: function () {
    this.controllers[0].zoom.apply(this.controllers[0], arguments);
  },
  setTrackVisible: function () {
    this.controllers[0].setTrackVisible.apply(this.controllers[0],
      arguments);
  },
  revalidate: function () {
    this.controllers[0].revalidate.apply(this.controllers[0], arguments);
  },
  add: function (heatMap) {
    var that = this;
    this.controllers.push(heatMap);
    // setQuickSearchField, setTrackVisible, removeTrack, updateDataset, zoom, moveTrack, resizeTrack, paintAll, fitToWindow, revalidate, setToolTip, setMousePosition
    heatMap.on('change', function (event) {
      if (!that.firing) {
        var source = event.source;
        var method = event.name;
        that.firing = true;
        _.each(that.controllers, function (c) {
          if (c !== source) {
            c[method].apply(c, event.arguments);
          }
        });
        that.firing = false;
      }
    });
  }
};

morpheus.HeatMapElementCanvas = function (project) {
  morpheus.AbstractCanvas.call(this, true);
  var _this = this;
  this.colorScheme = null;
  this.project = project;
  this.dataset = null;
  this.columnPositions = new morpheus.Positions();
  this.rowPositions = new morpheus.Positions();
  this.lastPosition = {
    left: -1,
    right: -1,
    top: -1,
    bottom: -1
  };
  // drag to select rows and columns
  this.selectionBox = null;
  this.selectedRowElements = [];
  this.selectedColumnElements = [];
  project.getElementSelectionModel().on('selectionChanged', function (e) {
    _this.repaint();
  });
  this.gridColor = morpheus.HeatMapElementCanvas.GRID_COLOR;
  this.gridThickness = 0.1;
  this.elementDrawCallback = null;
  this.drawCallback = null;
  this.drawValuesFormat = morpheus.Util.createNumberFormat('.2f');
};
morpheus.HeatMapElementCanvas.GRID_COLOR = '#808080';
morpheus.HeatMapElementCanvas.prototype = {
  drawGrid: true,
  drawValues: false,
  setPropertiesFromParent: function (parentHeatMapElementCanvas) {
    this.drawGrid = parentHeatMapElementCanvas.drawGrid;
    this.gridThickness = parentHeatMapElementCanvas.gridThickness;
    this.gridColor = parentHeatMapElementCanvas.gridColor;
    this.drawValues = parentHeatMapElementCanvas.drawValues;
  },
  updateRowSelectionCache: function (repaint) {
    this.selectedRowElements = morpheus.HeatMapElementCanvas.getSelectedSpans(this.project.getRowSelectionModel().getViewIndices());
    if (repaint) {
      this.repaint();
    }
  },
  updateColumnSelectionCache: function (repaint) {
    this.selectedColumnElements = morpheus.HeatMapElementCanvas.getSelectedSpans(this.project.getColumnSelectionModel().getViewIndices());
    if (repaint) {
      this.repaint();
    }
  },
  setGridColor: function (gridColor) {
    this.gridColor = gridColor;
  },
  getGridColor: function () {
    return this.gridColor;
  },
  setGridThickness: function (gridThickness) {
    this.gridThickness = gridThickness;
  },
  getGridThickness: function () {
    return this.gridThickness;
  },
  getColorScheme: function () {
    return this.colorScheme;
  },
  isDrawGrid: function () {
    return this.drawGrid;
  },
  setDrawGrid: function (drawGrid) {
    this.drawGrid = drawGrid;
  },
  getDrawValuesFormat: function () {
    return this.drawValuesFormat;
  },
  setDrawValuesFormat: function (f) {
    if (typeof f === 'object') { // convert to function
      f = morpheus.Util.createNumberFormat(f.pattern);
    }
    this.drawValuesFormat = f;
  },
  setDrawValues: function (drawValues) {
    this.drawValues = drawValues;
  },
  isDrawValues: function () {
    return this.drawValues;
  },
  setColorScheme: function (colorScheme) {
    this.colorScheme = colorScheme;
  },
  setDataset: function (dataset) {
    this.dataset = dataset;
    this.columnPositions.setLength(this.dataset.getColumnCount());
    this.rowPositions.setLength(this.dataset.getRowCount());
    this.updateRowSelectionCache(false);
    this.updateColumnSelectionCache(false);
  },
  getColumnPositions: function () {
    return this.columnPositions;
  },
  getRowPositions: function () {
    return this.rowPositions;
  },
  getPreferredSize: function (context) {
    var w = Math.ceil(this.columnPositions.getPosition(this.columnPositions
        .getLength() - 1)
      + this.columnPositions.getItemSize(this.columnPositions
        .getLength() - 1));
    var h = Math.ceil(this.rowPositions.getPosition(this.rowPositions
        .getLength() - 1)
      + this.rowPositions
        .getItemSize(this.rowPositions.getLength() - 1));
    return {
      width: w,
      height: h
    };
  },
  prePaint: function (clip, context) {
    var lastPosition = this.lastPosition;
    var columnPositions = this.columnPositions;
    var rowPositions = this.rowPositions;
    var left = morpheus.Positions.getLeft(clip, columnPositions);
    var right = morpheus.Positions.getRight(clip, columnPositions);
    var top = morpheus.Positions.getTop(clip, rowPositions);
    var bottom = morpheus.Positions.getBottom(clip, rowPositions);
    if (this.invalid || left !== lastPosition.left
      || right !== lastPosition.right || top !== lastPosition.top
      || bottom !== lastPosition.bottom) {
      lastPosition.right = right;
      lastPosition.left = left;
      lastPosition.top = top;
      lastPosition.bottom = bottom;
      this.invalid = true;
    }
  },
  postPaint: function (clip, context) {
    // draw mouse over stuff
    morpheus.CanvasUtil.resetTransform(context);
    var project = this.project;
    context.strokeStyle = 'Grey';
    context.lineWidth = 1;
    var rowPositions = this.getRowPositions();
    var columnPositions = this.getColumnPositions();
    if (project.getHoverColumnIndex() >= 0
      || project.getHoverRowIndex() >= 0) {
      var height = rowPositions
        .getItemSize(project.getHoverColumnIndex());
      var width = columnPositions.getItemSize(project
        .getHoverColumnIndex());
      var y = (project.getHoverRowIndex() === -1 ? rowPositions
        .getPosition(rowPositions.getLength() - 1) : rowPositions
        .getPosition(project.getHoverRowIndex()));
      var x = (project.getHoverColumnIndex() === -1 ? columnPositions
        .getPosition(0) : columnPositions.getPosition(project
        .getHoverColumnIndex()));

      if (project.getHoverColumnIndex() !== -1) {
        // thin rectangle down entire column
        context.strokeRect(x - clip.x, 0, width, this
          .getUnscaledHeight());
      }
      if (project.getHoverRowIndex() !== -1) {
        // thin rectangle across entire row
        context.strokeRect(0, y - clip.y, this.getUnscaledWidth(),
          height);
      }
      if (project.getHoverColumnIndex() !== -1
        && project.getHoverRowIndex() !== -1) {
        context.strokeStyle = 'black';
        context.lineWidth = 3;
        context.strokeRect(x - clip.x + 1.5, y - clip.y + 1.5,
          width - 1.5, height - 1.5);
        if (project.isSymmetric()) {
          var y2 = rowPositions.getPosition(project.getHoverColumnIndex());
          var x2 = columnPositions.getPosition(project.getHoverRowIndex());
          context.strokeRect(x2 - clip.x + 1.5, y2 - clip.y + 1.5,
            width - 1.5, height - 1.5);
        }

      }
    }
    var left = morpheus.Positions.getLeft(clip, columnPositions);
    var right = morpheus.Positions.getRight(clip, columnPositions);
    var top = morpheus.Positions.getTop(clip, rowPositions);
    var bottom = morpheus.Positions.getBottom(clip, rowPositions);

    context.strokeStyle = 'rgb(0,0,0)';
    context.lineWidth = 2;
    // context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    context.translate(-clip.x, -clip.y);
    var selectedElements = project.getElementSelectionModel()
      .getViewIndices();

    if (selectedElements != null) {
      selectedElements.forEach(function (id) {
        var rowIndex = id.getArray()[0];
        var columnIndex = id.getArray()[1];
        if (rowIndex >= top && rowIndex < bottom && columnIndex >= left
          && columnIndex < right) {
          var rowSize = rowPositions.getItemSize(rowIndex);
          var py = rowPositions.getPosition(rowIndex);
          var columnSize = columnPositions.getItemSize(columnIndex);
          var px = columnPositions.getPosition(columnIndex);
          context.strokeRect(px + 1.5, py + 1.5, columnSize - 1.5,
            rowSize - 1.5);

        }
      });
    }
    // draw selection bounding boxes
    context.strokeStyle = 'rgb(182,213,253)';
    var selectedRowElements = this.selectedRowElements;
    var selectedColumnElements = this.selectedColumnElements;

    if (!(selectedRowElements.length === 0 &&
        selectedColumnElements.length === 0)) {
      if (selectedRowElements.length === 0) {
        selectedRowElements = [[top, bottom - 1]];
      }
      if (selectedColumnElements.length === 0) {
        selectedColumnElements = [[left, right - 1]];
      }
    }
    var nrows = selectedRowElements.length;
    var ncols = selectedColumnElements.length;

    if (nrows !== 0 || ncols !== 0) {
      for (var i = 0; i < nrows; i++) {
        var r = selectedRowElements[i];
        var y1 = rowPositions.getPosition(r[0]);
        var y2 = rowPositions.getPosition(r[1]) + rowPositions.getItemSize(i);
        for (var j = 0; j < ncols; j++) {
          var c = selectedColumnElements[j];
          var x1 = columnPositions.getPosition(c[0]);
          var x2 = columnPositions.getPosition(c[1]) + columnPositions.getItemSize(j);
          context.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
      }
    }
    if (this.selectionBox) {
      context.strokeStyle = 'rgb(0,0,0)';
      context.lineWidth = 2;
      if (context.setLineDash) {
        context.setLineDash([5]);
      }
      var x1 = columnPositions.getPosition(this.selectionBox.x[0]);
      var x2 = columnPositions.getPosition(this.selectionBox.x[1]);
      if (x2 < x1) {
        var tmp = x1;
        x1 = x2;
        x2 = tmp + columnPositions.getItemSize(this.selectionBox.x[0]);
      } else {
        x2 += columnPositions.getItemSize(this.selectionBox.x[1]);
      }
      var y1 = rowPositions.getPosition(this.selectionBox.y[0]);
      var y2 = rowPositions.getPosition(this.selectionBox.y[1]);
      if (y2 < y1) {
        var tmp = y1;
        y1 = y2;
        y2 = tmp + rowPositions.getItemSize(this.selectionBox.y[0]);
      } else {
        y2 += rowPositions.getItemSize(this.selectionBox.y[1]);
      }

      context.strokeRect(x1, y1, x2 - x1, y2 - y1);
      if (context.setLineDash) {
        context.setLineDash([]);
      }
      context.lineWidth = 1;
    }
  },
  setElementDrawCallback: function (elementDrawCallback) {
    this.elementDrawCallback = elementDrawCallback;
  },
  setSelectionBox: function (selectionBox) {
    this.selectionBox = selectionBox;
  },
  setDrawCallback: function (drawCallback) {
    this.drawCallback = drawCallback;
  },
  draw: function (clip, context) {
    var columnPositions = this.columnPositions;
    var rowPositions = this.rowPositions;
    var left = morpheus.Positions.getLeft(clip, columnPositions);
    var right = morpheus.Positions.getRight(clip, columnPositions);
    var top = morpheus.Positions.getTop(clip, rowPositions);
    var bottom = morpheus.Positions.getBottom(clip, rowPositions);

    context.translate(-clip.x, -clip.y);
    this._draw({
      left: left,
      right: right,
      top: top,
      bottom: bottom,
      context: context
    });
    context.translate(clip.x, clip.y);

    if (this.drawCallback) {
      this.drawCallback({
        clip: clip,
        context: context
      });
    }

  },
  _draw: function (options) {
    var left = options.left;
    var right = options.right;
    var top = options.top;
    var bottom = options.bottom;
    var context = options.context;
    var fontFamily = morpheus.CanvasUtil.getFontFamily(context);
    var columnPositions = this.columnPositions;
    var rowPositions = this.rowPositions;
    //if (rowPositions.getSize() < 1 || columnPositions.getSize() < 1) {
    //force sub-pixel rendering
    morpheus.CanvasUtil.forceSubPixelRendering(context);
    //}

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    var dataset = this.dataset;

    var colorScheme = this.colorScheme;
    var drawGrid = this.drawGrid;
    var elementDrawCallback = this.elementDrawCallback;
    var hasElementDrawCallback = elementDrawCallback != null;
    var drawValues = this.drawValues && columnPositions.getSize() > 7 && rowPositions.getSize() > 7;
    var nf;
    if (drawValues) {
      nf = this.drawValuesFormat;
      var fontSize = columnPositions.getSize();
      context.font = fontSize + 'px ' + fontFamily;
      var textWidth = context.measureText('-99.9').width;
      fontSize = ( (columnPositions.getSize() - 1) / textWidth) * fontSize;
      fontSize = Math.min(fontSize, 17);
      context.font = fontSize + 'px ' + morpheus.CanvasUtil.getFontFamily(context);
    }
    var seriesNameToIndex = {};
    for (var i = 0; i < dataset.getSeriesCount(); i++) {
      seriesNameToIndex[dataset.getName(i)] = i;
    }
    var sizer;
    var sizeBySeriesName;
    var sizeBySeriesIndex;

    var conditions;
    var conditionSeriesIndices;
    var sizeFractionRemapper = d3.scale.linear().domain([0, 1]).range([0.2, 1]);
    for (var row = top; row < bottom; row++) {
      var rowSize = rowPositions.getItemSize(row);
      var py = rowPositions.getPosition(row);
      for (var column = left; column < right; column++) {
        var columnSize = columnPositions.getItemSize(column);
        var px = columnPositions.getPosition(column);
        var value = dataset.getValue(row, column);
        context.fillStyle = colorScheme.getColor(row, column, value);
        if (column === left) { // check if the color scheme for this
          // row is sizing
          sizer = colorScheme.getSizer();
          sizeBySeriesName = sizer.getSeriesName();
          sizeBySeriesIndex = sizeBySeriesName != null ? seriesNameToIndex[sizeBySeriesName]
            : undefined;
          conditionSeriesIndices = [];
          conditions = colorScheme.getConditions().getConditions();
          for (var ci = 0, nconditions = conditions.length; ci < nconditions; ci++) {
            conditionSeriesIndices
              .push(seriesNameToIndex[conditions[ci].seriesName]);
          }

        }
        var yoffset = 0;
        var xoffset = 0;
        var cellRowSize = rowSize;
        var cellColumnSize = columnSize;
        if (sizeBySeriesIndex !== undefined) {
          var sizeByValue = dataset.getValue(row, column,
            sizeBySeriesIndex);
          if (!isNaN(sizeByValue)) {
            var sizeFraction = sizeFractionRemapper(sizer.valueToFraction(sizeByValue)); // remap 0-1 to 0.2-1
            cellRowSize = cellRowSize * sizeFraction;
            yoffset = (rowSize - cellRowSize) / 2;

            cellColumnSize = cellColumnSize * sizeFraction;
            xoffset = (columnSize - cellColumnSize) / 2;

          }
        }
        if (conditions.length > 0) {
          var condition = null;
          for (var ci = 0, nconditions = conditions.length; ci < nconditions; ci++) {
            var cond = conditions[ci];
            var condValue = dataset.getValue(row, column,
              conditionSeriesIndices[ci]);

            if (!isNaN(condValue) && cond.accept(condValue)) {
              condition = cond;
              break;
            }

          }
          if (condition !== null) {
            if (condition.shape != null) {
              if (condition.inheritColor) {
                if (sizeBySeriesIndex === undefined) {
                  xoffset = 1;
                  yoffset = 1;
                  cellRowSize -= 2;
                  cellColumnSize -= 2;
                }
                var x = px + xoffset + cellRowSize / 2;
                var y = py + yoffset + cellColumnSize / 2;
                morpheus.CanvasUtil.drawShape(context, condition.shape,
                  x, y, Math.min(cellColumnSize, cellRowSize) / 2, true);
              } else { // e.g. filled circle on top of heat map
                context.fillRect(px + xoffset, py + yoffset, cellColumnSize,
                  cellRowSize);
                // x and y are at center
                var x = px + xoffset + cellRowSize / 2;
                var y = py + yoffset + cellColumnSize / 2;
                context.fillStyle = condition.color;
                morpheus.CanvasUtil.drawShape(context, condition.shape,
                  x, y, Math.min(cellColumnSize, cellRowSize) / 4, true);
              }

            } else {
              context.fillRect(px + xoffset, py + yoffset, cellColumnSize,
                cellRowSize);
            }
          } else {
            context.fillRect(px + xoffset, py + yoffset, cellColumnSize,
              cellRowSize);
          }
        } else {
          context.fillRect(px + xoffset, py + yoffset, cellColumnSize, cellRowSize);
        }
        if (drawValues && cellColumnSize > 7 && cellRowSize > 7 && !isNaN(value)) {
          context.fillStyle = 'rgb(0,0,0)';
          context.fillText(nf(value), px + xoffset + cellColumnSize / 2, py + yoffset + cellRowSize / 2, cellColumnSize);
        }
        if (hasElementDrawCallback) {
          elementDrawCallback(context, dataset, row, column, px, py,
            columnSize, rowSize);
        }
      }
    }
    if (drawGrid && rowPositions.getSize() > 10 && columnPositions.getSize() > 10) {
      context.strokeStyle = this.gridColor;
      context.lineWidth = this.gridThickness;
      context.beginPath();

      for (var row = top; row < bottom; row++) {
        var rowSize = rowPositions.getItemSize(row);
        var py = rowPositions.getPosition(row);
        for (var column = left; column < right; column++) {
          var columnSize = columnPositions.getItemSize(column);
          var px = columnPositions.getPosition(column);
          var grid = columnSize > 10 && rowSize > 10;
          if (grid) {
            context.rect(px, py, columnSize, rowSize);
          }
        }
      }
      context.stroke();

    }
    context.lineWidth = 1;
  }
};
morpheus.Util.extend(morpheus.HeatMapElementCanvas, morpheus.AbstractCanvas);

morpheus.HeatMapElementCanvas.getSelectedSpans = function (set) {
  var array = [];
  if (set.size() > 0) {
    var index = 0;
    var start = index;
    var viewIndices = set.values();
    viewIndices.sort(function (a, b) {
      return (a === b ? 0 : (a < b ? -1 : 1));
    });
    var length = viewIndices.length;
    while (index < length) {
      var prior = index === 0 ? viewIndices[0] : viewIndices[index - 1];
      var current = viewIndices[index];
      if ((current - prior) > 1) {
        array.push([viewIndices[start], viewIndices[index - 1]]);
        start = index;
      }
      index++;
    }
    if (start == 0) {
      array.push([viewIndices[0], viewIndices[viewIndices.length - 1]]);
    } else {
      array.push([viewIndices[start], viewIndices[index - 1]]);
    }
  }
  return array;
};

morpheus.KeyboardCharMap = [
  '', // [0]
  '', // [1]
  '', // [2]
  'CANCEL', // [3]
  '', // [4]
  '', // [5]
  'HELP', // [6]
  '', // [7]
  'BACKSPACE', // [8]
  'TAB', // [9]
  '', // [10]
  '', // [11]
  'CLEAR', // [12]
  'ENTER', // [13]
  'ENTER_SPECIAL', // [14]
  '', // [15]
  'SHIFT', // [16]
  'CONTROL', // [17]
  'ALT', // [18]
  'PAUSE', // [19]
  'CAPS_LOCK', // [20]
  'KANA', // [21]
  'EISU', // [22]
  'JUNJA', // [23]
  'FINAL', // [24]
  'HANJA', // [25]
  '', // [26]
  'Escape', // [27]
  'CONVERT', // [28]
  'NONCONVERT', // [29]
  'ACCEPT', // [30]
  'MODECHANGE', // [31]
  'Space', // [32]
  'Page Up', // [33]
  'Page Down', // [34]
  'End', // [35]
  'Home', // [36]
  'Left', // [37]
  'Up', // [38]
  'Right', // [39]
  'Down', // [40]
  'SELECT', // [41]
  'PRINT', // [42]
  'EXECUTE', // [43]
  'PRINTSCREEN', // [44]
  'INSERT', // [45]
  'Delete', // [46]
  '', // [47]
  '0', // [48]
  '1', // [49]
  '2', // [50]
  '3', // [51]
  '4', // [52]
  '5', // [53]
  '6', // [54]
  '7', // [55]
  '8', // [56]
  '9', // [57]
  'COLON', // [58]
  'SEMICOLON', // [59]
  'LESS_THAN', // [60]
  'Equals', // [61]
  'GREATER_THAN', // [62]
  'QUESTION_MARK', // [63]
  'AT', // [64]
  'A', // [65]
  'B', // [66]
  'C', // [67]
  'D', // [68]
  'E', // [69]
  'F', // [70]
  'G', // [71]
  'H', // [72]
  'I', // [73]
  'J', // [74]
  'K', // [75]
  'L', // [76]
  'M', // [77]
  'N', // [78]
  'O', // [79]
  'P', // [80]
  'Q', // [81]
  'R', // [82]
  'S', // [83]
  'T', // [84]
  'U', // [85]
  'V', // [86]
  'W', // [87]
  'X', // [88]
  'Y', // [89]
  'Z', // [90]
  'OS_KEY', // [91] Windows Key (Windows) or Command Key (Mac)
  '', // [92]
  'CONTEXT_MENU', // [93]
  '', // [94]
  'SLEEP', // [95]
  '0', // [96]
  '1', // [97]
  '2', // [98]
  '3', // [99]
  '4', // [100]
  '5', // [101]
  '6', // [102]
  '7', // [103]
  '8', // [104]
  '9', // [105]
  'MULTIPLY', // [106]
  '+', // [107]
  'SEPARATOR', // [108]
  'SUBTRACT', // [109]
  'DECIMAL', // [110]
  'DIVIDE', // [111]
  'F1', // [112]
  'F2', // [113]
  'F3', // [114]
  'F4', // [115]
  'F5', // [116]
  'F6', // [117]
  'F7', // [118]
  'F8', // [119]
  'F9', // [120]
  'F10', // [121]
  'F11', // [122]
  'F12', // [123]
  'F13', // [124]
  'F14', // [125]
  'F15', // [126]
  'F16', // [127]
  'F17', // [128]
  'F18', // [129]
  'F19', // [130]
  'F20', // [131]
  'F21', // [132]
  'F22', // [133]
  'F23', // [134]
  'F24', // [135]
  '', // [136]
  '', // [137]
  '', // [138]
  '', // [139]
  '', // [140]
  '', // [141]
  '', // [142]
  '', // [143]
  'NUM_LOCK', // [144]
  'SCROLL_LOCK', // [145]
  'WIN_OEM_FJ_JISHO', // [146]
  'WIN_OEM_FJ_MASSHOU', // [147]
  'WIN_OEM_FJ_TOUROKU', // [148]
  'WIN_OEM_FJ_LOYA', // [149]
  'WIN_OEM_FJ_ROYA', // [150]
  '', // [151]
  '', // [152]
  '', // [153]
  '', // [154]
  '', // [155]
  '', // [156]
  '', // [157]
  '', // [158]
  '', // [159]
  'CIRCUMFLEX', // [160]
  'EXCLAMATION', // [161]
  'DOUBLE_QUOTE', // [162]
  'HASH', // [163]
  'DOLLAR', // [164]
  'PERCENT', // [165]
  'AMPERSAND', // [166]
  'UNDERSCORE', // [167]
  'OPEN_PAREN', // [168]
  'CLOSE_PAREN', // [169]
  'ASTERISK', // [170]
  'Plus', // [171]
  'PIPE', // [172]
  '-', // [173]
  'OPEN_CURLY_BRACKET', // [174]
  'CLOSE_CURLY_BRACKET', // [175]
  'TILDE', // [176]
  '', // [177]
  '', // [178]
  '', // [179]
  '', // [180]
  'VOLUME_MUTE', // [181]
  'VOLUME_DOWN', // [182]
  'VOLUME_UP', // [183]
  '', // [184]
  '', // [185]
  'SEMICOLON', // [186]
  'EQUALS', // [187]
  'COMMA', // [188]
  'MINUS', // [189]
  'PERIOD', // [190]
  '/', // [191]
  'BACK_QUOTE', // [192]
  '', // [193]
  '', // [194]
  '', // [195]
  '', // [196]
  '', // [197]
  '', // [198]
  '', // [199]
  '', // [200]
  '', // [201]
  '', // [202]
  '', // [203]
  '', // [204]
  '', // [205]
  '', // [206]
  '', // [207]
  '', // [208]
  '', // [209]
  '', // [210]
  '', // [211]
  '', // [212]
  '', // [213]
  '', // [214]
  '', // [215]
  '', // [216]
  '', // [217]
  '', // [218]
  'OPEN_BRACKET', // [219]
  'BACK_SLASH', // [220]
  'CLOSE_BRACKET', // [221]
  'QUOTE', // [222]
  '', // [223]
  'META', // [224]
  'ALTGR', // [225]
  '', // [226]
  'WIN_ICO_HELP', // [227]
  'WIN_ICO_00', // [228]
  '', // [229]
  'WIN_ICO_CLEAR', // [230]
  '', // [231]
  '', // [232]
  'WIN_OEM_RESET', // [233]
  'WIN_OEM_JUMP', // [234]
  'WIN_OEM_PA1', // [235]
  'WIN_OEM_PA2', // [236]
  'WIN_OEM_PA3', // [237]
  'WIN_OEM_WSCTRL', // [238]
  'WIN_OEM_CUSEL', // [239]
  'WIN_OEM_ATTN', // [240]
  'WIN_OEM_FINISH', // [241]
  'WIN_OEM_COPY', // [242]
  'WIN_OEM_AUTO', // [243]
  'WIN_OEM_ENLW', // [244]
  'WIN_OEM_BACKTAB', // [245]
  'ATTN', // [246]
  'CRSEL', // [247]
  'EXSEL', // [248]
  'EREOF', // [249]
  'PLAY', // [250]
  'ZOOM', // [251]
  '', // [252]
  'PA1', // [253]
  'WIN_OEM_CLEAR', // [254]
  '' // [255]
];
morpheus.HeatMapKeyListener = function (heatMap) {
  var allActions = heatMap.getActionManager().getActions();
  var actions = allActions.filter(function (a) {
    return a.cb != null && a.which != null;
  });
  allActions.sort(function (a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    return (a === b ? 0 : (a < b ? -1 : 1));
  });
  var keydown = function (e) {
    var tagName = e.target.tagName;
    var found = false;
    var commandKey = morpheus.Util.IS_MAC ? e.metaKey : e.ctrlKey;
    var altKey = e.altKey;
    var shiftKey = e.shiftKey;
    var which = e.which;
    var isInputField = (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA');
    var acceptOptions = {
      isInputField: isInputField,
      heatMap: heatMap
    };
    var shortcutMatches = function (sc) {
      if (sc.which.indexOf(which) !== -1 && (sc.commandKey === undefined || commandKey === sc.commandKey) && (sc.shiftKey === undefined || shiftKey === sc.shiftKey) &&
        (sc.accept == undefined || sc.accept(acceptOptions))) {
        sc.cb({heatMap: heatMap});
        return true;
      }
    };

    if (!isInputField) {
      for (var i = 0, n = actions.length; i < n; i++) {
        var sc = actions[i];
        if (shortcutMatches(sc)) {
          found = true;
          break;
        }
      }
    } else { // only search global shortcuts
      for (var i = 0, n = actions.length; i < n; i++) {
        var sc = actions[i];
        if (sc.global && shortcutMatches(sc)) {
          found = true;
          break;
        }
      }
    }

    if (found) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      return false;
    }
  };
  var $keyelement = heatMap.$tabPanel;
  $keyelement.on('keydown', keydown);

  $keyelement.on('dragover.morpheus dragenter.morpheus', function (e) {
    e.preventDefault();
    e.stopPropagation();
  }).on(
    'drop.morpheus',
    function (e) {
      if (heatMap.options.menu.File && heatMap.options.menu.File.indexOf('Open') !== -1 && e.originalEvent.dataTransfer
        && e.originalEvent.dataTransfer.files.length) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.originalEvent.dataTransfer.files;
        for (var i = 0; i < files.length; i++) {
          morpheus.HeatMap.showTool(new morpheus.OpenFileTool({
            file: files[i]
          }), heatMap);
        }

      }
    });
  $keyelement.on('paste.morpheus',
    function (e) {
      if (heatMap.options.toolbar.openFile) {
        var tagName = e.target.tagName;
        if (tagName == 'INPUT' || tagName == 'SELECT'
          || tagName == 'TEXTAREA') {
          return;
        }
        var text = e.originalEvent.clipboardData.getData('text/plain');
        if (text != null && text.length > 0) {
          e.preventDefault();
          e.stopPropagation();
          var blob = new Blob([text]);
          var url = window.URL.createObjectURL(blob);
          morpheus.HeatMap.showTool(new morpheus.OpenFileTool({
            file: url
          }), heatMap);
        }
      }
    });

  $keyelement.on('mousewheel', function (e) {
    var scrolly = e.deltaY * e.deltaFactor;
    var scrollx = e.deltaX * e.deltaFactor;
    var stop = false;
    if (e.altKey) {
      heatMap.zoom(scrolly > 0, {
        rows: true,
        columns: true
      });
      stop = true;
    } else {
      if (scrolly !== 0) {
        var scrollTop = heatMap.scrollTop();
        if (heatMap.scrollTop(scrollTop - scrolly) !== scrollTop) {
          stop = true;
        }
      }
      if (scrollx !== 0) {
        var scrollLeft = heatMap.scrollLeft();
        if (heatMap.scrollLeft(scrollLeft + scrollx) !== scrollLeft) {
          stop = true;
        }
      }
    }
    if (stop && heatMap.options.standalone) {
      e.preventDefault();
      e.stopPropagation();
    }
  });

  function shortcutToString(sc) {
    var s = ['<b>'];

    if (sc.commandKey) {
      s.push(morpheus.Util.COMMAND_KEY);
    }
    if (sc.shiftKey) {
      s.push('Shift+');
    }
    if (sc.which) {
      s.push(morpheus.KeyboardCharMap[sc.which[0]]);
    }
    s.push('</b>');
    return s.join('');
  }

  this.showKeyMapReference = function () {
    var html = [];
    html.push('<table class="table table-condensed">');
    allActions.forEach(function (sc) {
      html.push('<tr><td>');
      html.push(shortcutToString(sc));
      html.push('</td><td>');
      if (sc.icon) {
        html.push('<span class="' + sc.icon + '"></span> ');
      }

      html.push(sc.name);
      html.push('</td></tr>');
    });

    html.push('</table>');
    morpheus.FormBuilder.showInModal({
      title: 'Keyboard Shortcuts',
      html: html.join(''),
      focus: document.activeElement
    });
  };
};

morpheus.HeatMapOptions = function (heatMap) {
  var items = [
    {
      name: 'color_by',
      required: true,
      help: 'Use a different color scheme for distinct row annotation values',
      type: 'select',
      options: ['(None)'].concat(morpheus.MetadataUtil
        .getMetadataNames(heatMap.getProject()
          .getFullDataset().getRowMetadata())),
      value: heatMap.heatmap.getColorScheme()
        .getSeparateColorSchemeForRowMetadataField()
    }, {
      name: 'color_by_value',
      required: true,
      type: 'select',
      options: []
    }, {
      name: 'load_predefined_scheme',
      required: true,
      type: 'select',
      options: [
        {
          name: '',
          value: ''
        }, {
          name: 'relative',
          value: 'relative'
        }, {
          name: 'binary',
          value: 'binary'
        }, {
          name: 'MAF',
          value: 'MAF'
        }, {
          name: 'fixed (-1.5, -0.1, 0.1, 1.5)',
          value: 'cn'
        }]
    }, {
      name: 'save_color_scheme',
      type: 'button'
    }, {
      name: 'load_color_scheme',
      type: 'file'
    }];

  items.push({
    name: 'size_by',
    required: true,
    type: 'select',
    options: ['(None)'].concat(morpheus.DatasetUtil
      .getSeriesNames(heatMap.getProject().getFullDataset()))
  });
  items.push({
    name: 'size_by_minimum',
    title: 'Size by minimum',
    required: true,
    type: 'text',
    style: 'max-width: 100px;'
  });
  items.push({
    name: 'size_by_maximum',
    title: 'Size by maximum',
    required: true,
    type: 'text',
    style: 'max-width: 100px;'
  });

  items.push({
    name: 'conditional_rendering',
    required: true,
    type: 'button'
  });

  var displayItems = [
    {
      disabled: heatMap.getProject().getFullDataset().getColumnCount() !== heatMap.getProject().getFullDataset().getRowCount(),
      name: 'link_rows_and_columns',
      help: 'For square matrices',
      required: true,
      type: 'checkbox',
      style: 'max-width: 100px;',
      value: heatMap.getProject().isSymmetric()
    },
    {
      name: 'show_row_number',
      required: true,
      type: 'checkbox',
      value: heatMap.isShowRowNumber()
    },
    {
      name: 'show_grid',
      required: true,
      type: 'checkbox',
      value: heatMap.heatmap.isDrawGrid()
    },
    {
      name: 'grid_thickness',
      required: true,
      type: 'text',
      style: 'max-width: 100px;',
      value: morpheus.Util.nf(heatMap.heatmap.getGridThickness())
    },
    {
      name: 'grid_color',
      required: true,
      type: 'color',
      style: 'max-width: 50px;',
      value: heatMap.heatmap.getGridColor()
    },
    {
      name: 'row_size',
      required: true,
      type: 'text',
      style: 'max-width: 100px;',
      value: morpheus.Util.nf(heatMap.heatmap.getRowPositions()
        .getSize())
    },
    {
      name: 'column_size',
      required: true,
      type: 'text',
      style: 'max-width: 100px;',
      value: morpheus.Util.nf(heatMap.heatmap
        .getColumnPositions().getSize())
    }, {
      name: 'show_values',
      required: true,
      type: 'checkbox',
      value: heatMap.heatmap.isDrawValues()
    }, {
      name: 'number_of_fraction_digits',
      required: true,
      type: 'number',
      min: 0,
      step: 1,
      style: 'max-width: 100px;',
      value: morpheus.Util.getNumberFormatPatternFractionDigits(heatMap.heatmap.getDrawValuesFormat().toJSON().pattern)
    }];
  if (heatMap.rowDendrogram) {
    displayItems
      .push({
        name: 'row_dendrogram_line_thickness',
        required: true,
        type: 'text',
        style: 'max-width: 100px;',
        value: morpheus.Util
          .nf(heatMap.rowDendrogram ? heatMap.rowDendrogram.lineWidth
            : 1)
      });
  }
  if (heatMap.columnDendrogram) {
    displayItems
      .push({
        name: 'column_dendrogram_line_thickness',
        required: true,
        type: 'text',
        style: 'max-width: 100px;',
        value: morpheus.Util
          .nf(heatMap.columnDendrogram ? heatMap.columnDendrogram.lineWidth
            : 1)
      });
  }

  displayItems.push({
    name: 'info_window',
    required: true,
    type: 'select',
    style: 'max-width:130px;',
    options: [
      {
        name: 'Fixed To Top',
        value: 0
      }, {
        name: 'New Window',
        value: 1
      }],
    value: heatMap.tooltipMode
  });

  displayItems.push({
    name: 'inline_tooltip',
    required: true,
    type: 'checkbox',
    value: heatMap.options.inlineTooltip
  });

  var colorSchemeFormBuilder = new morpheus.FormBuilder();
  _.each(items, function (item) {
    colorSchemeFormBuilder.append(item);
  });
  var displayFormBuilder = new morpheus.FormBuilder();
  _.each(displayItems, function (item) {
    displayFormBuilder.append(item);
  });
  var colorSchemeChooser = new morpheus.HeatMapColorSchemeChooser({
    showRelative: true,
    colorScheme: heatMap.heatmap
      .getColorScheme()
  });
  var updatingSizer = false;

  function colorSchemeChooserUpdated() {
    if (heatMap.heatmap.getColorScheme().getSizer
      && heatMap.heatmap.getColorScheme().getSizer() != null) {
      colorSchemeFormBuilder.setValue('size_by', heatMap.heatmap
        .getColorScheme().getSizer().getSeriesName());
      colorSchemeFormBuilder.setEnabled('size_by_minimum',
        heatMap.heatmap.getColorScheme().getSizer()
          .getSeriesName() != null);
      colorSchemeFormBuilder.setEnabled('size_by_maximum',
        heatMap.heatmap.getColorScheme().getSizer()
          .getSeriesName() != null);

      if (!updatingSizer) {
        colorSchemeFormBuilder.setValue('size_by_minimum',
          heatMap.heatmap.getColorScheme().getSizer().getMin());
        colorSchemeFormBuilder.setValue('size_by_maximum',
          heatMap.heatmap.getColorScheme().getSizer().getMax());
      }
    }
  }

  colorSchemeChooser.on('change', function () {
    colorSchemeChooserUpdated();
    // repaint the heat map when color scheme changes
    heatMap.heatmap.setInvalid(true);
    heatMap.heatmap.repaint();
    colorSchemeChooser.restoreCurrentValue();
  });

  function createMetadataField(isColumns) {
    var options = [];
    var value = {};
    _.each(heatMap.getVisibleTrackNames(isColumns), function (name) {
      value[name] = true;
    });
    _.each(morpheus.MetadataUtil.getMetadataNames(isColumns ? heatMap
        .getProject().getFullDataset().getColumnMetadata() : heatMap
        .getProject().getFullDataset().getRowMetadata()),
      function (name) {
        options.push(name);
      });
    var field = {
      type: 'bootstrap-select',
      search: options.length > 10,
      name: isColumns ? 'column_annotations' : 'row_annotations',
      multiple: true,
      value: value,
      options: options,
      toggle: true
    };

    return field;
  }

  var annotationsBuilder = new morpheus.FormBuilder();
  annotationsBuilder.append(createMetadataField(false));
  annotationsBuilder.append(createMetadataField(true));

  function annotationsListener($select, isColumns) {
    var names = [];
    _.each(heatMap.getVisibleTrackNames(isColumns), function (name) {
      names.push(name);
    });
    var values = $select.val();
    var selectedNow = _.difference(values, names);
    var unselectedNow = _.difference(names, values);
    var tracks = [];
    _.each(selectedNow, function (name) {
      tracks.push({
        name: name,
        isColumns: isColumns,
        visible: true
      });
    });
    _.each(unselectedNow, function (name) {
      tracks.push({
        name: name,
        isColumns: isColumns,
        visible: false
      });
    });
    heatMap.setTrackVisibility(tracks);
    colorSchemeChooser.restoreCurrentValue();
  }

  var $ca = annotationsBuilder.$form.find('[name=column_annotations]');
  $ca.on('change', function (e) {
    annotationsListener($(this), true);
  });
  var $ra = annotationsBuilder.$form.find('[name=row_annotations]');
  $ra.on('change', function (e) {
    annotationsListener($(this), false);
  });
  var annotationOptionsTabId = _.uniqueId('morpheus');
  var heatMapOptionsTabId = _.uniqueId('morpheus');
  var displayOptionsTabId = _.uniqueId('morpheus');

  var $metadataDiv = $('<div class="tab-pane" id="' + annotationOptionsTabId
    + '"></div>');
  $metadataDiv.append($(annotationsBuilder.$form));
  var $heatMapDiv = $('<div class="tab-pane active" id="'
    + heatMapOptionsTabId + '"></div>');
  $heatMapDiv.append(colorSchemeChooser.$div);
  $heatMapDiv.append($(colorSchemeFormBuilder.$form));
  var $displayDiv = $('<div class="tab-pane" id="' + displayOptionsTabId
    + '"></div>');
  $displayDiv.append($(displayFormBuilder.$form));
  displayFormBuilder.setEnabled('grid_thickness', heatMap.heatmap.isDrawGrid());
  displayFormBuilder.setEnabled('grid_color', heatMap.heatmap.isDrawGrid());

  displayFormBuilder.$form.find('[name=show_grid]').on('click', function (e) {
    var grid = $(this).prop('checked');
    displayFormBuilder.setEnabled('grid_thickness', grid);
    displayFormBuilder.setEnabled('grid_color', grid);
    heatMap.heatmap.setDrawGrid(grid);
    heatMap.revalidate();
    colorSchemeChooser.restoreCurrentValue();
  });
  var $fractionDigits = displayFormBuilder.$form.find('[name=number_of_fraction_digits]');
  displayFormBuilder.$form.find('[name=show_values]').on('click', function (e) {
    var drawValues = $(this).prop('checked');
    heatMap.heatmap.setDrawValues(drawValues);
    // $fractionDigits.prop('disabled', !drawValues);
    heatMap.revalidate();
    colorSchemeChooser.restoreCurrentValue();
  });

  $fractionDigits.on(
    'keyup input', _.debounce(
      function () {
        var n = parseInt($(this)
          .val());
        if (n >= 0) {
          heatMap.heatmap.setDrawValuesFormat(morpheus.Util.createNumberFormat('.' + n + 'f'));
          heatMap.heatmap.setInvalid(true);
          heatMap.heatmap.repaint();
        }
      }, 100));

  displayFormBuilder.$form.find('[name=inline_tooltip]').on('click',
    function (e) {
      heatMap.options.inlineTooltip = $(this).prop('checked');
    });

  displayFormBuilder.$form.find('[name=grid_color]').on(
    'change',
    function (e) {
      var value = $(this).val();
      heatMap.heatmap.setGridColor(value);
      heatMap.heatmap.setInvalid(true);
      heatMap.heatmap.repaint();
    });

  displayFormBuilder.$form.find('[name=grid_thickness]').on(
    'keyup',
    _.debounce(function (e) {
      var value = parseFloat($(this).val());
      if (!isNaN(value)) {
        heatMap.heatmap.setGridThickness(value);
        heatMap.heatmap.setInvalid(true);
        heatMap.heatmap.repaint();
      }
    }, 100));

  displayFormBuilder.$form.find('[name=row_size]').on(
    'keyup',
    _.debounce(function (e) {
      var value = parseFloat($(this).val());
      if (!isNaN(value)) {
        heatMap.heatmap.getRowPositions().setSize(
          value);
        heatMap.revalidate();
        colorSchemeChooser.restoreCurrentValue();
      }

    }, 100));
  displayFormBuilder.$form.find('[name=info_window]').on('change',
    function (e) {
      heatMap.setTooltipMode(parseInt($(this).val()));
    });
  displayFormBuilder.find('link_rows_and_columns').on('click',
    function (e) {
      var checked = $(this).prop('checked');
      if (checked) {
        heatMap.getProject().setSymmetric(heatMap);
      } else {
        heatMap.getProject().setSymmetric(null);
      }
    });
  displayFormBuilder.find('show_row_number').on('click',
    function (e) {
      var checked = $(this).prop('checked');
      heatMap.setShowRowNumber(checked);
      heatMap.revalidate();
    });

  var $colorByValue = colorSchemeFormBuilder.$form
    .find('[name=color_by_value]');
  var separateSchemesField = heatMap.heatmap.getColorScheme()
    .getSeparateColorSchemeForRowMetadataField();
  if (separateSchemesField != null) {
    var v = heatMap.project.getFullDataset().getRowMetadata()
      .getByName(separateSchemesField);
    if (v != null) {
      $colorByValue.html(morpheus.Util.createOptions(morpheus.VectorUtil
        .createValueToIndexMap(
          v).keys()));
    }
  }

  if (separateSchemesField != null) {
    colorSchemeChooser.setCurrentValue($colorByValue.val());
  }
  if (heatMap.heatmap.getColorScheme().getSizer
    && heatMap.heatmap.getColorScheme().getSizer() != null
    && heatMap.heatmap.getColorScheme().getSizer().getSeriesName()) {
    colorSchemeFormBuilder.setValue('size_by', heatMap.heatmap
      .getColorScheme().getSizer().getSeriesName());
  }
  colorSchemeFormBuilder.$form.find('[name=size_by]')
    .on(
      'change',
      function (e) {
        var series = $(this).val();
        if (series == '(None)') {
          series = null;
        }
        colorSchemeChooser.colorScheme.getSizer()
          .setSeriesName(series);
        colorSchemeChooser.fireChanged();
      });
  colorSchemeFormBuilder.$form.find('[name=size_by_minimum]').on(
    'keyup',
    _.debounce(function (e) {
      updatingSizer = true;
      colorSchemeChooser.colorScheme.getSizer().setMin(
        parseFloat($(this).val()));
      colorSchemeChooser.fireChanged(true);
      updatingSizer = false;
    }, 100));
  colorSchemeFormBuilder.$form.find('[name=size_by_maximum]').on(
    'keyup',
    _.debounce(function (e) {
      updatingSizer = true;
      colorSchemeChooser.colorScheme.getSizer().setMax(
        parseFloat($(this).val()));
      colorSchemeChooser.fireChanged(true);
      updatingSizer = false;
    }, 100));
  colorSchemeFormBuilder.$form
    .find('[name=conditional_rendering]')
    .on(
      'click',
      function (e) {
        e.preventDefault();
        var conditionalRenderingUI = new morpheus.ConditionalRenderingUI(
          heatMap);
        morpheus.FormBuilder.showInModal({
          title: 'Conditional Rendering',
          html: conditionalRenderingUI.$div,
          close: 'Close',
          modalClass: 'morpheus-sub-modal'
        });
      });

  colorSchemeFormBuilder.find('save_color_scheme').on('click', function (e) {
    e.preventDefault();
    var blob = new Blob([JSON.stringify(heatMap.heatmap.getColorScheme().toJSON())], {
      type: 'application/json'
    });
    saveAs(blob, 'color_scheme.json');
  });
  colorSchemeFormBuilder.on('change', function (e) {
    if (e.name === 'load_color_scheme') {
      if (e.value !== '' && e.value != null) {
        morpheus.Util.getText(e.value).done(
          function (text) {
            var json = JSON.parse($.trim(text));
            heatMap.heatmap.getColorScheme().fromJSON(json);
            colorSchemeChooser
              .setColorScheme(heatMap.heatmap
                .getColorScheme());
            heatMap.heatmap.setInvalid(true);
            heatMap.heatmap.repaint();

          }).fail(function () {
          morpheus.FormBuilder.showInModal({
            title: 'Error',
            html: 'Unable to read saved color scheme.'
          });
        });

      }
    }
  });

  colorSchemeFormBuilder.$form
    .on(
      'change',
      '[name=load_predefined_scheme]',
      function (e) {
        var val = $(this).val();
        if (val !== '') {
          if (val === 'relative') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.AbstractColorSupplier.fromJSON(morpheus.HeatMapColorScheme.Predefined
                  .RELATIVE()));
          } else if (val === 'cn') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.AbstractColorSupplier.fromJSON(morpheus.HeatMapColorScheme.Predefined
                  .CN()));
          } else if (val === 'MAF') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.AbstractColorSupplier.fromJSON(morpheus.HeatMapColorScheme.Predefined
                  .MAF()));
          } else if (val === 'binary') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.AbstractColorSupplier.fromJSON(morpheus.HeatMapColorScheme.Predefined
                  .BINARY()));
          } else {
            console.log('not found');
          }
          colorSchemeChooser
            .setColorScheme(heatMap.heatmap
              .getColorScheme());
          heatMap.heatmap.setInvalid(true);
          heatMap.heatmap.repaint();
          $(this).val('');
        } else {
          console.log('empty option selected');
        }
        colorSchemeChooser.restoreCurrentValue();
      });
  colorSchemeFormBuilder.$form
    .find('[name=color_by]')
    .on(
      'change',
      function (e) {
        var colorByField = $(this).val();
        if (colorByField == '(None)') {
          colorByField = null;
        }
        var colorByValue = null;
        heatMap.heatmap.getColorScheme()
          .setSeparateColorSchemeForRowMetadataField(
            colorByField);
        if (colorByField != null) {
          $colorByValue
            .html(morpheus.Util
              .createOptions(morpheus.VectorUtil
                .createValueToIndexMap(
                  heatMap.project
                    .getFullDataset()
                    .getRowMetadata()
                    .getByName(
                      colorByField))
                .keys()));
          colorByValue = $colorByValue.val();
        } else {
          $colorByValue.html('');
        }

        heatMap.heatmap.getColorScheme().setCurrentValue(
          colorByValue);
        colorSchemeChooser.setCurrentValue(colorByValue);
        heatMap.heatmap.setInvalid(true);
        heatMap.heatmap.repaint();
        colorSchemeChooser.setColorScheme(heatMap.heatmap
          .getColorScheme());
      });
  $colorByValue.on('change', function (e) {
    if (heatMap.heatmap.getColorScheme()
        .getSeparateColorSchemeForRowMetadataField() == null) {
      colorSchemeChooser.setCurrentValue(null);
      heatMap.heatmap.getColorScheme().setCurrentValue(null);
      colorSchemeChooser.setColorScheme(heatMap.heatmap
        .getColorScheme());
    } else {
      colorSchemeChooser.setCurrentValue($colorByValue.val());
      colorSchemeChooser.setColorScheme(heatMap.heatmap
        .getColorScheme());
    }
  });
  displayFormBuilder.$form.find('[name=column_size]').on(
    'keyup',
    _.debounce(function (e) {
      heatMap.heatmap.getColumnPositions().setSize(
        parseFloat($(this).val()));
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();

    }, 100));
  displayFormBuilder.$form.find('[name=row_gap_size]').on('keyup',
    _.debounce(function (e) {
      heatMap.rowGapSize = parseFloat($(this).val());
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();
    }, 100));
  displayFormBuilder.$form.find('[name=column_gap_size]').on('keyup',
    _.debounce(function (e) {
      heatMap.columnGapSize = parseFloat($(this).val());
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();
    }, 100));
  displayFormBuilder.$form.find('[name=squish_factor]').on('keyup',
    _.debounce(function (e) {
      var f = parseFloat($(this).val());
      heatMap.heatmap.getColumnPositions().setSquishFactor(f);
      heatMap.heatmap.getRowPositions().setSquishFactor(f);
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();
    }, 100));
  displayFormBuilder.$form.find('[name=row_dendrogram_line_thickness]').on(
    'keyup', _.debounce(function (e) {
      heatMap.rowDendrogram.lineWidth = parseFloat($(this).val());
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();

    }, 100));
  displayFormBuilder.$form.find('[name=column_dendrogram_line_thickness]')
    .on(
      'keyup',
      _.debounce(function (e) {
        heatMap.columnDendrogram.lineWidth = parseFloat($(
          this).val());
        heatMap.revalidate();
        colorSchemeChooser.restoreCurrentValue();
      }, 100));
  var $tab = $('<div class="tab-content"></div>');
  $metadataDiv.appendTo($tab);
  $heatMapDiv.appendTo($tab);
  $displayDiv.appendTo($tab);
  var $div = $('<div></div>');
  var $ul = $('<ul class="nav nav-tabs" role="tablist">' + '<li><a href="#'
    + annotationOptionsTabId
    + '" role="tab" data-toggle="tab">Annotations</a></li>'
    + '<li><a href="#' + heatMapOptionsTabId
    + '" role="tab" data-toggle="tab">Color Scheme</a></li>'
    + '<li><a href="#' + displayOptionsTabId
    + '" role="tab" data-toggle="tab">Display</a></li>' + '</ul>');
  $ul.appendTo($div);
  $tab.appendTo($div);
  // set current scheme
  colorSchemeChooser.setColorScheme(heatMap.heatmap.getColorScheme());
  colorSchemeChooserUpdated();
  $ul.find('[role=tab]:eq(1)').tab('show');
  morpheus.FormBuilder.showInModal({
    title: 'Options',
    html: $div,
    close: 'Close',
    focus: heatMap.getFocusEl(),
    onClose: function () {
      $div.find('input').off('keyup');
      $ca.off('change');
      $ra.off('change');
      $div.remove();
      colorSchemeChooser.dispose();
    }
  });
};

morpheus.HeatMapSizer = function () {
  this.seriesName = null;
  this.sizeByScale = d3.scale.linear().domain([this.min, this.max])
  .range([0, 1]).clamp(true);
};
morpheus.HeatMapSizer.prototype = {
  min: 0,
  max: 1,
  copy: function () {
    var sizer = new morpheus.HeatMapSizer();
    sizer.seriesName = this.seriesName;
    sizer.min = this.min;
    sizer.max = this.max;
    sizer.sizeByScale = this.sizeByScale.copy();
    return sizer;
  },
  valueToFraction: function (value) {
    return this.sizeByScale(value);
  },
  setMin: function (min) {
    this.min = min;
    this.sizeByScale = d3.scale.linear().domain([this.min, this.max])
    .range([0, 1]).clamp(true);
  },
  setMax: function (max) {
    this.max = max;
    this.sizeByScale = d3.scale.linear().domain([this.min, this.max])
    .range([0, 1]).clamp(true);
  },
  getMin: function () {
    return this.min;
  },
  getMax: function () {
    return this.max;
  },
  getSeriesName: function () {
    return this.seriesName;
  },
  setSeriesName: function (name) {
    this.seriesName = name;
  }
};

morpheus.HeatMapToolBar = function (heatMap) {
  this.heatMap = heatMap;
  this.rowSearchResultModelIndices = [];
  this.columnSearchResultModelIndices = [];
  var _this = this;
  var layout = ['<div class="hidden-print">'];
  layout.push('<div data-name="toolbar"></div>');
  layout.push(
    '<div data-name="tip" style="white-space:nowrap; border-top: thin solid #e7e7e7;margin-bottom:2px;height: 14px; font-size: 10px;overflow:hidden;"></div>');
  layout.push('</div>');

  var $el = $(layout.join(''));
  var searchHtml = [];
  var $searchForm = $(
    '<form style="display:inline-block;margin-right:14px;" name="searchForm"' +
    ' class="form' +
    ' form-inline' +
    ' form-compact"' +
    ' role="search"></form>');
  $searchForm.on('submit', function (e) {
    e.preventDefault();
  });

  // toogle search buttons
  searchHtml.push('<div title="Toggle' +
    ' Search (' + morpheus.Util.COMMAND_KEY + '/)" class="btn-group"' +
    ' data-toggle="buttons">');
  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml.push(
    '<input data-search="rows" type="radio" autocomplete="off" name="searchToggle"' +
    ' type="button"> Rows');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml.push(
    '<input data-search="columns" type="radio" autocomplete="off" name="searchToggle"> Columns');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml.push(
    '<input data-search="values" type="radio" autocomplete="off" name="searchToggle">' +
    ' Values');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml.push(
    '<input data-search="rowDendrogram" type="radio" autocomplete="off"' +
    ' name="searchToggle"> Row Dendrogram');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml.push(
    '<input data-search="columnDendrogram" type="radio" autocomplete="off"' +
    ' name="searchToggle"> Column Dendrogram');
  searchHtml.push('</label>');
  searchHtml.push('</div>');

  function createSearchOptionsMenu() {
    searchHtml.push('<div style="display:inline-block;" class="dropdown">');
    searchHtml.push(
      '<button type="button" class="btn btn-default btn-xxs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"> <span class="fa fa-caret-down"></span></button>');
    searchHtml.push('<ul data-name="searchOptions" class="dropdown-menu">');
    searchHtml.push(
      '<li><a data-group="matchMode" data-name="exact" href="#"><span' +
      ' data-type="toggle"></span>Exact' +
      ' Match</a></li>');
    searchHtml.push(
      '<li><a data-group="matchMode" data-name="contains" href="#"><span' +
      ' data-type="toggle"' +
      ' class="dropdown-checkbox fa fa-check"></span>Contains</a></li>');
    searchHtml.push('<li role="separator" class="divider"></li>');

    searchHtml.push(
      '<li><a data-group="searchMode" data-name="matchAny" href="#"><span' +
      ' data-type="toggle"' +
      ' class="dropdown-checkbox fa fa-check"></span>Match Any Search Term</a></li>');

    searchHtml.push(
      '<li><a data-group="searchMode" data-name="matchAll" href="#"><span' +
      ' data-type="toggle"></span>Match All Search Terms</a></li>');

    searchHtml.push('<li role="separator" class="divider"></li>');
    searchHtml.push('<li><a data-name="searchHelp" href="#">Help</a></li>');
    searchHtml.push('</ul>');
    searchHtml.push('</div>');
  }

  function createSearchMenu(dataName, navigation) {
    searchHtml.push(
      '<div style="display:inline-block;" data-name="' + dataName + '">');
    searchHtml.push('<div class="form-group">');
    searchHtml.push(
      '<input type="text" class="form-control input-sm" autocomplete="off"' +
      ' name="search">');
    searchHtml.push('</div>');
    searchHtml.push('<div class="form-group">');
    searchHtml.push(
      '<span data-name="searchResultsWrapper" style="display:none;">');
    searchHtml.push(
      '<span style="font-size:12px;" data-name="searchResults"></span>');
    if (navigation) {
      searchHtml.push(
        '<button name="previousMatch" type="button" class="btn btn-default btn-xxs" data-toggle="tooltip" title="Previous"><i class="fa fa-chevron-up"></i></button>');
      searchHtml.push(
        '<button name="nextMatch" type="button" class="btn btn-default btn-xxs" data-toggle="tooltip" title="Next"><i class="fa fa-chevron-down"></i></button>');
      searchHtml.push(
        '<button name="matchesToTop" type="button" class="btn btn-default btn-xxs" data-toggle="tooltip" title="Matches To Top"><i class="fa fa-level-up"></i></button>');
    }
    searchHtml.push('</span>');
    searchHtml.push('</div>');
    searchHtml.push('</div>');
    searchHtml.push('</div>');
  }

  if (heatMap.options.toolbar.searchRows ||
    heatMap.options.toolbar.searchColumns ||
    heatMap.options.toolbar.searchValues) {
    createSearchOptionsMenu();
  }
  if (heatMap.options.toolbar.searchRows) {
    createSearchMenu('searchRowsGroup', true);
  }
  if (heatMap.options.toolbar.searchColumns) {
    createSearchMenu('searchColumnsGroup', true);
  }

  if (heatMap.options.toolbar.searchValues) {
    createSearchMenu('searchValuesGroup', false);
  }
  createSearchMenu('searchRowDendrogramGroup', false);
  createSearchMenu('searchColumnDendrogramGroup', false);

  // dimensions
  if (heatMap.options.toolbar.dimensions) {
    searchHtml.push('<div class="form-group">');
    searchHtml.push(
      '<h6 style="display: inline; margin-left:10px;" data-name="dim"></h6>');
    searchHtml.push(
      '<h6 style="display: inline; margin-left:10px;" data-name="selection"></h6>');
    searchHtml.push('</div>');
  }

  var $menus = $(
    '<div style="display: inline-block;margin-right:14px;"></div>');

  function createMenu(menuName, actions, minWidth) {
    if (!minWidth) {
      minWidth = '0px';
    }
    var menu = [];
    var dropdownId = _.uniqueId('morpheus');
    menu.push('<div class="dropdown morpheus-menu">');
    menu.push(
      '<a class="dropdown-toggle morpheus-black-link morpheus-black-link-background" type="button"' +
      ' id="' + dropdownId +
      '" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">');
    menu.push(menuName);

    menu.push('</a>');
    menu.push('<ul style="min-width:' + minWidth +
      ';" class="dropdown-menu" aria-labelledby="' + dropdownId + '">');
    actions.forEach(function (name) {
      if (name == null) {
        menu.push('<li role="separator" class="divider"></li>');
      } else {
        var action = heatMap.getActionManager().getAction(name);
        if (action != null) {
          menu.push('<li>');
          menu.push(
            '<a class="morpheus-menu-item" data-action="' + action.name +
            '" href="#">');
          menu.push(action.name);
          if (action.ellipsis) {
            menu.push('...');
          }
          if (action.icon) {
            menu.push('<span class="' + action.icon +
              ' morpheus-menu-item-icon"></span> ');
          }
          if (action.which) {
            menu.push('<span class="pull-right">');
            if (action.commandKey) {
              menu.push(morpheus.Util.COMMAND_KEY);
            }
            if (action.shiftKey) {
              menu.push('Shift+');
            }
            menu.push(morpheus.KeyboardCharMap[action.which[0]]);
            menu.push('</span>');
          }

          menu.push('</a>');
          menu.push('</li>');
        }
      }
    });

    menu.push('</ul>');
    menu.push('</div>');
    $(menu.join('')).appendTo($menus);
  }

  if (heatMap.options.menu) {
    if (heatMap.options.menu.File) {
      createMenu('File', heatMap.options.menu.File, '240px');
    }
    if (heatMap.options.menu.View) {
      createMenu('Edit', heatMap.options.menu.Edit);
    }
    if (heatMap.options.menu.View) {
      createMenu('View', heatMap.options.menu.View, '170px');
    }
    if (heatMap.options.menu.Tools) {
      createMenu('Tools', heatMap.options.menu.Tools);
    }
    if (heatMap.options.menu.Help) {
      createMenu('Help', heatMap.options.menu.Help, '220px');
    }
  }

  $(searchHtml.join('')).appendTo($searchForm);
  var $lineOneColumn = $el.find('[data-name=toolbar]');

  $menus.appendTo($lineOneColumn);
  $searchForm.appendTo($lineOneColumn);
  var toolbarHtml = ['<div style="display: inline;">'];
  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  // zoom
  if (heatMap.options.toolbar.zoom) {

    var dropdownId = _.uniqueId('morpheus');
    toolbarHtml.push('<div style="display:inline-block;" class="dropdown">');
    toolbarHtml.push(
      '<a class="dropdown-toggle morpheus-black-link" type="button" id="' +
      dropdownId +
      '" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">');
    // toolbarHtml.push('<input style="width:2em;height:21px;" id="' + dropdownId + '" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">');
    toolbarHtml.push('<button type="button"' +
      ' class="btn btn-default btn-xxs"><span class="fa' +
      ' fa-search-plus"></span>');
    toolbarHtml.push(
      ' <span style="font-size: .8em;" class="fa fa-caret-down"></span>');
    toolbarHtml.push('</button>');
    toolbarHtml.push(
      '<ul style="width:200px;" class="dropdown-menu" aria-labelledby="' + dropdownId + '">');
    toolbarHtml.push(
      '<li><a class="morpheus-menu-item" href="#" data-action="Zoom In">Zoom In<span class="pull-right">+</span></a></li>');
    toolbarHtml.push(
      '<li><a class="morpheus-menu-item" href="#" data-action="Zoom Out">Zoom' +
      ' Out<span class="pull-right">-</span></a></li>');
    toolbarHtml.push('<li role="separator" class="divider"></li>');
    toolbarHtml.push(
      '<li><a class="morpheus-menu-item" href="#" data-action="Fit To Window">Fit To Window<span' +
      ' class="fa' +
      ' fa-compress morpheus-menu-item-icon"></span><span class="pull-right">' +
      morpheus.Util.COMMAND_KEY +
      morpheus.KeyboardCharMap[heatMap.getActionManager().getAction('Fit To Window').which[0]] + '</span> </a></li>');
    toolbarHtml.push(
      '<li><a class="morpheus-menu-item" href="#" data-action="Fit Rows To Window">Fit Rows To Window</a></li>');
    toolbarHtml.push(
      '<li><a class="morpheus-menu-item" href="#" data-action="Fit Columns To Window">Fit Columns To Window</a></li>');
    toolbarHtml.push('<li role="separator" class="divider"></li>');
    toolbarHtml.push(
      '<li><a class="morpheus-menu-item" href="#" data-action="100%">100%</a></li>');
    toolbarHtml.push('</ul>');
    toolbarHtml.push('</div>');
  }
  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  if (heatMap.options.toolbar.sort) {
    toolbarHtml.push(
      '<button data-toggle="tooltip" title="Sort" name="Sort" type="button" class="btn' +
      ' btn-default btn-xxs"><span class="fa fa-sort-alpha-asc"></span></button>');
  }
  if (heatMap.options.toolbar.options) {
    toolbarHtml.push(
      '<button data-action="Options" data-toggle="tooltip" title="Options" type="button"' +
      ' class="btn btn-default btn-xxs"><span class="fa fa-cog"></span></button>');

  }

  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  if (heatMap.options.toolbar.openFile) {
    toolbarHtml.push(
      '<button data-action="Open File" data-toggle="tooltip" title="Open File ('
      + morpheus.Util.COMMAND_KEY
      +
      'O)" type="button" class="btn btn-default btn-xxs"><span class="fa fa-folder-open-o"></span></button>');
  }
  if (heatMap.options.toolbar.saveImage) {
    toolbarHtml.push(
      '<button data-action="Save Image" data-toggle="tooltip" title="Save Image ('
      + morpheus.Util.COMMAND_KEY
      +
      'S)" type="button" class="btn btn-default btn-xxs"><span class="fa fa-file-image-o"></span></button>');
  }
  if (heatMap.options.toolbar.saveDataset) {
    toolbarHtml.push(
      '<button data-action="Save Dataset" data-toggle="tooltip" title="Save Dataset ('
      + morpheus.Util.COMMAND_KEY
      +
      'Shift+S)" type="button" class="btn btn-default btn-xxs"><span class="fa fa-floppy-o"></span></button>');
  }
  if (heatMap.options.toolbar.saveSession) {
    toolbarHtml.push(
      '<button data-action="Save Session" data-toggle="tooltip" title="Save Session" type="button"' +
      ' class="btn btn-default btn-xxs"><span class="fa fa-anchor"></span></button>');
  }

  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  if (heatMap.options.toolbar.filter) {
    toolbarHtml.push(
      '<button data-action="Filter" data-toggle="tooltip" title="Filter" type="button"' +
      ' class="btn btn-default btn-xxs"><span class="fa fa-filter"></span></button>');
  }
  if (heatMap.options.toolbar.chart && typeof echarts !== 'undefined') {
    toolbarHtml.push(
      '<button data-action="Chart" data-toggle="tooltip" title="Chart" type="button" class="btn' +
      ' btn-default btn-xxs"><span class="fa fa-line-chart"></span></button>');

  }
  // legend
  if (heatMap.options.toolbar.colorKey) {
    toolbarHtml.push('<div class="morpheus-button-divider"></div>');
    toolbarHtml.push('<div class="btn-group">');
    toolbarHtml.push(
      '<button type="button" class="btn btn-default btn-xxs" data-toggle="dropdown"><span title="Color Key" data-toggle="tooltip" class="fa fa-key"></span></button>');
    toolbarHtml.push('<ul data-name="key" class="dropdown-menu" role="menu">');
    toolbarHtml.push('<li data-name="keyContent"></li>');
    toolbarHtml.push('</ul>');
    toolbarHtml.push('</div>');
  }
  toolbarHtml.push('</div>');
  var $toolbar = $(toolbarHtml.join(''));

  $toolbar.find('[data-action]').on('click', function (e) {
    e.preventDefault();
    heatMap.getActionManager().execute($(this).data('action'));
  }).on('blur', function (e) {
    if (document.activeElement === document.body) {
      heatMap.focus();
    }
  });
  $menus.on('click', 'li > a', function (e) {
    e.preventDefault();
    heatMap.getActionManager().execute($(this).data('action'));
  }).on('blur', function (e) {
    if (document.activeElement === document.body) {
      heatMap.focus();
    }
  });
  if (heatMap.options.toolbar.$customButtons) {
    heatMap.options.toolbar.$customButtons.appendTo($toolbar);
  }
  $toolbar.appendTo($lineOneColumn);
  // $hide.appendTo($el.find('[data-name=toggleEl]'));
  $el.prependTo(heatMap.$content);
  this.$tip = $el.find('[data-name=tip]');

  $el.find('[data-toggle="tooltip"]').tooltip({
    placement: 'bottom',
    container: 'body',
    trigger: 'hover'
  }).on('click', function () {
    $(this).tooltip('hide');
  });
  var $key = $el.find('[data-name=key]');
  var $keyContent = $el.find('[data-name=keyContent]');
  $key.dropdown().parent().on('show.bs.dropdown', function () {
    new morpheus.HeatMapColorSchemeLegend(heatMap, $keyContent);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'colorKey'
    });
  });

  var searchHelpHtml = [];
  searchHelpHtml.push('<h4>Symbols</h4>');
  searchHelpHtml.push('<table class="table table-bordered">');
  searchHelpHtml.push('<tr><th>Term</th><th>Description</th></tr>');
  searchHelpHtml.push(
    '<tr><td><code><strong>*</strong></code></td><td>Quote a search term for an' +
    ' exact' +
    ' match. <br' +
    ' />Example: <code><strong>"root beer"</strong></code></td></tr>');

  searchHelpHtml.push(
    '<tr><td><code><strong>-</strong></code></td><td>Exclude matches using -' +
    ' modifier.</td></tr>');
  searchHelpHtml.push(
    '<tr><td><code><strong>..</strong></code></td><td>Separate numbers by two' +
    ' periods' +
    ' without spaces to' +
    ' see numbers that fall within a range.. <br' +
    ' />Example: <code><strong>1..10</strong></code></td></tr>');
  searchHelpHtml.push(
    '<tr><td><code><strong><= < > >= =</strong></code></td><td>Perform a' +
    ' numeric' +
    ' search.' +
    ' <br' +
    ' />Example: <code><strong>>4</strong></code></td></tr>');
  searchHelpHtml.push('</table>');
  searchHelpHtml.push('<h4>Search fields</h4>');
  searchHelpHtml.push(
    '<p>You can restrict your search to any field by typing the field name followed by a colon ":" and then the term you are looking for. For example, to search for matches containing "beer" in the beverage field, you can enter:' +
    ' <code><strong>beverage:beer</strong></code>');
  searchHelpHtml.push(
    'Note that searches only include metadata fields that are displayed. You' +
    ' can search a hidden field by performing a field search.');

  // searchHelpHtml.push('<br />Note: The field is only valid for the term that it directly' +
  // 	' precedes.');
  searchHelpHtml.push(
    '<p>You can search for an exact list of values by enclosing the list of' +
    ' values in parentheses. For example: <code><strong>pet:(cat dog)</strong></code>' +
    ' searches all pets that are either cats or dogs.</p>');
  var $searchHelp = $(searchHelpHtml.join(''));
  $el.find('[data-name=searchHelp]').on('click', function (e) {
    e.preventDefault();
    morpheus.FormBuilder.showInModal({
      title: 'Search Help',
      html: $searchHelp,
      appendTo: heatMap.getContentEl(),
      focus: heatMap.getFocusEl()
    });
  });
  var $searchRowsGroup = $searchForm.find('[data-name=searchRowsGroup]');
  var $searchColumnsGroup = $searchForm.find('[data-name=searchColumnsGroup]');
  var $searchValuesGroup = $searchForm.find('[data-name=searchValuesGroup]');
  var $searchRowDendrogramGroup = $searchForm.find(
    '[data-name=searchRowDendrogramGroup]');
  var $searchColumnDendrogramGroup = $searchForm.find(
    '[data-name=searchColumnDendrogramGroup]');

  this.$searchRowDendrogramGroup = $searchRowDendrogramGroup;
  this.$searchColumnDendrogramGroup = $searchColumnDendrogramGroup;
  this.matchMode = 'contains';
  this.matchAllPredicates = false;
  var $searchToggle = $searchForm.find('[name=searchToggle]'); // buttons
  var nameToSearchObject = {};

  function getSearchElements($group, searchName, cb) {
    var obj = {
      $group: $group,
      $search: $group.find('[name=search]'),
      $searchResultsWrapper: $group.find('[data-name=searchResultsWrapper]'),
      $searchResults: $group.find('[data-name=searchResults]'),
      $previousMatch: $group.find('[name=previousMatch]'),
      $nextMatch: $group.find('[name=nextMatch]'),
      $matchesToTop: $group.find('[name=matchesToTop]'),
      $toggleButton: $searchToggle.filter('[data-search=' + searchName + ']').parent()
    };

    nameToSearchObject[searchName] = obj;
    return obj;
  }

  var $searchOptions = $el.find('[data-name=searchOptions]');
  $searchOptions.on('click', 'li > a', function (e) {
    e.preventDefault();
    var $this = $(this);
    var group = $this.data('group');
    if (group === 'matchMode') {
      _this.matchMode = $this.data('name');
    } else {
      _this.matchAllPredicates = $this.data('name') === 'matchAll';
    }

    var $searchField;
    if (_this.rowSearchObject.$search.is(':visible')) {
      $searchField = _this.rowSearchObject.$search;
    } else if (_this.columnSearchObject.$search.is(':visible')) {
      $searchField = _this.rowSearchObject.$search;
    } else if (_this.rowDendrogramSearchObject.$search.is(':visible')) {
      $searchField = _this.rowSearchObject.$search;
    } else if (_this.columnDendrogramSearchObject.$search.is(':visible')) {
      $searchField = _this.rowSearchObject.$search;
    } else if (_this.valueSearchObject.$search.is(':visible')) {
      $searchField = _this.rowSearchObject.$search;
    }
    if ($searchField) {
      $searchField.trigger($.Event('keyup', {
        keyCode: 13,
        which: 13
      }));
      // trigger search again
    }

    var $span = $(this).find('span');
    if ($span.data('type') === 'toggle') {
      $searchOptions.find('[data-group=' + group + '] > [data-type=toggle]').removeClass('dropdown-checkbox' +
        ' fa' +
        ' fa-check');
      $span.addClass('dropdown-checkbox fa fa-check');
    }
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchMatchMode'
    });
  });
  this.rowSearchObject = getSearchElements($searchRowsGroup, 'rows',
    function () {
      _this.search(true);
    });
  this.columnSearchObject = getSearchElements($searchColumnsGroup, 'columns',
    function () {
      _this.search(false);
    });
  this.rowDendrogramSearchObject = getSearchElements($searchRowDendrogramGroup,
    'rowDendrogram', function () {
      _this.searchDendrogram(false);
    });
  this.columnDendrogramSearchObject = getSearchElements(
    $searchColumnDendrogramGroup, 'columnDendrogram', function () {
      _this.searchDendrogram(false);
    });
  this.valueSearchObject = getSearchElements($searchValuesGroup, 'values',
    function () {
      searchValues();
    });

  // set button and search controls visibility
  if (!heatMap.options.toolbar.searchRows) {
    this.rowSearchObject.$toggleButton.hide();
    this.rowSearchObject.$group.css('display', 'none');
  }

  if (!heatMap.options.toolbar.searchColumns) {
    this.columnSearchObject.$toggleButton.hide();
    this.columnSearchObject.$group.css('display', 'none');
  }
  if (!heatMap.options.toolbar.searchValues) {
    this.valueSearchObject.$toggleButton.hide();
    this.valueSearchObject.$group.css('display', 'none');
  }
  this.rowDendrogramSearchObject.$toggleButton.hide();
  this.rowDendrogramSearchObject.$group.hide();

  this.columnDendrogramSearchObject.$toggleButton.hide();
  this.columnDendrogramSearchObject.$group.hide();

  this.rowDendrogramSearchObject.$searchResultsWrapper.show();
  this.columnDendrogramSearchObject.$searchResultsWrapper.show();
  this.valueSearchObject.$searchResultsWrapper.show();

  this.rowSearchObject.$search.css({
    'border-top': '3.8px solid #e6e6e6',
    'border-bottom': '3.8px solid #e6e6e6',
    width: '240px'
  });

  this.columnSearchObject.$search.css({
    'border-right': '3.8px solid #e6e6e6',
    'border-left': '3.8px solid #e6e6e6',
    width: '240px'
  });

  this.$valueSearchResults = $searchValuesGroup.find('[name=searchResults]');
  this.$valueTextField = $searchValuesGroup.find('[name=search]');
  this.$dimensionsLabel = $el.find('[data-name=dim]');
  this.$selectionLabel = $el.find('[data-name=selection]');

  $searchToggle.on('change', function (e) {
    var search = $(this).data('search');
    for (var name in nameToSearchObject) {
      var searchObject = nameToSearchObject[name];
      if (name === search) {
        searchObject.$group.css('display', 'inline-block');
        searchObject.$search.focus();
      } else {
        searchObject.$group.css('display', 'none');
      }
    }
  });

  this.toggleSearch = function () {
    var $visible = $searchToggle.filter(':visible');
    var $checked = $searchToggle.filter(':checked');
    var $next = $visible.eq($visible.index($checked) + 1);
    if (!$next.length) {
      $next = $visible.first();
    }
    $next.click();
  };

  for (var i = 0; i < $searchToggle.length; i++) {
    var $button = $($searchToggle[i]);
    if ($button.parent().css('display') === 'block') {
      $button.click();
      break;
    }
  }

  heatMap.on('dendrogramAnnotated', function (e) {
    if (e.isColumns) { // show buttons
      _this.rowDendrogramSearchObject.$toggleButton.show();
    } else {
      _this.columnDendrogramSearchObject.$toggleButton.show();
    }
  });
  heatMap.on('dendrogramChanged', function (e) {
    if (e.isColumns) {
      _this.rowDendrogramSearchObject.$group.hide();
      _this.rowDendrogramSearchObject.$toggleButton.hide();
    } else {
      _this.columnDendrogramSearchObject.$group.hide();
      _this.columnDendrogramSearchObject.$toggleButton.hide();
    }
  });
  var project = heatMap.getProject();

  morpheus.Util.autosuggest({
    $el: this.rowSearchObject.$search,
    filter: function (terms, cb) {
      var indices = [];
      var meta = project.getSortedFilteredDataset().getRowMetadata();
      heatMap.getVisibleTrackNames(false).forEach(function (name) {
        var index = morpheus.MetadataUtil.indexOf(meta, name);
        if (index !== -1) {
          indices.push(index);
        }
      });
      meta = new morpheus.MetadataModelColumnView(meta, indices);
      morpheus.MetadataUtil.autocomplete(meta)(terms, cb);
    },
    select: function () {
      _this.search(true);
    }
  });

  this.rowSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.search(true);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchRows'
    });
  }, 500));
  morpheus.Util.autosuggest({
    $el: this.columnSearchObject.$search,
    filter: function (terms, cb) {
      var indices = [];
      var meta = project.getSortedFilteredDataset().getColumnMetadata();
      heatMap.getVisibleTrackNames(true).forEach(function (name) {
        var index = morpheus.MetadataUtil.indexOf(meta, name);
        if (index !== -1) {
          indices.push(index);
        }
      });
      meta = new morpheus.MetadataModelColumnView(meta, indices);
      morpheus.MetadataUtil.autocomplete(meta)(terms, cb);
    },
    select: function () {
      _this.search(false);
    }
  });
  this.columnSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.search(false);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchColumns'
    });
  }, 500));

  // dendrogram search

  morpheus.Util.autosuggest({
    $el: this.rowDendrogramSearchObject.$search,
    filter: function (tokens, cb) {
      var d = heatMap.getDendrogram(false);
      if (!d.searchTerms) {
        cb([]);
      } else {
        var token = tokens != null && tokens.length > 0
          ? tokens[tokens.selectionStartIndex]
          : '';
        token = $.trim(token);
        if (token === '') {
          cb([]);
        } else {
          morpheus.Util.autocompleteArrayMatcher(token, cb, d.searchTerms, null,
            10);
        }
      }
    },
    select: function () {
      _this.searchDendrogram(false);
    }
  });

  this.rowDendrogramSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.searchDendrogram(false);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchRowDendrogram'
    });
  }, 500));

  morpheus.Util.autosuggest({
    $el: this.columnDendrogramSearchObject.$search,
    filter: function (tokens, cb) {
      var d = heatMap.getDendrogram(true);
      if (!d.searchTerms) {
        cb([]);
      } else {
        var token = tokens != null && tokens.length > 0
          ? tokens[tokens.selectionStartIndex]
          : '';
        token = $.trim(token);
        if (token === '') {
          cb([]);
        } else {
          morpheus.Util.autocompleteArrayMatcher(token, cb, d.searchTerms, null,
            10);
        }
      }
    },
    select: function () {
      _this.searchDendrogram(true);
    }
  });

  this.columnDendrogramSearchObject.$search.on('keyup',
    _.debounce(function (e) {
      if (e.which === 13) {
        e.preventDefault();
      }
      _this.searchDendrogram(true);
      morpheus.Util.trackEvent({
        eventCategory: 'ToolBar',
        eventAction: 'searchColumnDendrogram'
      });
    }, 500));

  function searchValues() {
    var $searchResultsLabel = _this.$valueSearchResults;
    var text = $.trim(_this.$valueTextField.val());
    if (text === '') {
      $searchResultsLabel.html('');
      project.getElementSelectionModel().setViewIndices(null);
    } else {
      var viewIndices = morpheus.DatasetUtil.searchValues({
        dataset: project.getSortedFilteredDataset(),
        text: text,
        matchAllPredicates: _this.matchAllPredicates,
        defaultMatchMode: _this.matchMode
      });

      project.getElementSelectionModel().setViewIndices(viewIndices);
      $searchResultsLabel.html(viewIndices.size() + ' match'
        + (viewIndices.size() === 1 ? '' : 'es'));
    }
  }

  morpheus.Util.autosuggest({
    $el: this.$valueTextField,
    filter: function (terms, cb) {
      morpheus.DatasetUtil.autocompleteValues(
        project.getSortedFilteredDataset())(terms, cb);
    },
    select: function () {
      searchValues();
    }
  });

  this.$valueTextField.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      _this.$valueTextField.autocomplete('close');
      e.preventDefault();
    }
    searchValues();
  }, 500));

  this.toggleControls = function () {
    if ($lineOneColumn.css('display') === 'none') {
      $lineOneColumn.css('display', '');
      _this.rowSearchObject.$search.focus();
    } else {
      $lineOneColumn.css('display', 'none');
      $(_this.heatMap.heatmap.canvas).focus();
    }
  };
  this.$el = $el;
  var updateFilterStatus = function () {
    if (heatMap.getProject().getRowFilter().isEnabled()
      || heatMap.getProject().getColumnFilter().isEnabled()) {
      _this.$el.find('[name=filterButton]').addClass('btn-primary');
    } else {
      _this.$el.find('[name=filterButton]').removeClass('btn-primary');
    }

  };
  updateFilterStatus();

  this.columnSearchObject.$matchesToTop.on(
    'click',
    function (e) {
      e.preventDefault();
      var $this = $(this);
      $this.toggleClass('btn-primary');
      _this.setSelectionOnTop({
        isColumns: true,
        isOnTop: $this.hasClass('btn-primary'),
        updateButtonStatus: false
      });
      morpheus.Util.trackEvent({
        eventCategory: 'ToolBar',
        eventAction: 'columnMatchesToTop'
      });
    });
  this.rowSearchObject.$matchesToTop.on(
    'click',
    function (e) {
      e.preventDefault();
      var $this = $(this);
      $this.toggleClass('btn-primary');
      _this.setSelectionOnTop({
        isColumns: false,
        isOnTop: $this.hasClass('btn-primary'),
        updateButtonStatus: false
      });
      morpheus.Util.trackEvent({
        eventCategory: 'ToolBar',
        eventAction: 'rowMatchesToTop'
      });
    });
  project.on('rowSortOrderChanged.morpheus', function (e) {
    if (_this.searching) {
      return;
    }
    _this._updateSearchIndices(false);
    _this.rowSearchObject.$matchesToTop.removeClass('btn-primary');
  });

  project.on('columnSortOrderChanged.morpheus', function (e) {
    if (_this.searching) {
      return;
    }
    _this._updateSearchIndices(true);
    _this.columnSearchObject.$matchesToTop.removeClass('btn-primary');
  });

  heatMap.getProject().on('rowFilterChanged.morpheus', function (e) {
    _this.search(true);
    updateFilterStatus();
  });
  heatMap.getProject().on('columnFilterChanged.morpheus', function (e) {
    _this.search(false);
    updateFilterStatus();
  });
  heatMap.getProject().on('datasetChanged.morpheus', function () {
    _this.search(true);
    _this.search(false);
    updateFilterStatus();
  });
  heatMap.getProject().getRowSelectionModel().on(
    'selectionChanged.morpheus', function () {
      _this.updateSelectionLabel();
    });
  heatMap.getProject().getColumnSelectionModel().on(
    'selectionChanged.morpheus', function () {
      _this.updateSelectionLabel();
    });
  this.rowSearchResultViewIndicesSorted = null;
  this.currentRowSearchIndex = 0;
  this.columnSearchResultViewIndicesSorted = null;
  this.currentColumnSearchIndex = -1;
  this.columnSearchObject.$previousMatch.on(
    'click',
    function () {
      _this.currentColumnSearchIndex--;
      if (_this.currentColumnSearchIndex < 0) {
        _this.currentColumnSearchIndex = _this.columnSearchResultViewIndicesSorted.length -
          1;
      }
      heatMap.scrollLeft(
        heatMap.getHeatMapElementComponent().getColumnPositions().getPosition(
          _this.columnSearchResultViewIndicesSorted[_this.currentColumnSearchIndex]));
      morpheus.Util.trackEvent({
        eventCategory: 'ToolBar',
        eventAction: 'previousColumnMatch'
      });
    });
  this.rowSearchObject.$previousMatch.on(
    'click',
    function () {
      _this.currentRowSearchIndex--;
      if (_this.currentRowSearchIndex < 0) {
        _this.currentRowSearchIndex = _this.rowSearchResultViewIndicesSorted.length -
          1;
      }
      heatMap.scrollTop(
        heatMap.getHeatMapElementComponent().getRowPositions().getPosition(
          _this.rowSearchResultViewIndicesSorted[_this.currentRowSearchIndex]));
      morpheus.Util.trackEvent({
        eventCategory: 'ToolBar',
        eventAction: 'previousRowMatch'
      });
    });
  this.columnSearchObject.$nextMatch.on('click', function () {
    _this.next(true);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'nextColumnMatch'
    });

  });
  this.rowSearchObject.$nextMatch.on('click', function () {
    _this.next(false);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'nextRowMatch'
    });
  });
  this.updateDimensionsLabel();
  this.updateSelectionLabel();
}
;
morpheus.HeatMapToolBar.HIGHLIGHT_SEARCH_MODE = 0;
morpheus.HeatMapToolBar.FILTER_SEARCH_MODE = 1;
morpheus.HeatMapToolBar.MATCHES_TO_TOP_SEARCH_MODE = 2;
morpheus.HeatMapToolBar.SELECT_MATCHES_SEARCH_MODE = 3;
morpheus.HeatMapToolBar.prototype = {
  quickColumnFilter: false,
  searching: false,
  rowSearchMode: morpheus.HeatMapToolBar.SELECT_MATCHES_SEARCH_MODE,
  columnSearchMode: morpheus.HeatMapToolBar.SELECT_MATCHES_SEARCH_MODE,
  _updateSearchIndices: function (isColumns) {
    var project = this.heatMap.getProject();
    if (isColumns) {
      var viewIndices = [];
      var modelIndices = this.columnSearchResultModelIndices;
      for (var i = 0, length = modelIndices.length; i < length; i++) {
        var index = project.convertModelColumnIndexToView(modelIndices[i]);
        if (index !== -1) {
          viewIndices.push(index);
        }
      }
      viewIndices.sort(function (a, b) {
        return a < b ? -1 : 1;
      });
      this.columnSearchResultViewIndicesSorted = viewIndices;
      this.currentColumnSearchIndex = -1;
    } else {
      var viewIndices = [];
      var modelIndices = this.rowSearchResultModelIndices;
      for (var i = 0, length = modelIndices.length; i < length; i++) {
        var index = project.convertModelRowIndexToView(modelIndices[i]);
        if (index !== -1) {
          viewIndices.push(index);
        }
      }
      viewIndices.sort(function (a, b) {
        return a < b ? -1 : 1;
      });
      this.rowSearchResultViewIndicesSorted = viewIndices;
      this.currentRowSearchIndex = -1;
    }
  },
  next: function (isColumns) {
    var heatMap = this.heatMap;
    if (isColumns) {
      this.currentColumnSearchIndex++;
      if (this.currentColumnSearchIndex >=
        this.columnSearchResultViewIndicesSorted.length) {
        this.currentColumnSearchIndex = 0;
      }
      heatMap.scrollLeft(
        heatMap.getHeatMapElementComponent().getColumnPositions().getPosition(
          this.columnSearchResultViewIndicesSorted[this.currentColumnSearchIndex]));
    } else {
      this.currentRowSearchIndex++;
      if (this.currentRowSearchIndex >=
        this.rowSearchResultViewIndicesSorted.length) {
        this.currentRowSearchIndex = 0;
      }
      heatMap.scrollTop(
        heatMap.getHeatMapElementComponent().getRowPositions().getPosition(
          this.rowSearchResultViewIndicesSorted[this.currentRowSearchIndex]));
    }
  },
  getSearchField: function (type) {
    if (type === morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD) {
      return this.columnSearchObject.$search;
    } else if (type === morpheus.HeatMapToolBar.ROW_SEARCH_FIELD) {
      return this.rowSearchObject.$search;
    } else if (type ===
      morpheus.HeatMapToolBar.COLUMN_DENDROGRAM_SEARCH_FIELD) {
      return this.columnDendrogramSearchObject.$search;
    } else if (type === morpheus.HeatMapToolBar.ROW_DENDROGRAM_SEARCH_FIELD) {
      return this.rowDendrogramSearchObject.$search;
    }
  },
  setSearchText: function (options) {
    var $tf = options.isColumns ? this.columnSearchObject.$search
      : this.rowSearchObject.$search;
    var existing = options.append ? $.trim($tf.val()) : '';
    if (existing !== '') {
      existing += ' ';
    }
    if (options.onTop) {
      options.isColumns ? this.columnSearchObject.$matchesToTop.addClass(
        'btn-primary') : this.rowSearchObject.$matchesToTop.addClass(
        'btn-primary');

    }
    $tf.val(existing + options.text);
    this.search(!options.isColumns);
    if (options.scrollTo) {
      this.next(options.isColumns);
      // click next
    }
  },
  updateDimensionsLabel: function () {
    var p = this.heatMap.getProject();
    var d = p.getFullDataset();
    var f = p.getSortedFilteredDataset();
    var text = [];

    if (f.getRowCount() !== d.getRowCount()) {
      text.push('<b>');
      text.push(morpheus.Util.intFormat(f.getRowCount()));
      text.push('/');
      text.push(morpheus.Util.intFormat(d.getRowCount()));
      text.push('</b>');
    } else {
      text.push(morpheus.Util.intFormat(f.getRowCount()));
    }

    text.push(' rows by ');
    if (f.getColumnCount() !== d.getColumnCount()) {
      text.push('<b>');
      text.push(morpheus.Util.intFormat(f.getColumnCount()));
      text.push('/');
      text.push(morpheus.Util.intFormat(d.getColumnCount()));
      text.push('</b>');
    } else {
      text.push(morpheus.Util.intFormat(f.getColumnCount()));
    }

    text.push(' columns');
    this.$dimensionsLabel.html(text.join(''));
  },
  updateSelectionLabel: function () {
    var nc = this.heatMap.getProject().getColumnSelectionModel().count();
    var nr = this.heatMap.getProject().getRowSelectionModel().count();
    var text = [];
    text.push(morpheus.Util.intFormat(nr) + ' row');
    if (nr !== 1) {
      text.push('s');
    }
    text.push(', ');
    text.push(morpheus.Util.intFormat(nc) + ' column');
    if (nc !== 1) {
      text.push('s');
    }
    text.push(' selected');
    this.$selectionLabel.html(text.join(''));
  },
  searchDendrogram: function (isColumns) {
    var searchObject = isColumns
      ? this.columnDendrogramSearchObject
      : this.rowDendrogramSearchObject;
    var text = $.trim(searchObject.$search.val());
    var dendrogram = isColumns ? this.heatMap.columnDendrogram
      : this.heatMap.rowDendrogram;
    var $searchResults = searchObject.$searchResults;
    var matches = morpheus.DendrogramUtil.search({
      rootNode: dendrogram.tree.rootNode,
      text: text,
      matchAllPredicates: this.matchAllPredicates,
      defaultMatchMode: this.matchMode
    });
    if (matches === -1) {
      $searchResults.html('');
    } else {
      $searchResults.html(matches + ' match'
        + (matches === 1 ? '' : 'es'));
    }
    if (matches <= 0) {
      var positions = isColumns ? this.heatMap.getHeatMapElementComponent().getColumnPositions()
        : this.heatMap.getHeatMapElementComponent().getRowPositions();
      positions.setSquishedIndices(null);
      if (isColumns) {
        this.heatMap.getProject().setGroupColumns([], true);
      } else {
        this.heatMap.getProject().setGroupRows([], true);
      }
      positions.setSize(isColumns ? this.heatMap.getFitColumnSize()
        : this.heatMap.getFitRowSize());
    } else {
      morpheus.DendrogramUtil.squishNonSearchedNodes(this.heatMap,
        isColumns);
    }
    this.heatMap.updateDataset(); // need to update spaces for group
    // by
    this.heatMap.revalidate();
  },
  search: function (isRows) {
    this.searching = true;
    var isMatchesOnTop = isRows ? this.rowSearchObject.$matchesToTop.hasClass(
      'btn-primary') : this.columnSearchObject.$matchesToTop.hasClass(
      'btn-primary');
    var heatMap = this.heatMap;
    var project = heatMap.getProject();

    var sortKeys = isRows
      ? project.getRowSortKeys()
      : project.getColumnSortKeys();
    sortKeys = sortKeys.filter(function (key) {
      return !(key instanceof morpheus.MatchesOnTopSortKey &&
        key.toString() === 'matches on top');
    });

    var dataset = project.getSortedFilteredDataset();
    var $searchResultsLabel = isRows
      ? this.rowSearchObject.$searchResults
      : this.columnSearchObject.$searchResults;
    var searchText = !isRows
      ? $.trim(this.columnSearchObject.$search.val())
      : $.trim(this.rowSearchObject.$search.val());

    var metadata = isRows
      ? dataset.getRowMetadata()
      : dataset.getColumnMetadata();
    var visibleIndices = [];
    heatMap.getVisibleTrackNames(!isRows).forEach(function (name) {
      var index = morpheus.MetadataUtil.indexOf(metadata, name);
      if (index !== -1) {
        visibleIndices.push(index);
      }
    });
    var fullModel = metadata;
    metadata = new morpheus.MetadataModelColumnView(metadata,
      visibleIndices);

    var searchResultViewIndices = morpheus.MetadataUtil.search({
      model: metadata,
      fullModel: fullModel,
      text: searchText,
      isColumns: !isRows,
      matchAllPredicates: this.matchAllPredicates,
      defaultMatchMode: this.matchMode
    });
    if (searchText === '') {
      $searchResultsLabel.html('');
      if (isRows) {
        this.rowSearchObject.$searchResultsWrapper.hide();
      } else {
        this.columnSearchObject.$searchResultsWrapper.hide();
      }

    } else {
      $searchResultsLabel.html(searchResultViewIndices.length + ' match'
        + (searchResultViewIndices.length === 1 ? '' : 'es'));
      if (isRows) {
        this.rowSearchObject.$searchResultsWrapper.show();
      } else {
        this.columnSearchObject.$searchResultsWrapper.show();
      }

    }

    var searchResultsModelIndices = [];
    if (searchResultViewIndices != null) {
      for (var i = 0, length = searchResultViewIndices.length; i <
      length; i++) {
        var viewIndex = searchResultViewIndices[i];
        searchResultsModelIndices.push(isRows
          ? project.convertViewRowIndexToModel(viewIndex)
          : project.convertViewColumnIndexToModel(viewIndex));
      }
    }

    if (searchResultViewIndices !== null && isMatchesOnTop) {
      var key = new morpheus.MatchesOnTopSortKey(project,
        searchResultsModelIndices, 'matches on top', !isRows);
      // keep other sort keys
      searchResultViewIndices = key.indices; // matching indices
      // are now on top
      // add to beginning of sort keys
      sortKeys.splice(0, 0, key);
      if (isRows) {
        project.setRowSortKeys(sortKeys, false);
      } else {
        project.setColumnSortKeys(sortKeys, false);
      }
    }
    var searchResultsViewIndicesSet = new morpheus.Set();
    if (searchResultViewIndices != null) {
      for (var i = 0, length = searchResultViewIndices.length; i <
      length; i++) {
        var viewIndex = searchResultViewIndices[i];
        searchResultsViewIndicesSet.add(viewIndex);
      }
    }
    if (searchResultViewIndices == null) {
      searchResultViewIndices = [];
    }

    if (isRows) {
      this.rowSearchResultModelIndices = searchResultsModelIndices;
      this.rowSearchResultViewIndicesSorted = searchResultViewIndices.sort(
        function (a, b) {
          return a < b ? -1 : 1;
        });
      this.currentRowSearchIndex = -1;

    } else {
      this.columnSearchResultModelIndices = searchResultsModelIndices;
      this.columnSearchResultViewIndicesSorted = searchResultViewIndices.sort(
        function (a, b) {
          return a < b ? -1 : 1;
        });
      this.currentColumnSearchIndex = -1;
    }
    // update selection
    (!isRows
      ? project.getColumnSelectionModel()
      : project.getRowSelectionModel()).setViewIndices(
      searchResultsViewIndicesSet, true);

    if (isMatchesOnTop) { // resort
      if (isRows) {
        project.setRowSortKeys(morpheus.SortKey.keepExistingSortKeys(
          sortKeys, project.getRowSortKeys()), true);
      } else {
        project.setColumnSortKeys(
          morpheus.SortKey.keepExistingSortKeys(sortKeys,
            project.getColumnSortKeys()), true);
      }
    }
    this.updateDimensionsLabel();
    this.updateSelectionLabel();
    this.searching = false;

  },
  isSelectionOnTop: function (isColumns) {
    var $btn = isColumns
      ? this.columnSearchObject.$matchesToTop
      : this.rowSearchObject.$matchesToTop;
    return $btn.hasClass('btn-primary');
  },
  setSelectionOnTop: function (options) {
    if (options.updateButtonStatus) {
      var $btn = options.isColumns
        ? this.columnSearchObject.$matchesToTop
        : this.rowSearchObject.$matchesToTop;
      if (options.isOnTop) {
        $btn.addClass('btn-primary');
      } else {
        $btn.removeClass('btn-primary');
      }
    }
    var project = this.heatMap.getProject();
    var sortKeys = options.isColumns
      ? project.getColumnSortKeys()
      : project.getRowSortKeys();
    // remove existing matches on top key
    sortKeys = sortKeys.filter(function (key) {
      return !(key instanceof morpheus.MatchesOnTopSortKey &&
        key.name === 'matches on top');
    });
    if (options.isOnTop) { // bring to top
      var key = new morpheus.MatchesOnTopSortKey(project,
        options.isColumns
          ? this.columnSearchResultModelIndices
          : this.rowSearchResultModelIndices,
        'matches on top');
      sortKeys.splice(0, 0, key);
      if (options.isColumns) {
        this.heatMap.scrollLeft(0);
      } else {
        this.heatMap.scrollTop(0);
      }
    }
    this.searching = true;
    if (options.isColumns) {
      project.setColumnSortKeys(sortKeys, true);
    } else {
      project.setRowSortKeys(sortKeys, true);
    }
    this._updateSearchIndices(options.isColumns);
    this.searching = false;

  }
};
morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD = 'column';
morpheus.HeatMapToolBar.ROW_SEARCH_FIELD = 'column';
morpheus.HeatMapToolBar.COLUMN_DENDROGRAM_SEARCH_FIELD = 'column_dendrogram';
morpheus.HeatMapToolBar.ROW_DENDROGRAM_SEARCH_FIELD = 'row_dendrogram';

morpheus.HeatMapTooltipProvider = function (heatMap, rowIndex, columnIndex, options, separator, quick, tipText) {
  var dataset = heatMap.project.getSortedFilteredDataset();
  if (!quick) {
    if (options.value) { // key value pairs for custom tooltip
      _.each(options.value, function (pair) {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(pair.name);
        tipText.push(': <b>');
        if (_.isArray(pair.value)) {
          for (var i = 0; i < pair.value.length; i++) {
            if (i > 0) {
              tipText.push(', ');
            }
            tipText.push(pair.value[i]);
          }
        } else {
          tipText.push(pair.value);
        }
        tipText.push('</b>');
      });
    }
  }
  if (rowIndex !== -1 && columnIndex !== -1) {
    var tooltipSeriesIndices = options.tooltipSeriesIndices ? options.tooltipSeriesIndices : morpheus.Util.sequ32(dataset.getSeriesCount());
    for (var i = 0, nseries = tooltipSeriesIndices.length; i < nseries; i++) {
      morpheus.HeatMapTooltipProvider._matrixValueToString(heatMap, dataset,
        rowIndex, columnIndex, tooltipSeriesIndices[i], tipText, separator,
        options.showSeriesNameInTooltip || i > 0);
      if (heatMap.options.symmetric && dataset.getValue(rowIndex, columnIndex, tooltipSeriesIndices[i]) !== dataset.getValue(columnIndex, rowIndex, tooltipSeriesIndices[i])) {
        morpheus.HeatMapTooltipProvider._matrixValueToString(heatMap, dataset,
          columnIndex, rowIndex, tooltipSeriesIndices[i], tipText, separator, false);
      }
    }

    if (quick) {
      var quickRowTracks = heatMap.rowTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      });
      morpheus.HeatMapTooltipProvider._tracksToString(quickRowTracks, dataset.getRowMetadata(), rowIndex, tipText, separator);
      morpheus.HeatMapTooltipProvider._tracksToString(heatMap.columnTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      }), dataset.getColumnMetadata(), columnIndex, tipText, separator);

    }
  } else if (quick) {
    if (rowIndex !== -1) {
      morpheus.HeatMapTooltipProvider._tracksToString(heatMap.rowTracks.filter(function (t) {
        return t.settings.inlineTooltip && options.name !== t.getName();
      }), dataset.getRowMetadata(), rowIndex, tipText, separator);
    }
    if (columnIndex !== -1) {
      morpheus.HeatMapTooltipProvider._tracksToString(heatMap.columnTracks.filter(function (t) {
        return t.settings.inlineTooltip && options.name !== t.getName();
      }), dataset.getColumnMetadata(), columnIndex, tipText, separator);
    }
  }

  if (!quick) {
    if (rowIndex !== -1) {
      morpheus.HeatMapTooltipProvider._metadataToString(options,
        heatMap.rowTracks, dataset.getRowMetadata(), rowIndex,
        tipText, separator);
    }
    if (columnIndex !== -1) {
      morpheus.HeatMapTooltipProvider._metadataToString(options,
        heatMap.columnTracks, dataset.getColumnMetadata(),
        columnIndex, tipText, separator);
    }
  } else if (options.name != null) {
    var metadata = (rowIndex !== -1 ? dataset.getRowMetadata() : dataset.getColumnMetadata());
    var vector = metadata.getByName(options.name);
    var track = heatMap.getTrack(options.name, columnIndex !== -1);
    var colorByName = track != null ? track.settings.colorByField : null;
    var additionalVector = colorByName != null ? metadata
    .getByName(colorByName) : null;
    morpheus.HeatMapTooltipProvider.vectorToString(vector,
      rowIndex !== -1 ? rowIndex : columnIndex, tipText, separator,
      additionalVector);

  }
  var rowNodes = [];
  var columnNodes = [];
  var selectedRowNodes = [];
  var selectedColumnNodes = [];

  if (options.rowNodes) {
    rowNodes = options.rowNodes;
  }
  if (options.columnNodes) {
    columnNodes = options.columnNodes;
  }
  if (!quick) {
    if (heatMap.rowDendrogram) {
      selectedRowNodes = _
      .values(heatMap.rowDendrogram.selectedRootNodeIdToNode);
    }
    if (heatMap.columnDendrogram) {
      selectedColumnNodes = _
      .values(heatMap.columnDendrogram.selectedRootNodeIdToNode);
    }
    if (selectedRowNodes.length > 0 && rowNodes.length > 0) {
      var nodeIds = {};
      _.each(selectedRowNodes, function (n) {
        nodeIds[n.id] = true;
      });
      rowNodes = _.filter(rowNodes, function (n) {
        return nodeIds[n.id] === undefined;
      });
    }
    if (selectedColumnNodes.length > 0 && columnNodes.length > 0) {
      var nodeIds = {};
      _.each(selectedColumnNodes, function (n) {
        nodeIds[n.id] = true;
      });
      columnNodes = _.filter(columnNodes, function (n) {
        return nodeIds[n.id] === undefined;
      });
    }
  }
  morpheus.HeatMapTooltipProvider._nodesToString(tipText, rowNodes, null, separator);
  morpheus.HeatMapTooltipProvider._nodesToString(tipText, columnNodes, null, separator);
  if (!quick) {
    if (selectedRowNodes.length > 0) {
      morpheus.HeatMapTooltipProvider._nodesToString(tipText,
        selectedRowNodes, heatMap.rowDendrogram._selectedNodeColor,
        separator);
    }
    if (selectedColumnNodes.length > 0) {
      morpheus.HeatMapTooltipProvider._nodesToString(tipText,
        selectedColumnNodes,
        heatMap.columnDendrogram._selectedNodeColor, separator);
    }
  }

};

morpheus.HeatMapTooltipProvider._matrixValueToString = function (heatMap, dataset, rowIndex, columnIndex, seriesIndex, tipText, separator, showSeriesNameInTooltip) {
  var val = dataset.getValue(rowIndex, columnIndex, seriesIndex);
  if (val != null) {
    var nf = heatMap.getHeatMapElementComponent().getDrawValuesFormat();
    if (val.toObject || !_.isNumber(val)) {
      var obj = val.toObject ? val.toObject() : val;
      if (morpheus.Util.isArray(obj)) {
        var v = morpheus.Util.toString(obj);
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        if (showSeriesNameInTooltip) {
          tipText.push(dataset.getName(seriesIndex));
          tipText.push(': ');
        }
        tipText.push('<b>');
        tipText.push(v);
        tipText.push('</b>');
      } else {
        var keys = _.keys(obj);
        if (keys.length === 0) {
          var v = morpheus.Util.toString(obj);
          if (tipText.length > 0) {
            tipText.push(separator);
          }
          if (showSeriesNameInTooltip) {
            tipText.push(dataset.getName(seriesIndex));
            tipText.push(': ');
          }
          tipText.push('<b>');
          tipText.push(v);
          tipText.push('</b>');
        } else {
          for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
            var key = keys[i];
            if (key !== '__v') { // special value key
              var objVal = obj[key];
              var v;
              if (morpheus.Util.isArray(objVal)) {
                v = morpheus.Util.arrayToString(objVal, ', ');
              } else {
                v = morpheus.Util.toString(objVal);
              }
              if (tipText.length > 0) {
                tipText.push(separator);
              }
              tipText.push(key);
              tipText.push(': <b>');
              tipText.push(v);
              tipText.push('</b>');
            }
          }
          if (_.isNumber(val)) {
            tipText.push(separator);
            tipText.push('Value: <b>');
            tipText.push(nf(val));
            tipText.push('</b>');
          }
        }
      }
    } else {
      if (tipText.length > 0) {
        tipText.push(separator);
      }

      if (showSeriesNameInTooltip) {
        tipText.push(dataset.getName(seriesIndex));
        tipText.push(': ');
      }
      tipText.push('<b>');
      tipText.push(nf(val));
      tipText.push('</b>');
    }
  }
};

morpheus.HeatMapTooltipProvider.vectorToString = function (vector, index, tipText, separator, additionalVector) {
  var arrayValueToString = function (arrayFieldName, arrayVal) {
    if (arrayVal != null) {
      if (arrayFieldName != null) {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(arrayFieldName); // e.g. PC3
      }
      if (arrayVal.toObject) {
        tipText.push(' ');
        var obj = arrayVal.toObject();
        var keys = _.keys(obj);
        _.each(keys, function (key) {
          var subVal = obj[key];
          if (subVal != null && subVal != '') {
            if (tipText.length > 0) {
              tipText.push(separator);
            }
            tipText.push(key);
            tipText.push(': <b>');
            tipText.push(morpheus.Util.toString(subVal));
            tipText.push('</b>');
          }
        });
      } else {
        tipText.push(': <b>');
        tipText.push(morpheus.Util.toString(arrayVal));
        tipText.push('</b>');
      }

    }
  };
  if (vector != null) {
    var primaryVal = vector.getValue(index);
    if (primaryVal != null && primaryVal != '') {
      var primaryFields = vector.getProperties().get(
        morpheus.VectorKeys.FIELDS);
      if (primaryFields != null) {
        var visibleFieldIndices = vector.getProperties().get(
          morpheus.VectorKeys.VISIBLE_FIELDS);
        if (visibleFieldIndices === undefined) {
          visibleFieldIndices = morpheus.Util
          .seq(primaryFields.length);
        }
        var additionalFieldNames = additionalVector != null ? additionalVector
        .getProperties().get(morpheus.VectorKeys.FIELDS)
          : null;
        var additionalVal = additionalFieldNames != null ? additionalVector
        .getValue(index)
          : null;
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(vector.getName());
        for (var j = 0; j < visibleFieldIndices.length; j++) {
          arrayValueToString(primaryFields[visibleFieldIndices[j]],
            primaryVal[visibleFieldIndices[j]]);
        }

        if (additionalVal != null) {
          if (tipText.length > 0) {
            tipText.push(separator);
          }
          tipText.push(additionalVector.getName());
          for (var j = 0; j < visibleFieldIndices.length; j++) {
            arrayValueToString(
              additionalFieldNames[visibleFieldIndices[j]],
              additionalVal[visibleFieldIndices[j]]);
          }

        }
      } else if (primaryVal.summary) {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(vector.getName());
        tipText.push(': ');
        var obj = primaryVal.summary;
        var keys = _.keys(obj);
        for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
          var key = keys[i];
          if (key !== '__v') { // special value key
            var objVal = obj[key];
            var v;
            if (morpheus.Util.isArray(objVal)) {
              v = morpheus.Util.arrayToString(objVal, ', ');
            } else {
              v = morpheus.Util.toString(objVal);
            }
            if (tipText.length > 0) {
              tipText.push(separator);
            }
            tipText.push(key);
            tipText.push(': <b>');
            tipText.push(v);
            tipText.push('</b>');
          }
        }

      } else {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(vector.getName());
        tipText.push(': <b>');
        tipText.push(morpheus.Util.toString(primaryVal));
        tipText.push('</b>');
      }

    }
  }
};
morpheus.HeatMapTooltipProvider._tracksToString = function (tracks, metadata, index, tipText, separator) {
  for (var i = 0; i < tracks.length; i++) {
    morpheus.HeatMapTooltipProvider.vectorToString(metadata.getByName(tracks[i].name), index, tipText,
      separator);

  }
};
morpheus.HeatMapTooltipProvider._metadataToString = function (options, tracks, metadata, index,
                                                              tipText, separator) {
  var filtered = [];
  for (var i = 0, ntracks = tracks.length; i < ntracks; i++) {
    var track = tracks[i];
    if ((track.isVisible() && track.isShowTooltip())) {
      if (tracks[i].name === options.name) { // show the vector that we're mousing over 1st
        filtered.splice(0, 0, track);
      } else {
        filtered.push(track);
      }
    }
  }

  morpheus.HeatMapTooltipProvider._tracksToString(filtered, metadata, index, tipText, separator);

};
morpheus.HeatMapTooltipProvider._nodesToString = function (tipText, nodes, color, separator) {
  var renderField = function (name, value) {
    if (value != null) {
      if (tipText.length > 0) {
        tipText.push(separator);
      }
      if (color) {
        tipText.push('<span style="color:' + color + '">');
      }
      tipText.push(name);
      tipText.push(': <b>');
      if (_.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          if (i > 0) {
            tipText.push(', ');
          }
          tipText.push(morpheus.Util.toString(value[i]));
        }
      } else {
        tipText.push(morpheus.Util.toString(value));
      }
      tipText.push('</b>');
      if (color) {
        tipText.push('</span>');
      }
    }
  };
  _.each(nodes, function (node) {
    if (node.info) {
      for (var name in node.info) {
        var value = node.info[name];
        renderField(name, value);
      }
    }
    renderField('height', node.height);
    renderField('depth', node.depth);
    var nLeafNodes = 1 + Math.abs(node.maxIndex - node.minIndex);
    if (nLeafNodes > 0) {
      renderField('# of leaf nodes', nLeafNodes);
      // renderField('height', node.height);
    }
  });
};

morpheus.HeatMapTrackColorLegend = function (tracks, colorModel) {
  morpheus.AbstractCanvas.call(this, false);
  this.tracks = tracks;
  this.colorModel = colorModel;
  this.canvas.style.position = '';
};
morpheus.HeatMapTrackColorLegend.prototype = {
  getPreferredSize: function () {
    var tracks = this.tracks;
    var colorModel = this.colorModel;
    var xpix = 0;
    var ypix = 0;
    var maxYPix = 0;
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    context.font = '12px ' + morpheus.CanvasUtil.getFontFamily(context);
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector(tracks[i].settings.colorByField);
      if (vector.getProperties().get(morpheus.VectorKeys.DISCRETE)) {
        var map = colorModel.getDiscreteColorScheme(vector);
        map.forEach(function (color, key) {
          var width = context.measureText(key).width;
          if (!isNaN(width)) {
            maxWidth = Math.max(maxWidth, width);
          }
          ypix += 14;
        });
      } else {
        maxWidth = 220;
        ypix += 40;

      }
      maxWidth = Math.max(maxWidth,
        context.measureText(vector.getName()).width);
      xpix += maxWidth + 10 + 14;
      maxYPix = Math.max(maxYPix, ypix);
    }
    return {
      width: xpix,
      height: maxYPix > 0 ? (maxYPix + 12) : 0
    };
  },
  draw: function (clip, context) {
    var tracks = this.tracks;
    var colorModel = this.colorModel;
    var xpix = 0;
    // legends are placed side by side
    for (var i = 0; i < tracks.length; i++) {
      var ypix = 0;
      var vector = tracks[i].getVector(tracks[i].settings.colorByField);
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      context.font = '12px ' + morpheus.CanvasUtil.getFontFamily(context);
      context.textAlign = 'left';
      // draw name
      context.textBaseline = 'top';
      context.fillText(vector.getName(), xpix, ypix);

      context.strokeStyle = 'LightGrey';
      var maxWidth = 0;
      var textWidth = context.measureText(vector.getName()).width;
      if (!isNaN(textWidth)) {
        maxWidth = Math.max(0, textWidth);
      }
      ypix += 14;
      if (vector.getProperties().get(morpheus.VectorKeys.DISCRETE)) {
        var toStringFunction = morpheus.VectorTrack.vectorToString(vector);
        var map = colorModel.getDiscreteColorScheme(vector);
        var values = map.keys().sort(morpheus.SortKey.ASCENDING_COMPARATOR);
        values.forEach(function (key) {
          if (key != null) {
            key = toStringFunction(key);
            var color = colorModel.getMappedValue(vector, key);
            var textWidth = context.measureText(key).width;
            if (!isNaN(textWidth)) {
              maxWidth = Math.max(maxWidth, textWidth);
            }
            context.fillStyle = color;
            var xoffset = 0;
            if (tracks[i].isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
              context.fillRect(xpix, ypix, 12, 12);
              context.strokeRect(xpix, ypix, 12, 12);
              context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
              xoffset = 16;
            }
            context.fillText(key, xpix + xoffset, ypix);
            ypix += 14;
          }
        });
      } else {
        var scheme = colorModel.getContinuousColorScheme(vector);
        context.save();
        context.translate(xpix, ypix);
        morpheus.HeatMapColorSchemeLegend.drawColorScheme(context,
          scheme, 200);
        context.restore();
        maxWidth = Math.max(maxWidth, 220);
        ypix += 40;
      }
      xpix += maxWidth + 10 + 14; // space between tracks + color chip
    }
  }
};
morpheus.Util.extend(morpheus.HeatMapTrackColorLegend, morpheus.AbstractCanvas);

morpheus.HeatMapTrackFontLegend = function (tracks, model) {
  morpheus.AbstractCanvas.call(this, false);
  this.tracks = tracks;
  this.model = model;
  this.canvas.style.position = '';
};
morpheus.HeatMapTrackFontLegend.prototype = {
  getPreferredSize: function () {
    var tracks = this.tracks;
    var model = this.model;
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    context.font = '900 12px ' + morpheus.CanvasUtil.getFontFamily(context);
    var xpix = 0;
    var ypix = 0;
    var maxYPix = 0;
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector(tracks[i].settings.fontField);
      var map = model.getMap(vector.getName());

      map.forEach(function (font, key) {
        // skip normal font weight
        if (font != null && font.weight != '400') {
          var width = context.measureText(key).width;
          if (!isNaN(width)) {
            maxWidth = Math.max(maxWidth, width);
          }
          ypix += 14;
        }
      });

      xpix += maxWidth + 6;
      maxYPix = Math.max(maxYPix, ypix);
    }
    return {
      width: xpix,
      height: maxYPix > 0 ? (maxYPix + 30) : 0
    };
  },
  draw: function (clip, context) {
    // draw legends horizontally
    var tracks = this.tracks;
    var model = this.model;
    var xpix = 0;
    var ypix = 0;
    context.textAlign = 'left';
    context.textBaseline = 'top';
    context.font = '12px ' + morpheus.CanvasUtil.getFontFamily(context);
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.strokeStyle = 'black';
    var font = context.font;
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var textVector = tracks[i].getVector();
      var fontVector = tracks[i].getVector(tracks[i].settings.fontField);
      context.font = font;
      context.fillText(textVector.getName(), xpix, ypix); // vector name
      maxWidth = Math.max(maxWidth,
        context.measureText(textVector.getName()).width);
      ypix += 14;
      var map = model.getMap(fontVector.getName());
      var values = map.keys().sort(morpheus.SortKey.ASCENDING_COMPARATOR);
      values.forEach(function (key) {
        var mappedFont = model.getMappedValue(fontVector, key);
        if (mappedFont != null && mappedFont.weight != '400') {
          context.font = mappedFont.weight + ' ' + font;
          var width = context.measureText(key).width;
          if (!isNaN(width)) {
            maxWidth = Math.max(maxWidth, width);
          }
          context.fillText(key, xpix, ypix);
          ypix += 14;
        }
      });

      xpix += maxWidth + 6; // space between tracks
    }
  }
};
morpheus.Util.extend(morpheus.HeatMapTrackFontLegend, morpheus.AbstractCanvas);

morpheus.HeatMapTrackShapeLegend = function (tracks, shapeModel) {
  morpheus.AbstractCanvas.call(this, false);
  this.tracks = tracks;
  this.shapeModel = shapeModel;
  this.canvas.style.position = '';
};
morpheus.HeatMapTrackShapeLegend.prototype = {
  getPreferredSize: function () {
    var tracks = this.tracks;
    var shapeModel = this.shapeModel;
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    var xpix = 0;
    var ypix = 0;
    var maxYPix = 0;
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector();
      var map = shapeModel.getMap(vector.getName());

      map.forEach(function (color, key) {
        var width = context.measureText(key).width;
        if (!isNaN(width)) {
          maxWidth = Math.max(maxWidth, width);
        }
        ypix += 14;
      });

      xpix += maxWidth + 24;
      maxYPix = Math.max(maxYPix, ypix);
    }
    return {
      width: xpix,
      height: maxYPix > 0 ? (maxYPix + 30) : 0
    };
  },
  draw: function (clip, context) {
    // draw legends horizontally
    var tracks = this.tracks;
    var shapeModel = this.shapeModel;
    var xpix = 0;
    var ypix = 0;
    context.textAlign = 'left';
    context.textBaseline = 'top';
    context.font = '12px ' + morpheus.CanvasUtil.getFontFamily(context);
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.strokeStyle = 'black';
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector();
      context.fillText(vector.getName(), xpix, ypix);
      maxWidth = Math.max(maxWidth,
        context.measureText(vector.getName()).width);
      ypix += 14;
      var map = shapeModel.getMap(vector.getName());
      var values = map.keys().sort(morpheus.SortKey.ASCENDING_COMPARATOR);
      values.forEach(function (key) {
        var shape = shapeModel.getMappedValue(vector, key);
        var width = context.measureText(key).width;
        if (!isNaN(width)) {
          maxWidth = Math.max(maxWidth, width);
        }
        morpheus.CanvasUtil.drawShape(context, shape, xpix + 8,
          ypix + 6, 6);
        context.fillText(key, xpix + 16, ypix);
        ypix += 14;
      });

      xpix += maxWidth + 24; // space between columns + shape
    }
  }
};
morpheus.Util.extend(morpheus.HeatMapTrackShapeLegend, morpheus.AbstractCanvas);

/**
 * rows and columns can contain field, renameTo, display, order
 *
 */

morpheus.HeatMap = function (options) {
  morpheus.Util.loadTrackingCode();
  var _this = this;
  // don't extend
  var dontExtend = ['parent', 'columnDendrogram', 'rowDendrogram'];
  var cache = [];
  for (var i = 0; i < dontExtend.length; i++) {
    var field = dontExtend[i];
    cache[i] = options[field];
    options[field] = null;
  }
  options = $.extend(
    true,
    {},
    {
      /*
       * The element in which to render to the heat map.
       */
      el: null,
      /*
       * A File or URL to a <a target="_blank"
       * href="http://support.lincscloud.org/hc/en-us/articles/202105453-GCT-Gene-Cluster-Text-Format-">GCT
       * 1.3</a>, ' + '<a target="_blank"
       * href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT
       * 1.2</a>, ' + '<a target="_blank"
       * href="https://wiki.nci.nih.gov/display/TCGA/Mutation+Annotation+Format+%28MAF%29+Specification">MAF</a>, ' + '<a
       * target="_blank",
       * href="http://www.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29">GMT</a>, ' + '
       * or a tab-delimitted text file. Can also be an array
       * of File or URLs in which case the datasets are
       * combined by matching on column ids.
       */
      dataset: undefined,
      /*
       *
       * @description Array of file, datasetField, fileField,
       *              and include (optional fields to include
       *              from file). File can be xlsx file,
       *              tab-delimitted text file, or gmt file.
       *              <p>
       *              <b>Example:</b> Annotate rows matching
       *              'name' field in dataset to 'id' field in
       *              file.
       *              </p>
       *              <code>[{file:'https://MY_URL', datasetField:'name', fileField:'id'}]</code>
       */
      rowAnnotations: undefined,
      /*
       * Array of file, datasetField, fileField, and include
       * (optional fields to include from file). File can be
       * xlsx file, tab-delimitted text file, or gmt file.
       */
      columnAnnotations: undefined,

      /*
       * Array of column metadata names to group the heat map
       * by.
       *
       * <p>
       * <b>Example:</b> Group by the type and gender
       * metadata field.
       * </p>
       *
       * <code>['type', 'gender']</code>
       */
      columnGroupBy: undefined,
      /*
       * Array of row metadata names to group the heat map by.
       *
       * <p>
       * <b>Example:</b> Group by the gene metadata field.
       * </p>
       * <code>['gene']</code>
       */
      rowGroupBy: undefined,
      /*
       * Object that describes mapping of values to colors.
       * scalingMode can be 'fixed' or 'relative'. Stepped indicates
       * whether color scheme is continuous (false) or
       * discrete (true).
       * <p>
       * <b>Example:</b> Use a fixed color scheme with color
       * stops at -100, -90, 90, and 100.
       * <p>
       * <code>{ scalingMode : 'fixed', stepped:false, values : [-100, -90, 90, 100], colors : ['blue', 'white', 'white', 'red'] };</code>
       */
      colorScheme: undefined,
      /*
       * Array of metadata names and sort order. Use 0 for
       * ascending and 1 for descending. To sort by values use
       * modelIndices.
       *
       * <p>
       * <b>Example:</b> Sort ascending by gene, and then
       * descending by stdev
       * </p>
       * <code>[{field:'gene', order:0}, {field:'stdev',
       *              order:1}]</code>
       */
      rowSortBy: undefined,
      /*
       * Array of metadata names and sort order. Use 0 for
       * ascending and 1 for descending.
       *
       * <p>
       * <b>Example:</b> to sort ascending by gene, and then
       * descending by stdev
       * </p>
       * <code> [{name:'gene',
       *              order:0}, {name:'stdev', order:1}]</code>
       */
      columnSortBy: undefined,
      /*
       * URL to a dendrogram in <a target="_blank"
       * href="https://en.wikipedia.org/wiki/Newick_format">Newick
       * format</a>
       */
      rowDendrogram: undefined,
      /*
       * URL to a dendrogram in <a target="_blank"
       * href="https://en.wikipedia.org/wiki/Newick_format">Newick
       * format</a>
       */
      columnDendrogram: undefined,

      /*
       * Column metadata field in dataset used to match leaf
       * node ids in column dendrogram Newick file
       */
      columnDendrogramField: 'id',
      /*
       * Row metadata field in dataset used to match leaf node
       * ids in row dendrogram Newick file
       */
      rowDendrogramField: 'id',
      /*
       * Array of objects describing how to display row
       * metadata fields. Each object in the array must have
       * field, and optionally display, order, and renameTo.
       * Field is the metadata field name. Display is a comma
       * delimited string that describes how to display a
       * metadata field. Options are text, color, stacked_bar,
       * bar, highlight, shape, discrete, and continuous.
       * Order is a number that indicates the order in which
       * the field should appear in the heat map. RenameTo
       * allows you to rename a field.
       */
      rows: [],
      /*
       * Array of objects describing how to display column
       * metadata fields. Each object in the array must have
       * field, and optionally display, order, and renameTo.
       * Field is the metadata field name. Display is a comma
       * delimited string that describes how to display a
       * metadata field. Options are text, color, stacked_bar,
       * bar, highlight, shape, discrete, and continuous.
       * Order is a number that indicates the order in which
       * the field should appear in the heat map. RenameTo
       * allows you to rename a field.
       */
      columns: [],
      /*
       * Optional array of tools to run at load time. For
       * example: <code>tools : [ {
       * name : 'Marker Selection',
       * params : {
       * 		field : [ comparisonVector.getName() ],
       *      class_a : [ 'A' ], class_b : [ 'B' ] }} ]</code>
       */
      tools: undefined,
      /*
       * Optional array of {name:string, values:[]}
       */
      rowFilter: undefined,
      columnFilter: undefined,
      /*
       * Whether to auto-hide the tab bar when only one tab is visible
       */
      autohideTabBar: false,
      /*
       * Whether this heat map tab can be closed
       */
      closeable: true,
      /*
       * Whether heat map tab can be renamed
       */
      rename: true,
      /*
       * Heat map row size in pixels or 'fit' to fit heat map to current height.
       */
      rowSize: 13,
      /*
       * Heat map column size in pixels or 'fit' to fit heat map to current width.
       */
      columnSize: 13,
      rowGapSize: 10,
      columnGapSize: 10,
      /*
       * Whether to draw heat map grid
       */
      drawGrid: true,
      /*
       * Heat map grid color
       */
      gridColor: '#808080',

      showRowNumber: false,
      /*
       * Heat map grid thickness in pixels
       */
      gridThickness: 0.1,
      height: 'window', // set the available height for the
      // heat map. If not
      // set, it will be determined automatically
      width: undefined, // set the available width for the
      // heat map. If not
      // set, it will be determined automatically
      /* Whether to focus this tab */
      focus: true,
      tooltipMode: 0, // 0=top status bar, 1=dialog, 2=follow
      inheritFromParent: true,
      inheritFromParentOptions: {
        transpose: false
      },
      /** Callback function to invoke for customizing inline matrix tooltips. */
      tooltip: undefined,
      structureUrlProvider: undefined,
      promises: undefined, // additional promises to wait
      // for
      // not inherited
      renderReady: undefined,
      // not inherited
      datasetReady: undefined,
      // inherited
      tabOpened: undefined,
      loadedCallback: undefined,
      name: undefined,
      rowsSortable: true,
      columnsSortable: true,
      popupEnabled: true,
      symmetric: false,
      keyboard: true,
      inlineTooltip: true,
      // Prevent mousewheel default (stops accidental page back on Mac), but also prevents page
      // scrolling
      standalone: false,
      $loadingImage: morpheus.Util.createLoadingEl(),
      menu: {
        File: [
          'Open', null, 'Save Image', 'Save Dataset', 'Save Session', null, 'Close Tab', null, 'Rename' +
          ' Tab'],
        Tools: [
          'New Heat Map',
          null,
          'Hierarchical Clustering',
          'KMeans Clustering',
          null,
          'Marker Selection',
          'Nearest Neighbors',
          'Create Calculated Annotation',
          null,
          'Adjust',
          'Collapse',
          'Similarity Matrix',
          'Transpose',
          null,
          'Chart',
          null,
          'Sort/Group',
          'Filter',
          null,
          'API'],
        View: ['Zoom In', 'Zoom Out', null, 'Fit To Window', 'Fit Rows To Window', 'Fit Columns To Window', null, '100%', null, 'Options'],
        Edit: [
          'Copy Image',
          'Copy Selected Dataset',
          null,
          'Move Selected Rows To Top',
          'Annotate Selected Rows',
          'Copy Selected Rows',
          'Invert' +
          ' Selected Rows',
          'Select All Rows',
          'Clear Selected Rows',
          null,
          'Move Selected Columns To Top',
          'Annotate Selected Columns',
          'Copy Selected Columns',
          'Invert' +
          ' Selected Columns',
          'Select All Columns',
          'Clear Selected Columns'],
        Help: [
          'Search Menus', null, 'Contact', 'Configuration', 'Tutorial', 'Source Code', null, 'Keyboard' +
          ' Shortcuts']
      },
      toolbar: {
        dimensions: true,
        zoom: true,
        searchRows: true,
        searchColumns: true,
        searchValues: false,
        options: true,
        saveImage: true,
        filter: true,
        colorKey: true
      }
    }, options);

  for (var i = 0; i < dontExtend.length; i++) {
    var field = dontExtend[i];
    options[field] = cache[i];
  }
  if (options.menu == null) {
    options.menu = {};
  }
  if (options.toolbar == null) {
    options.toolbar = {};
  }

  this.options = options;
  this.tooltipProvider = morpheus.HeatMapTooltipProvider;
  if (!options.el) {
    this.$el = $('<div></div>');
  } else {
    this.$el = $(options.el);
  }
  this.rowGapSize = options.rowGapSize;
  this.columnGapSize = options.columnGapSize;
  this.actionManager = new morpheus.ActionManager();
  this.actionManager.heatMap = this;
  this.$el.addClass('morpheus');

  if (this.options.dataset == null) {
    var datasetFormBuilder = new morpheus.FormBuilder();
    datasetFormBuilder.append({
      name: 'file',
      type: 'file'
    });
    this.options.dataset = $.Deferred();
    morpheus.FormBuilder.showOkCancel({
      title: 'Dataset',
      appendTo: this.getContentEl(),
      focus: this.getFocusEl(),
      content: datasetFormBuilder.$form,
      okCallback: function () {
        var file = datasetFormBuilder.getValue('file');
        morpheus.DatasetUtil.read(file).done(function (dataset) {
          _this.options.dataset.resolve(dataset);
        }).fail(function (err) {
          _this.options.dataset.reject(err);
        });
      },
      cancelCallback: function () {
        _this.options.dataset.reject('Session cancelled.');
      }
    });
  }
  if (this.options.name == null) {
    this.options.name = morpheus.Util.getBaseFileName(morpheus.Util.getFileName(this.options.dataset.file ? this.options.dataset.file
      : this.options.dataset));
  }

  var isPrimary = this.options.parent == null;
  if (this.options.parent == null) {

    if (!morpheus.Util.isHeadless()) {
      if (this.options.tabManager == null) {
        this.tabManager =
          new morpheus.TabManager({
            landingPage: function () {
              if (_this.options.landingPage == null) {
                _this.options.landingPage = new morpheus.LandingPage({tabManager: _this.tabManager});
                _this.options.landingPage.$el.prependTo(_this.$el);
              }
              return _this.options.landingPage;
            },
            autohideTabBar: this.options.autohideTabBar
          });
      } else {
        this.tabManager = this.options.tabManager;
      }

      if (this.options.tabManager == null) {
        this.tabManager.appendTo(this.$el);
      }
    }
  } else {
    if (this.options.inheritFromParent) {
      this.popupItems = this.options.parent.popupItems;
      if (!this.options.tabOpened) {
        this.options.tabOpened = this.options.parent.options.tabOpened;
      }
      this.options.drawCallback = this.options.parent.options.drawCallback;
    }
    this.tabManager = this.options.parent.tabManager;
  }
  this.$content = $('<div></div>');
  this.$content.css({
    'width': '100%',
    'user-select': 'none',

    '-webkit-user-select': 'none',
    '-webkit-user-drag': 'none',
    '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    '-moz-user-select': 'none',
    '-moz-user-drag': 'none',
    '-moz-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    '-ms-user-select': 'none',
    '-ms-user-drag': 'none',
    '-ms-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    '-o-user-select': 'none',
    '-o-user-drag': 'none',
    '-o-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    'overflow-x': 'visible',
    'overflow-y': 'visible'
  });

  this.$content.on('remove.morpheus', function () {
    _this.$content.off('remove.morpheus');
    _this.dispose();
  });
  if (!morpheus.Util.isHeadless()) {
    var tab = this.tabManager.add({
      $el: this.$content,
      closeable: this.options.closeable,
      rename: this.options.rename,
      title: this.options.name,
      object: this,
      focus: this.options.focus
    });
    this.tabId = tab.id;
    this.$tabPanel = tab.$panel;
  }
  if (options.$loadingImage) {
    options.$loadingImage.appendTo(this.$content);
  }

  this.options.dataSource = !options.dataset ? ''
    : (options.dataset.file ? options.dataset.file : options.dataset);
  this._togglingInfoWindow = false;

  var promises = [];
  if (options.promises) {
    for (var i = 0; i < options.promises.length; i++) {
      promises.push(options.promises[i]);
    }
  }
  this.whenLoaded = [];

  if (options.rowAnnotations) {
    var rowDef = morpheus.DatasetUtil.annotate({
      annotations: options.rowAnnotations,
      isColumns: false
    });
    rowDef.done(function (callbacks) {
      _this.whenLoaded = _this.whenLoaded.concat(callbacks);
    });
    promises.push(rowDef);

  }
  if (options.columnAnnotations) {
    var columnDef = morpheus.DatasetUtil.annotate({
      annotations: options.columnAnnotations,
      isColumns: true
    });
    columnDef.done(function (callbacks) {
      _this.whenLoaded = _this.whenLoaded.concat(callbacks);
    });
    promises.push(columnDef);
  }

  if (options.rowDendrogram != null
    && _.isString(options.rowDendrogram)) {
    if (options.rowDendrogram[0] === '(') {
      _this.options.rowDendrogram = morpheus.DendrogramUtil.parseNewick(options.rowDendrogram);
    } else {
      var rowDendrogramDeferred = morpheus.Util.getText(options.rowDendrogram);
      rowDendrogramDeferred.done(function (text) {
        _this.options.rowDendrogram = morpheus.DendrogramUtil.parseNewick(text);
      });
      promises.push(rowDendrogramDeferred);
    }

  }
  if (options.columnDendrogram != null
    && _.isString(options.columnDendrogram)) {
    if (options.columnDendrogram[0] === '(') {
      _this.options.columnDendrogram = morpheus.DendrogramUtil.parseNewick(options.columnDendrogram);
    } else {
      var columnDendrogramDeferred = morpheus.Util.getText(options.columnDendrogram);
      columnDendrogramDeferred.done(function (text) {
        _this.options.columnDendrogram = morpheus.DendrogramUtil.parseNewick(text);
      });
      promises.push(columnDendrogramDeferred);
    }

  }
  var heatMapLoaded = function () {
    if (typeof window !== 'undefined') {
      $(window).on('orientationchange.morpheus resize.morpheus', _this.resizeListener = function () {
        _this.revalidate();
      });
    }
    _this.revalidate();
    if (options.loadedCallback) {
      options.loadedCallback(_this);
    }

    if (_this.tabManager) {
      if (_this.options.focus) {
        _this.tabManager.setActiveTab(tab.id);
        _this.focus();
      } else if (_this.tabManager.getTabCount() === 1) {
        _this.tabManager.setActiveTab(tab.id);
      }
    }
    _this.$el.trigger('heatMapLoaded', _this);
  };
  if (morpheus.Util.isArray(options.dataset)) {
    var d = morpheus.DatasetUtil.readDatasetArray(options.dataset);
    d.fail(function (message) {
      if (_this.options.$loadingImage) {
        _this.options.$loadingImage.remove();
      }
      if (_this.options.error) {
        _this.options.error(message);
      }
      morpheus.FormBuilder.showInModal({
        title: 'Error',
        html: message,
        appendTo: _this.getContentEl(),
        focus: _this.getFocusEl()
      });
    });
    d.done(function (joined) {
      if (_this.options.$loadingImage) {
        _this.options.$loadingImage.remove();
      }

      _this.options.dataset = joined;
      _this._init();
      if (joined.getRowMetadata().getByName('Source') != null
        && !_this.options.colorScheme) {
        _this.heatmap.getColorScheme().setSeparateColorSchemeForRowMetadataField(
          'Source');
      }

      _.each(
        options.dataset,
        function (option) {
          if (option.colorScheme) {
            _this.heatmap.getColorScheme().setCurrentValue(
              morpheus.Util.getBaseFileName(morpheus.Util.getFileName(option.dataset)));
            _this.heatmap.getColorScheme().setColorSupplierForCurrentValue(
              morpheus.AbstractColorSupplier.fromJSON(option.colorScheme));

          } else {
            try {
              _this.autoDisplay({
                extension: morpheus.Util.getExtension(morpheus.Util.getFileName(option.dataset)),
                filename: morpheus.Util.getBaseFileName(morpheus.Util.getFileName(option.dataset))
              });
            }
            catch (x) {
              console.log('Autodisplay errror');
            }

          }
        });

      heatMapLoaded();
    });
  } else {
    var deferred = options.dataset.file ? morpheus.DatasetUtil.read(
      options.dataset.file, options.dataset.options)
      : morpheus.DatasetUtil.read(options.dataset);
    deferred.done(function (dataset) {
      _this.options.dataset = dataset;
    });
    deferred.fail(function (err) {
      _this.options.$loadingImage.remove();
      var message = [
        'Error opening '
        + (options.dataset.file ? morpheus.Util.getFileName(options.dataset.file) : morpheus.Util.getFileName(options.dataset)) + '.'];

      if (err.message) {
        message.push('<br />Cause: ');
        message.push(err.message);

      }
      if (_this.options.error) {
        _this.options.error(message);
      }
      morpheus.FormBuilder.showInModal({
        title: 'Error',
        html: message.join(''),
        appendTo: _this.getContentEl(),
        focus: _this.getFocusEl()
      });
    });

    promises.push(deferred);
    var datasetOverlay = null;
    if (options.datasetOverlay) {
      var d = options.datasetOverlay.file ? morpheus.DatasetUtil.read(
        options.datasetOverlay.file, options.datasetOverlay.options)
        : morpheus.DatasetUtil.read(options.datasetOverlay);
      d.done(function (dataset) {
        datasetOverlay = dataset;
      });
      promises.push(d);
    }
    $.when.apply($, promises).done(function () {

      if (_this.options.$loadingImage) {
        _this.options.$loadingImage.remove();
      }
      if (_this.options.dataset == null) {
        return _this.tabManager.remove(_this.tabId);
      }
      _this._init();
      if (datasetOverlay) {
        morpheus.DatasetUtil.overlay({
          dataset: _this.options.dataset,
          newDataset: datasetOverlay,
          rowAnnotationName: 'id',
          newRowAnnotationName: 'id',
          columnAnnotationName: 'id',
          newColumnAnnotationName: 'id'
        });
      }
      heatMapLoaded();
    });
  }
};

morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS = 6;

/**
 *
 * @param tool A tool instance
 * @param heatMap The calling heat map instance
 * @param callback Optional callback to invoke when tool is done
 */
morpheus.HeatMap.showTool = function (tool, heatMap, callback) {
  if (tool.gui) {
    var gui = tool.gui(heatMap.getProject());
    var formBuilder = new morpheus.FormBuilder();
    _.each(gui, function (item) {
      formBuilder.append(item);
    });
    var tabId = heatMap.getTabManager().getActiveTabId();
    if (tool.init) {
      tool.init(heatMap.getProject(), formBuilder, {
        heatMap: heatMap
      });
    }
    heatMap.trigger('beforeToolShown', {
      tool: tool,
      formBuilder: formBuilder
    });
    var okCallback = function () {
      var $dialogContent = $('<div><span>' + tool.toString() + '...</span><button class="btn' +
        ' btn-xs btn-default" style="margin-left:6px;display: none;">Cancel</button></div>');
      var value = null;

      var $dialog = morpheus.FormBuilder.showInDraggableDiv({
        $content: $dialogContent,
        appendTo: heatMap.getContentEl(),
        width: 'auto'
      });
      var input = {};
      _.each(gui, function (item) {
        input[item.name] = formBuilder.getValue(item.name);
      });
      // give ui a chance to update

      setTimeout(function () {
        value = tool.execute({
          heatMap: heatMap,
          project: heatMap.getProject(),
          input: input
        });
        if (value instanceof Worker) {
          $dialogContent.find('button').css('display', '').on('click', function () {
            value.terminate();
          });
          value.onerror = function (e) {
            value.terminate();
            morpheus.FormBuilder.showInModal({
              title: 'Error',
              html: e,
              close: 'Close',
              focus: heatMap.getFocusEl(),
              appendTo: heatMap.getContentEl()
            });
            if (e.stack) {
              console.log(e.stack);
            }
          };
          var terminate = _.bind(value.terminate, value);
          value.terminate = function () {
            terminate();
            $dialog.remove();
            if (callback) {
              callback(input);
            }
          };
        } else {
          if (value != null && typeof value.done === 'function') { // promise
            value.always(function () {
              if (callback) {
                callback(input);
              }
              $dialog.remove();
            });
          } else {
            if (callback) {
              callback(input);
            }
            $dialog.remove();
          }

        }
      }, 20);
      setTimeout(function () {
        // in case an exception was thrown
        if (!(value instanceof Worker)) {
          $dialog.remove();
        }
      }, 5000);

    };
    var $formDiv;
    tool.ok = function () {
      $formDiv.modal('hide');
      okCallback();
    };
    var guiOptions = $.extend({}, {
      ok: true
    }, gui.options);
    $formDiv = morpheus.FormBuilder.showOkCancel({
      title: tool.toString(),
      apply: tool.apply,
      ok: guiOptions.ok,
      cancel: guiOptions.cancel,
      size: guiOptions.size,
      draggable: true,
      content: formBuilder.$form,
      appendTo: heatMap.getContentEl(),
      align: 'right',
      okCallback: okCallback,
      focus: heatMap.getFocusEl()
    });
  }
  else { // run headless
    tool.execute({
      heatMap: heatMap,
      project: heatMap.getProject(),
      input: {}
    });
    if (callback) {
      callback({});
    }
  }
};

morpheus.HeatMap.getSpaces = function (groupByKeys, length, gapSize) {
  var previousArray = [];
  var nkeys = groupByKeys.length;
  for (var keyIndex = 0; keyIndex < nkeys; keyIndex++) {
    var key = groupByKeys[keyIndex];
    previousArray.push(key.getValue(0));
  }
  var spaces = [];
  var sum = 0;
  spaces.push(sum);
  for (var i = 1; i < length; i++) {
    var isEqual = true;
    for (var keyIndex = 0; keyIndex < nkeys; keyIndex++) {
      var key = groupByKeys[keyIndex];
      var comparator = key.getComparator();
      var val = key.getValue(i);
      var c = comparator(val, previousArray[keyIndex]);
      if (c !== 0) { // not equal, add space
        isEqual = false;
        for (var keyIndex2 = 0; keyIndex2 < nkeys; keyIndex2++) {
          previousArray[keyIndex2] = groupByKeys[keyIndex2].getValue(i);
        }
        break;
      }
    }
    if (!isEqual) {
      sum += gapSize;
    }
    spaces.push(sum);
  }
  return spaces;
};
morpheus.HeatMap.createGroupBySpaces = function (dataset, groupByKeys, gapSize, isColumns) {
  if (groupByKeys.length > 0) {
    var nkeys = groupByKeys.length;
    for (var keyIndex = 0; keyIndex < nkeys; keyIndex++) {
      groupByKeys[keyIndex].init(groupByKeys[keyIndex].isColumns() ? new morpheus.TransposedDatasetView(dataset) : dataset);
    }
    return morpheus.HeatMap.getSpaces(groupByKeys, isColumns ? dataset.getColumnCount() : dataset.getRowCount(),
      gapSize);
  }
};
morpheus.HeatMap.isDendrogramVisible = function (project, isColumns) {
  var sortKeys = isColumns ? project.getColumnSortKeys() : project.getRowSortKeys();
  if (sortKeys.length === 0) {
    return true;
  }
  // var filter = isColumns ? this.project.getColumnFilter()
  //   : this.project.getRowFilter();
  // // TODO compare filters
  var size = isColumns ? project.getSortedFilteredDataset().getColumnCount()
    : project.getSortedFilteredDataset().getRowCount();
  for (var i = 0; i < sortKeys.length; i++) {
    if (!sortKeys[i].isPreservesDendrogram() || sortKeys[i].nvisible !== size) {
      return false;
    }
  }
  return true;
};

morpheus.HeatMap.prototype = {
  updatingScroll: false,
  getWhitespaceEl: function () {
    return this.$whitespace;
  },
  getActionManager: function () {
    return this.actionManager;
  },
  autoDisplay: function (options) {
    if (options.filename == null) {
      options.filename = '';
    }
    var colorScheme;
    if (options.extension === 'segtab' || options.extension === 'seg') {
      colorScheme = {
        scalingMode: 'fixed',
        values: morpheus.HeatMapColorScheme.Predefined.CN().values.map(function (value) {
          return Math.pow(2, 1 + value);
        }),
        colors: morpheus.HeatMapColorScheme.Predefined.CN().colors
      };
    } else if (options.extension === 'maf') {
      colorScheme = morpheus.HeatMapColorScheme.Predefined.MAF();
      var rowMutProfile = this.project.getFullDataset().getRowMetadata().getByName('mutation_summary');
      var fieldNames = rowMutProfile.getProperties().get(morpheus.VectorKeys.FIELDS);
      var useMafColorMap = true;
      if (fieldNames.length !== morpheus.MafFileReader.FIELD_NAMES.length) {
        useMafColorMap = false;
      } else {
        for (var i = 0; i < fieldNames.length; i++) {
          if (fieldNames[i] !== morpheus.MafFileReader.FIELD_NAMES[i]) {
            useMafColorMap = false;
            break;
          }
        }
      }
      if (!useMafColorMap) {
        colorScheme = {
          scalingMode: 'fixed',
          stepped: true,
          values: [0],
          colors: ['rgb(255,255,255)']
        };
        for (var i = 0; i < fieldNames.length; i++) {
          colorScheme.values.push(i + 1);
          colorScheme.colors.push(morpheus.VectorColorModel.TWENTY_COLORS[i % morpheus.VectorColorModel.TWENTY_COLORS.length]);
          colorScheme.names.push(fieldNames[i]);
        }
      }
      var columnMutationSummaryVectors = [];
      var columnMutationSummaryNames = ['mutation_summary', 'mutation_summary_selection'];
      for (var i = 0; i < columnMutationSummaryNames.length; i++) {
        var name = columnMutationSummaryNames[i];
        if (this.project.getFullDataset().getColumnMetadata().getByName(name)) {
          columnMutationSummaryVectors.push(this.project.getFullDataset().getColumnMetadata().getByName(name));
          track = this.getTrack(name, true);
          if (track) {
            track.settingFromConfig('stacked_bar');
            if (name === 'mutation_summary_selection') {
              track.settings.autoscaleAlways = true;
            }
          }
        }
      }

      var track = this.getTrack('mutation_summary', false);
      if (track) {
        track.settingFromConfig('stacked_bar');
      }

      for (var i = 1; i < colorScheme.colors.length; i++) {
        if (rowMutProfile) {
          this.getProject().getRowColorModel().setMappedValue(
            rowMutProfile, i - 1, colorScheme.colors[i]);
        }
        for (var j = 0; j < columnMutationSummaryVectors.length; j++) {
          this.getProject().getColumnColorModel().setMappedValue(
            columnMutationSummaryVectors[j], i - 1, colorScheme.colors[i]);
        }

      }
    } else if (options.extension === 'gmt') {
      colorScheme = morpheus.HeatMapColorScheme.Predefined.BINARY();
    } else if (options.filename === 'all_lesions.conf_99'
      || options.filename === 'all_data_by_genes.txt' || options.filename.toLowerCase().indexOf('gistic') !== -1) {
      colorScheme = {
        scalingMode: 'fixed',
        values: [-0.5, 0, 0.5],
        colors: ['blue', 'white', 'red']
      };
    } else if (options.filename.toLowerCase().indexOf('copynumber') !== -1 ||
      options.filename.toLowerCase().indexOf('copy number') !== -1) {
      colorScheme = {
        scalingMode: 'fixed',
        values: [-1.5, 0, 1.5],
        colors: ['blue', 'white', 'red']
      };
    } else if (options.filename.toLowerCase().indexOf('achilles') !== -1) {
      colorScheme = {
        scalingMode: 'fixed',
        values: [-3, -1, 1, 3],
        colors: ['blue', 'white', 'white', 'red']
      };
    }

    if (colorScheme && options.filename && this.heatmap.getColorScheme()) {
      this.heatmap.getColorScheme().setCurrentValue(options.filename);
      this.heatmap.getColorScheme().setColorSupplierForCurrentValue(
        morpheus.AbstractColorSupplier.fromJSON(colorScheme));
    }
    return colorScheme;
  },
  /**
   *
   * @param sortOrder
   * @param isColumns
   *            Whether sorting based on column selection
   * @param append
   *            Whether to add to existing sort order
   */
  sortBasedOnSelection: function (sortOrder, isColumns, append) {
    // if isColumns, sort rows
    var project = this.project;
    var selectionModel = isColumns ? project.getColumnSelectionModel()
      : project.getRowSelectionModel();
    var modelIndices = selectionModel.toModelIndices();
    if (modelIndices.length === 0) {
      return;
    }

    var priorSortKeyIndex = -1;
    if (sortOrder == null) {
      // toggle sort order?
      var existingSortKeys = isColumns ? project.getRowSortKeys()
        : project.getColumnSortKeys();
      for (var i = 0, length = existingSortKeys.length; i < length; i++) {
        var key = existingSortKeys[i];
        if (key instanceof morpheus.SortByValuesKey
          && morpheus.Util.arrayEquals(key.modelIndices,
            modelIndices)) {
          priorSortKeyIndex = i;
          if (key.getSortOrder() === morpheus.SortKey.SortOrder.UNSORTED) {
            sortOrder = morpheus.SortKey.SortOrder.DESCENDING; // 1st
            // click
          } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.DESCENDING) {
            sortOrder = morpheus.SortKey.SortOrder.ASCENDING; // 2nd
            // click
          } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
            sortOrder = morpheus.SortKey.SortOrder.TOP_N; // 3rd
            // click
          } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.TOP_N) {
            sortOrder = morpheus.SortKey.SortOrder.UNSORTED; // 4th
            // click
          }
          break;
        }
      }

    }

    if (sortOrder == null) {
      sortOrder = morpheus.SortKey.SortOrder.DESCENDING;
    }

    var sortKeys;
    if (append) {
      sortKeys = !isColumns ? project.getColumnSortKeys() : project.getRowSortKeys();

      if (priorSortKeyIndex !== -1) {
        if (sortOrder === morpheus.SortKey.SortOrder.UNSORTED) {
          // remove existing sort key
          sortKeys.splice(priorSortKeyIndex, 1);
        } else {
          sortKeys[priorSortKeyIndex].setSortOrder(sortOrder);
        }

      } else {
        if (sortOrder !== morpheus.SortKey.SortOrder.UNSORTED) {
          sortKeys.push(new morpheus.SortByValuesKey(modelIndices,
            sortOrder, !isColumns));
        }
        // add new sort key
      }

      sortKeys = morpheus.SortKey.keepExistingSortKeys(sortKeys,
        !isColumns ? project.getColumnSortKeys() : project.getRowSortKeys());

    } else {
      var newSortKeys = sortOrder === morpheus.SortKey.SortOrder.UNSORTED ? []
        : [
          new morpheus.SortByValuesKey(modelIndices, sortOrder,
            !isColumns)];
      sortKeys = morpheus.SortKey.keepExistingSortKeys(newSortKeys,
        !isColumns ? project.getColumnSortKeys() : project.getRowSortKeys());
    }

    if (!isColumns) { // sort columns by selected rows
      project.setColumnSortKeys(sortKeys, true);
      this.scrollLeft(0);
    } else { // sort rows by selected column
      project.setRowSortKeys(sortKeys, true);
      this.scrollTop(0);
    }
    morpheus.Util.trackEvent({
      eventCategory: 'Tool',
      eventAction: isColumns ? 'sortRowsBasedOnSelection' : 'sortColumnsBasedOnSelection'
    });

  },
  getToolbarElement: function () {
    return this.toolbar.$el;
  },
  getToolbar: function () {
    return this.toolbar;
  },
  setName: function (name) {
    this.options.name = name;
  },
  getName: function () {
    return this.options.name;
  },
  showOptions: function () {
    new morpheus.HeatMapOptions(this);
  },
  getProject: function () {
    return this.project;
  },
  getDendrogram: function (isColumns) {
    return isColumns ? this.columnDendrogram : this.rowDendrogram;
  },
  toJSON: function (options) {
    var _this = this;
    var json = {};
    // color scheme
    json.colorScheme = this.heatmap.getColorScheme().toJSON();

    json.name = this.options.name;

    json.showRowNumber = this.isShowRowNumber();

    // annotation shapes
    json.rowShapeModel = this.getProject().getRowShapeModel().toJSON(this.getVisibleTracks(false));
    json.columnShapeModel = this.getProject().getColumnShapeModel().toJSON(this.getVisibleTracks(true));

    // annotation font
    json.rowFontModel = this.getProject().getRowFontModel().toJSON(this.getVisibleTracks(false));
    json.columnFontModel = this.getProject().getColumnFontModel().toJSON(this.getVisibleTracks(true));

    // annotation colors
    json.rowColorModel = this.getProject().getRowColorModel().toJSON(this.getVisibleTracks(false));
    json.columnColorModel = this.getProject().getColumnColorModel().toJSON(this.getVisibleTracks(true));
    // annotation display
    json.rows = this.getVisibleTracks(false).map(function (track) {
      var size = morpheus.CanvasUtil.getPreferredSize(_this.getTrackHeaderByIndex(_this.getTrackIndex(track.getName(), false), false));
      var obj = track.settings;
      obj.field = track.getName();
      obj.size = {
        width: size.widthSet ? size.width : undefined
      };
      return obj;
    });
    json.columns = this.getVisibleTracks(true).map(function (track) {
      var size = morpheus.CanvasUtil.getPreferredSize(_this.getTrackHeaderByIndex(_this.getTrackIndex(track.getName(), true), true));
      var obj = track.settings;
      obj.field = track.getName();
      obj.size = {
        width: size.widthSet ? size.width : undefined,
        height: size.heightSet ? size.height : undefined
      };
      return obj;
    });

    // sort
    json.rowSortBy = morpheus.SortKey.toJSON(this.getProject().getRowSortKeys());
    json.columnSortBy = morpheus.SortKey.toJSON(this.getProject().getColumnSortKeys());

    // group
    json.rowGroupBy = morpheus.SortKey.toJSON(this.getProject().getGroupRows());
    json.columnGroupBy = morpheus.SortKey.toJSON(this.getProject().getGroupColumns());

    // filter
    json.rowFilter = morpheus.CombinedFilter.toJSON(this.getProject().getRowFilter());
    json.columnFilter = morpheus.CombinedFilter.toJSON(this.getProject().getColumnFilter());

    // element size, symmetric
    json.symmetric = this.options.symmetric;
    json.rowSize = this.heatmap.getRowPositions().getSize();
    json.columnSize = this.heatmap.getColumnPositions().getSize();
    json.rowGapSize = this.heatmap.rowGapSize;
    json.columnGapSize = this.heatmap.columnGapSize;
    json.drawGrid = this.heatmap.isDrawGrid();
    json.gridColor = this.heatmap.getGridColor();
    json.gridThickness = this.heatmap.getGridThickness();
    json.drawValues = this.heatmap.isDrawValues();

    // selection
    json.rowSelection = this.getProject().getRowSelectionModel().toModelIndices();
    json.columnSelection = this.getProject().getColumnSelectionModel().toModelIndices();

    // search terms
    json.rowSearchTerm = this.toolbar.getSearchField(morpheus.HeatMapToolBar.ROW_SEARCH_FIELD).val();
    json.columnSearchTerm = this.toolbar.getSearchField(morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD).val();

    //  dendrogram
    if (this.rowDendrogram != null) {
      var out = [];
      morpheus.DendrogramUtil.writeNewick(this.rowDendrogram.tree.rootNode, out, function (n) {
        return n.index;
      });
      json.rowDendrogram = out.join('');
      json.rowDendrogramField = null;
    }
    if (this.columnDendrogram != null) {
      var out = [];
      morpheus.DendrogramUtil.writeNewick(this.columnDendrogram.tree.rootNode, out, function (n) {
        return n.index;
      });
      json.columnDendrogram = out.join('');
      json.columnDendrogramField = null;
    }
    if (options.dataset) {
      json.dataset = morpheus.Dataset.toJSON(this.getProject().getFullDataset());
    }

    return json;
  },
  /**
   * @param tree
   *            An object with maxHeight, a rootNode, leafNodes, and
   *            nLeafNodes
   */
  setDendrogram: function (tree, isColumns, modelOrder) {
    var dendrogram = isColumns ? this.columnDendrogram : this.rowDendrogram;
    if (dendrogram) {
      dendrogram.dispose();
      dendrogram = null;
    }
    if (tree != null) {
      //  var modelIndexSet = new morpheus.Set();
      var size = isColumns ? this.project.getFullDataset().getColumnCount() : this.project.getFullDataset().getRowCount();
      if (isColumns) {
        dendrogram = new morpheus.ColumnDendrogram(this, tree,
          this.heatmap.getColumnPositions(), this.project);
        dendrogram.filter = this.project.getColumnFilter().shallowClone();
        this.columnDendrogram = dendrogram;
        var sortKey = new morpheus.SpecifiedModelSortOrder(modelOrder,
          modelOrder.length, 'dendrogram', true);
        sortKey.setPreservesDendrogram(true);
        sortKey.setLockOrder(2);
        sortKey.setUnlockable(false);
        this.project.setColumnSortKeys(
          [sortKey], true);
      } else {
        dendrogram = new morpheus.RowDendrogram(this, tree,
          this.heatmap.getRowPositions(), this.project);
        dendrogram.filter = this.project.getRowFilter().shallowClone();
        this.rowDendrogram = dendrogram;
        var sortKey = new morpheus.SpecifiedModelSortOrder(modelOrder,
          modelOrder.length, 'dendrogram', false);
        sortKey.setPreservesDendrogram(true);
        sortKey.setLockOrder(2);
        sortKey.setUnlockable(false);
        this.project.setRowSortKeys(
          [sortKey], true);
      }
      dendrogram.appendTo(this.$parent);
      dendrogram.$label.appendTo(this.$parent);
      dendrogram.$squishedLabel.appendTo(this.$parent);

    } else { // no more dendrogram
      var sortKeys = isColumns ? this.project.getColumnSortKeys()
        : this.project.getRowSortKeys();
      // remove dendrogram sort key
      for (var i = 0; i < sortKeys.length; i++) {
        if (sortKeys[i].isPreservesDendrogram()) {
          sortKeys.splice(i, 1);
          i--;
        }
      }
      if (isColumns) {
        this.heatmap.getColumnPositions().setSquishedIndices(null);
        delete this.columnDendrogram;
        this.project.setColumnSortKeys(sortKeys, true);
      } else {
        delete this.rowDendrogram;
        this.project.setRowSortKeys(sortKeys, true);
        this.heatmap.getRowPositions().setSquishedIndices(null);
      }

    }
    // FIXME update grouping
    this.trigger('dendrogramChanged', {
      isColumns: isColumns
    });
  },
  getTabManager: function () {
    return this.tabManager;
  },
  getSelectedElementsText: function () {
    var _this = this;
    var project = this.project;
    var selectedViewIndices = project.getElementSelectionModel().getViewIndices();
    if (selectedViewIndices.size() > 0) {
      var tipText = [];
      var dataset = project.getSortedFilteredDataset();
      var rowTracks = _this.rowTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      });
      var columnTracks = _this.columnTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      });
      selectedViewIndices.forEach(function (id) {
        var rowIndex = id.getArray()[0];
        var columnIndex = id.getArray()[1];
        tipText.push(morpheus.Util.nf(dataset.getValue(rowIndex,
          columnIndex)));
        rowTracks.forEach(function (track) {
          tipText.push('\t');
          tipText.push(morpheus.Util.toString(dataset.getRowMetadata().getByName(track.name).getValue(
            rowIndex)));
        });
        columnTracks.forEach(function (track) {
          tipText.push('\t');
          tipText.push(morpheus.Util.toString(dataset.getColumnMetadata().getByName(track.name).getValue(columnIndex)));
        });

        tipText.push('\n');

      });
      return tipText.join('');

    }

  },
  _init: function () {
    var _this = this;
    morpheus.MetadataUtil.renameFields(this.options.dataset, this.options);
    var dataset = this.options.dataset;
    var rowDendrogram = this.options.rowDendrogram;
    var columnDendrogram = this.options.columnDendrogram;
    _.each(this.whenLoaded, function (f) {
      f(_this.options.dataset);
    });
    if (this.options.datasetReady) {
      var updatedDataset = this.options.datasetReady(dataset);
      if (updatedDataset) {
        dataset = updatedDataset;
      }
    }

    this.project = new morpheus.Project(dataset);

    if (this.tabManager) {
      this.tabManager.setTabTitle(this.tabId, this.project.getFullDataset().getRowCount()
        + ' row'
        + morpheus.Util.s(this.project.getFullDataset().getRowCount())
        + ' x '
        + this.project.getFullDataset().getColumnCount()
        + ' column'
        + morpheus.Util.s(this.project.getFullDataset().getColumnCount()));
    }
    if (this.options.inheritFromParent && this.options.parent != null) {
      morpheus.HeatMap.copyFromParent(this.project, this.options);
    }

    // filter ui will be initialized automatically
    if (this.options.rowFilter) {
      morpheus.CombinedFilter.fromJSON(_this.project.getRowFilter(), this.options.rowFilter);
      _this.project.setRowFilter(_this.project.getRowFilter(), true);
    }
    if (this.options.columnFilter) {
      morpheus.CombinedFilter.fromJSON(_this.project.getColumnFilter(), this.options.columnFilter);
      _this.project.setColumnFilter(_this.project.getColumnFilter(), true);
    }
    this.whenLoaded = null;
    this.$parent = $('<div></div>').css('position', 'relative');

    this.$parent.appendTo(this.$content);
    if (!morpheus.Util.isHeadless()) {
      this.toolbar = new morpheus.HeatMapToolBar(this);
    }

    // scroll bars at the bottom of the heatmap, and right of the heatmap
    // TODO along bottom of row metadata, and along left of column metadata
    // the viewport is the size of the visible region, the view is the full
    // size of the heat map
    this.vscroll = new morpheus.ScrollBar(true);
    this.vscroll.appendTo(this.$parent);
    this.vscroll.on('scroll', function () {
      if (_this.updatingScroll) {
        return;
      }
      _this.paintAll({
        paintRows: true,
        paintColumns: false,
        invalidateRows: true,
        invalidateColumns: false
      });
    });

    // for resizing column dendrogram
    this.beforeColumnTrackDivider = new morpheus.Divider(false);
    this.beforeColumnTrackDivider.appendTo(this.$parent);
    var dragStartHeight = 0;
    this.beforeColumnTrackDivider.on('resizeStart', function (e) {
      dragStartHeight = _this.columnDendrogram.getUnscaledHeight();
    }).on('resize', function (e) {
      // grow or shrink the column dendrogram
      var newHeight = Math.max(8, dragStartHeight + e.delta);
      _this.columnDendrogram.setPrefHeight(newHeight);
      _this.revalidate();
    }).on('resizeEnd', function () {
      dragStartHeight = 0;
    });

    // for resizing row dendrogram
    this.afterRowDendrogramDivider = new morpheus.Divider(true);
    this.afterRowDendrogramDivider.appendTo(this.$parent);
    var rowDendrogramStartWidth = 0;
    this.afterRowDendrogramDivider.on('resizeStart', function (e) {
      rowDendrogramStartWidth = _this.rowDendrogram.getUnscaledWidth();
    }).on('resize', function (e) {
      // grow or shrink the column dendrogram
      var newWidth = Math.max(8, rowDendrogramStartWidth + e.delta);
      _this.rowDendrogram.setPrefWidth(newWidth);
      _this.revalidate();
    }).on('resizeEnd', function () {
      rowDendrogramStartWidth = 0;
    });

    this.afterVerticalScrollBarDivider = new morpheus.Divider(true);
    this.afterVerticalScrollBarDivider.appendTo(this.$parent);
    var resizeStartHeatMapWidth = 0;
    this.afterVerticalScrollBarDivider.on('resizeStart', function (e) {
      resizeStartHeatMapWidth = _this.heatmap.getUnscaledWidth();
    }).on('resize', function (e) {
      // grow or shrink the heat map
      _this.heatmap.prefWidth = resizeStartHeatMapWidth + e.delta;
      _this.revalidate();
    });
    // horizontal scroll
    this.hscroll = new morpheus.ScrollBar(false);
    this.hscroll.appendTo(this.$parent);
    this.hscroll.on('scroll', function () {
      if (_this.updatingScroll) {
        return;
      }
      _this.paintAll({
        paintRows: false,
        paintColumns: true,
        invalidateRows: false,
        invalidateColumns: true
      });
    });
    this.$whitespace = $('<div style="position: absolute;"></div>');
    this.$whitespace.appendTo(this.$parent);
    var heatmap = new morpheus.HeatMapElementCanvas(this.project);
    if (this.options.drawCallback) {
      heatmap.setDrawCallback(this.options.drawCallback);
    }

    $(heatmap.canvas).on(
      'contextmenu',
      function (e) {
        var items = [];
        morpheus.Popup.showPopup(
          [

            {
              name: 'Copy Image',
              class: 'copy'
            },
            {
              name: 'Save Image (' + morpheus.Util.COMMAND_KEY + 'S)'
            },
            // {
            //   name: 'Copy Selection',
            //   disabled: _this.project
            //   .getElementSelectionModel()
            //   .count() === 0,
            //   class: 'copy'
            // },
            {
              separator: true
            },
            {
              name: 'Show Inline Tooltip',
              checked: _this.options.inlineTooltip
            }],
          {
            x: e.pageX,
            y: e.pageY
          },
          e.target,
          function (event, item) {
            if (item === 'Show Inline Tooltip') {
              _this.options.inlineTooltip = !_this.options.inlineTooltip;
            } else if (item === ('Save Image (' + morpheus.Util.COMMAND_KEY + 'S)')) {
              _this.getActionManager().execute('Save Image');
            } else if (item === 'Copy Selection') {
              var text = _this.getSelectedElementsText();
              if (text !== '') {
                event.clipboardData.setData(
                  'text/plain',
                  text);
              }
            } else if (item === 'Copy Image') {
              _this.getActionManager().execute('Copy Image', {event: event});
            } else {
              console.log(item + ' unknown.');
            }
          });

        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      });
    heatmap.appendTo(this.$parent);
    this.heatmap = heatmap;
    var rowDendrogramSortKey = null;
    if (rowDendrogram != null) {
      var tree = rowDendrogram;
      if (tree.leafNodes.length !== this.project.getSortedFilteredDataset().getRowCount()) {
        throw '# leaf nodes in row dendrogram ' + tree.leafNodes.length
        + ' != ' + this.project.getSortedFilteredDataset().getRowCount();
      }
      var rowIndices = null;
      // when saving a session the dataset is reordered to reflect the clustering
      if (this.options.rowDendrogramField != null) {
        var vector = dataset.getRowMetadata().getByName(
          this.options.rowDendrogramField);
        rowIndices = [];
        var map = new morpheus.Map();
        var re = /[,:]/g;
        for (var j = 0, size = vector.size(); j < size; j++) {
          var key = vector.getValue(j);
          map.set(key.replace(re, ''), j);
        }
        // need to replace special characters to match ids in newick
        // file

        for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
          var index = map.get(tree.leafNodes[i].name);
          if (index === undefined) {
            throw 'Unable to find row dendrogram id '
            + tree.leafNodes[i].name
            + ' in row annotations';
          }
          rowIndices.push(index);
        }
      } else {
        // see if leaf node ids are indices
        // for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //   var newickId = tree.leafNodes[i].name;
        //   newickId = parseInt(newickId);
        //   if (!isNaN(newickId)) {
        //     rowIndices.push(newickId);
        //   } else {
        //     break;
        //   }
        // }
        // if (rowIndices.length !== tree.leafNodes.length) {
        //   rowIndices = [];
        //   for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //     rowIndices.push(i);
        //   }
        // }
      }
      this.rowDendrogram = new morpheus.RowDendrogram(this, tree, heatmap.getRowPositions(), this.project, true);
      this.rowDendrogram.appendTo(this.$parent);
      this.rowDendrogram.$label.appendTo(this.$parent);
      this.rowDendrogram.$squishedLabel.appendTo(this.$parent);
      if (rowIndices != null) {
        rowDendrogramSortKey = new morpheus.SpecifiedModelSortOrder(
          rowIndices, rowIndices.length, 'dendrogram');
        rowDendrogramSortKey.setLockOrder(2);
        rowDendrogramSortKey.setUnlockable(false);
        rowDendrogramSortKey.setPreservesDendrogram(true);
      }
    }
    var columnDendrogramSortKey = null;
    if (columnDendrogram != null) {
      var tree = columnDendrogram;

      if (tree.leafNodes.length !== this.project.getSortedFilteredDataset().getColumnCount()) {
        throw '# leaf nodes ' + tree.leafNodes.length + ' != '
        + this.project.getSortedFilteredDataset().getColumnCount();
      }
      var columnIndices = null;
      if (this.options.columnDendrogramField != null) {
        columnIndices = [];
        var vector = dataset.getColumnMetadata().getByName(
          this.options.columnDendrogramField);
        var map = new morpheus.Map();
        var re = /[,:]/g;
        for (var j = 0, size = vector.size(); j < size; j++) {
          var key = vector.getValue(j);
          map.set(key.replace(re, ''), j);
        }

        for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
          var index = map.get(tree.leafNodes[i].name);
          if (index === undefined) {
            throw 'Unable to find column dendrogram id '
            + tree.leafNodes[i].name
            + ' in column annotations';
          }
          columnIndices.push(index);
        }
      } else {
        // for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //   var newickId = tree.leafNodes[i].name;
        //   newickId = parseInt(newickId);
        //   if (!isNaN(newickId)) {
        //     columnIndices.push(newickId);
        //   } else {
        //     break;
        //   }
        // }
        // if (columnIndices.length !== tree.leafNodes.length) {
        //   columnIndices = [];
        //   for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //     columnIndices.push(i);
        //   }
        // }
      }
      this.columnDendrogram = new morpheus.ColumnDendrogram(this, tree,
        heatmap.getColumnPositions(), this.project, true);
      this.columnDendrogram.appendTo(this.$parent);
      this.columnDendrogram.$label.appendTo(this.$parent);
      this.columnDendrogram.$squishedLabel.appendTo(this.$parent);
      if (columnIndices != null) {
        columnDendrogramSortKey = new morpheus.SpecifiedModelSortOrder(
          columnIndices, columnIndices.length, 'dendrogram');
        columnDendrogramSortKey.setLockOrder(2);
        columnDendrogramSortKey.setUnlockable(false);
        columnDendrogramSortKey.setPreservesDendrogram(true);
      }
    }

    if (this.options.drawGrid != null) {
      this.heatmap.setDrawGrid(this.options.drawGrid);
    }

    if (this.options.gridColor != null) {
      this.heatmap.setGridColor(this.options.gridColor);
    }
    if (this.options.gridThickness != null) {
      this.heatmap.setGridThickness(this.options.gridThickness);
    }
    if (this.options.drawValues != null) {
      this.heatmap.setDrawValues(this.options.drawValues);
    }

    if (rowDendrogramSortKey != null) {
      this.project.setRowSortKeys([rowDendrogramSortKey]);
    }
    if (columnDendrogramSortKey != null) {
      this.project.setColumnSortKeys([columnDendrogramSortKey]);
    }
    if (this.options.rowSortBy && this.options.rowSortBy.length > 0) {
      this.project.setRowSortKeys(morpheus.SortKey.fromJSON(this.project, this.options.rowSortBy), false);
    }
    if (this.options.columnSortBy && this.options.columnSortBy.length > 0) {
      this.project.setColumnSortKeys(morpheus.SortKey.fromJSON(this.project, this.options.columnSortBy), false);
    }
    if (this.options.rowGroupBy != null && this.options.rowGroupBy.length > 0) {
      var keys = morpheus.SortKey.fromJSON(this.project, this.options.rowGroupBy);
      for (var i = 0; i < keys.length; i++) {
        this.project.groupRows.push(keys[i]);
      }
    }
    if (this.options.columnGroupBy != null && this.options.columnGroupBy.length > 0) {
      var keys = morpheus.SortKey.fromJSON(this.project, this.options.columnGroupBy);
      for (var i = 0; i < keys.length; i++) {
        this.project.groupColumns.push(keys[i]);
      }
    }
    if (this.options.rowSelection != null && this.options.rowSelection.length > 0) {
      var indices = new morpheus.Set();
      for (var i = 0, length = this.options.rowSelection.length; i < length; i++) {
        indices.add(this.project.convertModelRowIndexToView(this.options.rowSelection[i]));
      }
      this.project.getRowSelectionModel().setViewIndices(indices, false);
    }
    if (this.options.columnSelection != null && this.options.columnSelection.length > 0) {
      var indices = new morpheus.Set();
      for (var i = 0, length = this.options.columnSelection.length; i < length; i++) {
        indices.add(this.project.convertModelColumnIndexToView(this.options.columnSelection[i]));
      }
      this.project.getColumnSelectionModel().setViewIndices(indices, false);
    }
    // if (this.options.rowSearchTerm != null && this.options.rowSearchTerm !== '') {
    //   this.toolbar.getSearchField(morpheus.HeatMapToolBar.ROW_SEARCH_FIELD).val(this.options.rowSearchTerm);
    // }
    // if (this.options.columnSearchTerm != null && this.options.columnSearchTerm !== '') {
    //   this.toolbar.getSearchField(morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD).val(this.options.columnSearchTerm);
    // }

    this.vSortByValuesIndicator = new morpheus.SortByValuesIndicator(
      this.project, true, heatmap.getRowPositions());
    this.vSortByValuesIndicator.appendTo(this.$parent);
    this.hSortByValuesIndicator = new morpheus.SortByValuesIndicator(
      this.project, false, heatmap.getColumnPositions());
    this.hSortByValuesIndicator.appendTo(this.$parent);
    this.verticalSearchBar = new morpheus.ScentedSearch(this.project.getRowSelectionModel(), heatmap.getRowPositions(), true,
      this.vscroll, this);
    this.horizontalSearchBar = new morpheus.ScentedSearch(this.project.getColumnSelectionModel(), heatmap.getColumnPositions(),
      false, this.hscroll, this);
    this.rowTracks = [];
    this.rowTrackHeaders = [];
    this.columnTracks = [];
    this.columnTrackHeaders = [];
    if (this.options.rowSize != null && this.options.rowSize !== 'fit') {
      this.heatmap.getRowPositions().setSize(this.options.rowSize);
    }
    if (this.options.columnSize != null && this.options.columnSize !== 'fit') {
      this.heatmap.getColumnPositions().setSize(
        this.options.columnSize);
    }
    var setInitialDisplay = function (isColumns, options) {
      var nameToOption = new morpheus.Map();
      // at
      // least
      // one
      // display option
      // supplied

      var displaySpecified = (_this.options.parent != null && _this.options.inheritFromParent);
      if (options != null && options.length > 0) {
        displaySpecified = true;
        for (var i = 0; i < options.length; i++) {
          nameToOption.set(options[i].renameTo != null ? options[i].renameTo
            : options[i].field, options[i]);
        }
      }

      var displayMetadata = isColumns ? dataset.getColumnMetadata()
        : dataset.getRowMetadata();
      // see if default fields found
      if (!displaySpecified) {
        var defaultFieldsToShow = new morpheus.Set();
        ['pert_iname', 'moa', 'target', 'description', 'cell_id', 'pert_type'].forEach(function (field) {
          defaultFieldsToShow.add(field);
        });
        for (var i = 0, metadataCount = displayMetadata.getMetadataCount(); i < metadataCount; i++) {
          var v = displayMetadata.get(i);
          if (defaultFieldsToShow.has(v.getName()) && !nameToOption.has(v.getName())) {
            nameToOption.set(v.getName(), {
              display: ['text']
            });
            displaySpecified = true;
          }
        }
      }
      var isFirst = true;
      for (var i = 0, metadataCount = displayMetadata.getMetadataCount(); i < metadataCount; i++) {
        var v = displayMetadata.get(i);
        var name = v.getName();
        var option = nameToOption.get(name);
        if (displaySpecified && option == null) {
          continue;
        }
        if (morpheus.MetadataUtil.DEFAULT_HIDDEN_FIELDS.has(name)
          && option == null) {
          continue;
        }
        var count = isColumns ? dataset.getColumnCount() : dataset.getRowCount();
        if (option == null && !displaySpecified && count > 1
          && !morpheus.VectorUtil.containsMoreThanOneValue(v)) {
          continue;
        }
        if (option == null) {
          option = {};
        }
        if (option.title) {
          v.getProperties().set(morpheus.VectorKeys.TITLE,
            option.title);
        }

        if (option.display == null) {
          if (name === 'pert_iname' || name === 'id' || isFirst) {
            option.inlineTooltip = true;
            option.display = ['text'];
          } else {
            option.display = isColumns ? 'color,highlight' : 'text';
          }
        }
        isFirst = false;
        var track = _this.addTrack(name, isColumns, option);

        if (option.size) {
          if (!isColumns && option.size.width != null) {
            var header = _this.getTrackHeaderByIndex(_this.getTrackIndex(name, isColumns), isColumns);
            track.setPrefWidth(option.size.width); // can only set width
            header.setPrefWidth(option.size.width);
          } else if (isColumns && (option.size.width != null || option.size.height != null)) {
            var header = _this.getTrackHeaderByIndex(_this.getTrackIndex(name, isColumns), isColumns);
            if (option.size.height) {
              track.setPrefHeight(option.size.height);
              header.setPrefHeight(option.size.height);
            }
            if (option.size.width) {
              // TODO set width for all tracks since they all have same width
              track.setPrefWidth(option.size.width);
              header.setPrefWidth(option.size.width);
            }
          }
        }
        if (option.header && option.header.font) {
          var header = _this.getTrackHeaderByIndex(_this.getTrackIndex(name, isColumns), isColumns);
          header.font = option.header.font;
        }
        if (option.formatter) {
          v.getProperties().set(morpheus.VectorKeys.FORMATTER, morpheus.Util.createNumberFormat(option.formatter));
        }
        if (track.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
          && option.color) {
          var m = isColumns ? _this.project.getColumnColorModel()
            : _this.project.getRowColorModel();
          if (track.getFullVector().getProperties.get(morpheus.VectorKeys.DISCRETE)) {
            _.each(options.color, function (p) {
              m.setMappedValue(v, p.value, p.color);
            });
          } else {
            var cs = m.createContinuousColorMap(v);
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            _.each(options.color, function (p) {
              min = Math.min(min, p.value);
              max = Math.max(max, p.value);
            });

            cs.setMin(min);
            cs.setMax(max);
            var valueToFraction = d3.scale.linear().domain(
              [cs.getMin(), cs.getMax()]).range(
              [0, 1]).clamp(true);
            var fractions = [];
            var colors = [];
            _.each(options.color, function (p) {
              fractions.push(valueToFraction(p.value));
              colors.push(p.color);
            });

            cs.setFractions({
              fractions: fractions,
              colors: colors
            });
          }

          if (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)
            && option.shape) {
            var m = isColumns ? _this.project.getColumnShapeModel()
              : _this.project.getRowShapeModel();
            _.each(options.shape, function (p) {
              m.setMappedValue(v, p.value, p.shape);
            });

          }
        }
      }
    };
    setInitialDisplay(false, this.options.rows);
    setInitialDisplay(true, this.options.columns);

    function reorderTracks(array, isColumns) {
      if (array == null || array.length <= 1) {
        return;
      }
      var nameOrderPairs = [];
      var found = false;
      array.forEach(function (item, index) {

        var name = item.renameTo || item.field;
        var order = index;
        if (item.order != null) {
          order = item.order;
          found = true;
        }
        nameOrderPairs.push({
          name: name,
          order: order
        });
      });
      if (!found) {
        array.forEach(function (item, index) {
          var name = item.renameTo || item.field;
          nameOrderPairs.push({
            name: name,
            order: index
          });
        });
      }

      nameOrderPairs.sort(function (a, b) {
        return (a.order === b.order ? 0 : (a.order < b.order ? -1
          : 1));
      });
      for (var i = 0, counter = 0; i < nameOrderPairs.length; i++) {
        var index = _this.getTrackIndex(nameOrderPairs[i].name,
          isColumns);
        if (index !== -1) {
          _this.moveTrack(index, counter, isColumns);
          counter++;
        }
      }

    }

    reorderTracks(this.options.rows, false);
    reorderTracks(this.options.columns, true);

    if (this.options.showRowNumber) {
      this.setShowRowNumber(true);
    }
    var colorSchemeSpecified = this.options.colorScheme != null;
    if (this.options.colorScheme == null) {
      var ext = '';
      if (this.options.dataSource) {
        ext = morpheus.Util.getExtension(morpheus.Util.getFileName(this.options.dataSource));
      }

      var colorScheme = this.autoDisplay({
        filename: morpheus.Util.getBaseFileName(morpheus.Util.getFileName(this.options.dataset)),
        extension: ext
      });
      if (colorScheme == null) {
        colorScheme = {
          type: 'relative'
        };
      }
      this.options.colorScheme = colorScheme;
      var name = this.project.getFullDataset().getName();
      if (ext === 'maf' && !this.options.rowSortBy) {
        var sortKeys = [];
        if (this.project.getFullDataset().getRowMetadata().getByName(
            'order')) {
          sortKeys.push(new morpheus.SortKey('order',
            morpheus.SortKey.SortOrder.ASCENDING));
        }
        sortKeys.push(new morpheus.SortKey('id',
          morpheus.SortKey.SortOrder.ASCENDING));
        this.project.setRowSortKeys(sortKeys, false);

      }
      if (morpheus.DatasetUtil.getSeriesIndex(this.project.getFullDataset(), 'allelic_fraction') !== -1) {
        this.options.sizeBy = {
          seriesName: 'allelic_fraction',
          min: 0,
          max: 1
        };
      }

    }
    if (this.options.parent && this.options.inheritFromParent) {
      this.heatmap.setPropertiesFromParent(this.options.parent.heatmap);
    }
    if (this.options.parent && this.options.inheritFromParent
      && !colorSchemeSpecified) {
      heatmap.setColorScheme(this.options.parent.heatmap.getColorScheme().copy(this.project));
    } else {
      heatmap.setColorScheme(new morpheus.HeatMapColorScheme(
        this.project, this.options.colorScheme));
      if (this.options.dataset.getRowMetadata().getByName('Source') != null) {
        // separate color scheme for each source file
        var sourcesSet = morpheus.VectorUtil.getSet(this.options.dataset.getRowMetadata().getByName('Source'));
        this.heatmap.getColorScheme().setSeparateColorSchemeForRowMetadataField('Source');
        sourcesSet.forEach(function (source) {
          _this.autoDisplay({
            extension: morpheus.Util.getExtension(source),
            filename: '' + source
          });
        });
      }
    }

    if (this.options.sizeBy) {
      heatmap.getColorScheme().getSizer().setSeriesName(
        this.options.sizeBy.seriesName);
      heatmap.getColorScheme().getSizer().setMin(
        this.options.sizeBy.min);
      heatmap.getColorScheme().getSizer().setMax(
        this.options.sizeBy.max);
    }

    this.updateDataset();

    // tabOpened is inherited by child heat maps
    if (this.options.tabOpened) {
      this.options.tabOpened(this);
      this.updateDataset();
    }
    // renderReady is only called once for the parent heat map
    if (this.options.renderReady) {
      this.options.renderReady(this);
      this.updateDataset();
    }

    if (this.options.rowSize === 'fit') {
      this.heatmap.getRowPositions().setSize(this.getFitRowSize());
      this.revalidate({
        paint: false
      });
    }
    if (this.options.columnSize === 'fit') {
      this.heatmap.getColumnPositions().setSize(
        this.getFitColumnSize());
      this.revalidate({
        paint: false
      });

    }
    if (this.options.rowColorModel) {
      this.getProject().getRowColorModel().fromJSON(this.options.rowColorModel);
    }
    if (this.options.columnColorModel) {
      this.getProject().getColumnColorModel().fromJSON(this.options.columnColorModel);
    }
    if (this.options.rowShapeModel) {
      this.getProject().getRowShapeModel().fromJSON(this.options.rowShapeModel);
    }
    if (this.options.columnShapeModel) {
      this.getProject().getColumnShapeModel().fromJSON(this.options.columnShapeModel);
    }
    if (this.options.rowFontModel) {
      this.getProject().getRowFontModel().fromJSON(this.options.rowFontModel);
    }
    if (this.options.columnFontModel) {
      this.getProject().getColumnFontModel().fromJSON(this.options.columnFontModel);
    }
    if (this.options.rowSize === 'fit' || this.options.columnSize === 'fit') {
      // note that we have to revalidate twice because column sizes are
      // dependent on row sizes and vice versa
      if (this.options.columnSize === 'fit') {
        this.heatmap.getColumnPositions().setSize(
          this.getFitColumnSize());
        this.revalidate({
          paint: false
        });
      }
      if (this.options.rowSize === 'fit') {
        this.heatmap.getRowPositions().setSize(this.getFitRowSize());
        this.revalidate({
          paint: false
        });
      }
      this.paintAll({
        paintRows: true,
        paintColumns: true,
        invalidateRows: true,
        invalidateColumns: true
      });
    }

    this.options.parent = null; // avoid memory leak
    this.$tipFollow = $('<div style="display:none;"' +
      ' class="morpheus-tip-inline"></div>');
    this.$tipFollow.appendTo(this.$parent);

    this.$tipInfoWindow = $('<div class="morpheus-tip-dialog"></div>');
    this.$tipInfoWindow.appendTo(this.$parent);

    if (!morpheus.Util.isHeadless()) {
      this.$tipInfoWindow.dialog({
        close: function (event, ui) {
          if (!_this._togglingInfoWindow) {
            _this.toggleInfoWindow();
          }
        },
        autoOpen: false,
        width: 220,
        height: 280,
        minHeight: 38,
        minWidth: 10,
        collision: 'fit',
        position: {
          my: 'right-30 bottom',
          at: 'right top',
          of: this.$parent
        },
        title: 'Info'
      });
      this.setTooltipMode(this.options.tooltipMode);
    }

    this.getProject().on(
      'rowFilterChanged columnFilterChanged rowGroupByChanged columnGroupByChanged rowSortOrderChanged columnSortOrderChanged datasetChanged',
      function (e) {
        if (e.type === 'datasetChanged') { // remove
          // tracks
          // that are no
          // longer in the
          // dataset

          var dataset = _this.getProject().getFullDataset();
          for (var i = 0; i < _this.rowTracks.length; i++) {
            var track = _this.rowTracks[i];
            if (!dataset.getRowMetadata().getByName(
                track.getName())) {
              _this.removeTrack(track.getName(),
                false);
              i--;
            }
          }
          for (var i = 0; i < _this.columnTracks.length; i++) {
            var track = _this.columnTracks[i];
            if (!dataset.getColumnMetadata().getByName(
                track.getName())) {
              _this.removeTrack(track.getName(),
                true);
              i--;
            }
          }

        }

        _this.updateDataset();
        _this.revalidate();
      });

    this.getProject().on('trackChanged', function (e) {
      var columns = e.columns;
      _.each(e.vectors, function (v, i) {
        var index = _this.getTrackIndex(v.getName(), columns);
        if (index === -1) {
          _this.addTrack(v.getName(), columns, e.display[i]);
        } else {
          // repaint
          var track = _this.getTrackByIndex(index, columns);
          var display = e.display[i];
          if (display) {
            track.settingFromConfig(display);
          }
          track.setInvalid(true);
        }
      });
      _this.revalidate();
    });
    this.getProject().on('rowTrackRemoved', function (e) {
      _this.removeTrack(e.vector.getName(), false);
      _this.revalidate();
    });
    this.getProject().on('columnTrackRemoved', function (e) {
      _this.removeTrack(e.vector.getName(), true);
      _this.revalidate();
    });
    this.getProject().getRowSelectionModel().on(
      'selectionChanged',
      function () {
        // repaint tracks that indicate selection
        for (var i = 0; i < _this.columnTracks.length; i++) {
          var track = _this.columnTracks[i];
          if (track.getFullVector().getProperties().get(morpheus.VectorKeys.RECOMPUTE_FUNCTION_SELECTION)) {
            var selectedDataset = _this.getProject().getSelectedDataset({
              selectedRows: true,
              selectedColumns: false,
              emptyToAll: false
            });
            var vector = selectedDataset.getColumnMetadata().getByName(track.getName());
            var f = morpheus.VectorUtil.jsonToFunction(vector, morpheus.VectorKeys.FUNCTION);
            if (typeof f === 'function') {
              // iterate over each column
              var view = new morpheus.DatasetColumnView(selectedDataset);
              // TODO only set values that are currently visible
              for (var j = 0, size = vector.size(); j < size; j++) {
                view.setIndex(j);
                vector.setValue(j, f(view, selectedDataset, j));
              }
              track.setInvalid(true);
              track.repaint();
            }
          }
        }
        _this.verticalSearchBar.update();
        _this.heatmap.updateRowSelectionCache();
        _this.paintAll({
          paintRows: true,
          paintColumns: false,
          invalidateRows: false,
          invalidateColumns: false
        });
      });
    this.getProject().getColumnSelectionModel().on('selectionChanged',
      function () {
        _this.horizontalSearchBar.update();
        _this.heatmap.updateColumnSelectionCache();
        _this.paintAll({
          paintRows: false,
          paintColumns: true,
          invalidateRows: false,
          invalidateColumns: false
        });
      });

    this.pasteListener = function (e) {
      if (_this.isActiveComponent()) {
        var text = e.originalEvent.clipboardData.getData('text/plain');
        if (text != null && text.length > 0) {
          e.preventDefault();
          e.stopPropagation();
          // open a file from clipboard
          var url;
          if (text.indexOf('http') === 0) {
            url = text;
          } else {
            var blob = new Blob([text], {type: 'text/plain'});
            url = URL.createObjectURL(blob);
          }
          morpheus.HeatMap.showTool(
            new morpheus.OpenFileTool({
              file: url
            }), _this);
        }
      }
    };
    this.beforeCopyListener = function (e) {
      if (_this.isActiveComponent()) {
        e.preventDefault();
      }

    };
    this.copyListener = function (ev) {
      if (_this.isActiveComponent()) {
        var activeComponent = _this.getActiveComponent();
        var project = _this.project;
        if (activeComponent === 'heatMap' || ev.shiftKey) {
          // copy selected text or image
          // var text = _this.getSelectedElementsText();
          // if (text !== '') {
          // 	ev.originalEvent.clipboardData.setData(
          // 		'text/plain', text);
          // 	return;
          // }
          var bounds = _this.getTotalSize();
          var height = bounds.height;
          var width = bounds.width;
          var canvas = $('<canvas></canvas>')[0];
          canvas.height = height;
          canvas.width = width;
          var context = canvas.getContext('2d');
          _this.snapshot(context);
          var url = canvas.toDataURL();
          ev.originalEvent.clipboardData.setData(
            'text/html',
            '<img src="' + url + '">');
          ev.preventDefault();
          ev.stopImmediatePropagation();
          return;
        }
        // copy all selected rows and columns
        var dataset = project.getSelectedDataset({
          emptyToAll: false
        });
        var rowsSelected = dataset.getRowCount() > 0;
        var columnsSelected = dataset.getColumnCount() > 0;
        var columnMetadata = dataset.getColumnMetadata();
        var rowMetadata = dataset.getRowMetadata();
        // only copy visible tracks
        var visibleColumnFields = _this.getVisibleTrackNames(true);
        var columnFieldIndices = [];
        _.each(visibleColumnFields, function (name) {
          var index = morpheus.MetadataUtil.indexOf(
            columnMetadata, name);
          if (index !== -1) {
            columnFieldIndices.push(index);
          }
        });
        columnMetadata = new morpheus.MetadataModelColumnView(
          columnMetadata, columnFieldIndices);
        var rowMetadata = dataset.getRowMetadata();
        // only copy visible tracks
        var visibleRowFields = _this.getVisibleTrackNames(false);
        var rowFieldIndices = [];
        _.each(visibleRowFields, function (name) {
          var index = morpheus.MetadataUtil.indexOf(
            rowMetadata, name);
          if (index !== -1) {
            rowFieldIndices.push(index);
          }
        });
        rowMetadata = new morpheus.MetadataModelColumnView(
          rowMetadata, rowFieldIndices);
        var text = [];

        if (rowsSelected && columnsSelected) { // copy
          // as
          // gct
          // 1.3
          text = new morpheus.GctWriter().write(dataset);
        } else {
          var text = [];
          var model = rowsSelected ? rowMetadata
            : columnMetadata;
          for (var i = 0, count = model.getItemCount(); i < count; i++) {
            for (var j = 0, nfields = model.getMetadataCount(); j < nfields; j++) {
              var v = model.get(j);
              if (j > 0) {
                text.push('\t');
              }
              text.push(morpheus.Util.toString(v.getValue(i)));
            }
            text.push('\n');
          }
          text = text.join('');
        }
        ev.originalEvent.clipboardData.setData(
          'text/plain', text);
        ev.preventDefault();
        ev.stopImmediatePropagation();

      }
    };

    if (typeof window !== 'undefined') {
      $(window)
        .on('paste.morpheus', this.pasteListener)
        .on('beforecopy.morpheus', this.beforeCopyListener)
        .on('copy.morpheus', this.copyListener);
    }
    if (this.options.keyboard && !morpheus.Util.isHeadless()) {
      new morpheus.HeatMapKeyListener(this);
    }
    if (this.options.symmetric) {
      this.getProject().setSymmetric(this);
    }
    var dragStartScrollTop;
    var dragStartScrollLeft;
    var panstartMousePosition;
    this.hammer = morpheus.Util.hammer(_this.heatmap.canvas, ['pan', 'pinch', 'tap', 'swipe']).on('swipe', this.swipe = function (event) {
      event.preventDefault();
    }).on('panend', this.panend = function (event) {
      _this.panning = false;
      if (panstartMousePosition) {
        panstartMousePosition = null;
        _this.heatmap.setSelectionBox(null);
        _this.heatmap.repaint();
      }
      event.preventDefault();
    }).on('panmove', this.panmove = function (event) {
      if (panstartMousePosition) {
        var pos = morpheus.CanvasUtil.getMousePosWithScroll(event.target, event,
          _this.scrollLeft(), _this.scrollTop());
        var rowIndex = _this.heatmap.getRowPositions().getIndex(pos.y, false);
        var columnIndex = _this.heatmap.getColumnPositions().getIndex(pos.x, false);
        _this.updatingScroll = false;
        _this.heatmap.setSelectionBox({
          y: [panstartMousePosition.rowIndex, rowIndex],
          x: [panstartMousePosition.columnIndex, columnIndex]
        });
        var rowIndices = new morpheus.Set();
        for (var i = Math.min(panstartMousePosition.rowIndex, rowIndex),
               end = Math.max(panstartMousePosition.rowIndex, rowIndex); i <= end; i++) {
          rowIndices.add(i);
        }
        var columnIndices = new morpheus.Set();
        for (var i = Math.min(panstartMousePosition.columnIndex, columnIndex),
               end = Math.max(panstartMousePosition.columnIndex, columnIndex); i <= end; i++) {
          columnIndices.add(i);
        }
        _this.project.getRowSelectionModel().setViewIndices(rowIndices, true);
        _this.project.getColumnSelectionModel().setViewIndices(columnIndices, true);
        // _this.heatmap.repaint(); don't need to repaint as setViewIndices triggers repaint
      } else {
        _this.updatingScroll = true; // avoid infinite paints
        var rows = false;
        var columns = false;
        if (event.deltaY !== 0) {
          var pos = dragStartScrollTop + event.deltaY;
          _this.scrollTop(pos);
          rows = true;
        }
        if (event.deltaX !== 0) {
          var pos = dragStartScrollLeft + event.deltaX;
          _this.scrollLeft(pos);
          columns = true;
        }
        _this.updatingScroll = false;
        if (rows || columns) {
          _this.paintAll({
            paintRows: rows,
            paintColumns: rows,
            invalidateRows: rows,
            invalidateColumns: columns
          });
        }
      }
      event.preventDefault();
    }).on('panstart', this.panstart = function (event) {
      _this.panning = true; // don't draw inline tooltips when panning
      _this.project.setHoverRowIndex(-1);
      _this.project.setHoverColumnIndex(-1);

      if (event.srcEvent.shiftKey) {
        var pos = morpheus.CanvasUtil.getMousePosWithScroll(event.target, event,
          _this.scrollLeft(), _this.scrollTop());
        panstartMousePosition = {
          rowIndex: _this.heatmap.getRowPositions().getIndex(pos.y, false),
          columnIndex: _this.heatmap.getColumnPositions().getIndex(pos.x, false)
        };
      } else {
        panstartMousePosition = null;
        dragStartScrollTop = _this.scrollTop();
        dragStartScrollLeft = _this.scrollLeft();
      }
      event.preventDefault();
    }).on(
      'tap',
      this.tap = function (event) {
        // var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
        //   : event.srcEvent.ctrlKey;
        if (morpheus.Util.IS_MAC && event.srcEvent.ctrlKey) { // right-click
          // on
          // Mac
          return;
        }
        _this.project.getRowSelectionModel().setViewIndices(new morpheus.Set(), true);
        _this.project.getColumnSelectionModel().setViewIndices(new morpheus.Set(), true);
        // var position = morpheus.CanvasUtil
        // .getMousePosWithScroll(event.target, event,
        //   _this.scrollLeft(), _this
        //   .scrollTop());
        // var rowIndex = _this.heatmap.getRowPositions()
        // .getIndex(position.y, false);
        // var columnIndex = _this.heatmap
        // .getColumnPositions().getIndex(position.x,
        //   false);
        // _this.project.getElementSelectionModel().click(
        //   rowIndex, columnIndex,
        //   event.srcEvent.shiftKey || commandKey);
      }).on(
      'pinch',
      this.pinch = function (event) {
        var scale = event.scale;
        _this.heatmap.getRowPositions().setSize(13 * scale);
        _this.heatmap.getColumnPositions().setSize(
          13 * scale);
        var reval = {};
        if (_this.project.getHoverRowIndex() !== -1) {
          reval.scrollTop = this.heatmap.getRowPositions().getPosition(
            this.project.getHoverRowIndex());
        }
        if (_this.project.getHoverColumnIndex() !== -1) {
          reval.scrollLeft = this.heatmap.getColumnPositions().getPosition(
            this.project.getHoverColumnIndex());
        }

        _this.revalidate(reval);
        event.preventDefault();
      });
    var heatMapMouseMoved = function (event) {
      var mouseI, mouseJ;
      if (event.type === 'mouseout') {
        mouseI = -1;
        mouseJ = -1;
      } else {
        var position = morpheus.CanvasUtil.getMousePosWithScroll(
          event.target, event, _this.scrollLeft(), _this.scrollTop());
        mouseI = _this.heatmap.getRowPositions().getIndex(position.y,
          false);
        mouseJ = _this.heatmap.getColumnPositions().getIndex(
          position.x, false);
      }
      _this.setMousePosition(mouseI, mouseJ, {
        event: event
      });
    };
    $(_this.heatmap.canvas).on('mouseout', heatMapMouseMoved).on(
      'mousemove', heatMapMouseMoved);
    // tools to run at load time
    _.each(this.options.tools, function (item) {
      var action = _this.getActionManager().getAction(item.name);
      if (action == null) {
        console.log(item.name + ' not found.');
      } else {

        var actionGui = action.gui();
        var gui = actionGui.gui(_this.getProject());
        var formBuilder = new morpheus.FormBuilder();
        _.each(gui, function (item) {
          formBuilder.append(item);
        });
        var input = {};
        _.each(gui, function (item) {
          input[item.name] = formBuilder.getValue(item.name);
        });
        if (item.params) {
          // overide default values
          for (var key in item.params) {
            input[key] = item.params[key];
          }
        }

        actionGui.execute({
          heatMap: _this,
          project: _this.getProject(),
          input: input
        });

      }

    });
  },
  setMousePosition: function (i, j, options) {
    this.mousePositionOptions = options;
    var updateColumns = this.project.getHoverColumnIndex() !== j;
    var updateRows = this.project.getHoverRowIndex() !== i;
    if (updateColumns || updateRows) {
      if (!this.panning) {
        this.project.setHoverRowIndex(i);
        this.project.setHoverColumnIndex(j);
      }
      this.setToolTip(i, j, options);
      this.paintAll({
        paintRows: updateRows,
        paintColumns: updateColumns,
        invalidateRows: false,
        invalidateColumns: false
      });
    } else {
      this._updateTipFollowPosition(options);

    }
    // else if (this.options.tooltipMode === 2 &&
    // (this.project.getHoverColumnIndex() !== -1 || this.project
    // .getHoverRowIndex() !== -1)) {
    //
    // }
    this.trigger('change', {
      name: 'setMousePosition',
      source: this,
      arguments: arguments
    });
  },
  getContentEl: function () {
    return this.$content;
  },
  focus: function () {
    var scrollTop = document.body.scrollTop;
    this.$tabPanel.focus();
    document.body.scrollTop = scrollTop;
  },
  getFocusEl: function () {
    return this.$tabPanel;
  },
  /**
   Set where the tooltip is shown
   @param mode 0 is formula bar, 1 is dialog, -1 is no tooltip
   */

  setTooltipMode: function (mode) {
    this._togglingInfoWindow = true;
    this.options.tooltipMode = mode;
    this.$tipInfoWindow.html('');
    this.toolbar.$tip.html('');
    this.$tipFollow.html('').css({
      display: 'none'
    });
    this.toolbar.$tip.css('display', mode === 0 ? '' : 'none');
    this.setToolTip(-1, -1);
    if (this.options.tooltipMode === 1) {
      this.$tipInfoWindow.dialog('open');
    } else {
      this.$tipInfoWindow.dialog('close');
    }
    this._togglingInfoWindow = false;
  },
  toggleInfoWindow: function () {
    this.setTooltipMode(this.options.tooltipMode == 1 ? 0 : 1);
  },
  _setTipText: function (tipText, tipFollowText, options) {
    if (this.options.tooltipMode === 0) {
      this.toolbar.$tip.html(tipText.join(''));
    } else if (this.options.tooltipMode === 1) {
      this.$tipInfoWindow.html(tipText.join(''));
    }

    if (tipFollowText != null) {
      this.tipFollowHidden = false;
      this.$tipFollow.html(tipFollowText);
      this._updateTipFollowPosition(options);
    } else {
      this.tipFollowHidden = true;
      this.$tipFollow.empty().css({
        display: 'none'
      });
    }
    this.trigger('change', {
      name: 'setToolTip',
      source: this,
      arguments: arguments
    });
  },
  setToolTip: function (rowIndex, columnIndex, options) {
    options = options || {};
    if (this.options.showSeriesNameInTooltip) {
      options.showSeriesNameInTooltip = true;
    }
    if (this.options.tooltipSeriesIndices) {
      options.tooltipSeriesIndices = this.options.tooltipSeriesIndices;
    }
    if (options.heatMapLens) {
      var maxSelectedCount = 20;
      // don't draw lens if currently visible
      // row lens
      var $wrapper = $('<div></div>');
      var wrapperHeight = 0;
      var wrapperWidth = 0;
      var found = false;
      var inline = [];
      var indicesForLens = [];
      // only draw heat map lens if less than maxSelectedCount indices selected
      if (rowIndex != null && rowIndex.length > 0) {
        for (var hoverIndex = 0; hoverIndex < rowIndex.length; hoverIndex++) {
          var row = rowIndex[hoverIndex];
          if (row >= 0 && (row >= this.heatmap.lastPosition.bottom || row < this.heatmap.lastPosition.top)) {
            indicesForLens.push(row);
          } else {
            inline.push(row);
          }
        }
        if (indicesForLens.length < maxSelectedCount) {
          for (var hoverIndex = 0; hoverIndex < indicesForLens.length; hoverIndex++) {
            var row = indicesForLens[hoverIndex];
            var heatMapWidth = this.heatmap.getUnscaledWidth();
            var top = row; // Math.max(0, rowIndex - 1);
            var bottom = row + 1; //Math.min(rowIndex + 1, this.heatmap.rowPositions.getLength());
            var startPix = this.heatmap.rowPositions.getPosition(top);
            var endPix = startPix + this.heatmap.rowPositions.getItemSize(top);
            var heatMapHeight = endPix - startPix;
            var canvas = morpheus.CanvasUtil.createCanvas();
            var trackWidth = 0;
            for (var i = 0, ntracks = this.rowTracks.length; i < ntracks; i++) {
              var track = this.rowTracks[i];
              if (track.isVisible()) {
                trackWidth += track.getUnscaledWidth();
              }
            }

            var canvasWidth = trackWidth + heatMapWidth + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
            canvas.width = canvasWidth * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.width = canvasWidth + 'px';
            canvas.height = heatMapHeight * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.height = heatMapHeight + 'px';
            var context = canvas.getContext('2d');
            morpheus.CanvasUtil.resetTransform(context);
            context.save();
            context.translate(-this.heatmap.lastClip.x, -startPix);
            context.rect(this.heatmap.lastClip.x, startPix, this.heatmap.lastClip.width, this.heatmap.lastClip.height);
            context.clip();
            this.heatmap._draw({
              left: this.heatmap.lastPosition.left,
              right: this.heatmap.lastPosition.right,
              top: top,
              bottom: bottom,
              context: context
            });
            context.restore();
            context.translate(heatMapWidth + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS, -startPix);
            trackWidth = 0;
            for (var i = 0, ntracks = this.rowTracks.length; i < ntracks; i++) {
              var track = this.rowTracks[i];
              if (track.isVisible()) {
                context.save();
                context.translate(trackWidth, 0);
                context.rect(0, startPix, track.getUnscaledWidth(), track.lastClip.height);
                context.clip();
                track._draw({
                  start: top,
                  end: bottom,
                  vector: track.getVector(),
                  context: context,
                  availableSpace: track.getUnscaledWidth()
                });
                context.restore();
                trackWidth += track.getUnscaledWidth();
              }
            }
            $(canvas).appendTo($wrapper);
            canvas.style.top = wrapperHeight + 'px';
            wrapperHeight += parseFloat(canvas.style.height);
            wrapperWidth = parseFloat(canvas.style.width);

          }
        }

        if (indicesForLens.length > 0) {
          if (indicesForLens.length < maxSelectedCount) {
            $wrapper.css({
              height: wrapperHeight,
              width: wrapperWidth
            });

            var rect = this.$parent[0].getBoundingClientRect();
            this.$tipFollow.html($wrapper).css({
              display: '',
              left: Math.round(parseFloat(this.heatmap.canvas.style.left) - 1) + 'px',
              top: (options.event.clientY - rect.top - wrapperHeight / 2) + 'px'
            });
          } else {
            this.$tipFollow.html('');
          }
          return;
        } else {
          var tipText = [];
          var tipFollowText = [];
          if (inline.length < maxSelectedCount) {
            for (var hoverIndex = 0; hoverIndex < inline.length; hoverIndex++) {
              this.tooltipProvider(this, inline[hoverIndex], -1,
                options, this.options.tooltipMode === 0 ? '&nbsp;&nbsp;&nbsp;'
                  : '<br />', false, tipText);
              if (this.options.inlineTooltip) {
                this.tooltipProvider(this, inline[hoverIndex], -1,
                  options, '<br />', true, tipFollowText);

              }
            }
          }
          var text = tipFollowText.join('');
          this._setTipText(tipText, text.length === 0 ? null : '<span style="max-width:400px;">' + text + '</span>', options);
        }
      }
      if (columnIndex != null && columnIndex.length > 0) {
        for (var hoverIndex = 0; hoverIndex < columnIndex.length; hoverIndex++) {
          var column = columnIndex[hoverIndex];
          if (column >= 0 && (column >= this.heatmap.lastPosition.right || column < this.heatmap.lastPosition.left)) {
            indicesForLens.push(column);
          } else {
            inline.push(column);
          }
        }

        if (indicesForLens.length < maxSelectedCount) {
          for (var hoverIndex = 0; hoverIndex < indicesForLens.length; hoverIndex++) {
            var column = indicesForLens[hoverIndex];
            var heatMapHeight = this.heatmap.getUnscaledHeight();
            var left = column; // Math.max(0, rowIndex - 1);
            var right = column + 1; //Math.min(rowIndex + 1, this.heatmap.rowPositions.getLength());
            var startPix = this.heatmap.columnPositions.getPosition(left);
            var endPix = startPix + this.heatmap.columnPositions.getItemSize(left);
            var heatMapWidth = endPix - startPix;
            var canvas = morpheus.CanvasUtil.createCanvas();
            var trackHeight = 0;
            for (var i = 0, ntracks = this.columnTracks.length; i < ntracks; i++) {
              var track = this.columnTracks[i];
              if (track.isVisible()) {
                trackHeight += track.getUnscaledHeight();
              }
            }
            var canvasHeight = trackHeight + heatMapHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
            canvas.width = heatMapWidth * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.width = heatMapWidth + 'px';
            canvas.height = canvasHeight * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.height = canvasHeight + 'px';
            var context = canvas.getContext('2d');
            morpheus.CanvasUtil.resetTransform(context);
            context.translate(-startPix, 0);
            context.save();
            context.rect(startPix, trackHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS,
              this.heatmap.lastClip.width, this.heatmap.lastClip.height + trackHeight +
              morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS);
            context.clip();
            context.translate(0, trackHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS - this.heatmap.lastClip.y);

            this.heatmap._draw({
              top: this.heatmap.lastPosition.top,
              bottom: this.heatmap.lastPosition.bottom,
              left: left,
              right: right,
              context: context
            });
            context.restore();
            trackHeight = 0;
            for (var i = 0, ntracks = this.columnTracks.length; i < ntracks; i++) {
              var track = this.columnTracks[i];
              if (track.isVisible()) {
                context.save();
                context.translate(0, trackHeight);
                context.rect(startPix, 0, track.lastClip.width, track.getUnscaledHeight());
                context.clip();
                track._draw({
                  start: left,
                  end: right,
                  vector: track.getVector(),
                  context: context,
                  availableSpace: track.getUnscaledHeight(),
                  clip: {
                    x: track.lastClip.x,
                    y: track.lastClip.y
                  }
                });
                context.restore();
                trackHeight += track.getUnscaledHeight();
              }
            }
            canvas.style.left = wrapperWidth + 'px';
            wrapperWidth += parseFloat(canvas.style.width);
            wrapperHeight = parseFloat(canvas.style.height);
            $(canvas).appendTo($wrapper);
          }
        }
        if (indicesForLens.length > 0) {
          if (indicesForLens.length < maxSelectedCount) {
            $wrapper.css({
              height: wrapperHeight,
              width: wrapperWidth
            });

            var rect = this.$parent[0].getBoundingClientRect();
            this.$tipFollow.html($wrapper).css({
              top: parseFloat(this.heatmap.canvas.style.top) - trackHeight - morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS - 1,
              left: (options.event.clientX - rect.left) - (wrapperWidth / 2),
              display: ''
            });

          } else {
            this.$tipFollow.html('');
          }
          return;
        } else {
          var tipText = [];
          var tipFollowText = [];
          if (inline.length < maxSelectedCount) {
            for (var hoverIndex = 0; hoverIndex < inline.length; hoverIndex++) {
              this.tooltipProvider(this, -1, inline[hoverIndex],
                options, this.options.tooltipMode === 0 ? '&nbsp;&nbsp;&nbsp;'
                  : '<br />', false, tipText);
              if (this.options.inlineTooltip) {
                this.tooltipProvider(this, -1, inline[hoverIndex],
                  options, '<br />', true, tipFollowText);
              }
            }
          }
          var text = tipFollowText.join('');
          this._setTipText(tipText, text === '' ? null : '<span style="max-width:400px;">' + text + '</span>', options);
        }
      }

      // column lens

    }

    // tooltipMode=0 top, 1=window, 2=inline
    var tipText = [];
    this.tooltipProvider(this, rowIndex, columnIndex,
      options, this.options.tooltipMode === 0 ? '&nbsp;&nbsp;&nbsp;'
        : '<br />', false, tipText);

    var text = [];
    var customToolTip = false;
    var $tipFollowText;
    if (!this.panning) {
      var tipFollowText = [];
      if (this.options.inlineTooltip) {
        this.tooltipProvider(this, rowIndex, columnIndex,
          options, '<br />', true, tipFollowText);

        if (this.options.tooltip && rowIndex !== -1 && columnIndex !== -1) {
          tipFollowText.push('<div data-name="tip"></div>');
        }
      }

      text = tipFollowText.join('');
      $tipFollowText = $('<span style="max-width:400px;">' + text + '</span>');

      // tooltip callback
      if (this.options.tooltip && rowIndex !== -1 && columnIndex !== -1) {
        this.options.tooltip(this, rowIndex, columnIndex, $tipFollowText.find('[data-name=tip]'));
        customToolTip = true;
      }

    }
    this._setTipText(tipText, text.length > 0 || customToolTip ? $tipFollowText : null, options);

  }
  ,
  _updateTipFollowPosition: function (options) {
    if (this.tipFollowHidden) {
      return;
    }
    // top, bottom are negative when scrolled
    var parentRect = this.$parent[0].getBoundingClientRect();
    var tipRect = this.$tipFollow[0].getBoundingClientRect();
    var tipWidth = tipRect.width;
    var tipHeight = tipRect.height;
    var offset = 10;
    var left = options.event.clientX - parentRect.left + offset;
    var top = options.event.clientY - parentRect.top + offset;
    // default is bottom-right
    var scrollBarSize = 18;
    if ((left + tipWidth) >= ( parentRect.right - parentRect.left - scrollBarSize)) { // offscreen
      // right, place tip on
      // left
      left = options.event.clientX - parentRect.left - offset - tipWidth;
    }
    if ((top + tipHeight) >= (parentRect.bottom - parentRect.top - scrollBarSize)) { // offscreen
      // bottom,
      // place tip
      // on top
      top = options.event.clientY - parentRect.top - offset - tipHeight;
    }
    this.$tipFollow.css({
      left: left + 'px',
      top: top + 'px',
      display: ''
    });

  }
  ,
  setTrackVisibility: function (tracks) {
    var _this = this;
    _.each(tracks, function (track) {
      var existingTrack = _this.getTrack(track.name, track.isColumns);
      if (track.visible && existingTrack != null
        && _.keys(existingTrack.settings).length === 0) {
        existingTrack.settingFromConfig('Text');
      }
      _this.setTrackVisible(track.name, track.visible, track.isColumns);
    });
    this.revalidate();
    this.trigger('change', {
      name: 'setTrackVisibility',
      source: this,
      arguments: arguments
    });
  }
  ,
  setTrackVisible: function (name, visible, isColumns) {
    var trackIndex = this.getTrackIndex(name, isColumns);
    if (trackIndex === -1) { // not currently visible
      if (!visible) {
        return;
      }
      this.addTrack(name, isColumns);
    } else {
      var track = isColumns ? this.columnTracks[trackIndex]
        : this.rowTracks[trackIndex];
      var header = isColumns ? this.columnTrackHeaders[trackIndex]
        : this.rowTrackHeaders[trackIndex];
      if (track.isVisible() !== visible) {
        track.setVisible(visible);
        header.setVisible(visible);
      } else {
        return;
      }
    }
    this.trigger('change', {
      name: 'setTrackVisible',
      source: this,
      arguments: arguments
    });
  },
  addTrack: function (name, isColumns, renderSettings, trackIndex) {
    if (name === undefined) {
      throw 'Name not specified';
    }

    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    var headers = isColumns ? this.columnTrackHeaders : this.rowTrackHeaders;
    // see if already exists
    var existingIndex = this.getTrackIndex(name, isColumns);
    if (existingIndex !== -1) {
      return tracks[existingIndex];
    }
    if (renderSettings == null) {
      var metadata = isColumns ? this.project.getFullDataset().getColumnMetadata() : this.project.getFullDataset().getRowMetadata();
      renderSettings = morpheus.VectorUtil.getDataType(metadata.getByName(name)) === '[number]' ? {display: ['bar']}
        : {display: ['text']};
    }

    var positions = isColumns ? this.heatmap.getColumnPositions() : this.heatmap.getRowPositions();
    var track = new morpheus.VectorTrack(this.project, name, positions, isColumns, this);
    track.settingFromConfig(renderSettings);
    track.appendTo(this.$parent);
    var header = new morpheus.VectorTrackHeader(this.project, name, isColumns,
      this);
    header.appendTo(this.$parent);
    track._selection = new morpheus.TrackSelection(track, positions,
      isColumns ? this.project.getColumnSelectionModel() : this.project.getRowSelectionModel(),
      isColumns, this);
    if (trackIndex != null && trackIndex >= 0) {
      tracks.splice(trackIndex, 0, track);
      headers.splice(trackIndex, 0, header);
    } else {
      tracks.push(track);
      headers.push(header);
    }
    return track;
  }
  ,
  addPopup: function (item) {
    if (!this.popupItems) {
      this.popupItems = [];
    }
    this.popupItems.push(item);
  }
  ,
  getPopupItems: function () {
    return this.popupItems || [];
  }
  ,
  removeTrack: function (name, isColumns) {
    var index = this.getTrackIndex(name, isColumns);
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    if (isNaN(index) || index < 0 || index >= tracks.length) {
      console.log('removeTrack: ' + name + ' not found.');
      return;
    }

    var headers = isColumns ? this.columnTrackHeaders
      : this.rowTrackHeaders;
    var track = tracks[index];
    var header = headers[index];
    track.dispose();
    header.dispose();
    tracks.splice(index, 1);
    headers.splice(index, 1);
    this.trigger('change', {
      name: 'removeTrack',
      source: this,
      arguments: arguments
    });
  }
  ,
  updateDataset: function () {
    var dataset = this.project.getSortedFilteredDataset();
    this.verticalSearchBar.update();
    this.horizontalSearchBar.update();
    this.heatmap.setDataset(dataset);
    this.heatmap.getRowPositions().setSpaces(morpheus.HeatMap.createGroupBySpaces(dataset, this.project.getGroupRows(),
      this.rowGapSize, false));
    this.heatmap.getColumnPositions()
      .setSpaces(morpheus.HeatMap.createGroupBySpaces(dataset, this.project.getGroupColumns(), this.columnGapSize, true));
    this.trigger('change', {
      name: 'updateDataset',
      source: this,
      arguments: arguments
    });
  }
  ,
  zoom: function (isZoomIn, options) {
    options = $.extend({}, {
      rows: true,
      columns: true
    }, options);
    if (isZoomIn) {
      if (options.rows) {
        this.heatmap.getRowPositions().setSize(
          this.heatmap.getRowPositions().getSize() * 1.5);
      }
      if (options.columns) {
        this.heatmap.getColumnPositions().setSize(
          this.heatmap.getColumnPositions().getSize() * 1.5);
      }
    } else {
      if (options.rows) {
        this.heatmap.getRowPositions().setSize(
          this.heatmap.getRowPositions().getSize() / 1.5);
      }
      if (options.columns) {
        this.heatmap.getColumnPositions().setSize(
          this.heatmap.getColumnPositions().getSize() / 1.5);
      }
    }
    var reval = {};
    if (options.rows && this.project.getHoverRowIndex() !== -1) {
      reval.scrollTop = this.heatmap.getRowPositions().getPosition(
        this.project.getHoverRowIndex());
    }
    if (options.columns && this.project.getHoverColumnIndex() !== -1) {
      reval.scrollLeft = this.heatmap.getColumnPositions().getPosition(
        this.project.getHoverColumnIndex());
    }
    this.revalidate(reval);
    this.trigger('change', {
      name: 'zoom',
      source: this,
      arguments: arguments
    });
  }
  ,
  getTrackIndex: function (name, isColumns) {
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    for (var i = 0, length = tracks.length; i < length; i++) {
      if (tracks[i].name !== undefined && tracks[i].name === name) {
        return i;
      }
    }
    return -1;
  }
  ,
  getNumTracks: function (isColumns) {
    return isColumns ? this.columnTracks.length : this.rowTracks.length;
  }
  ,
  moveTrack: function (index, newIndex, isColumns) {
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    var headers = isColumns ? this.columnTrackHeaders
      : this.rowTrackHeaders;
    var track = tracks[index];
    tracks.splice(index, 1);
    var header = headers[index];
    headers.splice(index, 1);
    tracks.splice(newIndex, 0, track);
    headers.splice(newIndex, 0, header);
    this.trigger('change', {
      name: 'moveTrack',
      source: this,
      arguments: arguments
    });
  }
  ,
  getTrackByIndex: function (index, isColumns) {
    return isColumns ? this.columnTracks[index] : this.rowTracks[index];
  }
  ,
  getTrackHeaderByIndex: function (index, isColumns) {
    return isColumns ? this.columnTrackHeaders[index]
      : this.rowTrackHeaders[index];
  }
  ,
  getTrack: function (name, isColumns) {
    var index = this.getTrackIndex(name, isColumns);
    if (index === -1) {
      return undefined;
    }
    return isColumns ? this.columnTracks[index] : this.rowTracks[index];
  }
  ,
  /**
   * @return true if active element is an ancestor of this heat map.
   */
  isActiveComponent: function () {
    var active = document.activeElement;
    var tagName = active.tagName;
    if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA') {
      return false;
    }
    return this.$tabPanel[0].contains(active);
  }
  ,
  /**
   *
   * @return {string} 'rowTrack' if row track is active, 'columnTrack' if column track is active,
   * 'heatMap' if heat map is active.
   */
  getActiveComponent: function () {
    var active = document.activeElement;
    if (active.tagName === 'CANVAS') {
      for (var i = 0, ntracks = this.columnTracks.length; i < ntracks; i++) {
        if (this.columnTracks[i].canvas === active) {
          return 'columnTrack';
        }
      }
      for (var i = 0, ntracks = this.rowTracks.length; i < ntracks; i++) {
        if (this.rowTracks[i].canvas === active) {
          return 'rowTrack';
        }
      }
      if (this.heatmap.canvas === active) {
        return 'heatMap';
      }
    }
    return '';
  },
  dispose: function () {
    //this.$content.remove();
    if (this.project == null) {
      return; // failed to initialize
    }
    this.project.off();
    this.$tipInfoWindow.dialog('destroy');
    this.rowTrackHeaders.forEach(function (header) {
      header.dispose();
    });
    this.columnTrackHeaders.forEach(function (header) {
      header.dispose();
    });
    this.rowTracks.forEach(function (track) {
      track.dispose();
    });
    this.columnTracks.forEach(function (track) {
      track.dispose();
    });
    if (this.rowDendrogram != null) {
      this.rowDendrogram.dispose();
    }
    if (this.columnDendrogram != null) {
      this.columnDendrogram.dispose();
    }
    this.beforeColumnTrackDivider.dispose();
    this.afterRowDendrogramDivider.dispose();
    this.afterVerticalScrollBarDivider.dispose();
    this.hscroll.dispose();
    this.vscroll.dispose();
    this.hammer.off('swipe', this.swipe).off('panmove', this.panmove).off('panstart', this.panstart).off('tap',
      this.tap).off('pinch', this.pinch).off('panend', this.panend);
    this.hammer.destroy();
    if (typeof window !== 'undefined') {
      $(window)
        .off('paste.morpheus', this.pasteListener)
        .off('beforecopy.morpheus', this.beforeCopyListener)
        .off('copy.morpheus', this.copyListener)
        .off('orientationchange.morpheus resize.morpheus', this.resizeListener);
    }
  }
  ,
  getVisibleTrackNames: function (isColumns) {
    return this.getVisibleTracks(isColumns).map(function (track) {
      return track.name;
    });
  },
  getVisibleTracks: function (isColumns) {
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    return tracks.filter(function (track) {
      return track.isVisible() && !track.getFullVector().getProperties().has(morpheus.VectorKeys.IS_INDEX);
    });
  },
  isShowRowNumber: function () {
    return this.options.showRowNumber;
  },
  setShowRowNumber: function (visible) {
    this.options.showRowNumber = visible;
    if (!visible) {
      this.removeTrack('#', false);
    } else {
      var track = this.addTrack('#', false, {popupEnabled: false, display: ['text']}, 0);
      track.getVector = function (name) {
        var v = new morpheus.AbstractVector('#', this.project.getSortedFilteredDataset().getRowCount());
        v.getProperties().set(morpheus.VectorKeys.FORMATTER, {pattern: 'i'});
        v.getValue = function (index) {
          return index + 1;
        };
        return v;
      };
      track.getFullVector = function () {
        var v = new morpheus.AbstractVector('#', this.project.getFullDataset().getRowCount());
        v.getProperties().set(morpheus.VectorKeys.FORMATTER, {pattern: 'i'});
        v.getValue = function (index) {
          return index + 1;
        };
        return v;
      };

      track.showPopup = function (e, isHeader) {
        if (e.preventDefault) {
          e.preventDefault();
        }
      };
    }
  }
  ,
  resizeTrack: function (name, width, height, isColumns) {
    var index = this.getTrackIndex(name, isColumns);
    if (index === -1) {
      throw name + ' not found in resize track';
    }
    var heatMapPrefWidth = null;
    if (!isColumns) {
      var track = this.rowTracks[index];
      var header = this.rowTrackHeaders[index];
      track.setPrefWidth(width); // can only set width
      header.setPrefWidth(width);
    } else {
      var track = this.columnTracks[index];
      var header = this.columnTrackHeaders[index];
      if (height) {
        track.setPrefHeight(height);
        header.setPrefHeight(height);
      }
      if (width) {
        for (var i = 0; i < this.columnTracks.length; i++) {
          this.columnTracks[i].setPrefWidth(width);
          this.columnTrackHeaders[i].setPrefWidth(width);
        }
        // set width for all tracks
      }
    }
    this.revalidate();
    this.trigger('change', {
      name: 'resizeTrack',
      source: this,
      arguments: arguments
    });
  }
  ,
  isDendrogramVisible: function (isColumns) {
    var dendrogram = isColumns ? this.columnDendrogram : this.rowDendrogram;
    if (dendrogram !== undefined) {
      return morpheus.HeatMap.isDendrogramVisible(this.project, isColumns);
    }
  }
  ,
  /**
   *
   * Paint all the components
   *
   * @param options.paintRows
   * @param options.paintColumns
   * @param options.invalidateRows
   * @param options.invalidateColumns
   */
  paintAll: function (options) {
    var unscaledHeight = this.heatmap.getUnscaledHeight();
    var unscaledWidth = this.heatmap.getUnscaledWidth();
    var y = this.scrollTop();
    var x = this.scrollLeft();
    this.hscroll.paint();
    this.vscroll.paint(); // FIXME
    var rows = options.paintRows;
    var columns = options.paintColumns;
    var invalidateRows = options.invalidateRows;
    var invalidateColumns = options.invalidateColumns;
    // TODO double buffer search bars
    this.hSortByValuesIndicator.setInvalid(invalidateRows
      || invalidateColumns);
    this.hSortByValuesIndicator.paint({
      x: x,
      y: 0,
      width: unscaledWidth,
      height: this.hSortByValuesIndicator.getUnscaledHeight()
    });
    this.vSortByValuesIndicator.setInvalid(invalidateRows
      || invalidateColumns);
    this.vSortByValuesIndicator.paint({
      x: 0,
      y: y,
      width: this.vSortByValuesIndicator.getUnscaledWidth(),
      height: unscaledHeight
    });
    if (rows) {
      for (var i = 0, length = this.rowTracks.length; i < length; i++) {
        var track = this.rowTracks[i];
        track.setInvalid(invalidateRows);
        if (track.isVisible()) {
          track.paint({
            x: 0,
            y: y,
            height: unscaledHeight,
            width: unscaledWidth
          });
          this.rowTrackHeaders[i].paint();
        }
      }
      if (this.rowDendrogram != null) {
        this.rowDendrogram.setInvalid(invalidateRows);
        if (this.isDendrogramVisible(false)) {
          this.rowDendrogram.setVisible(true);
          this.rowDendrogram.paint({
            x: 0,
            y: y,
            height: unscaledHeight,
            width: this.rowDendrogram.getUnscaledWidth()
          });
        } else {
          this.rowDendrogram.setVisible(false);
        }
      }
    }
    if (columns) {
      for (var i = 0, length = this.columnTracks.length; i < length; i++) {
        var track = this.columnTracks[i];
        track.setInvalid(invalidateColumns);
        track.paint({
          x: x,
          y: 0,
          width: unscaledWidth,
          height: track.getUnscaledHeight()
        });
        this.columnTrackHeaders[i].paint();
      }
      if (this.columnDendrogram != null) {
        this.columnDendrogram.setInvalid(invalidateColumns);
        if (this.isDendrogramVisible(true)) {
          this.columnDendrogram.setVisible(true);
          this.columnDendrogram.paint({
            x: x,
            y: 0,
            width: unscaledWidth,
            height: this.columnDendrogram.getUnscaledHeight()
          });
        } else {
          this.columnDendrogram.setVisible(false);
        }
      }
    }
    if (invalidateRows || invalidateColumns) {
      this.heatmap.setInvalid(true);
    }
    this.heatmap.paint({
      x: x,
      y: y,
      width: unscaledWidth,
      height: unscaledHeight
    });
    this.trigger('change', {
      name: 'paintAll',
      source: this,
      arguments: arguments
    });
  }
  ,
  scrollTop: function (pos) {
    if (pos === undefined) {
      return this.vscroll.getValue();
    }
    if (isNaN(pos)) {
      pos = 0;
    }
    if (this.vscroll.getVisibleExtent() === this.vscroll.getTotalExtent()) {
      pos = 0;
    }
    pos = Math.max(pos, 0);
    pos = Math.min(this.vscroll.getMaxValue(), pos);
    if (pos !== this.vscroll.getValue()) {
      this.vscroll.setValue(pos, true);
      this.trigger('change', {
        name: 'scrollTop',
        source: this,
        arguments: arguments
      });
    }
    return pos;
  }
  ,
  scrollLeft: function (pos) {
    if (pos === undefined) {
      return this.hscroll.getValue();
    }
    if (isNaN(pos)) {
      pos = 0;
    }
    if (this.hscroll.getVisibleExtent() === this.hscroll.getTotalExtent()) {
      pos = 0;
    }
    pos = Math.max(pos, 0);
    pos = Math.min(this.hscroll.getMaxValue(), pos);
    if (pos !== this.hscroll.getValue()) {
      this.trigger('change', {
        name: 'scrollLeft',
        source: this,
        arguments: arguments
      });
      this.hscroll.setValue(pos, true);
    }
    return pos;
  }
  ,
  getSelectedTrackName: function (isColumns) {
    return isColumns ? this.selectedColumnTrackName : this.selectedRowTrackName;
  },
  getLastSelectedTrackInfo: function () {
    return this.selectedTrackInfo;
  },
  setSelectedTrack: function (name, isColumns) {
    var previousName = isColumns ? this.selectedColumnTrackName : this.selectedRowTrackName;
    if (name !== previousName) {
      var index = this.getTrackIndex(previousName, isColumns); // de-select previous
      if (index !== -1) {
        this.getTrackHeaderByIndex(index, isColumns).setSelected(false);
      }
      if (isColumns) {
        this.selectedColumnTrackName = name;
        this.selectedTrackInfo = {name: name, isColumns: true};
      } else {
        this.selectedRowTrackName = name;
        this.selectedTrackInfo = {name: name, isColumns: false};
      }

      var index = this.getTrackIndex(name, isColumns);
      if (index !== -1) {
        this.getTrackHeaderByIndex(index, isColumns).setSelected(true);
      }
      this.trigger('change', {
        name: 'setSelected',
        source: this,
        arguments: arguments
      });
    }
  }
  ,
  saveImage: function (file, format) {
    var _this = this;
    var bounds = this.getTotalSize();
    if (format === 'pdf') {
      var context = new canvas2pdf.PdfContext(blobStream(), {size: [bounds.width, bounds.height]});
      this.snapshot(context);
      context.stream.on('finish', function () {
        var blob = context.stream.toBlob('application/pdf');
        saveAs(blob, file, true);
      });
      context.end();
    } else if (format === 'svg') {
      var context = new C2S(bounds.width, bounds.height);
      this.snapshot(context);
      var svg = context.getSerializedSvg();
      var prefix = [];
      prefix.push('<?xml version="1.0" encoding="utf-8"?>\n');
      prefix.push('<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"' +
        ' "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n');
      svg = prefix.join('') + svg;
      var blob = new Blob([svg], {
        type: 'text/plain;charset=utf-8'
      });
      saveAs(blob, file, true);
    } else {
      var canvas = $('<canvas></canvas>')[0];
      var height = bounds.height;
      var width = bounds.width;
      var backingScale = morpheus.CanvasUtil.BACKING_SCALE;
      canvas.height = backingScale * height;
      canvas.style.height = height + 'px';
      canvas.width = backingScale * width;
      canvas.style.width = width + 'px';
      var context = canvas.getContext('2d');
      morpheus.CanvasUtil.resetTransform(context);
      this.snapshot(context);
      var toBlob = canvas.toBlobHD ? ['toBlobHD'] : 'toBlob';
      canvas[toBlob](function (blob) {
        if (blob == null || blob.size === 0) {
          morpheus.FormBuilder.showInModal({
            title: 'Save Image',
            html: 'Image is too large to save.',
            appendTo: _this.getContentEl(),
            focus: _this.getFocusEl()
          });
          return;
        }
        saveAs(blob, file, true);
      });
    }
  }
  ,
  getTotalSize: function (options) {
    options = $.extend({}, {
      legend: true
    }, options);
    var _this = this;
    var heatmapPrefSize = this.heatmap.getPreferredSize();
    var totalSize = {
      width: heatmapPrefSize.width,
      height: heatmapPrefSize.height
    };
    if (this.isDendrogramVisible(false)) { // row dendrogram
      totalSize.width += this.rowDendrogram.getUnscaledWidth() + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    }
    if (this.isDendrogramVisible(true)) {
      totalSize.height += this.columnDendrogram.getUnscaledHeight() + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    }
    var maxRowHeaderHeight = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        var headerSize = this.rowTrackHeaders[i].getPrintSize();
        totalSize.width += Math.max(headerSize.width, track.getPrintSize().width);
        maxRowHeaderHeight = Math.max(maxRowHeaderHeight, headerSize.height);
      }
    }
    var maxColumnHeaderWidth = 0;
    var columnTrackHeightSum = 0;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        columnTrackHeightSum += track.getPrintSize().height;
        maxColumnHeaderWidth = Math.max(maxColumnHeaderWidth,
          this.columnTrackHeaders[i].getPrintSize().width);
      }
    }
    totalSize.height += Math.max(columnTrackHeightSum, maxRowHeaderHeight) + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    totalSize.width += maxColumnHeaderWidth + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    // color legend
    if (options.legend) {
      var totalLegendWidth = 15;
      var maxLegendHeight = 0;
      var colorByValues = this.heatmap.getColorScheme().getColorByValues();
      var ntracks = colorByValues.length;
      for (var i = 0; i < ntracks; i++) {
        var value = colorByValues[i];
        if (value != null || ntracks === 1) {
          // if (value != 'null') { // values are stored as string
          //
          // }

          this.heatmap.getColorScheme().setCurrentValue(value);
          var names = this.heatmap.getColorScheme().getNames();
          maxLegendHeight = Math.max(maxLegendHeight, names != null ? names.length * 14 : 30);
          totalLegendWidth += 250;
        }
      }
      maxLegendHeight += 10; // spacer
      totalSize.height = totalSize.height + maxLegendHeight;
      totalSize.width = Math.max(totalSize.width, totalLegendWidth);
    }

    // color
    var trackLegendSize = new morpheus.HeatMapTrackColorLegend(
      _.filter(
        this.columnTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
        }), this.getProject().getColumnColorModel()).getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);

    trackLegendSize = new morpheus.HeatMapTrackColorLegend(
      _.filter(
        this.rowTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
        }), this.getProject().getRowColorModel()).getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);

    // shape
    trackLegendSize = new morpheus.HeatMapTrackShapeLegend(
      _.filter(
        this.columnTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE));
        }), this.getProject().getColumnShapeModel()).getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);

    trackLegendSize = new morpheus.HeatMapTrackShapeLegend(
      _.filter(
        this.rowTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE));
        }), this.getProject().getRowShapeModel()).getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);

    // font
    trackLegendSize = new morpheus.HeatMapTrackShapeLegend(
      _.filter(
        this.columnTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT));
        }), this.getProject().getColumnFontModel()).getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);

    trackLegendSize = new morpheus.HeatMapTrackShapeLegend(
      _.filter(
        this.rowTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT));
        }), this.getProject().getRowFontModel()).getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);
    return totalSize;
  }
  ,
  getHeatMapElementComponent: function () {
    return this.heatmap;
  }
  ,
  snapshot: function (context, options) {
    options = $.extend({}, {
      legend: true
    }, options);
    var heatmapPrefSize = this.heatmap.getPreferredSize();
    var totalSize = this.getTotalSize(options);
    var legendHeight = 0;
    if (options.legend) {
      var colorByValues = this.heatmap.getColorScheme().getColorByValues();
      context.save();
      context.translate(15, 0);
      var ntracks = colorByValues.length;
      for (var i = 0, ntracks = colorByValues.length; i < ntracks; i++) {
        var value = colorByValues[i];
        if (value != null || ntracks === 1) {
          if (value != 'null') { // values are stored as string
            // var $label = $('<div style="overflow:hidden;text-overflow:' +
            //   ' ellipsis;width:250px;max-width:250px;">'
            //   + value + '</div>');
            // $keyContent.append($label);
            // totalHeight += $label.height();
          }
          var trackLegend = new morpheus.ColorSupplierLegend(
            this.heatmap.getColorScheme(), value);
          trackLegend.draw({}, context);
          legendHeight = Math.max(legendHeight, trackLegend.getUnscaledHeight());
          var legendWidth = trackLegend.getUnscaledWidth();
          context.translate(legendWidth, 0);
        }
      }
      legendHeight += 10; // spacer

      // morpheus.HeatMapColorSchemeLegend.drawColorScheme(context,
      //   this.heatmap.getColorScheme(), 200, true);
      context.restore();
      // legendHeight = this.heatmap.getColorScheme().getNames() != null ? this.heatmap
      //   .getColorScheme().getNames().length * 14
      //   : 40;
    }
    var legendOffset = 15;
    var maxLegendHeight = 0;

    // color legend
    context.save();
    context.translate(legendOffset, legendHeight);
    var trackLegend = new morpheus.HeatMapTrackColorLegend(
      _.filter(
        this.columnTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
        }), this.getProject().getColumnColorModel());
    trackLegend.draw({}, context);
    var legendSize = trackLegend.getPreferredSize();
    legendOffset += legendSize.width;
    maxLegendHeight = Math.max(maxLegendHeight, legendSize.height);
    context.restore();

    // shape legend
    context.save();
    context.translate(legendOffset, legendHeight);
    trackLegend = new morpheus.HeatMapTrackShapeLegend(
      _.filter(
        this.columnTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE));
        }), this.getProject().getColumnShapeModel());
    trackLegend.draw({}, context);
    legendSize = trackLegend.getPreferredSize();
    legendOffset += legendSize.width;
    maxLegendHeight = Math.max(maxLegendHeight, legendSize.height);
    context.restore();

    // font legend
    context.save();
    context.translate(legendOffset, legendHeight);
    trackLegend = new morpheus.HeatMapTrackFontLegend(
      _.filter(
        this.columnTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT));
        }), this.getProject().getColumnFontModel());
    trackLegend.draw({}, context);
    legendSize = trackLegend.getPreferredSize();
    legendOffset += legendSize.width;
    maxLegendHeight = Math.max(maxLegendHeight, legendSize.height);
    context.restore();

    // row color legend
    context.save();
    context.translate(legendOffset, legendHeight);
    trackLegend = new morpheus.HeatMapTrackColorLegend(
      _.filter(
        this.rowTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
        }), this.getProject().getRowColorModel());
    trackLegend.draw({}, context);
    legendSize = trackLegend.getPreferredSize();
    legendOffset += legendSize.width;
    maxLegendHeight = Math.max(maxLegendHeight, legendSize.height);
    context.restore();

    // shape legend
    context.save();
    context.translate(legendOffset, legendHeight);
    trackLegend = new morpheus.HeatMapTrackShapeLegend(
      _.filter(
        this.rowTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE));
        }), this.getProject().getRowShapeModel());
    trackLegend.draw({}, context);
    legendSize = trackLegend.getPreferredSize();
    legendOffset += legendSize.width;
    maxLegendHeight = Math.max(maxLegendHeight, legendSize.height);
    context.restore();

    // font legend
    context.save();
    context.translate(legendOffset, legendHeight);
    trackLegend = new morpheus.HeatMapTrackFontLegend(
      _.filter(
        this.rowTracks,
        function (track) {
          return track.isVisible()
            && (track.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT));
        }), this.getProject().getRowFontModel());
    trackLegend.draw({}, context);
    legendSize = trackLegend.getPreferredSize();
    legendOffset += legendSize.width;
    maxLegendHeight = Math.max(maxLegendHeight, legendSize.height);
    context.restore();

    legendHeight += maxLegendHeight;

    var heatmapY = this.isDendrogramVisible(true) ? (this.columnDendrogram.getUnscaledHeight() +
      morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS) : 0;
    heatmapY += legendHeight;
    var columnTrackY = heatmapY;
    var heatmapX = this.isDendrogramVisible(false) ? (this.rowDendrogram.getUnscaledWidth() +
      morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS) : 0;
    var isColumnTrackVisible = false;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        var header = this.columnTrackHeaders[i];
        heatmapX = Math.max(heatmapX, header.getPrintSize().width);
        heatmapY += track.getPrintSize().height;
        isColumnTrackVisible = true;
      }
    }
    if (isColumnTrackVisible) {
      heatmapY += morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    }

    // check if row headers are taller than column tracks
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        var header = this.rowTrackHeaders[i];
        heatmapY = Math.max(heatmapY, header.getPrintSize().height);
      }
    }
    if (this.isDendrogramVisible(true)) {
      var columnDendrogramClip = {
        x: 0,
        y: 0,
        height: this.columnDendrogram.getUnscaledHeight(),
        width: heatmapPrefSize.width
      };
      context.save();
      context.translate(heatmapX, legendHeight);
      this.columnDendrogram.prePaint(columnDendrogramClip, context);
      this.columnDendrogram.draw(columnDendrogramClip, context);
      context.restore();
    }
    if (this.isDendrogramVisible(false)) {
      var rowDendrogramClip = {
        x: 0,
        y: 0,
        width: this.rowDendrogram.getUnscaledWidth(),
        height: heatmapPrefSize.height
      };
      context.save();
      context.translate(0, heatmapY);
      this.rowDendrogram.prePaint(rowDendrogramClip, context);
      this.rowDendrogram.draw(rowDendrogramClip, context);
      context.restore();
    }

    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        context.save();
        context.translate(heatmapX, columnTrackY);
        var trackClip = {
          x: 0,
          y: 0,
          width: heatmapPrefSize.width,
          height: track.getPrintSize().height
        };
        track.print(trackClip, context);
        context.restore();
        // draw header
        var header = this.columnTrackHeaders[i];
        context.save();
        var headerSize = header.getPrintSize();
        var headerClip = {
          x: 0,
          y: 0,
          width: headerSize.width,
          height: trackClip.height
        };
        context.translate(heatmapX - 2, columnTrackY + trackClip.height);
        header.print(headerClip, context);
        context.restore();
        columnTrackY += Math.max(headerClip.height, trackClip.height);
      }
    }
    context.save();
    context.translate(heatmapX, heatmapY);

    this.heatmap.draw({
      x: 0,
      y: 0,
      width: heatmapPrefSize.width,
      height: heatmapPrefSize.height
    }, context);
    context.restore();
    var rowTrackWidthSum = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        context.save();
        var tx = morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS + heatmapX + heatmapPrefSize.width + rowTrackWidthSum;
        var ty = heatmapY;
        var trackClip = {
          x: 0,
          y: 0,
          width: track.getPrintSize().width,
          height: heatmapPrefSize.height
        };
        context.translate(tx, ty);
        context.strokeStyle = 'white';
        context.rect(0, 0, trackClip.width, trackClip.height);
        // stroke is needed for clip to work for svg export
        context.stroke();
        context.clip();

        track.print(trackClip, context);
        context.restore();
        // draw header
        var header = this.rowTrackHeaders[i];
        context.save();
        var headerSize = header.getPrintSize();
        var headerClip = {
          x: 0,
          y: 0,
          width: headerSize.width,
          height: headerSize.height
        };
        context.translate(tx, ty - 4);
        header.print(headerClip, context);
        context.restore();
        rowTrackWidthSum += Math.max(headerSize.width, trackClip.width);
      }
    }
  }
  ,
  resetZoom: function () {
    var heatmap = this.heatmap;
    var rowSizes = heatmap.getRowPositions();
    var columnSizes = heatmap.getColumnPositions();
    rowSizes.setSize(13);
    columnSizes.setSize(13);
    var reval = {};
    if (this.project.getHoverRowIndex() !== -1) {
      reval.scrollTop = this.heatmap.getRowPositions().getPosition(
        this.project.getHoverRowIndex());
    }
    if (this.project.getHoverColumnIndex() !== -1) {
      reval.scrollLeft = this.heatmap.getColumnPositions().getPosition(
        this.project.getHoverColumnIndex());
    }
    this.revalidate(reval);
  }
  ,
  getFitColumnSize: function () {
    var heatmap = this.heatmap;
    var availablePixels = this.getAvailableWidth();
    if (availablePixels === -1) {
      return 13;
    }
    if (this.rowDendrogram) {
      availablePixels -= this.rowDendrogram.getUnscaledWidth();
    }
    var trackPixels = 12; // spacer
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        trackPixels += track.getUnscaledWidth();
      }
    }
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) { // all column track headers have the
        // same width
        trackPixels += this.columnTrackHeaders[i].getUnscaledWidth();
        break;
      }
    }

    availablePixels -= trackPixels;

    var positions = heatmap.getColumnPositions();
    var totalCurrent = positions.getItemSize(positions.getLength() - 1)
      + positions.getPosition(positions.getLength() - 1);
    var size = positions.getSize();
    size = size * (availablePixels / totalCurrent);
    size = Math.min(13, size);
    return size;
  }
  ,
  getFitRowSize: function () {
    var heatmap = this.heatmap;
    var availablePixels = this.getAvailableHeight();
    if (availablePixels === -1) {
      return 13;
    }
    if (this.columnDendrogram) {
      availablePixels -= this.columnDendrogram.getUnscaledHeight();
    }
    var trackPixels = 12;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        trackPixels += track.getUnscaledHeight();
      }
    }
    availablePixels -= trackPixels;
    var positions = heatmap.getRowPositions();
    var totalCurrent = positions.getItemSize(positions.getLength() - 1)
      + positions.getPosition(positions.getLength() - 1);

    var size = positions.getSize();
    size = size * (availablePixels / totalCurrent);
    size = Math.min(13, size);
    return size;
  }
  ,
  /**
   * @param options.fitRows
   * @param options.fitColumns
   * @param options.repaint
   */
  fitToWindow: function (options) {
    if (options.fitRows) {
      this.heatmap.getRowPositions().setSize(this.getFitRowSize());
    }
    if (options.fitColumns) {
      this.heatmap.getColumnPositions().setSize(this.getFitColumnSize());
    }
    if (options.repaint) {
      var revalOptions = {};
      if (options.fitRows) {
        if (this.project.getHoverRowIndex() !== -1) {
          revalOptions.scrollTop = this.heatmap.getRowPositions().getPosition(
            this.project.getHoverRowIndex());
        }
      }
      if (options.fitColumns) {
        if (this.project.getHoverColumnIndex() !== -1) {
          revalOptions.scrollLeft = this.heatmap.getColumnPositions().getPosition(this.project.getHoverColumnIndex());
        }
      }
      this.revalidate(revalOptions);
    }
  }
  ,
  getAvailableHeight: function () {
    if (_.isNumber(this.options.height)) {
      return this.options.height;
    }
    var height = $(window).height() - this.$parent.offset().top - 24;
    if (this.options.height === 'window') {
      return height;
    }
    return Math.max(Math.round(screen.height * 0.7), height);
  }
  ,
  getAvailableWidth: function () {
    if (this.options.width) {
      return this.options.width;
    }
    // (this.$el.parent().outerWidth() - 30);
    // return this.$el.width() - 30;

    return this.tabManager.getWidth() - 30;
  }
  ,
  /**
   * Layout all the components
   */
  revalidate: function (options) {
    if (morpheus.Util.isHeadless()) {
      // hack to force creation of color scheme
      for (var i = 0, length = this.rowTracks.length; i < length; i++) {
        var track = this.rowTracks[i];
        track.setInvalid(true);
        if (track.isVisible()) {
          track.paint({
            x: 0,
            y: 0,
            height: 10,
            width: 10
          });
        }
      }
      for (var i = 0, length = this.columnTracks.length; i < length; i++) {
        var track = this.columnTracks[i];
        track.setInvalid(true);
        if (track.isVisible()) {
          track.paint({
            x: 0,
            y: 0,
            height: 10,
            width: 10
          });
        }
      }
      return;
    }
    options = $.extend({}, {
      paint: true
    }, options);
    this.updatingScroll = true;
    var availableHeight = this.getAvailableHeight();
    var availableWidth = this.getAvailableWidth();
    var heatmapPrefSize = this.heatmap.getPreferredSize();

    var columnDendrogramHeight = 0;
    var rowDendrogramWidth = 0;
    if (this.columnDendrogram) {
      columnDendrogramHeight = morpheus.CanvasUtil.getPreferredSize(this.columnDendrogram).height;
    }
    if (this.rowDendrogram) {
      rowDendrogramWidth = morpheus.CanvasUtil.getPreferredSize(this.rowDendrogram).width;
    }
    var rowTrackWidthSum = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      if (this.rowTracks[i].isVisible()) {
        // was manually resized
        if (this.rowTracks[i].getPrefWidth() !== undefined) {
          this.rowTrackHeaders[i].setPrefWidth(this.rowTracks[i].getPrefWidth());
        }
        rowTrackWidthSum += Math.max(morpheus.CanvasUtil.getPreferredSize(this.rowTrackHeaders[i]).width,
          morpheus.CanvasUtil.getPreferredSize(this.rowTracks[i]).width);
      }
    }
    if (availableWidth !== -1 && (rowTrackWidthSum + rowDendrogramWidth + heatmapPrefSize.width) > availableWidth) {
      // shrink row tracks
      //var over = (rowTrackWidthSum + rowDendrogramWidth + heatmapPrefSize.width) - availableWidth;
      rowTrackWidthSum = 0;
      for (var i = 0, length = this.rowTracks.length; i < length; i++) {
        if (this.rowTracks[i].isVisible()) {
          var rowTrackHeaderSize = morpheus.CanvasUtil.getPreferredSize(this.rowTrackHeaders[i]);
          var width = Math.max(rowTrackHeaderSize.width, morpheus.CanvasUtil.getPreferredSize(this.rowTracks[i]).width);
          if (!rowTrackHeaderSize.widthSet) {
            width = Math.min(400, width);
            this.rowTracks[i].setPrefWidth(width);
            this.rowTrackHeaders[i].setPrefWidth(width);
          }
          rowTrackWidthSum += width;
        }
      }
    }

    var ypos = columnDendrogramHeight;
    var maxHeaderWidth = 0;
    // get max column header width
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      if (this.columnTracks[i].isVisible()) {
        if (this.columnTracks[i].getPrefHeight() !== undefined) {
          this.columnTrackHeaders[i].setPrefHeight(this.columnTracks[i].getPrefHeight());
        }
        var width = morpheus.CanvasUtil.getPreferredSize(this.columnTrackHeaders[i]).width;
        maxHeaderWidth = Math.max(maxHeaderWidth, width);
      }
    }
    var xpos = Math.max(rowDendrogramWidth, maxHeaderWidth);
    var heatMapWidth = heatmapPrefSize.width;
    var maxHeatMapWidth = Math.max(50, availableWidth === -1 ? Number.MAX_VALUE : (availableWidth - rowTrackWidthSum
      - xpos
      - morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS));
    if (maxHeatMapWidth > 0 && heatMapWidth > maxHeatMapWidth) {
      heatMapWidth = maxHeatMapWidth;
      heatMapWidth = Math.min(heatMapWidth, heatmapPrefSize.width); // can't
      // go
      // bigger
      // than
      // pref
      // width
    }
    if (this.heatmap.prefWidth !== undefined) { // heat map was manually
      // resized
      heatMapWidth = Math.min(heatmapPrefSize.width,
        this.heatmap.prefWidth);
    }
    if (this.columnDendrogram !== undefined) {
      this.columnDendrogram.setBounds({
        width: heatMapWidth,
        height: columnDendrogramHeight,
        left: xpos,
        top: 0
      });
      this.columnDendrogram.$label.css('left',
        xpos + this.columnDendrogram.getUnscaledWidth() + 10).css(
        'top', 2);
      this.columnDendrogram.$squishedLabel.css('left',
        xpos + this.columnDendrogram.getUnscaledWidth() + 10).css(
        'top', 18);

      this.beforeColumnTrackDivider.setVisible(true);
      this.beforeColumnTrackDivider.setBounds({
        left: xpos - maxHeaderWidth,
        top: ypos,
        width: maxHeaderWidth
      });
      ypos++;
    } else {
      this.beforeColumnTrackDivider.setVisible(false);
    }

    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        var size = morpheus.CanvasUtil.getPreferredSize(track);
        var headerSize = morpheus.CanvasUtil.getPreferredSize(this.columnTrackHeaders[i]);
        size.height = Math.max(size.height, headerSize.height);
        track.setBounds({
          width: heatMapWidth,
          height: size.height,
          left: xpos,
          top: ypos
        });
        this.columnTrackHeaders[i].setBounds({
          width: maxHeaderWidth,
          height: size.height,
          left: xpos - maxHeaderWidth,
          top: ypos
        });
        ypos += size.height;
      }
    }
    this.$whitespace[0].style.left = Math.ceil(xpos + heatMapWidth + 10) + 'px';
    this.$whitespace[0].style.top = '0px';
    ypos += morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    var heatMapHeight = heatmapPrefSize.height;
    if (availableHeight !== -1 && heatMapHeight > (availableHeight - ypos)) {
      heatMapHeight = Math.max(100, Math.min(heatmapPrefSize.height,
        availableHeight - ypos));
    }
    if (ypos < 0) {
      ypos = 0;
    }
    if (this.rowDendrogram) {
      this.rowDendrogram.setBounds({
        width: Math.max(rowDendrogramWidth, maxHeaderWidth),
        height: heatMapHeight,
        left: 0,
        top: ypos
      });
      this.rowDendrogram.$label.css('left', 0).css('top', 2);
      this.afterRowDendrogramDivider.setVisible(true);
      this.afterRowDendrogramDivider.setBounds({
        height: heatMapHeight,
        left: this.rowDendrogram.getUnscaledWidth(),
        top: ypos
      });
      xpos++;
    } else {
      this.afterRowDendrogramDivider.setVisible(false);
    }
    this.heatmap.setBounds({
      width: heatMapWidth,
      height: heatMapHeight,
      left: xpos,
      top: ypos
    });
    this.hSortByValuesIndicator.setBounds({
      height: 4,
      width: heatMapWidth,
      left: xpos,
      top: ypos - 4
    });
    this.hscroll.setVisible(heatMapWidth < heatmapPrefSize.width);
    this.hscroll.setExtent(heatMapWidth, heatmapPrefSize.width,
      options.scrollLeft !== undefined ? options.scrollLeft
        : (heatmapPrefSize.width === this.hscroll.getTotalExtent() ? this.hscroll.getValue()
        : heatmapPrefSize.width
        * this.hscroll.getValue()
        / this.hscroll.getMaxValue()));
    this.hscroll.setBounds({
      left: xpos,
      top: ypos + heatMapHeight + 2
    });
    xpos += heatMapWidth;
    var nvisibleRowTracks = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        nvisibleRowTracks++;
        break;
      }
    }
    this.vSortByValuesIndicator.setBounds({
      width: 4,
      height: heatMapHeight,
      left: xpos,
      top: ypos
    });
    if (nvisibleRowTracks > 0) {
      xpos = xpos
        + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS; // leave
      // space
      // after
      // afterVerticalScrollBarDivider
    }
    var rowAnnotationXStart = xpos;
    // set row track bounds
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        var size = morpheus.CanvasUtil.getPreferredSize(track);
        var headerSize = morpheus.CanvasUtil.getPreferredSize(this.rowTrackHeaders[i]);
        size.width = Math.max(headerSize.width, size.width);
        size.height = heatMapHeight;
        track.setBounds({
          width: size.width,
          height: size.height,
          left: xpos,
          top: ypos
        });

        this.rowTrackHeaders[i].setBounds({
          width: size.width,
          left: xpos,
          top: ypos - headerSize.height - 5,
          height: headerSize.height
        });
        xpos += size.width;
      }
    }
    this.afterVerticalScrollBarDivider.setVisible(nvisibleRowTracks > 0 ? true : false);
    this.afterVerticalScrollBarDivider.setBounds({
      left: rowAnnotationXStart - 2,
      top: ypos - 18
    });
    this.vscroll.setVisible(heatMapHeight < heatmapPrefSize.height);
    this.vscroll.setExtent(heatMapHeight, heatmapPrefSize.height,
      options.scrollTop !== undefined ? options.scrollTop
        : (heatmapPrefSize.height === this.vscroll.getTotalExtent() ? this.vscroll.getValue()
        : heatmapPrefSize.height
        * this.vscroll.getValue()
        / this.vscroll.getMaxValue()));
    xpos += 2;
    this.vscroll.setBounds({
      left: xpos,
      top: ypos
    });
    xpos += this.vscroll.getUnscaledWidth();
    if (this.hscroll.isVisible()) {
      ypos += this.hscroll.getUnscaledHeight() + 2;
    }
    var totalHeight = 2 + ypos + heatMapHeight;
    if (options.paint) {
      this.paintAll({
        paintRows: true,
        paintColumns: true,
        invalidateRows: true,
        invalidateColumns: true
      });
    }
    this.$parent.css({
      height: Math.ceil(totalHeight) + 'px',
      width: availableWidth === -1 ? (Math.ceil(xpos + 2) + 'px') : ''
    });

    this.updatingScroll = false;
    this.trigger('change', {
      name: 'revalidate',
      source: this,
      arguments: arguments
    });
  }
};
morpheus.HeatMap.copyFromParent = function (project, options) {
  // TODO persist sort order, grouping, dendrogram

  project.rowColorModel = options.parent.getProject().getRowColorModel().copy();
  project.columnColorModel = options.parent.getProject().getColumnColorModel().copy();

  project.rowShapeModel = options.parent.getProject().getRowShapeModel().copy();
  project.columnShapeModel = options.parent.getProject().getColumnShapeModel().copy();

  project.rowFontModel = options.parent.getProject().getRowFontModel().copy();
  project.columnFontModel = options.parent.getProject().getColumnFontModel().copy();

  var parentRowTracks = options.parent.rowTracks || [];
  var parentColumnTracks = options.parent.columnTracks || [];
  if (options.inheritFromParentOptions.rows) { // row similarity matrix
    project.columnShapeModel = project.rowShapeModel;
    project.columnColorModel = project.rowColorModel;
    project.columnFontModel = project.rowFontModel;
    parentColumnTracks = parentRowTracks.slice().reverse();
  }
  if (options.inheritFromParentOptions.columns) { // column similarity matrix
    project.rowShapeModel = project.columnShapeModel;
    project.rowColorModel = project.columnColorModel;
    project.rowFontModel = project.columnFontModel;
    parentRowTracks = parentColumnTracks.slice().reverse();
  }

  if (options.inheritFromParentOptions.transpose) {
    var tmp = project.rowShapeModel;
    project.rowShapeModel = project.columnShapeModel;
    project.columnShapeModel = tmp;

    tmp = project.rowColorModel;
    project.rowColorModel = project.columnColorModel;
    project.columnColorModel = tmp;

    tmp = project.rowFontModel;
    project.rowFontModel = project.columnFontModel;
    project.columnFontModel = tmp;

    tmp = parentRowTracks.slice().reverse();
    // swap tracks
    parentRowTracks = parentColumnTracks.slice().reverse();
    parentColumnTracks = tmp;
  }
  // copy track rendering options and order
  // from parent
  options.rows = options.rows || [];

  for (var i = 0; i < parentRowTracks.length; i++) {
    var track = parentRowTracks[i];
    if (track.isVisible()) {
      options.rows.push({
        order: options.rows.length,
        field: track.getName(),
        display: $.extend(true, {}, track.settings),
        force: true
      });
    }
  }
  options.columns = options.columns || [];
  for (var i = 0; i < parentColumnTracks.length; i++) {
    var track = parentColumnTracks[i];
    if (track.isVisible()) {
      options.columns.push({
        order: options.columns.length,
        field: track.getName(),
        display: $.extend(true, {}, track.settings),
        force: true
      });
    }
  }
};
morpheus.Util.extend(morpheus.HeatMap, morpheus.Events);

morpheus.HelpMenu = function () {
  var html = [];
  html.push('<ul class="morpheus-footer-links">');
  html.push('<li><a href="index.html">Home</a></li>');
  html.push('<li><a data-name="contact" href="#">Contact</a></li>');
  html.push('<li><a href="documentation.html">Documentation</a></li>');
  html.push('<li><a href="tutorial.html">Tutorial</a></li>');

  html.push(
    '<li><a href="configuration.html">Configuration</a></li>');

  html.push(
    '<li><a href="https://github.com/cmap/morpheus.js">Source Code</a></li>');
  html.push(
    '<li><a href="https://github.com/cmap/morpheus.R">R Interface</a></li>');
  html.push('<li><a href="https://github.com/cmap/morpheus-export">Command Line</a></li>');
  html.push('</ul>');
  this.$el = $(html.join(''));
  this.$el.find('[data-name=contact]').on('click', function (e) {
    morpheus.FormBuilder.showInModal({
      title: 'Contact',
      html: 'Please email us at morpheus@broadinstitute.org',
      focus: document.activeElement
    });
    e.preventDefault();
  });

};

morpheus.HistogramLegend = function (dataset, colorScheme, metadataValue) {
  morpheus.AbstractCanvas.call(this, true);
  this.colorScheme = colorScheme;
  this.metadataValue = metadataValue;
  this.dataset = dataset;
  this.binNumberToOccurences = null;
  this.setBounds({
    width: 250,
    height: 70
  });
  this.name = null;
  this.canvas.style.position = '';
  this.canvas.style.border = '1px solid LightGrey';
};

morpheus.HistogramLegend.prototype = {
  binSize: 0,
  maxCount: 0,
  total: 0,
  setName: function (name) {
    this.name = name;
  },
  setBinSize: function (binSize) {
    this.binSize = binSize;
  },
  buildHistogram: function () {
    var binSize = this.binSize;
    var dataset = this.dataset;
    var metadataValue = this.metadataValue;
    var colorScheme = this.colorScheme;
    var min = colorScheme.getMin();
    var max = colorScheme.getMax();
    if (min === max) {
      min -= 0.5;
      max += 0.5;
    }
    var vector =
      dataset.getRowMetadata().getByName(colorScheme.getSeparateColorSchemeForRowMetadataField());
    // var numberOfBins = Math.ceil(morpheus.Log2(dataset.getRowCount() * dataset.getColumnCount()) + 1);
    // var binSize = (max - min) / numberOfBins;
    var numberOfBins = Math.ceil((max - min) / binSize);
    var binNumberToOccurences = new Uint32Array(numberOfBins);
    this.binNumberToOccurences = binNumberToOccurences;
    //var values = new Float32Array(dataset.getRowCount() * dataset.getColumnCount()); // for
    // boxplot
    var index = 0;
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      if (vector == null || vector.getValue(i) === metadataValue) {
        for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
          var value = dataset.getValue(i, j);
          if (isNaN(value)) {
            continue;
          }
          //    values[index++] = value;
          var bin = Math.floor(((value - min) / binSize));
          if (bin < 0) {
            bin = 0;
          } else if (bin >= numberOfBins) {
            bin = numberOfBins - 1;
          }
          binNumberToOccurences[bin]++;
        }
      }
    }
    // values = values.slice(0, index);
    // values.sort();

    var maxCount = 0;
    var total = 0;
    for (var i = 0; i < numberOfBins; i++) {
      var count = binNumberToOccurences[i];
      maxCount = count >= maxCount ? count : maxCount;
      total += count;
    }
    this.maxCount = maxCount;
    this.total = total;
  },
  draw: function (clip, context) {
    this.buildHistogram();
    var colorScheme = this.colorScheme;
    var canvasWidth = this.getUnscaledWidth() - 50;
    var valueToPosition = d3.scale.linear().domain([colorScheme.getMin(), colorScheme.getMax()]).range([0, canvasWidth]).clamp(
      true);
    var histogramHeight = 30;
    var countToPosition = d3.scale.linear().domain([0, this.maxCount / this.total]).range([histogramHeight, 0]).clamp(
      true);
    var binNumberToOccurences = this.binNumberToOccurences;
    var min = colorScheme.getMin();
    var binSize = this.binSize;
    var y0 = countToPosition(0);

    if (this.name != null) {
      context.font = '11px ' + morpheus.CanvasUtil.getFontFamily(context);
      context.fillStyle = 'black';
      context.lineWidth = 1;
      //  context.textBaseline = 'top';
      context.fillText(this.name, 0.5, 12);
      context.translate(0, 14);
    }
    context.lineWidth = 0.2;
    context.strokeStyle = '#D3D2C2';
    context.fillStyle = '#D3D2C2'; //'#d9d9d9';
    context.translate(25, 0);
    context.beginPath();
    context.moveTo(0, y0);
    context.lineTo(canvasWidth, y0);
    context.stroke();
    context.lineWidth = 1;
    context.strokeStyle = 'white';
    for (var i = 0, numberOfBins = binNumberToOccurences.length; i < numberOfBins; i++) {
      var count = binNumberToOccurences[i];
      if (count > 0) {
        count /= this.total;
        var start = min + (i * binSize);
        var end = start + binSize;
        var x = valueToPosition(start);
        var width = valueToPosition(end) - x;
        var y = countToPosition(count);
        context.rect(x, y0, width, y - y0);
        context.fill();
        context.stroke();
      }
    }
    // boxplot
    // var q25 = valueToPosition(this.q25);
    // var q75 = valueToPosition(this.q75);
    // var median = valueToPosition(this.median);
    // var lav = valueToPosition(this.lowerAdjacentValue);
    // var uav = valueToPosition(this.upperAdjacentValue);
    // context.translate(0, histogramHeight + 1);
    // context.fillStyle = 'black';
    //  var boxPlotHeight = 8;
    // context.fillRect(q25, 0, q75 - q25, boxPlotHeight);
    //
    // context.fillRect(lav, boxPlotHeight / 2 - 1, q25 - lav, 2);
    //
    // context.fillRect(q75, boxPlotHeight / 2 - 1, uav - q75, 2);
    //
    // context.fillStyle = 'white';
    // context.fillRect(median - 1, 0.5, 2, boxPlotHeight - 0.5);
    //
    context.translate(0, histogramHeight + 1);
    context.fillStyle = 'black';
    morpheus.HeatMapColorSchemeLegend.drawColorScheme(context,
      this.colorScheme, canvasWidth, false, false, 6);
  }
}
;

morpheus.Util.extend(morpheus.HistogramLegend, morpheus.AbstractCanvas);

morpheus.LegendWithStops = function () {
  var _this = this;
  morpheus.AbstractCanvas.call(this, false);
  this.setBounds({
    width: 300,
    height: 40
  });
  $(this.canvas).on('mousedown', function (event) {
    var position = morpheus.CanvasUtil.getMousePos(
      event.target, event);
    _this.selectedIndex = _this
    .findIndexForPosition(position);
    _this.trigger('selectedIndex', {
      selectedIndex: _this.selectedIndex
    });
  });
  this.hammer = morpheus.Util.hammer(this.canvas, ['pan'])
  .on(
    'panmove',
    this.panmove = function (event) {
      if (_this.selectedIndex !== -1) {
        var position = morpheus.CanvasUtil.getMousePos(
          event.target, event);
        var fraction = _this.fractionToStopPix
        .invert(position.x);
        fraction = Math.max(0, fraction);
        fraction = Math.min(1, fraction);
        _this.trigger('moved', {
          fraction: fraction
        });
      }
    }).on(
    'panstart',
    this.panstart = function (event) {
    }).on('panend', this.panend = function (event) {
    _this.selectedIndex = -1;
  });
  $(this.canvas).on('keydown', function (e) {
    // 8=backspace, 46=delete
    if ((e.which == 8 || e.which == 46) && _this.selectedIndex !== -1) {
      _this.trigger('delete');
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  });
};
morpheus.LegendWithStops.prototype = {
  border: 7,
  stopHalfSize: 5,
  selectedIndex: -1,
  destroy: function () {
    $(this.canvas).off('keyup').off('mousedown');
    this.hammer.off('panstart',
      this.panstart).off('panmove', this.panmove);
    this.hammer.destroy();
  },
  setSelectedIndex: function (index) {
    this.selectedIndex = index;
  },
  findIndexForPosition: function (position) {
    // pix - stopHalfSize to pix + stopHalfSize
    if (position.y >= 22) {
      for (var i = 0, length = this.fractions.length; i < length; i++) {
        var pix = this.fractionToStopPix(this.fractions[i]);
        var start = pix - this.stopHalfSize;
        var end = pix + this.stopHalfSize;
        if (position.x >= start && position.x <= end) {
          return i;
        }
      }
    }
    return -1;
  },
  draw: function (fractions, colors, stepped, fractionToStopPix) {
    this.fractions = fractions;
    this.colors = colors;
    this.stepped = stepped;
    this.fractionToStopPix = fractionToStopPix;
    var context = this.canvas.getContext('2d');
    morpheus.CanvasUtil.resetTransform(context);
    context.clearRect(0, 0, this.getUnscaledWidth(), this
    .getUnscaledHeight());
    context.translate(this.border, 0);
    morpheus.HeatMapColorSchemeLegend.draw(context, fractions, colors, this
      .getUnscaledWidth()
      - 2 * this.border, this.getUnscaledHeight() - 20, stepped);
    context.translate(-this.border, 0);
    context.lineWidth = 1;
    context.strokeStyle = 'Grey';
    context.strokeRect(this.border, 0, this.getUnscaledWidth() - 2
      * this.border, this.getUnscaledHeight() - 20);
    for (var i = 0; i < fractions.length; i++) {
      if (i > 0 && fractions[i] === fractions[i - 1]) {
        continue;
      }
      context.fillStyle = colors[i];
      var pix = fractionToStopPix(fractions[i]);
      context.fillRect(pix - this.stopHalfSize, 22,
        this.stopHalfSize * 2, this.stopHalfSize * 2);
      if (this.selectedIndex === i) {
        context.lineWidth = 2;
        context.strokeStyle = 'black';
      } else {
        context.lineWidth = 1;
        context.strokeStyle = 'Grey';
      }
      context.strokeRect(pix - this.stopHalfSize, 22,
        this.stopHalfSize * 2, this.stopHalfSize * 2);
    }
  }
};
morpheus.Util.extend(morpheus.LegendWithStops, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.LegendWithStops, morpheus.Events);

morpheus.Popup = {};
morpheus.Popup.initted = false;
morpheus.Popup.init = function () {
  if (morpheus.Popup.initted) {
    return;
  }

  morpheus.Popup.initted = true;
  morpheus.Popup.$popupDiv = $(document.createElement('div'));
  morpheus.Popup.$popupDiv.css('position', 'absolute').css('zIndex', 1050).css('overflow', 'auto').addClass('dropdown clearfix');
  morpheus.Popup.$contextMenu = $(document.createElement('ul'));
  morpheus.Popup.$contextMenu.addClass('dropdown-menu').css('display',
    'block').css('position', 'static').css('margin-bottom', '5px');
  morpheus.Popup.$contextMenu.appendTo(morpheus.Popup.$popupDiv);
  morpheus.Popup.$contextMenu.on('click', 'a', function (e) {
    e.preventDefault();
    var $this = $(this);
    // if (!$this.hasClass('copy')) {
    morpheus.Popup.popupCallback(e, $this.data('name'));
    morpheus.Popup.hide();
    // }

  });
};

morpheus.Popup.popupInDom = false;
morpheus.Popup.hidePopupMenu = function (e) {
  if (morpheus.Popup.component == e.target) {
    e.preventDefault();
    e.stopPropagation();
  }
  morpheus.Popup.hide();
};
morpheus.Popup.hide = function () {
  morpheus.Popup.$popupDiv.hide();
  $(document.body).off('mousedown', morpheus.Popup.hidePopupMenu);
  morpheus.Popup.popupCallback = null;
  morpheus.Popup.component = null;
};

morpheus.Popup.showPopup = function (menuItems, position, component, callback) {
  morpheus.Popup.init();
  if (morpheus.Popup.component == component) {
    morpheus.Popup.hide();
    return;
  }
  morpheus.Popup.popupCallback = callback;
  morpheus.Popup.component = component;
  var html = [];
  for (var i = 0, length = menuItems.length; i < length; i++) {
    var item = menuItems[i];
    if (item.header) {
      html.push('<li role="presentation" class="dropdown-header">'
        + item.name + '</li>');
    } else if (item.separator) {
      html.push('<li class="divider"></li>');
    } else {
      html.push('<li role="presentation"');
      if (item.disabled) {
        html.push('class="disabled"');
      }
      html.push('><a data-name="' + item.name
        + '" data-type="popup-item" tabindex="-1" href="#"');
      if (item.class) {
        html.push(' class="' + item.class + '"');
      }
      html.push('>');
      if (item.checked) {
        html
        .push('<span class="dropdown-checkbox fa fa-check"></span>');
      }

      html.push(item.name);
      if (item.icon) {
        html.push('<span class="pull-right ' + item.icon + '"></span>');
      }
      html.push('</a>');

      html.push('</li>');
    }
  }
  morpheus.Popup.$contextMenu.html(html.join(''));
  if (!morpheus.Popup.popupInDom) {
    morpheus.Popup.popupInDom = true;
    morpheus.Popup.$popupDiv.appendTo($(document.body));
  }
  var $body = $(document.body);
  var $window = $(window);
  var windowWidth = $window.width();
  var windowHeight = $window.height();
  var popupWidth = morpheus.Popup.$popupDiv.width();
  var popupHeight = morpheus.Popup.$popupDiv.height();
  var left = position.x;
  var top = position.y;
  // default is bottom-right
  if ((left + popupWidth) >= windowWidth) { // offscreen right
    left -= popupWidth;
    left = Math.max(4, left);
  }
  if ((top + popupHeight) >= (windowHeight)) { // offscreen bottom
    top -= popupHeight;
    top = Math.max(4, top);
  }

  morpheus.Popup.$popupDiv.css({
    // height: popupHeight + 'px',
    display: 'block',
    left: left,
    top: top
  });

  morpheus.Popup.$popupDiv.show();

  $body.off('mousedown', morpheus.Popup.hidePopupMenu);
  window.setTimeout(function () {
    $body.on('mousedown', function (e) {
      var $target = $(e.target);
      if ($target[0] !== morpheus.Popup.$popupDiv[0] && $target.data('type') !== 'popup-item') {
        morpheus.Popup.hidePopupMenu(e);
      }
    });
  }, 1);
};

morpheus.RowDendrogram = function (heatMap, tree, positions, project) {
  morpheus.AbstractDendrogram.call(this, heatMap, tree, positions,
    project, morpheus.AbstractDendrogram.Type.ROW);
};
morpheus.RowDendrogram.prototype = {
  drawNode: function (context, node) {
    var radius = this.getNodeRadius(node);
    var pix = this.toPix(node);
    context.beginPath();
    context.arc(pix[0], pix[1], radius, Math.PI * 2, false);
    context.fill();
  },
  isDragHotSpot: function (p) {
    return Math.abs(this.scale(this.cutHeight) - p.x) <= 2;
  },
  drawCutSlider: function (clip, context) {
    if (context.setLineDash) {
      context.setLineDash([5]);
    }
    context.strokeStyle = 'black';
    var nx = this.scale(this.cutHeight);
    context.beginPath();
    context.moveTo(nx, clip.y);
    context.lineTo(nx, this.getUnscaledHeight());
    context.stroke();
    if (context.setLineDash) {
      context.setLineDash([]);
    }
  },
  getPreferredSize: function () {
    return {
      width: 100,
      height: Math.ceil(this.positions.getPosition(this.positions
          .getLength() - 1)
        + this.positions
        .getItemSize(this.positions.getLength() - 1))
    };
  },
  paintMouseOver: function (clip, context) {
    if (this.project.getHoverRowIndex() !== -1) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(0, -clip.y);
      this.drawRowBorder(context, this.positions, this.project
      .getHoverRowIndex(), this.getUnscaledWidth());
    }
  },
  drawRowBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(0, pix + size);
    context.lineTo(gridSize, pix + size);
    context.stroke();
    context.beginPath();
    context.moveTo(0, pix);
    context.lineTo(gridSize, pix);
    context.stroke();
  },
  createScale: function () {
    return d3.scale.linear().domain([0, this.tree.maxHeight]).range(
      [this.getUnscaledWidth(), 0]);
  },
  getMaxIndex: function (clip) {
    return morpheus.Positions.getBottom(clip, this.positions);
  },
  getMinIndex: function (clip) {
    return morpheus.Positions.getTop(clip, this.positions);
  },
  toPix: function (node) {
    var min = this.positions.getPosition(node.minIndex)
      + this.positions.getItemSize(node.minIndex) / 2;
    var max = this.positions.getPosition(node.maxIndex)
      + this.positions.getItemSize(node.maxIndex) / 2;
    return [this.scale(node.height), (min + max) / 2];
  },
  drawPathFromNodeToParent: function (context, node) {
    var pix = this.toPix(node);
    var parentPix = this.toPix(node.parent);
    context.beginPath();
    context.moveTo(pix[0], pix[1]);
    context.lineTo(parentPix[0], pix[1]);
    context.lineTo(parentPix[0], parentPix[1]);
    context.stroke();
  },
  drawNodePath: function (context, node, minIndex, maxIndex) {
    var children = node.children;
    var left = children[0];
    var right = children[1];
    // set up points for poly line
    var ry = this.toPix(right)[1];
    var rx = this.scale(right.height);
    var ly = this.toPix(left)[1];
    var lx = this.scale(left.height);
    var nx = this.scale(node.height);
    var x;
    var y;
    if (!this.drawLeafNodes) {
      var leftIsLeaf = left.children !== undefined;
      var rightIsLeaf = right.children !== undefined;
      if (leftIsLeaf) {
        lx = nx + 4;
      }
      if (rightIsLeaf) {
        rx = nx + 4;
      }
      x = [rx, nx, nx, lx];
      y = [ry, ry, ly, ly];
    } else {
      x = [rx, nx, nx, lx];
      y = [ry, ry, ly, ly];
    }
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for (var i = 1, length = x.length; i < length; i++) {
      context.lineTo(x[i], y[i]);
    }
    context.stroke();
  }
};
morpheus.Util.extend(morpheus.RowDendrogram, morpheus.AbstractDendrogram);

/**
 * @param model{morpheus.SelectionModel}
 */
morpheus.ScentedSearch = function (model, positions, isVertical, scrollbar,
                                   heatMap) {
  morpheus.AbstractCanvas.call(this, false);
  this.model = model;
  this.positions = positions;
  this.isVertical = isVertical;
  this.scrollbar = scrollbar;
  this.heatMap = heatMap;
  this.searchIndices = [];
  scrollbar.decorator = this;
  var _this = this;
  var mouseMove = function (e) {
    var indices = _this.getSearchIndices(e);

    document.body.style.cursor = indices.length === 0 ? 'default' : 'pointer';
    scrollbar.canvas.style.cursor = indices.length === 0 ? 'default' : 'pointer';
    var tipOptions = {
      event: e,
      heatMapLens: indices.length >= 0
    };
    if (isVertical) {
      heatMap.setToolTip(indices.length >= 0 ? indices : null,
        -1, tipOptions);
    } else {
      heatMap.setToolTip(-1, indices.length >= 0 ? indices
        : null, tipOptions);
    }

  };
  var mouseExit = function (e) {
    // need to set body cursor b/c mouse can be partially on the scroll bar,
    // but the canvas cursor has no effect
    document.body.style.cursor = 'default';
    scrollbar.canvas.style.cursor = 'default';
    heatMap.setToolTip(-1, -1, {event: e});
  };
  $(scrollbar.canvas).on('mousemove.morpheus', mouseMove).on('mouseout.morpheus', mouseExit);

};

morpheus.ScentedSearch.LINE_HEIGHT = 3.5;
morpheus.ScentedSearch.prototype = {
  mouseMovedIndex: -1,
  getIndex: function (event) {
    var pix = morpheus.CanvasUtil.getMousePos(event.target, event);
    var val = pix[this.isVertical ? 'y' : 'x'];
    return this.getIndexForPix(val);
  },
  getSearchIndices: function (event) {
    var pix = morpheus.CanvasUtil.getMousePos(event.target, event);
    var val = pix[this.isVertical ? 'y' : 'x'];
    return this.getSearchIndicesForPix(val);
  },
  getSearchIndicesForPix: function (pix) {
    var indices = this.searchIndices;
    if (indices == null) {
      return [];
    }
    var scale = this.scale;
    var tolerance = morpheus.ScentedSearch.LINE_HEIGHT;
    var matches = [];
    for (var i = 0, length = indices.length; i < length; i++) {
      var midVal = this.positions.getPosition(indices[i]) * scale;
      if (Math.abs(midVal - pix) <= tolerance) {
        matches.push(indices[i]);
      }
    }
    return matches;
  },
  getIndexForPix: function (pix) {
    var indices = this.searchIndices;
    if (indices == null) {
      return -1;
    }
    var tolerance = morpheus.ScentedSearch.LINE_HEIGHT;
    if (this.mouseMovedIndex > 0) {
      var midVal = this.positions
        .getPosition(indices[this.mouseMovedIndex])
        * scale;
      if (Math.abs(midVal - pix) <= tolerance) {
        return this.mouseMovedIndex;
      }
    }
    var low = 0;
    var scale = this.scale;
    var high = indices.length - 1;

    while (low <= high) {
      var mid = (low + high) >> 1;
      var midVal = this.positions.getPosition(indices[mid]) * scale;
      var cmp = 0;
      if (Math.abs(midVal - pix) <= tolerance) {
        cmp = 0;
      } else if (midVal < pix) {
        cmp = -1; // Neither val is NaN, thisVal is smaller
      } else if (midVal > pix) {
        cmp = 1; // Neither val is NaN, thisVal is larger
      }
      if (cmp < 0)
        low = mid + 1;
      else if (cmp > 0)
        high = mid - 1;
      else
        return mid; // key found
    }
    return -1; // -(low + 1); // key not found.

  },
  tap: function (position) {
    var val = position[this.isVertical ? 'y' : 'x'];
    var index = this.getIndexForPix(val);
    this.scrollbar.canvas.style.cursor = index < 0 ? 'default' : 'pointer';
    if (index >= 0) {
      if (this.isVertical) {
        this.heatMap.scrollTop(this.positions
        .getPosition(this.searchIndices[index]));
      } else {
        this.heatMap.scrollLeft(this.positions
        .getPosition(this.searchIndices[index]));
      }
      return true;
    }
    return false;
  },
  update: function () {
    this.searchIndices = this.model.getViewIndices().values().sort(
      function (a, b) {
        return a < b ? -1 : 1;
      });
  },
  draw: function (clip, context) {
    var width = this.scrollbar.getUnscaledWidth();
    var height = this.scrollbar.getUnscaledHeight();
    var availableLength = ((this.isVertical ? height : width))
      - morpheus.ScentedSearch.LINE_HEIGHT;
    this.scale = availableLength
      / (this.positions.getPosition(this.positions.getLength() - 1) + this.positions
      .getItemSize(this.positions.getLength() - 1));
    context.fillStyle = morpheus.ScentedSearch.TICK_COLOR;
    context.lineWidth = 1;
    this.drawIndices(context, this.searchIndices);
    this.drawHoverMatchingValues(context);
  },
  drawHoverMatchingValues: function (context) {
    var heatmap = this.heatMap;
    context.fillStyle = morpheus.ScentedSearch.MATCHING_VALUES_TICK_COLOR;
    if (heatmap.mousePositionOptions
      && heatmap.mousePositionOptions.name != null) {
      var isColumns = !this.isVertical;
      var track = heatmap.getTrack(heatmap.mousePositionOptions.name,
        isColumns);
      if (track == null) {
        return;
      }
      if (track.settings.highlightMatchingValues) {
        var hoverIndex = isColumns ? heatmap.getProject()
        .getHoverColumnIndex() : heatmap.getProject()
        .getHoverRowIndex();
        if (hoverIndex === -1) {
          return;
        }
        var vector = track.getVector();
        var value = vector.getValue(hoverIndex);
        var valueToModelIndices = track.getFullVector().getProperties()
        .get(morpheus.VectorKeys.VALUE_TO_INDICES);
        if (!valueToModelIndices) {
          var fullVector = track.getFullVector();
          valueToModelIndices = morpheus.VectorUtil
          .createValueToIndicesMap(fullVector);
          fullVector.getProperties().set(
            morpheus.VectorKeys.VALUE_TO_INDICES,
            valueToModelIndices);

        }
        var modelIndices = valueToModelIndices.get(value);
        if (modelIndices == null) {
          console.log('valueToModelIndices error');
          return;
        }
        var scale = this.scale;
        var lineLength = !this.isVertical ? this.scrollbar
        .getUnscaledHeight() : this.scrollbar
        .getUnscaledWidth();
        var isVertical = this.isVertical;
        var positions = this.positions;
        var project = heatmap.getProject();
        for (var i = 0, length = modelIndices.length; i < length; i++) {
          var modelIndex = modelIndices[i];
          var index = isVertical ? project
          .convertModelRowIndexToView(modelIndex) : project
          .convertModelColumnIndexToView(modelIndex);
          if (index === -1) {
            continue;
          }
          var pix = positions.getPosition(index) * scale;
          if (isVertical) {
            context.fillRect(0, pix, lineLength,
              morpheus.ScentedSearch.LINE_HEIGHT);
          } else {
            context.fillRect(pix, 0,
              morpheus.ScentedSearch.LINE_HEIGHT, lineLength);

          }
        }
      }

    }
  },
  drawIndices: function (context, highlightedIndices) {
    var scale = this.scale;
    var lineLength = !this.isVertical ? this.scrollbar.getUnscaledHeight()
      : this.scrollbar.getUnscaledWidth();

    var isVertical = this.isVertical;
    var positions = this.positions;
    for (var i = 0, length = highlightedIndices.length; i < length; i++) {
      var index = highlightedIndices[i];
      var pix = positions.getPosition(index) * scale;
      if (isVertical) {
        context.beginPath();
        context.rect(0, pix, lineLength,
          morpheus.ScentedSearch.LINE_HEIGHT);
        context.fill();
        //  context.stroke();

      } else {
        context.beginPath();
        context.rect(pix, 0, morpheus.ScentedSearch.LINE_HEIGHT,
          lineLength);
        context.fill();
        //context.stroke();
      }
    }

  }
};
morpheus.Util.extend(morpheus.ScentedSearch, morpheus.AbstractCanvas);
morpheus.ScentedSearch.MATCHING_VALUES_TICK_COLOR = 'black';
morpheus.ScentedSearch.TICK_COLOR = '#3182bd';

morpheus.ScrollBar = function (isVertical) {
  morpheus.AbstractCanvas.call(this);
  this.isVertical = isVertical;
  $(this.canvas).css('border', '1px solid #d8d8d8');
  if (isVertical) {
    this.setBounds({
      width: 12
    });
  } else {
    this.setBounds({
      height: 12
    });
  }
  this.field = this.isVertical ? 'y' : 'x';
  var that = this;
  var mouseMove = function (event) {
    if (!morpheus.CanvasUtil.dragging) {
      var position = morpheus.CanvasUtil.getMousePos(event.target, event,
        true);
      var mouseOver = (position[that.field] >= that.thumbPos && position[that.field] <= (that.thumbPos + that.thumbExtent));
      if (that.thumbMouseOver !== mouseOver) {
        that.thumbMouseOver = mouseOver;
        that.repaint();
      }
    }
  };
  var mouseExit = function (e) {
    if (!morpheus.CanvasUtil.dragging && that.thumbMouseOver) {
      that.thumbMouseOver = false;
      that.repaint();
    }
  };
  $(this.canvas).on('mousemove', mouseMove).on('mouseout', mouseExit).on(
    'mouseenter', mouseMove);
  this.hammer = morpheus.Util
  .hammer(this.canvas, [this.isVertical ? 'panv' : 'panh', 'tap'])
  .on(
    'panstart',
    this.panstart = function (event) {
      var position = morpheus.CanvasUtil.getMousePos(
        event.target, event, true);
      if (position[that.field] >= that.thumbPos
        && position[that.field] <= (that.thumbPos + that.thumbExtent)) {
        that.draggingThumb = true;
        that.dragStartThumbPos = that.thumbPos;
      } else {
        that.draggingThumb = false;
      }
    })
  .on('panend', this.panend = function (event) {
    that.draggingThumb = false;
  })
  .on(
    'panmove',
    this.panmove = function (event) {
      if (that.draggingThumb) {
        var position = morpheus.CanvasUtil.getMousePos(
          event.target, event);
        var thumbPosPix = that.dragStartThumbPos
          + (that.isVertical ? event.deltaY
            : event.deltaX);
        var f = thumbPosPix
          / (that.visibleExtent - that.thumbExtent);
        var value = f * that.maxValue;
        // convert pix to value
        that.setValue(value, true);
        event.preventDefault();
        event.srcEvent.stopPropagation();
        event.srcEvent.stopImmediatePropagation();
      }
    })
  .on(
    'tap doubletap',
    this.tap = function (event) {
      // ensure not clicked on the thumb
      if (!that.draggingThumb) {
        var position = morpheus.CanvasUtil.getMousePos(
          event.target, event);
        if (!that.decorator.tap(position)) {
          // scroll up or down by thumbExtent
          var thumbExtentToValue = (that.thumbExtent / that.totalExtent)
            * that.totalExtent;
          that.scrollToTop = position[that.field] < that.thumbPos;
          that.setValue(that.scrollToTop ? that.value
            - thumbExtentToValue : that.value
            + thumbExtentToValue, true);
        }
      }
    });
};
morpheus.ScrollBar.prototype = {
  thumbPos: 0, // the top of the thumb, from 0 to visibleExtent-thumbExtent
  thumbExtent: 0,
  extent: 0,
  value: 0, // from 0 to totalExtent-extent
  maxValue: 0, // totalExtent-extent
  totalExtent: 0,
  visibleExtent: 0,
  dragStartThumbPos: 0,
  draggingThumb: false,
  thumbMouseOver: false,
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.hammer.off('panend', this.panend).off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap).off('doubletap', this.tap);
    this.hammer.destroy();
  },
  draw: function (clip, context) {
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    if (this.visibleExtent === this.totalExtent) {
      context.clearRect(0, 0, width, height);
    } else {
      context.fillStyle = 'rgb(241,241,241)';
      context.fillRect(0, 0, width, height);
      context.fillStyle = !this.thumbMouseOver ? 'rgb(137,137,137)'
        : 'rgb(100,100,100)';
      if (this.isVertical) {
        context.fillRect(0, this.thumbPos, width, this.thumbExtent);
      } else {
        context.fillRect(this.thumbPos, 0, this.thumbExtent, height);
      }
    }
    this.decorator.draw(clip, context);
  },
  setThumbPosFromValue: function () {
    // value is thumb top position
    var f = this.maxValue == 0 ? 0 : this.value / this.maxValue;
    this.thumbPos = f * (this.visibleExtent - this.thumbExtent);
    this.thumbPos = Math.max(0, this.thumbPos);
  },
  getValue: function () {
    return this.value;
  },
  getMaxValue: function () {
    return this.maxValue;
  },
  setValue: function (value, trigger) {
    if (isNaN(value)) {
      value = 0;
    }
    if (this.visibleExtent === this.totalExtent) {
      value = 0;
    }
    value = Math.max(value, 0);
    value = Math.min(this.maxValue, value);
    this.value = value;
    this.setThumbPosFromValue();
    if (trigger) {
      this.trigger('scroll', {value: this.value});
      this.repaint();
    }
    return this.value;
  },
  setTotalExtent: function (totalExtent) {
    this.totalExtent = totalExtent;
    this._setRange();
  },
  getTotalExtent: function () {
    return this.totalExtent;
  },
  getVisibleExtent: function () {
    return this.visibleExtent;
  },
  _setRange: function () {
    this.thumbExtent = Math.max(10, this.visibleExtent
      * (this.visibleExtent / this.totalExtent));
    this.maxValue = this.totalExtent - this.visibleExtent;
    this.maxValue = Math.max(0, this.maxValue);
    if (this.isVertical) {
      this.setBounds({
        height: this.visibleExtent
      });
    } else {
      this.setBounds({
        width: this.visibleExtent
      });
    }
  },
  setExtent: function (visibleExtent, totalExtent, value) {
    this.visibleExtent = visibleExtent;
    this.totalExtent = totalExtent;
    this._setRange();
    this.setValue(value, false);
  }
};
morpheus.Util.extend(morpheus.ScrollBar, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.ScrollBar, morpheus.Events);

morpheus.ShapeChooser = function (options) {
  var formBuilder = new morpheus.FormBuilder();
  var map = options.map;
  var html = ['<select name="valuePicker" class="selectpicker" data-live-search="true">'];
  map.forEach(function (val, key) {
    html.push('<option');
    html.push(' value="');
    html.push(key);
    html.push('">');
    html.push(key);
    html.push('</option>');
  });
  html.push('</select>');
  formBuilder.append({
    name: 'selected_value',
    type: 'custom',
    value: html.join('')
  });

  var shapeField = new morpheus.ShapeField({showNone: true});

  formBuilder.append({
    style: 'max-width:50px;',
    name: 'selected_shape',
    type: 'custom',
    value: '<div data-name="shape"></div>'
  });
  shapeField.$el.appendTo(formBuilder.$form.find('[data-name=shape]'));

  var $valuePicker = formBuilder.$form.find('[name=valuePicker]');
  var selectedVal = $valuePicker.val();
  var _this = this;

  shapeField.setShapeValue(map.get(selectedVal));
  shapeField.on('change', function (e) {
    map.set(selectedVal, e.shape);
    _this.trigger('change', {
      value: selectedVal,
      shape: e.shape
    });

  });
  $valuePicker.selectpicker().change(function () {
    selectedVal = $valuePicker.val();
    shapeField.setShapeValue(map.get(selectedVal));
  });
  this.$div = formBuilder.$form;
};

morpheus.ShapeChooser.prototype = {};

morpheus.Util.extend(morpheus.ShapeChooser, morpheus.Events);

/**
 *
 * @param options.shapes Array of shape names or null to use morpheus.VectorShapeModel.SHAPES
 * @param options.showNone Whether none should be an option
 * @constructor
 */
morpheus.ShapeField = function (options) {
  var shapes = options.shapes || morpheus.VectorShapeModel.SHAPES;

  var _this = this;
  var html = [];
  var size2 = 8;
  var x = 4;
  var y = 4;
  html
    .push('<div style="margin-bottom:1em;" class="btn-group">');
  html
    .push(
      '<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-expanded="false"><span data-name="selection"></span> <span class="fa fa-caret-down"></span></button>');
  html.push('<ul class="dropdown-menu" role="menu">');
  if (options.showNone) {
    html.push('<li><a data-name="none" href="#">(None)</a></li>');
  }
  for (var i = 0; i < shapes.length; i++) {
    var context = new C2S(size2 * 2, size2 * 2);
    context.translate(4, 4);
    morpheus.CanvasUtil.drawShape(context, shapes[i], x, y, size2);
    var svg = context.getSerializedSvg();
    html.push('<li><a data-name="' + shapes[i] + '" href="#">' + svg
      + '</a></li>');
  }

  html.push('</ul></div>');
  var $el = $(html.join(''));
  var $header = $el.find('[data-name=selection]');
  $el.on('click', 'li > a', function (e) {
    e.preventDefault();
    var shape = $(this).data('name');
    setShapeValue(shape);
    _this.trigger('change', {
      shape: shape
    });
  });
  var setShapeValue = function (val) {
    if (val === 'none') {
      $header.html('(None)');
    } else {
      var context = new C2S(size2 * 2, size2 * 2);
      context.translate(4, 4);
      morpheus.CanvasUtil.drawShape(context, val, x, y, size2);
      $header.html(context.getSerializedSvg());
    }
  };
  this.setShapeValue = setShapeValue;
  this.$el = $el;
};
morpheus.ShapeField.prototype = {};
morpheus.Util.extend(morpheus.ShapeField, morpheus.Events);

morpheus.SortByValuesIndicator = function (project, isVertical, positions) {
  morpheus.AbstractCanvas.call(this, true);
  this.project = project;
  this.isVertical = isVertical;
  this.positions = positions;
  this.lastPosition = {
    start: -1,
    end: -1
  };
};
morpheus.SortByValuesIndicator.prototype = {
  prePaint: function (clip, context) {
    var positions = this.positions;
    var start = 0;
    var end = positions.getLength();
    if (!this.isVertical) {
      start = morpheus.Positions.getLeft(clip, positions);
      end = morpheus.Positions.getRight(clip, positions);
    } else {
      start = morpheus.Positions.getTop(clip, positions);
      end = morpheus.Positions.getBottom(clip, positions);
    }
    if (this.invalid || start !== this.lastPosition.start
      || end !== this.lastPosition.end) {
      this.lastPosition.start = start;
      this.lastPosition.end = end;
      this.invalid = true;
    }
  },
  draw: function (clip, context) {
    var project = this.project;
    var isVertical = this.isVertical;
    var positions = this.positions;
    var sortKeys = isVertical ? project.getColumnSortKeys() : project
    .getRowSortKeys();
    context.translate(-clip.x, -clip.y);
    context.fillStyle = 'black';
    context.textBaseline = 'top';
    context.textAlign = 'left';
    context.font = '8px ' + morpheus.CanvasUtil.getFontFamily(context);
    var start = 0;
    var end = positions.getLength();
    if (!isVertical) {
      start = morpheus.Positions.getLeft(clip, positions);
      end = morpheus.Positions.getRight(clip, positions);
    } else {
      start = morpheus.Positions.getTop(clip, positions);
      end = morpheus.Positions.getBottom(clip, positions);
    }
    var arrowWidth = 3;
    var arrowHeight = 4;
    for (var i = 0; i < sortKeys.length; i++) {
      var key = sortKeys[i];
      if (key instanceof morpheus.SortByValuesKey) { // are we sorting
        // columns by the
        // values in a row?

        var modelIndices = key.modelIndices;
        for (var j = 0; j < modelIndices.length; j++) {
          var modelIndex = modelIndices[j];
          var view = isVertical ? project
          .convertModelRowIndexToView(modelIndex) : project
          .convertModelColumnIndexToView(modelIndex);
          if (view !== -1 && view >= start && view < end) {
            context.save();
            var pix = positions.getPosition(view);
            var size = positions.getItemSize(view);
            if (!isVertical) {
              context.translate(pix + size / 2, 0);
            } else {
              context.translate(2, pix + size / 2);
            }
            context.beginPath();
            // if (!isVertical) {
            if (key.getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
              // up arrow
              context.moveTo(0, 0);
              context.lineTo(arrowWidth, arrowHeight);
              context.lineTo(-arrowWidth, arrowHeight);
            } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.DESCENDING) { // down
              // arrow
              context.moveTo(0, arrowHeight);
              context.lineTo(arrowWidth, 0);
              context.lineTo(-arrowWidth, 0);
            } else { // diamond
              context.moveTo(0, 0);
              context.lineTo(arrowWidth, arrowHeight / 2);
              context.lineTo(0, arrowHeight);
              context.lineTo(-arrowWidth, arrowHeight / 2);

            }
            // } else {
            // if (!ascending) { // left arrow
            // context.moveTo(0, 0);
            // context.lineTo(arrowWidth, arrowHeight);
            // context.lineTo(arrowWidth, -arrowHeight);
            // } else {
            // context.moveTo(arrowWidth, 0); // right arrow
            // context.lineTo(0, arrowHeight);
            // context.lineTo(0, -arrowHeight);
            // }
            // }
            context.fill();

            // don't indicate sort priority b/c of limited space
//						if (sortKeys.length > 1) {
//							context.fillText('' + (i + 1), 0, 0);
//						}
            context.restore();
          }
        }
      }
    }
  }
};
morpheus.Util.extend(morpheus.SortByValuesIndicator, morpheus.AbstractCanvas);

morpheus.SortDialog = function (project) {
  var _this = this;
  // choose rows or columns
  var $chooserDiv = $('<div class="container-fluid"></div>');
  var $div = $('<div class="container-fluid"></div>');
  var html = [];
  html
    .push('<div style="border-bottom:1px solid LightGrey;margin-bottom:20px;" class="row">');
  html.push('<form class="form-horizontal" role="form">');
  html
    .push('<div class="col-xs-2"><label class="control-label">Sort</label></div>');
  html.push('<div class="col-xs-5">');
  html
    .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="rows" checked>Rows</label></div>');
  html
    .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="columns">Columns</label></div>');
  html.push('</div>');
  html.push('</form>');
  html.push('</div>');
  $chooserDiv.html(html.join(''));

  function toggle(isColumns) {
    _this.isColumns = isColumns;
    var $element = _this.build(project, isColumns);
    $div.empty().html($element);
    $div.on('click', '[data-name=delete]', function (e) {
      var $this = $(this);
      e.preventDefault();
      $this.closest('div.row').remove();
    });
    $div.on('click', '[data-name=add]', function (e) {
      var $this = $(this);
      var level = [];
      var $sibling = $this.closest('div.row');
      _this.createLevel(level, new morpheus.SortKey('',
        morpheus.SortKey.SortOrder.ASCENDING), _this.fields);
      $sibling.after($(level.join('')));
      e.preventDefault();
    });
  }

  $chooserDiv.on('change', '[name=rowsOrColumns]', function (e) {
    var $this = $(this);
    toggle($this.val() === 'columns');
  });
  toggle(false);
  var $outer = $('<div></div>');
  $chooserDiv.appendTo($outer);
  $div.appendTo($outer);
  morpheus.FormBuilder
    .showOkCancel({
      title: 'Sort',
      content: $outer,
      okCallback: function () {
        var $forms = $div.find('form');
        var sortBy = $forms.find('[name=sortBy]').map(function () {
          return $(this).val();
        });
        var lockOrder = $forms.find('[name=lockOrder]').map(function () {
          return $(this).prop('checked');
        });
        var sortOrder = $forms.find('[name=sortOrder]:checked')
          .map(function () {
            return $(this).val();
          });

        var groupBy = $div.find('[name=groupBy]').val();
        var newSortKeys = [];
        var modelIndices = _this.isColumns ? project
          .getRowSelectionModel().toModelIndices() : project
          .getColumnSelectionModel().toModelIndices();
        var existingSortKeys = _this.isColumns ? project
          .getColumnSortKeys() : project.getRowSortKeys();
        for (var i = 0; i < existingSortKeys.length; i++) {
          // delete existing sort keys that were locked and were deleted by user
          if (existingSortKeys[i].isUnlockable()) {
            existingSortKeys.splice(i, 1);
            i--;
          }
        }

        var newSortKeyFields = new morpheus.Set();
        for (var i = 0; i < sortBy.length; i++) {
          if (!newSortKeyFields.has(sortBy[i])) { // don't add 2x
            newSortKeyFields.add(sortBy[i]);
            var key = null;
            if (sortBy[i] === 'selection') {
              key = new morpheus.SortByValuesKey(
                modelIndices, sortOrder[i],
                _this.isColumns);
            } else if (sortBy[i] !== '') {
              key = new morpheus.SortKey(
                sortBy[i], sortOrder[i]);
            }
            if (key != null) {
              newSortKeys.push(key);
              if (lockOrder[i]) {
                key.setLockOrder(1);
              }
            }
          }
        }
        var newGroupKeys = [];
        if (groupBy != null) {
          for (var i = 0; i < groupBy.length; i++) {
            newGroupKeys.push(new morpheus.SortKey(groupBy[i],
              morpheus.SortKey.SortOrder.UNSORTED));
          }
        }

        if (_this.isColumns) {
          project.setGroupColumns(newGroupKeys, true);
          project.setColumnSortKeys(morpheus.SortKey
            .keepExistingSortKeys(newSortKeys, existingSortKeys), true);
        } else {
          project.setGroupRows(newGroupKeys, true);
          project.setRowSortKeys(morpheus.SortKey
            .keepExistingSortKeys(newSortKeys, existingSortKeys), true);
        }
      }
    });
};
morpheus.SortDialog.prototype = {
  isColumns: false,
  build: function (project, isColumns) {
    var fields = morpheus.MetadataUtil.getMetadataNames(isColumns ? project
      .getFullDataset().getColumnMetadata() : project
      .getFullDataset().getRowMetadata());
    this.fields = fields;
    var html = [];
    var sortKeys = isColumns ? project.getColumnSortKeys() : project
      .getRowSortKeys();

    this.createLevel0(html);
    for (var i = 0; i < sortKeys.length; i++) { // add existing keys
      if (sortKeys[i].isUnlockable()) {
        this.createLevel(html, sortKeys[i], fields);
      }
    }
    // group by
    html.push('<div class="row">');
    html
      .push('<form class="form-horizontal" role="form">');
    html.push('<div class="col-xs-2"><label>Group by</label></div>');
    html.push('<div class="col-xs-4">');
    var groupByKeys = (isColumns ? project.getGroupColumns() : project
      .getGroupRows()).map(function (key) {
      return key.field;
    });

    html.push('<select multiple name="groupBy" class="selectpicker form-control">');
    _.each(fields, function (field) {
      html.push('<option value="' + field + '"');
      if (_.indexOf(groupByKeys, field) !== -1) {
        html.push(' selected');
      }
      html.push('>');
      html.push(field);
      html.push('</option>');
    });
    html.push('</select>');
    html.push('</div>');
    html.push('</div>');
    var $div = $(html.join(''));
    $div.find('.selectpicker').selectpicker({
      iconBase: 'fa',
      tickIcon: 'fa-check',
      style: 'btn-default btn-sm'
    });
    return $div;
  },
  createLevel0: function (html) {
    html
      .push('<div style="border-bottom:1px solid LightGrey;margin-bottom:20px;" class="row">');
    html.push('<form class="form-horizontal" role="form">');
    html.push('<div class="col-xs-8">');
    html.push('<a data-name="add" href="#">Add sort level</a>');
    html.push('</div>');
    html.push('</form>');
    html.push('</div>');
  },
  createLevel: function (html, key, fields) {
    html
      .push('<div style="border-bottom:1px solid LightGrey;margin-bottom:20px;" class="row">');
    html.push('<form class="form-horizontal" role="form">');
    html
      .push('<div class="col-xs-2"><label class="control-label">Sort by</label></div>');
    html.push('<div class="col-xs-4">');
    html.push('<select name="sortBy" class="form-control">');
    html.push('<option value=""></option>');
    html.push('<option value="selection"'
      + (key instanceof morpheus.SortByValuesKey ? ' selected' : '')
      + '>selection</option>');
    _.each(fields, function (field) {
      html.push('<option value="' + field + '"');
      if (field == key.toString()) {
        html.push(' selected');
      }
      html.push('>');
      html.push(field);
      html.push('</option>');
    });
    html.push('</select>');
    html.push('</div>');
    html.push('<div class="col-xs-5">');
    html
      .push('<div class="radio"><label><input type="radio" name="sortOrder" value="ascending"'
        + (morpheus.SortKey.SortOrder.ASCENDING == key
          .getSortOrder() ? ' checked' : '')
        + '>Ascending</label></div>');
    html
      .push('<div class="radio"><label><input type="radio" name="sortOrder" value="descending"'
        + (morpheus.SortKey.SortOrder.DESCENDING == key
          .getSortOrder() ? ' checked' : '')
        + '>Descending</label></div>');
    html.push('</div>');
    html.push('<div class="col-xs-1">');
    html.push('<a data-name="delete">Delete</a>');
    html.push('</div>');
    html.push('<div class="col-xs-12">');
    html.push('<div class="checkbox"><label><input name="lockOrder" type="checkbox"' + (key.getLockOrder() !== 0 ? ' checked' : '') + '> Lock sort level</label></div>');
    html.push('</div>');
    html.push('<div class="col-xs-12">');
    html.push('<br />');
    html.push('<a data-name="add" href="#">Add sort level</a>');
    html.push('</div>');
    html.push('</form>');
    html.push('</div>');
  }
};

morpheus.SteppedColorSupplier = function () {
  morpheus.AbstractColorSupplier.call(this);
  this.hiddenValue = 0;
  this.hiddenValues = new morpheus.Set();
  this.stepped = true;
};
/**
 * Convert value from input data range of input0 to input1 to pixel range of
 * pix0, pix1.
 *
 * @return The converted value.
 */
morpheus.SteppedColorSupplier.linearScale = function (value, input0, input1,
                                                      pix0, pix1) {
  return (value - input0) / (input1 - input0) * (pix1 - pix0) + pix0;
};
morpheus.SteppedColorSupplier.prototype = {
  createInstance: function () {
    return new morpheus.SteppedColorSupplier();
  },
  isStepped: function () {
    return true;
  },
  getHiddenValues: function () {
    return this.hiddenValues;
  },
  getIndexForFraction: function (f) {
    var fractions = this.fractions;
    if (f <= fractions[0]) {
      return 0;
    }
    if (f >= fractions[fractions.length - 1]) {
      return fractions.length - 1;
    }
    // Intervals exclude right end point and include left end point except
    // for the highest interval which includes everything > min
    for (var i = 0; i < fractions.length - 1; i++) {
      var left = fractions[i];
      var right = fractions[i + 1];
      if (f >= left && f < right) {
        return i;
      }
    }
    return fractions.length - 1;
  },
  getColor: function (row, column, value) {
    if (this.hiddenValues.has(value)) {
      value = this.hiddenValue;
    }
    if (isNaN(value)) {
      return this.missingColor;
    }
    var min = this.min;
    var max = this.max;
    var colors = this.colors;
    if (value <= min) {
      return colors[0];
    } else if (value >= max) {
      return colors[colors.length - 1];
    }
    var fraction = morpheus.SteppedColorSupplier.linearScale(value, min,
        max, 0, 100) / 100;
    return colors[this.getIndexForFraction(fraction)];
  }
};
morpheus.Util.extend(morpheus.SteppedColorSupplier,
  morpheus.AbstractColorSupplier);

/**
 * @param options.autohideTabBar
 *            Whether to autohide the tab bar when only 1 tab showing
 * @param options.landingPage Landing page to show when all tabs are closed
 */
morpheus.TabManager = function (options) {
  this.options = $.extend({}, {
    autohideTabBar: false,
    rename: true
  }, options);
  var _this = this;
  this.activeTabObject = null;
  this.activeTabId = null;
  this.idToTabObject = new morpheus.Map();
  this.$nav = $('<ul class="nav nav-tabs compact morpheus-nav"></ul>');
  this.$nav.sortable({
    containment: 'parent',
    axis: 'x',
    helper: 'clone',
    cancel: 'li:not(.morpheus-sortable)',
    items: 'li.morpheus-sortable'
  });
  this.$nav.sortable('disable');
  this.$nav.on('click', 'li > a', function (e) {
    var tabId = $(this).data('link');
    if (tabId != null) {
      e.preventDefault();
      if (_this.activeTabId !== tabId) {
        $(this).tab('show');
      }
    }
  });
  if (this.options.autohideTabBar) {
    this.$nav.css('display', 'none');
  }
  if (options.dropTab) {
    var html = [];
    html.push('<li class="morpheus-tab-addon dropdown pull-right tabdrop">');
    html.push('<div class="btn-group">');
    html.push('<button type="button" class="morpheus-drop-tab-toggle btn btn-link' +
      ' dropdown-toggle"' +
      ' data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">');
    html.push(' <span class="fa fa-angle-double-down"></span>');
    html.push('</button>');
    html
    .push('<ul class="dropdown-menu dropdown-menu-right" role="menu">');
    html.push('</ul>');
    html.push('</div>');
    html.push('</li>');
    var $tabDrop = $(html.join(''));
    // $tabDrop.css('display', 'none');
    var $tabDropMenu = $tabDrop.find('.dropdown-menu');
    $tabDrop.appendTo(this.$nav);
    var updateDropTab = function () {
      var totalWith = _this.$nav.width() - 17; // 17=width of dropdown
      var sum = 0;
      var tabDropItems = [];
      _this.$nav.find('> li').each(function () {
        var $li = $(this);
        var $a = $li.find('a');
        if (!$li.hasClass('morpheus-tab-addon')) {
          var title = $a.contents().first().text();
          var isActive = $li.hasClass('active');
          var href = $a.attr('href');
          tabDropItems.push('<li class="' + (isActive ? 'active' : '') + '"><a data-link="' + href.substring(1) + '" data-toggle="tab"' +
            ' href="' + href + '">' + title + '</a></li>');
          sum += $li.outerWidth();
          if (sum >= totalWith) {
            $li.css('display', 'none');
          } else {
            $li.css('display', '');
          }
        }
      });
      $tabDrop.css('display', tabDropItems.length > 0 ? '' : 'none');
      $tabDropMenu.html(tabDropItems.join(''));
    };
    $tabDrop.css('display', 'none');
    this.$nav.on('sortstop', function (event, ui) {
      updateDropTab();
    });
    $(window).on('resize', updateDropTab);
    this.$nav.on('remove', function () {
      $(window).off('resize', updateDropTab);
    });
    this.on('add remove rename reorder change', function () {
      updateDropTab();

    });
  }

  this.$nav.on('dblclick', 'li > a', function (e) {
    e.preventDefault();
    var $a = $(this);
    var $li = $a.parent('li');
    if ($li.hasClass('morpheus-tab-addon')) {
      return;
    }
    _this.rename($a.data('link'));

  });
  this.$nav.on('contextmenu.morpheus', 'li > a', function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    var $a = $(this);
    var $li = $a.parent('li');
    if ($li.hasClass('morpheus-tab-addon')) {
      return;
    }
    var menuItems = [];
    if ($a.data('morpheus-rename') && _this.options.rename) {
      menuItems.push({name: 'Rename'});
    }
    if ($a.data('morpheus-pin')) { // pinned
      menuItems.push({name: 'Unpin tab'});
    } else {
      menuItems.push({name: 'Pin tab'});
    }

    if (menuItems.length > 0) {
      morpheus.Popup.showPopup(menuItems, {
        x: e.pageX,
        y: e.pageY
      }, e.target, function (event, item) {
        if (item === 'Rename') {
          _this.rename($a.data('link'));
        } else if (item === 'Pin tab') {
          $a.data('morpheus-pin', true);
          $li.removeClass('morpheus-sortable');
          $li.detach();
          _this.$nav.prepend($li);
          $a.find('.close').hide();    // hide close button
          _this.$nav.sortable('option', 'items', 'li.morpheus-sortable');
          _this.$nav.sortable('refresh');
        } else if (item === 'Unpin tab') {
          $a.data('morpheus-pin', false);
          $li.addClass('morpheus-sortable');
          $a.find('.close').show(); // show close button
          _this.$nav.sortable('option', 'items', 'li.morpheus-sortable');
          _this.$nav.sortable('refresh');

        }
      });
    }
    return false;

  });

  this.$nav.on('click', 'button', function (e) { // close a tab
    // remove the link and tab content
    e.preventDefault();
    var target = $(this).attr('data-target');

    if (target != null) {
      target = target.substring(1); // remove #
      _this.remove(target);
    }
  });

  this.$tabContent = $('<div class="tab-content"></div>');
  this.$nav.on('shown.bs.tab', 'a[data-toggle="tab"]', function (e) {
    // triggered when clicking tab
    var previous = _this.activeTabId;
    _this.activeTabId = $(e.target).data('link');
    _this.activeTabObject = _this.idToTabObject.get(_this.activeTabId);
    _this.$nav.find('li').removeClass('active');
    _this.$nav.find('[data-link=' + _this.activeTabId + ']').each(function () {
      $(this).parent().addClass('active');// not added via droptab
    });
    var scrollTop = document.body.scrollTop;
    $('#' + _this.activeTabId).focus();
    document.body.scrollTop = scrollTop; // focus can change scroll position
    if (_this.adding) {
      return;
    }
    _this.trigger('change', {
      tab: _this.activeTabId,
      previous: previous
    });
  });

};
morpheus.TabManager.prototype = {
  getTabText: function (id) {
    return this.$nav.find('> li > a').filter('a[data-link=' + id + ']').contents().first().text();
  },
  getTabCount: function () {
    return this.idToTabObject.size();
  },
  setTabText: function (id, text) {
    this.$nav.find('> li > a').filter('[data-link=' + id + ']').contents().first()
    .replaceWith(text + '&nbsp;');
    this.idToTabObject.get(id).setName(name);
  },
  /**
   * @param id
   *            Tab id
   * @param task
   * @param task.worker
   *            Optional worker that the task is run in.
   * @param task.name
   * @param task.tabId
   *            Tab id for task
   */
  addTask: function (task) {

  },
  removeTask: function (task) {

  },
  getWidth: function () {
    return this.$tabContent.outerWidth() || $(window).width();
  },
  getActiveTab: function () {
    return this.activeTabObject;
  },
  getActiveTabId: function () {
    return this.activeTabId;
  },

  /**
   *
   * @param options.object The object that stores the tab content state and has a setName if
   * function if rename is true.
   * @param options.$el
   *            the tab element
   * @param options.title
   *            the tab title
   * @param options.closeable
   *            Whether tab can be closed
   * @param options.rename
   *            Whether tab can be renamed
   * @param options.focus
   *            Whether new tab should be focused-note the change event is not
   *            triggered when true
   * @param options.enabled
   *            Whether new tab is enabled
   *
   */
  add: function (options) {
    this.adding = true;
    var id = _.uniqueId('morpheus-tab');
    this.idToTabObject.set(id, options.object);
    var li = [];
    li.push('<li class="morpheus-sortable" role="presentation">');
    li.push('<a data-morpheus-rename="' + options.rename
      + '" data-toggle="tab" data-link="' + id + '" href="#' + id + '">');
    li.push(options.title);
    li.push('&nbsp;<i style="color:black;"></i>');
    if (options.closeable) {
      li
      .push('&nbsp<button style="font-size: 18px;" type="button" class="close"' +
        ' aria-label="Close"' +
        ' data-target="#'
        + id
        + '"><span aria-hidden="true"></span></button>');

    }
    li.push('</a></li>');
    var $link = $(li.join(''));
    $link.appendTo(this.$nav);
    var $panel = $('<div tabIndex="0" style="outline:0;cursor:default;" role="tabpanel"' +
      ' class="tab-pane" id="'
      + id + '"></div>');
    options.$el.appendTo($panel);
    $panel.appendTo(this.$tabContent);
    if (options.enabled === false) {
      $link.addClass('disabled');
      $link.find('a').addClass('btn disabled');
    }
    if (options.focus) {
      // update active tab, but don't fire event
      this.$nav.find('> li > a[data-toggle="tab"]:last').tab('show');
      this.activeTabId = id;
      this.activeTabObject = options.object;
      $panel.focus();
    }

    if (this.options.autohideTabBar) {
      this.$nav.css('display', this.idToTabObject.size() > 1 ? ''
        : 'none');
    }
    this.getTabCount() <= 1 ? this.$nav.sortable('disable') : this.$nav.sortable('enable');
    this.adding = false;
    this.trigger('add');
    return {
      $panel: $panel,
      id: id
    };
  },
  appendTo: function ($target) {
    this.$nav.appendTo($target);
    this.$tabContent.appendTo($target);
  },
  remove: function (target) {
    if (target === undefined) {
      target = this.activeTabId;
    }
    var obj = this.idToTabObject.remove(target);
    $('#' + target).remove(); // remove tab-pane
    this.activeTabObject = null;
    this._getA(target).parent().remove();
    this.$tabContent.find(target).remove();
    var $a = this.$nav.find('> li > a[data-toggle="tab"]:last');
    if ($a.length === 0) {
      // no content
      if (this.options.landingPage) {
        if (typeof this.options.landingPage === 'function') {
          this.options.landingPage().show();
        } else {
          this.options.landingPage.show();
        }
      }
    }

    $a.tab('show');
    if (this.options.autohideTabBar) {
      this.$nav.css('display', this.idToTabObject.size() > 1 ? ''
        : 'none');
    }
    this.getTabCount() <= 1 ? this.$nav.sortable('disable') : this.$nav.sortable('enable');
    if (this.idToTabObject.size() > 0) {
      $($a.attr('href')).focus();
    }
    if (obj != null && obj.onRemove) {
      obj.onRemove();
    }
    this.trigger('remove', {
      tab: target
    });
  },
  setOptions: function (options) {
    this.options = options;
    if (this.options.autohideTabBar) {
      this.$nav.css('display', this.idToTabObject.size() > 1 ? ''
        : 'none');
    }
  },
  getOptions: function () {
    return this.options;
  },
  setActiveTab: function (id) {
    if (id !== this.activeTabId) {
      var $a = this._getA(id);
      // make sure it's enabled
      $a.parent().removeClass('disabled');
      $a.removeClass('btn disabled');
      $a.tab('show');
      var previous = this.activeTabId;
      this.activeTabId = id;
      this.activeTabObject = this.idToTabObject.get(this.activeTabId);
      this.trigger('change', {
        tab: this.activeTabId,
        previous: previous
      });
    }

  },
  /**
   *
   * @param id
   *            The tab id
   * @param title
   *            The title (used to show tooltip)
   */
  setTabTitle: function (id, title) {
    this._getA(id).attr('title', title);
  },
  _getA: function (id) {
    if (id[0] === '#') {
      id = id.substring(1);
    }
    return this.$nav.find('> li > a[data-link=' + id + ']:first');
  },
  setTabEnabled: function (id, enabled) {
    var $a = this._getA(id);
    if (enabled) {
      $a.parent().removeClass('disabled');
      $a.removeClass('btn disabled');
    } else {
      $a.parent().addClass('disabled');
      $a.addClass('btn disabled');
    }

  },
  getIdToTabObject: function () {
    return this.idToTabObject;
  },
  getTabObject: function (id) {
    return this.idToTabObject.get(id);
  },
  rename: function (id) {
    var $a = this._getA(id);
    var $li = $a.parent();
    if ($li.hasClass('morpheus-tab-addon')) {
      return;
    }
    if (!$a.data('morpheus-rename') || !this.options.rename) {
      return;
    }
    var _this = this;
    var builder = new morpheus.FormBuilder();
    builder.append({
      name: 'name',
      type: 'text',
      value: $.trim($a.contents().first().text())
    });
    morpheus.FormBuilder.showOkCancel({
      title: 'Rename Tab',
      content: builder.$form,
      focus: document.activeElement,
      okCallback: function () {
        var name = $.trim(builder.getValue('name'));
        if (name !== '') {
          if (_this.activeTabObject != null && _this.activeTabObject.setName) {
            _this.activeTabObject.setName(name);
          }
          $a.contents().first().replaceWith(name + '&nbsp;');
          _this.trigger('rename');
        }
      }
    });
    // edit tab name
  }
};
morpheus.Util.extend(morpheus.TabManager, morpheus.Events);

/**
 * @param options.$el The jQuery element to render to. Must be in the DOM.
 * @param options.items An array of items to display in the table
 * @param options.search Whether to create a search widget
 * @param options.rowHeader Renderer to call for each row in the table
 * @param options.rowHeight Table row height
 * @param height: Height in pixels of table. '564px',
 * @param options.collapseBreakpoint: 500
 * @param options.showHeader: true
 * @param options.select: true
 * @param options.responsive: true
 * @param options.fixedWidth: Fixed table with when responsive is false. '320px'
 * @param options.columns An array of column descriptors. Each column can have the properties:
 * visible, name, field, renderer
 */



morpheus.Table = function (options) {
  options = morpheus.Table.createOptions(options);
  this.options = options;
  if (!options.width) {
    options.width = options.$el.attr('class');
  }
  var _this = this;

  var height = options.height;
  var $gridDiv = $('<div class="slick-table'
    + (options.tableClass ? (' ' + options.tableClass) : '')
    + '" style="width:' + options.fixedWidth + ';height:' + height
    + '"></div>');

  this.$gridDiv = $gridDiv;
  $gridDiv.appendTo(options.$el);
  // all columns (including those that are currently not visible */
  var columns = options.columns;
  this.columns = columns;
  var visibleColumns = columns.filter(function (c) {
    return c.visible;
  });
  var grid = new morpheus.Grid({
    gridOptions: {
      select: options.select,
      rowHeight: options.rowHeight,
      autoEdit: false,
      editable: false,
      autoHeight: options.height === 'auto',
      enableTextSelectionOnCells: true,
    },
    $el: $gridDiv,
    items: options.items,
    columns: visibleColumns
  });
  this.grid = grid;
  this.searchFunction = null;
  var searchFilter = {
    isEmpty: function () {
      return _this.searchFunction == null;
    },
    init: function () {
    },
    accept: function (item) {
      return _this.searchFunction(item);
    }
  };
  // add empty search filter
  this.grid
  .getFilter().add(searchFilter);
  var $header = $('<div class="slick-table-header"><div name="top"></div><div style="display: inline-block;" name="left" class="pad-bottom-8 pad-top-8"></div><div name="right" class="pull-right pad-bottom-8' +
    ' pad-top-8"></div></div>');
  this.$header = $header;
  var $right = $header.find('.pull-right');
  if (options.search) {
    var tableSearch = new morpheus.TableSearchUI({
      $el: $header.find('[name=top]'),
      $right: $right
    });
    tableSearch.setTable(this);
    this.tableSearch = tableSearch;
  }
  if (options.columnPicker && visibleColumns.length !== this.columns.length) {
    var select = [];
    select
    .push('<select data-width="90px" data-selected-text-format="static" title="Columns..." multiple class="pad-left-4 selectpicker show-tick">');
    // sort column names
    var sortedColumns = this.columns.slice().sort(function (a, b) {
      a = a.name.toLowerCase();
      b = b.name.toLowerCase();
      return (a === b ? 0 : (a < b ? -1 : 1));
    });
    sortedColumns.forEach(function (c, i) {
      select.push('<option value="' + i + '"');
      if (c.visible) {
        select.push(' selected');
      }
      select.push('>');
      select.push(c.name);
      select.push('</option>');
    });
    select.push('</select>');
    var $select = $(select.join(''));
    $select.appendTo($right);
    $select.selectpicker({
      iconBase: 'fa',
      tickIcon: 'fa-check',
      style: 'btn-default btn-xs'
    });
    $select.on('change', function () {
      var oldColumns = grid.getColumns().map(function (c) {
        return c.id;
      });
      var selectedColumnIndices = $select.val();
      visibleColumns = [];
      for (var i = 0; i < selectedColumnIndices.length; i++) {
        visibleColumns.push(sortedColumns[parseInt(selectedColumnIndices[i])]);
      }
      var newColumns = visibleColumns.map(function (c) {
        return c.id;
      });

      grid.setColumns(visibleColumns);

      if (newColumns.length > oldColumns.length) {
        var set = new morpheus.Set();
        for (var i = 0; i < newColumns.length; i++) {
          set.add(newColumns[i]);
        }
        for (var i = 0; i < oldColumns.length; i++) {
          set.remove(oldColumns[i]);
        }
        var added = set.values();

        grid.setSortColumns([{
          columnId: added[0],
          sortAsc: true
        }]);
      }
      // if column added, sort by added column
      _this.resize();
      _this.redraw();

    });
  }
  $header.prependTo(options.$el);
  var collapsed = false;
  var lastWidth = -1;
  var resize = function () {
    if (!_this.options.responsive) {
      return;
    }

    var gridWidth = options.$el.width();
    if (gridWidth === lastWidth) {
      return;
    }
    lastWidth = gridWidth;

    $gridDiv.css('width', gridWidth + 'px');
    // if (options.responsiveHeight) {
    // var verticalPosition = _this.$gridDiv[0].getBoundingClientRect().top
    // + window.pageYOffset;
    // $gridDiv.css('height',
    // (document.body.clientHeight - verticalPosition) + 'px');
    // }
    if (!collapsed && gridWidth < options.collapseBreakpoint
      && visibleColumns.length > 1) {
      collapsed = true;
      $gridDiv.addClass('slick-stacked');

      _this.grid.grid.getOptions().rowHeight = (options.collapsedRowHeight ? options.collapsedRowHeight : options.rowHeight)
        * visibleColumns.length;
      // collapse
      _this.grid.grid
      .setColumns([{
        id: 0,
        tooltip: function (item, value) {
          var html = [];
          for (var i = 0; i < visibleColumns.length; i++) {
            var text = visibleColumns[i].tooltip(item, visibleColumns[i]
            .getter(item));
            if (text != null && text !== '') {
              html.push(text);
            }
          }
          return html.join('<br />');
        },
        collapsed: true,
        getter: function (item) {
          return item;
        },
        formatter: function (row, cell, value, columnDef,
                             dataContext) {
          var html = [];
          html
          .push('<div class="slick-table-wrapper"><div class="slick-cell-wrapper">');
          if (options.rowHeader) { // e.g. render checkbox
            html.push(options.rowHeader(dataContext));
            html.push('<div style="height:4px;"></div>');
          }
          for (var i = 0; i < visibleColumns.length; i++) {
            if (i > 0) {
              html.push('<div style="height:4px;"></div>');
            }
            var c = visibleColumns[i];
            html.push(c.name);
            html.push(':');
            var s = c.renderer(dataContext, c
            .getter(dataContext));
            html.push(s);

          }
          html.push('</div></div>');
          return html.join('');
        },
        sortable: false,
        name: ''
      }]);
      $gridDiv.find('.slick-header').hide();
      _this.grid.grid.resizeCanvas();
      _this.grid.grid.invalidate();

    } else if (collapsed && gridWidth >= options.collapseBreakpoint) {
      $gridDiv.removeClass('slick-stacked');
      collapsed = false;
      if (options.showHeader) {
        $gridDiv.find('.slick-header').show();
      }
      _this.grid.grid.getOptions().rowHeight = options.rowHeight;
      _this.grid.grid.setColumns(visibleColumns);
      _this.grid.grid.resizeCanvas();
      if (options.select) {
        _this.grid.grid.setSelectedRows(_this.grid.grid
        .getSelectedRows());
      }
      _this.grid.grid.invalidate();
    } else {
      _this.grid.grid.resizeCanvas();
      _this.grid.grid.invalidate();
    }
    _this.grid.maybeAutoResizeColumns();

  };
  if (!options.showHeader) {
    $gridDiv.find('.slick-header').hide();
  }
  if (options.responsive) {
    $(window).on('resize orientationchange', resize);
    $gridDiv.on('remove', function () {
      $(window).off('resize', resize);
    });
    resize();
  }
  this.resize = resize;
  if (visibleColumns.length > 1 && options.items != null
    && options.items.length > 0) {
    this.setItems(options.items);
  }
  if (!$gridDiv.is(':visible')) {
    // find 1st parent that is not visible
    var $parent = $gridDiv;
    var observer = new MutationObserver(function (mutations) {
      if (window.getComputedStyle($parent[0]).display !== 'none') {
        observer.disconnect();
        resize();
      }
    });

    while ($parent.length > 0) {
      if (window.getComputedStyle($parent[0]).display === 'none') {
        break;
      }
      $parent = $parent.parent();

    }

    if ($parent.length > 0) {
      observer.observe($parent[0], {
        attributes: true,
        childList: false,
        characterData: false
      });
    }

  }
}
;

morpheus.Table.defaultRenderer = function (item, value) {
  if (value == null) {
    return '';
  } else if (_.isNumber(value)) {
    return morpheus.Util.nf(value);
  } else if (morpheus.Util.isArray(value)) {
    var s = [];
    for (var i = 0, length = value.length; i < length; i++) {
      if (i > 0) {
        s.push(', ');
      }
      var val = value[i];
      s.push(value[i]);
    }
    return s.join('');
  } else {
    return '' + value;
  }
};

morpheus.Table.prototype = {
  toText: function () {
    var text = [];
    var items = this.getItems();
    var columns = this.columns.filter(function (c) {
      return c.visible;
    });
    for (var j = 0; j < columns.length; j++) {
      if (j > 0) {
        text.push('\t');
      }
      text.push(columns[j].name);
    }
    text.push('\n');
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      for (var j = 0; j < columns.length; j++) {
        if (j > 0) {
          text.push('\t');
        }
        var value = columns[j].getter(item);
        text.push(morpheus.Util.toString(value));
      }
      text.push('\n');
    }
    return text.join('');
  },
  setHeight: function (height) {
    this.options.height = height;
    if (height === 'auto') {
      this.$gridDiv.css('height', '');
      this.grid.grid.getOptions().autoHeight = true;
      this.grid.grid.setOptions(this.grid.grid.getOptions());

    } else {
      this.$gridDiv.css('height', height);
    }
    this.grid.grid.resizeCanvas();
    if (height === 'auto') {
      var height = this.getItems().length * this.options.rowHeight
        + this.options.rowHeight;
      this.$gridDiv.find('.slick-viewport').css('height', height + 'px');
    }
    this.grid.grid.invalidate();

  },
  setSearchVisible: function (visible) {
    this.$header.find('[name=search]').css('display', visible ? '' : 'none');
  },
  autocomplete: function (tokens, response) {
    var matches = [];
    var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
      : '';
    token = $.trim(token);
    var columns = this.columns.filter(function (c) {
      return (c.searchable && c.visible) || c.alwaysSearch;
    });

    var ncolumns = columns.length;
    var showField = ncolumns > 1;
    if (token === '') {
      if (ncolumns <= 1) {
        return response(matches);
      }
      for (var i = 0; i < ncolumns; i++) {
        var field = columns[i].name;
        matches.push({
          value: field + ':',
          label: '<span style="font-weight:300;">' + field
          + ':</span>',
          show: true
        });
        // show column names

      }
      matches
      .sort(function (a, b) {
        return (a.value === b.value ? 0
          : (a.value < b.value ? -1 : 1));
      });
      return response(matches);
    }
    var field = null;
    var semi = token.indexOf(':');
    var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
    if (semi > 0) { // field search?
      if (token.charCodeAt(semi - 1) !== 92) { // \:
        var possibleField = $.trim(token.substring(0, semi));
        if (possibleField.length > 0 && possibleField[0] === '"'
          && possibleField[token.length - 1] === '"') {
          possibleField = possibleField.substring(1,
            possibleField.length - 1);
        }
        var columnNameToColumn = new morpheus.Map();
        var columnNames = columns.map(function (c) {
          return c.name;
        });
        for (var i = 0; i < columnNames.length; i++) {
          columnNameToColumn.set(columnNames[i], columns[i]);
        }
        var c = columnNameToColumn.get(possibleField);
        if (c !== undefined) {
          token = $.trim(token.substring(semi + 1));
          columns = [c];
          ncolumns = 1;
        }
      }

    } else if (ncolumns > 1) {
      var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
      for (var j = 0; j < ncolumns; j++) {
        var field = columns[j].name;
        if (regex.test(field)) {
          matches.push({
            value: field + ':',
            label: '<span style="font-weight:300;">' + field
            + ':</span>',
            show: true
          });
        }
      }
    }
    var set = new morpheus.Set();
    var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
    var items = this.getItems();
    var dataTypes = [];
    // filter numeric columns
    var filteredColumns = [];
    columns.forEach(function (c) {
      var dataType = null;
      for (var i = 0, nitems = items.length; i < nitems; i++) {
        var value = c.getter(items[i]);
        if (value != null) {
          dataType = morpheus.Util.getDataType(value);
          break;
        }
      }
      if (dataType === 'string' || dataType === '[string]') {
        dataTypes.push(dataType);
        filteredColumns.push(c);
      }
    });
    columns = filteredColumns;
    ncolumns = columns.length;
    var maxSize = matches.length + 10;
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      var item = items[i];
      for (var j = 0; j < ncolumns; j++) {
        var field = columns[j].name;
        var value = columns[j].getter(item);
        var dataType = dataTypes[j];
        if (dataType === '[string]') {
          var nvalues = value == null ? 0 : value.length;
          for (var k = 0; k < nvalues; k++) {
            var val = value[k];
            if (regex.test(val) && !set.has(val)) {
              set.add(val);
              matches
              .push({
                value: showField ? (field + ':' + val)
                  : val,
                label: showField ? ('<span style="font-weight:300;">'
                  + field
                  + ':</span>'
                  + '<span style="font-weight:900;">'
                  + val + '</span>')
                  : ('<span style="font-weight:900;">'
                  + val + '</span>')
              });
            }
            if (matches.length === maxSize) {
              return response(matches);
            }
          }
        } else {
          if (regex.test(value) && !set.has(value)) {
            set.add(value);
            matches
            .push({
              value: showField ? (field + ':' + value)
                : value,
              label: showField ? ('<span style="font-weight:300;">'
                + field
                + ':</span>'
                + '<span style="font-weight:900;">'
                + value + '</span>')
                : ('<span style="font-weight:900;">'
                + value + '</span>')
            });
            if (matches.length === maxSize) {
              return response(matches);
            }
          }
        }

      }
    }
    return response(matches);

  },
  searchWithPredicates: function (predicates) {
    if (predicates == null || predicates.length === 0) {
      this.searchFunction = null;
      this.grid
      .setFilter(this.grid
      .getFilter());
      return;
    }
    var columns = this.columns.filter(function (c) {
      return (c.searchable && c.visible) || c.alwaysSearch;
    });
    var columnNameToColumn = new morpheus.Map();
    var columnNames = columns.map(function (c) {
      return c.name;
    });
    for (var i = 0; i < columnNames.length; i++) {
      columnNameToColumn.set(columnNames[i], columns[i]);
    }

    var filteredPredicates = [];
    var npredicates = predicates.length;
    for (var i = 0; i < npredicates; i++) {
      var predicate = predicates[i];
      var filterColumnName = predicate.getField();
      if (filterColumnName != null) {
        var column = columnNameToColumn.get(filterColumnName);
        if (column) {
          predicate.column = column;
          filteredPredicates.push(predicate);
        }
      } else {
        filteredPredicates.push(predicate);
      }
    }
    predicates = filteredPredicates;
    npredicates = predicates.length;
    var f = function (item) {
      for (var p = 0; p < npredicates; p++) {
        var predicate = predicates[p];
        var searchColumns;
        if (predicate.column) {
          searchColumns = [predicate.column];
        } else {
          searchColumns = columns;
        }
        for (var j = 0, ncolumns = searchColumns.length; j < ncolumns; j++) {
          var value = searchColumns[j].getter(item);
          if (morpheus.Util.isArray(value)) {
            var nvalues = value.length;
            for (var i = 0; i < nvalues; i++) {
              if (predicate.accept(value[i])) {
                return true;
              }
            }
          } else {
            var predicate = predicates[p];
            if (predicate.accept(value)) {
              return true;
            }
          }
        }

      }

      return false;
    };
    this.searchFunction = f;
    this.grid
    .setFilter(this.grid
    .getFilter());
  },
  search: function (text) {
    if (text === '') {
      this.searchFunction = null;
      this.grid
      .setFilter(this.grid
      .getFilter());
    } else {
      var tokens = morpheus.Util.getAutocompleteTokens(text);
      var columns = this.columns.filter(function (c) {
        return (c.searchable && c.visible) || c.alwaysSearch;
      });
      var columnNames = columns.map(function (c) {
        return c.name;
      });
      var predicates = morpheus.Util.createSearchPredicates({
        tokens: tokens,
        fields: columnNames
      });
      this.searchWithPredicates(predicates);
    }
  },
  getSelectedRows: function () {
    return this.grid.getSelectedRows();
  },
  getSelectedItems: function () {
    return this.grid.getSelectedItems();
  },
  getSelectedItem: function () {
    return this.grid.getSelectedItem();
  },
  setSelectedRows: function (rows) {
    this.grid.setSelectedRows(rows);
  },
  getItems: function (items) {
    return this.grid.getItems();
  },
  getAllItemCount: function () {
    return this.grid.getAllItemCount();
  },
  getFilteredItemCount: function () {
    return this.grid.getFilteredItemCount();
  },
  setFilter: function (f) {
    this.grid.setFilter(f);
  },
  getFilter: function () {
    return this.grid.getFilter();
  },
  setItems: function (items) {
    this.grid.setItems(items);
    this.grid.redraw();
    // TODO update height?
  },
  redraw: function () {
    this.grid.redraw();
  },
  /**
   * @param evtStr
   *            selectionChanged
   */
  on: function (evtStr, handler) {
    this.grid.on(evtStr, handler);
    return this;
  },
  off: function (evtStr, handler) {
    this.grid.off(evtStr, handler);
    return this;
  },
  trigger: function (evtStr) {
    this.grid.trigger(evtStr);
  }
};

morpheus.Table.createOptions = function (options) {
  options = $.extend(true, {}, {
    items: [],
    height: '564px',
    collapseBreakpoint: 400,
    showHeader: true,
    select: true,
    rowHeader: null,
    responsive: true,
    fixedWidth: '320px',
    columnPicker: true
  }, options);

  if (!options.columns) {
    options.columns = [{
      name: ''
    }];
  }
  var columns = [];
  options.columns.forEach(function (c, i) {
    var column = $.extend(true, {}, {
      id: i,
      tooltip: function (dataContext, value) {
        return morpheus.Table.defaultRenderer(dataContext, value);
      },
      formatter: function (row, cell, value, columnDef, dataContext) {

        var html = [];
        html.push('<div class="slick-table-wrapper"><div class="slick-cell-wrapper">');
        if (options.rowHeader && cell === 0) {
          html.push(options.rowHeader(dataContext));
        }
        html.push(column.renderer(dataContext, value));
        html.push('</div></div>');
        return html.join('');

      },
      comparator: function (a, b) {
        var aNaN = (a == null || _.isNumber(a) && isNaN(a));
        var bNaN = (b == null || _.isNumber(b) && isNaN(b));
        if (aNaN && bNaN) {
          return 0;
        }
        if (aNaN) {
          return 1;
        }
        if (bNaN) {
          return -1;
        }
        if (a.toLowerCase) {
          a = a.toLowerCase();
        }
        if (b.toLowerCase) {
          b = b.toLowerCase();
        }

        return (a === b ? 0 : (a < b ? -1 : 1));
      },
      sortable: true,
      searchable: true,
      width: null,
      name: c.name,
      renderer: morpheus.Table.defaultRenderer
    }, c);

    if (column.visible === undefined) {
      column.visible = true;
    }
    if (!column.getter) {
      column.getter = column.field == null ? function (item) {
          return item;
        } : function (item) {
          return item[c.field];
        };
    }

    columns.push(column);
  });

  options.columns = columns;
  if (options.columns.length === 1) {
    options.tableClass = 'slick-table-compact';
  } else {
    options.tableClass = 'slick-bordered-table';
  }
  if (!options.rowHeight) {
    // options.rowHeight = options.tableClass === 'slick-table-compact' ? 18
    // 	: 20;
    options.rowHeight = 22;
  }
  return options;
};

morpheus.TableSearchUI = function (options) {
  var _this = this;
  var $search = $('<input name="search" type="text" class="form-control input-sm"' +
    ' placeholder="Search" autocomplete="off">');
  $search.appendTo(options.$el);
  this.$search = $search;
  this.$searchResults = $('<span class="pad-top-2 tableview-rowcount" name="search"></span>');
  this.$showAll = $('<div style="display:inline-block;min-width:60px;" name="search" class="pad-left-8 text-button-copy tableview-rowcount">Show' +
    ' all</div>');
  this.$searchResults.appendTo(options.$right);
  this.$showAll.appendTo(options.$right);
  this.$showAll.on('click', function (e) {
    e.preventDefault();
    $search.val('');
    _this.table.search('');
    _this.table.trigger('showAll', {table: _this.table});

  });
  $search.on('keyup', _.debounce(function () {
    _this.table.search($.trim($(this).val()));
  }, 100));
  morpheus.Util.autosuggest({
    $el: $search,
    suggestWhenEmpty: true,
    filter: function (tokens, response) {
      _this.table.autocomplete(tokens, response);
    },
    select: function () {
      _this.table.search($.trim($search.val()));
    }
  });
};

morpheus.TableSearchUI.prototype = {
  updateSearchLabel: function () {
    var text = 'Showing: ' + morpheus.Util.intFormat(this.table.getFilteredItemCount()) + ' / ' + morpheus.Util.intFormat(this.table.getAllItemCount());
    this.$searchResults.html(text);
  },
  setTable: function (table) {
    this.table = table;
    var _this = this;

    table.on('filter', function () {
      _this.updateSearchLabel();
    });

  }

};


morpheus.TrackSelection = function (track, positions, selectionModel, isColumns,
                                    heatMap) {
  var canvas = track.canvas;
  var startIndex = -1;
  var coord = isColumns ? 'x' : 'y';

  function getPosition(event, useDelta) {
    if (track.settings.squished) {
      var total = positions.getPosition(positions.getLength() - 1)
        + positions.getItemSize(positions.getLength() - 1);
      var squishFactor = total
        / (isColumns ? track.getUnscaledWidth() : track
          .getUnscaledHeight());
      var clientXY = morpheus.CanvasUtil.getClientXY(event, useDelta);
      var p = morpheus.CanvasUtil.getMousePosWithScroll(event.target,
        event, 0, 0, useDelta);
      p[coord] *= squishFactor;
      return p;

    } else {
      return morpheus.CanvasUtil.getMousePosWithScroll(event.target,
        event, heatMap.scrollLeft(), heatMap.scrollTop(),
        useDelta);
    }

  }

  var panning = false;
  var scrollIntervalId;
  var lastScrollTime = new Date().getTime();
  var _this = this;
  var throttlePanMove = 50;

  function mouseleave(e) {

    // listen for mouse hold events
    var scroll = function () {
      var now = new Date().getTime();
      var rect = canvas.getBoundingClientRect();
      var doPan = false;
      if (!isColumns) {
        if (e.clientY > rect.bottom || e.clientY < rect.top) {
          doPan = true;
        }
      } else {
        if (e.clientX > rect.right || e.clientX < rect.left) {
          doPan = true;
        }
      }
      if (doPan) {
        _this.panmove(e);
        scrollIntervalId = setTimeout(scroll, throttlePanMove);
      }
    };
    scrollIntervalId = setTimeout(scroll, throttlePanMove);
    $(canvas).one('mouseover', mouseover);
  }

  function mouseover() {
    // on mouse exit, see if mouse held
    // on mouse enter, stop listening
    clearTimeout(scrollIntervalId);
    $(canvas).one('mouseleave', mouseleave);
  }

  this.hammer = morpheus.Util
    .hammer(canvas, ['pan', 'tap', 'longpress'])
    .on('longpress', this.longpress = function (event) {
      event.preventDefault();
      event.srcEvent.stopImmediatePropagation();
      event.srcEvent.stopPropagation();
      heatMap.setSelectedTrack(track.name, isColumns);
      track.showPopup(event.srcEvent);
    }).on('panend', this.panend = function (event) {
      panning = false;
      clearInterval(scrollIntervalId);
      $(canvas).off('mouseover mouseleave');
    })
    .on(
      'panmove',
      this.panmove = function (event) {
        var now = new Date().getTime();
        var elapsed = now - lastScrollTime;
        if (elapsed < throttlePanMove) {
          return;
        }

        var position = getPosition(event);
        var endIndex = positions.getIndex(position[coord],
          false);
        var commandKey = (event.srcEvent == null) ? false : (morpheus.Util.IS_MAC ? event.srcEvent.metaKey
          : event.srcEvent.ctrlKey);
        var viewIndices = commandKey ? selectionModel
          .getViewIndices() : new morpheus.Set();
        var _startIndex = startIndex;
        if (startIndex > endIndex) {
          var tmp = endIndex;
          endIndex = _startIndex;
          _startIndex = tmp;
        }
        for (var i = _startIndex; i <= endIndex; i++) {
          viewIndices.add(i);
        }
        selectionModel.setViewIndices(viewIndices, true);
        if (!isColumns) {
          var scrollTop = heatMap.scrollTop();
          var heatMapHeight = heatMap.heatmap.getUnscaledHeight();
          var scrollBottom = scrollTop + heatMapHeight;
          if (position.y > scrollBottom) { // scroll down
            heatMap.scrollTop(position.y + 8 - heatMapHeight);
          } else if (position.y < scrollTop) {
            heatMap.scrollTop(position.y - 8);
          }
        } else {
          var scrollLeft = heatMap.scrollLeft();
          var heatMapWidth = heatMap.heatmap.getUnscaledWidth();
          var scrollRight = scrollLeft + heatMapWidth;
          if (position.x > scrollRight) {
            heatMap.scrollLeft(position.x + 8 - heatMapWidth);
          } else if (position.x < scrollLeft) {
            heatMap.scrollLeft(position.x - 8);
          }
        }
        event.preventDefault();
        if (event.srcEvent != null) {
          event.srcEvent.stopPropagation();
          event.srcEvent.stopImmediatePropagation();
        }
        lastScrollTime = new Date().getTime();
      })
    .on('panstart', this.panstart = function (event) {
      heatMap.setSelectedTrack(track.name, isColumns);
      var position = getPosition(event, true);
      startIndex = positions.getIndex(position[coord], false);
      panning = true;

      $(canvas).one('mouseleave.morpheus', mouseleave);

    })
    .on(
      'tap doubletap',
      this.tap = function (event) {
        var position = getPosition(event);
        var index = positions.getIndex(position[coord], false);
        if (event.tapCount > 1) {
          if ((isColumns && !heatMap.options.columnsSortable)
            || (!isColumns && !heatMap.options.rowsSortable)) {
            return;
          }
          heatMap.sortBasedOnSelection(null, isColumns,
            event.srcEvent.shiftKey);
        } else {
          heatMap.setSelectedTrack(track.name, isColumns);
          var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
            : event.srcEvent.ctrlKey;
          if (morpheus.Util.IS_MAC && event.srcEvent.ctrlKey) { // right-click
            // on
            // Mac
            return;
          }
          var viewIndices;
          if (commandKey) { // toggle selection
            viewIndices = selectionModel.getViewIndices();
            if (viewIndices.has(index)) {
              viewIndices.remove(index);
            } else {
              viewIndices.add(index);
            }
          } else if (event.srcEvent.shiftKey) { // add to
            // selection
            viewIndices = selectionModel.getViewIndices();
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            viewIndices.forEach(function (viewIndex) {
              min = Math.min(viewIndex, min);
              max = Math.max(viewIndex, max);
            });

            if (index >= max) { // select from index to max
              for (var i = max; i <= index; i++) {
                viewIndices.add(i);
              }
            } else {// select from index to min
              for (var i = Math.min(index, min), max = Math
                .max(index, min); i <= max; i++) {
                viewIndices.add(i);
              }
            }
          } else {
            viewIndices = new morpheus.Set();
            viewIndices.add(index);
          }
          selectionModel.setViewIndices(viewIndices, true);
        }
      });
};
morpheus.TrackSelection.prototype = {
  dispose: function () {
    this.hammer.off('longpress', this.longpress).off('panstart',
      this.panstart).off('panmove', this.panmove).off('panend', this.panend).off('tap', this.tap).off('doubletap', this.tap);
    this.hammer.destroy();
  }
};

morpheus.VectorTrackHeader = function (project, name, isColumns, heatMap) {
  morpheus.AbstractCanvas.call(this);
  this.font = {weight: '400'};
  this.project = project;
  this.name = name;
  this.isColumns = isColumns;
  var canvas = this.canvas;
  this.heatMap = heatMap;
  this.selectedBackgroundColor = '#c8c8c8';
  this.backgroundColor = 'rgb(255,255,255)';
  var vector = (isColumns ? project.getFullDataset().getColumnMetadata()
    : project.getFullDataset().getRowMetadata()).getByName(name);
  if (vector && vector.getProperties().has(morpheus.VectorKeys.TITLE)) {
    this.canvas.setAttribute('title', vector.getProperties().get(
      morpheus.VectorKeys.TITLE));
    $(this.canvas).tooltip();
  }

  var _this = this;

  this.setBounds({
    height: this.defaultFontHeight
    + morpheus.VectorTrackHeader.FONT_OFFSET
  });

  function getResizeCursor(pos) {
    if (isColumns) {
      if (pos.y < 3) {
        return {
          cursor: 'ns-resize',
          isPrevious: true
        };
      }
      if (pos.y >= (_this.getUnscaledHeight() - 3)) {
        return {
          cursor: 'ns-resize',
          isPrevious: false
        };
      }
      if (pos.x >= (_this.getUnscaledWidth() - 3)) { // change change column width
        return {
          isPrevious: false,
          cursor: 'ew-resize'
        };
      }
    } else {
      if (pos.x < 3 && heatMap.getTrackIndex(name, isColumns) > 0) { // can't drag left on 1st
        // row header
        return {
          cursor: 'ew-resize',
          isPrevious: true
        };
      }
      if (pos.x >= (_this.getUnscaledWidth() - 3)) {
        return {
          cursor: 'ew-resize',
          isPrevious: false
        };
      }
    }
  }

  var mouseMove = function (event) {
    if (!morpheus.CanvasUtil.dragging) {
      var pos = morpheus.CanvasUtil.getMousePos(event.target, event);
      var resizeCursor = getResizeCursor(pos);
      canvas.style.cursor = resizeCursor == null ? 'default' : resizeCursor.cursor;
      //document.body.style.cursor = !cursor ? 'default' : cursor;
      _this.isMouseOver = true;
      _this.repaint();
    }

  };
  var mouseExit = function (e) {
    if (!morpheus.CanvasUtil.dragging) {
      canvas.style.cursor = 'default';
    }
    _this.isMouseOver = false;
    _this.repaint();
  };
  var showPopup = function (e) {
    heatMap.setSelectedTrack(_this.name, isColumns);
    var track = heatMap.getTrack(_this.name, isColumns);
    if (!track) {
      throw _this.name + ' track not found';
    }
    e.preventDefault();
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    if (e.stopImmediatePropagation) {
      e.stopImmediatePropagation();
    }
    track.showPopup(e, true);
    return false;
  };

  $(this.canvas).css({'background-color': this.backgroundColor}).on(
    'mousemove.morpheus', mouseMove).on('mouseout.morpheus', mouseExit)
    .on('mouseenter.morpheus', mouseMove).on('contextmenu.morpheus', showPopup).addClass('morpheus-track-header ' + (isColumns ? 'morpheus-columns' : 'morpheus-rows'));

  var resizeCursor;
  var dragStartWidth = 0;
  var dragStartHeight = 0;
  var reorderingTrack = false;
  var dragStartPosition;
  var resizeTrackName;
  // var throttled = _.throttle(function(event) {
  //
  // if (event.type === 'mouseout') {
  // } else {
  // }
  // }, 100);
  // $(canvas).on('mouseout', throttled).on('mousemove', throttled);
  this.hammer = morpheus.Util
    .hammer(canvas, ['pan', 'tap', 'longpress'])
    .on('longpress', this.longpress = function (event) {
      event.preventDefault();
      heatMap.setSelectedTrack(_this.name, isColumns);
      var track = heatMap.getTrack(_this.name, isColumns);
      track.showPopup(event.srcEvent, true);
    })
    .on(
      'panend',
      this.panend = function (event) {
        _this.isMouseOver = false;
        morpheus.CanvasUtil.dragging = false;
        canvas.style.cursor = 'default';
        var index = heatMap.getTrackIndex(_this.name,
          isColumns);
        var header = heatMap.getTrackHeaderByIndex(index,
          isColumns);
        var track = heatMap
          .getTrackByIndex(index, isColumns);
        var $canvas = $(track.canvas);
        $canvas.css('z-index', '0');
        $(header.canvas).css('z-index', '0');
        heatMap.revalidate();
      })
    .on(
      'panstart',
      this.panstart = function (event) {
        _this.isMouseOver = false;

        if (morpheus.CanvasUtil.dragging) {
          return;
        }
        if (resizeCursor != null) { // resize
          morpheus.CanvasUtil.dragging = true;
          canvas.style.cursor = resizeCursor.cursor;
          if (resizeCursor.isPrevious) {
            var index = heatMap.getTrackIndex(_this.name,
              isColumns);
            index--; // FIXME index = -1
            if (index === -1) {
              index = 0;
            }
            var header = heatMap.getTrackHeaderByIndex(
              index, isColumns);
            dragStartWidth = header.getUnscaledWidth();
            dragStartHeight = header.getUnscaledHeight();
            resizeTrackName = header.name;
          } else {
            resizeTrackName = null;
            dragStartWidth = _this.getUnscaledWidth();
            dragStartHeight = _this.getUnscaledHeight();
          }
          event.preventDefault();
          reorderingTrack = false;
        } else { // move track
          var index = heatMap.getTrackIndex(_this.name,
            isColumns);
          if (index == -1) {
            throw _this.name + ' not found';
          }
          var header = heatMap.getTrackHeaderByIndex(
            index, isColumns);
          var track = heatMap.getTrackByIndex(index,
            isColumns);
          heatMap.setSelectedTrack(_this.name, isColumns);
          var $canvas = $(track.canvas);
          dragStartPosition = $canvas.position();
          $canvas.css('z-index', '100');
          $(header.canvas).css('z-index', '100');
          morpheus.CanvasUtil.dragging = true;
          resizeCursor = undefined;
          reorderingTrack = true;
        }
      })
    .on(
      'panmove',
      this.panmove = function (event) {
        _this.isMouseOver = false;
        if (resizeCursor != null) {
          var width;
          var height;
          if (resizeCursor.cursor === 'ew-resize') {
            var dx = event.deltaX;
            width = Math.max(8, dragStartWidth + dx);
          }

          if (resizeCursor.cursor === 'ns-resize') {
            var dy = event.deltaY;
            height = Math.max(8, dragStartHeight + dy);
          }

          heatMap.resizeTrack(resizeTrackName == null ? _this.name : resizeTrackName, width, height,
            isColumns);
        } else if (reorderingTrack) { // reorder
          var index = heatMap.getTrackIndex(_this.name,
            isColumns);
          var header = heatMap.getTrackHeaderByIndex(
            index, isColumns);
          var track = heatMap.getTrackByIndex(index,
            isColumns);
          var ntracks = heatMap.getNumTracks(isColumns);
          var delta = isColumns ? event.deltaY : event.deltaX;
          var newIndex = index + (delta > 0 ? 1 : -1);
          newIndex = Math.min(Math.max(0, newIndex),
            ntracks - 1);
          var prop = isColumns ? 'top' : 'left';
          var w = isColumns ? 'getUnscaledHeight'
            : 'getUnscaledWidth';
          var trackBounds = {};
          trackBounds[prop] = dragStartPosition[prop] + delta;
          track.setBounds(trackBounds);
          header.setBounds(trackBounds);
          var dragOverTrack = heatMap.getTrackByIndex(
            newIndex, isColumns);
          var dragOverWidth = dragOverTrack[w]();
          var dragOverLeft = $(dragOverTrack.canvas)
            .position()[prop];
          var dragleft = dragStartPosition[prop] + delta;
          var dragright = dragleft + track[w]();
          if ((delta > 0 && dragright >= dragOverLeft
              + dragOverWidth / 2)
            || (delta < 0 && dragleft <= dragOverLeft
              + dragOverWidth / 2)) {
            if (index !== newIndex) {
              heatMap.moveTrack(index, newIndex,
                isColumns);
              var otherHeader = heatMap
                .getTrackHeaderByIndex(index,
                  isColumns);
              var otherTrack = heatMap
                .getTrackByIndex(index, isColumns);
              var $movedCanvas = $(otherTrack.canvas);
              var newLeft = $movedCanvas.position()[prop];
              if (delta < 0) {
                newLeft += track[w]();
              } else {
                newLeft -= track[w]();
              }
              var otherBounds = {};
              otherBounds[prop] = newLeft;
              otherTrack.setBounds(otherBounds);
              otherHeader.setBounds(otherBounds);
            }
          }
        }
      })
    .on(
      'tap',
      this.tap = function (event) {
        if (morpheus.Util.IS_MAC && event.srcEvent.ctrlKey) { // right-click
          return;
        }
        _this.isMouseOver = false;
        heatMap.setSelectedTrack(_this.name, isColumns);
        var vector = (isColumns ? project.getFullDataset().getColumnMetadata()
          : project.getFullDataset().getRowMetadata()).getByName(name);
        // vector will be null for row #
        if ((isColumns && !heatMap.options.columnsSortable) || vector == null) {
          return;
        }
        if ((!isColumns && !heatMap.options.rowsSortable) || vector == null) {
          return;
        }

        var additionalSort = event.srcEvent.shiftKey;
        var isGroupBy = false; // event.srcEvent.altKey;

        var existingSortKeyIndex = _this
          .getSortKeyIndexForColumnName(_this
            .getSortKeys(), _this.name);
        var sortOrder;
        var sortKey;

        var dataType = morpheus.VectorUtil.getDataType(vector);
        if (existingSortKeyIndex != null) {
          sortKey = _this.getSortKeys()[existingSortKeyIndex.index];
          if (sortKey.getSortOrder() === morpheus.SortKey.SortOrder.UNSORTED) {
            sortOrder = morpheus.SortKey.SortOrder.ASCENDING; // 1st
            // click
          } else if (sortKey.getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
            sortOrder = morpheus.SortKey.SortOrder.DESCENDING; // 2nd
            // click
          } else if (sortKey.getSortOrder() === morpheus.SortKey.SortOrder.TOP_N) {
            sortOrder = morpheus.SortKey.SortOrder.UNSORTED;
          } else {
            sortOrder = dataType === 'number' || dataType === '[number]' ? morpheus.SortKey.SortOrder.TOP_N : morpheus.SortKey.SortOrder.UNSORTED; // 3rd
            // click
          }

        } else {
          sortKey = new morpheus.SortKey(_this.name,
            morpheus.SortKey.SortOrder.ASCENDING);
          sortOrder = morpheus.SortKey.SortOrder.ASCENDING;
        }
        if (sortKey != null) {
          sortKey.setSortOrder(sortOrder);
          _this.setSortingStatus(_this.getSortKeys(),
            sortKey, additionalSort, isGroupBy);
        }
      });
  $(this.canvas).on('mousedown', function (event) {
    resizeCursor = getResizeCursor(morpheus.CanvasUtil
      .getMousePos(event.target, event, true));
  });
};
morpheus.VectorTrackHeader.FONT_OFFSET = 2;
morpheus.VectorTrackHeader.prototype = {
  selected: false,
  isMouseOver: false,
  defaultFontHeight: 11,
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.hammer.off('longpress', this.longpress).off('panend', this.panend).off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap);
    this.hammer.destroy();
  },
  getPreferredSize: function () {
    var size = this.getPrintSize();
    size.width += 24; // leave space for sort, drag icon, lock

    if (!this.isColumns) {
      size.height = this.defaultFontHeight
        + morpheus.VectorTrackHeader.FONT_OFFSET;
    }
    // var vector = (this.isColumns ? this.project.getFullDataset()
    // .getColumnMetadata() : this.project.getFullDataset()
    // .getRowMetadata()).getByName(this.name);
    // if (vector
    // && vector.getProperties().get(
    // morpheus.VectorKeys.SHOW_HEADER_SUMMARY)) {
    // if (isNaN(size.height)) {
    // size.height = 0;
    // }
    // if (!this.isColumns) {
    // size.height += 50;
    // } else {
    // size.width += 50;
    // }
    //
    // }
    return size;
  },
  getPrintSize: function () {
    var context = this.canvas.getContext('2d');
    context.font = this.fontWeight + ' ' + this.defaultFontHeight + 'px '
      + morpheus.CanvasUtil.getFontFamily(context);
    var textWidth = 4 + context.measureText(this.name).width;
    return {
      width: textWidth,
      height: this.defaultFontHeight
      + morpheus.VectorTrackHeader.FONT_OFFSET
    };
  },
  getSortKeys: function () {
    return this.isColumns ? this.project.getColumnSortKeys() : this.project
      .getRowSortKeys();
  },
  setOrder: function (sortKeys) {
    if (this.isColumns) {
      this.project.setColumnSortKeys(morpheus.SortKey
        .keepExistingSortKeys(sortKeys, this.project
          .getColumnSortKeys()), false);
    } else {
      this.project.setRowSortKeys(morpheus.SortKey.keepExistingSortKeys(
        sortKeys, this.project.getRowSortKeys()), false);
    }
  },
  setGroupBy: function (groupBy) {
    var existingGroupBy = this.isColumns ? this.project.groupColumns
      : this.project.groupRows;
    // see if already exists, if so remove it
    var index = -1;
    for (var i = 0, length = existingGroupBy.length; i < length; i++) {
      if (existingGroupBy[i].toString() === groupBy.toString()) {
        index = i;
        break;
      }
    }
    var newGroupBy = [groupBy];
    if (index !== -1) {
      newGroupBy = existingGroupBy;
      newGroupBy.splice(index, 1);
    }
    if (this.isColumns) {
      this.project.setGroupColumns(newGroupBy, true);
    } else {
      this.project.setGroupRows(newGroupBy, true);
    }
  },
  setSelected: function (selected) {
    if (selected != this.selected) {
      this.selected = selected;
      $(this.canvas)
        .css(
          {
            'background-color': this.selected ? this.selectedBackgroundColor
              : this.backgroundColor
          });
    }
  },
  setSortingStatus: function (sortKeys, sortKey, additionalSort, isGroupBy) {
    if (!isGroupBy) {
      if (sortKey.getSortOrder() == morpheus.SortKey.SortOrder.UNSORTED
        && !additionalSort) {
        this.setOrder([]);
      } else {
        if (additionalSort && sortKeys.length == 0) {
          additionalSort = false;
        }
        if (!additionalSort) {
          sortKeys = [sortKey];
        } else {
          var sortKeyIndex = this.getSortKeyIndexForColumnName(
            sortKeys, sortKey.toString());
          if (sortKeyIndex === null) { // new sort column
            sortKeys.push(sortKey);
          } else { // change sort order of existing sort column
            sortKeys[sortKeyIndex.index] = sortKey;
          }
        }
        this.setOrder(sortKeys);
      }
    }
    if (isGroupBy) {
      this.setGroupBy(sortKey);
    } else {
      if (this.isColumns) {
        this.project.trigger('columnSortOrderChanged');
      } else {
        this.project.trigger('rowSortOrderChanged');
      }
    }
  },
  getSortKeyIndexForColumnName: function (sortKeys, columnName) {
    if (sortKeys != null) {
      var counter = 0;
      for (var i = 0, size = sortKeys.length; i < size; i++) {
        if (sortKeys[i].isUnlockable()) {
          counter++;
        }
        if (sortKeys[i] instanceof morpheus.SortKey && columnName === sortKeys[i].toString()) {
          return {
            index: i,
            number: counter
          };
        }
      }
    }
    return null;
  },
  print: function (clip, context) {
    if (clip.height <= 6) {
      return;
    }
    context.textBaseline = 'bottom';
    if (this.isColumns) {
      context.textAlign = 'right';
      context.font = this.font.weight + ' ' + Math.min(this.defaultFontHeight, clip.height
        - morpheus.VectorTrackHeader.FONT_OFFSET)
        + 'px ' + morpheus.CanvasUtil.getFontFamily(context);
    } else {
      context.textAlign = 'left';
      context.font = (clip.height - morpheus.VectorTrackHeader.FONT_OFFSET)
        + 'px ' + morpheus.CanvasUtil.getFontFamily(context);
    }
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.fillText(this.name, 0, 0);
  },
  draw: function (clip, context) {
    var sortKeys = this.getSortKeys();
    var name = this.name;
    var existingSortKeyIndex = this.getSortKeyIndexForColumnName(sortKeys,
      name);
    var unlockableSortKeys = sortKeys.filter(function (key) {
      return key.isUnlockable();
    });
    morpheus.CanvasUtil.resetTransform(context);
    context.clearRect(0, 0, this.getUnscaledWidth(), this
      .getUnscaledHeight());

    if (this.getUnscaledHeight() < 5) {
      return;
    }

    context.strokeStyle = '#ddd';
    if (this.isColumns) {
      context.beginPath();
      context.moveTo(0, this.getUnscaledHeight());
      context.lineTo(this.getUnscaledWidth(), this.getUnscaledHeight());
      context.stroke();
      context.textAlign = 'right';
    } else {
      context.beginPath();
      context.moveTo(this.getUnscaledWidth(), 0);
      context.lineTo(this.getUnscaledWidth(), this.getUnscaledHeight());
      context.stroke();
      context.textAlign = 'left';
    }

    var textWidth = context.measureText(name).width;
    var isColumns = this.isColumns;
    var xpix = this.isColumns ? this.getUnscaledWidth() - 2 : 10;
    if (isColumns) {
      if (existingSortKeyIndex != null) {
        xpix -= 6;
        if (sortKeys[existingSortKeyIndex.index].getLockOrder() !== 0) {
          xpix -= 10;
        }
      }
      if (sortKeys.length > 1) {
        xpix -= 6;
      }

    }
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    var ypix = this.isColumns ? (this.getUnscaledHeight() / 2)
      : (this.getUnscaledHeight() - (this.defaultFontHeight + morpheus.VectorTrackHeader.FONT_OFFSET) / 2);
    context.textBaseline = 'middle';
    if (this.isMouseOver) {
      var xdot = xpix - (isColumns ? textWidth + 4 : 4);
      var ydot = ypix - 3;
      for (var i = 0; i < 2; i++) {
        for (var j = 0; j < 3; j++) {
          context.fillRect(xdot - i * 3, ydot + j * 3, 1.5, 1.5);
        }
      }
    }
    var fontHeight = Math.min(this.defaultFontHeight, this
        .getUnscaledHeight()
      - morpheus.VectorTrackHeader.FONT_OFFSET);
    fontHeight = Math.min(fontHeight, morpheus.VectorTrack.MAX_FONT_SIZE);
    context.font = this.font.weight + ' ' + fontHeight + 'px ' + morpheus.CanvasUtil.getFontFamily(context);
    context.fillText(name, xpix, ypix);
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    if (existingSortKeyIndex !== null) {
      // draw arrow
      context.beginPath();
      var x = this.isColumns ? xpix + 4 : xpix + textWidth + 6;
      var arrowHeight = Math.min(8, this.getUnscaledHeight() / 2 - 1);
      var arrowWidth = 3;
      if (sortKeys[existingSortKeyIndex.index].getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
        // up arrow
        context.translate(x, ypix - arrowHeight);
        context.moveTo(0, 0);
        context.lineTo(arrowWidth, arrowHeight);
        context.lineTo(-arrowWidth, arrowHeight);
      } else if (sortKeys[existingSortKeyIndex.index].getSortOrder() === morpheus.SortKey.SortOrder.DESCENDING) { // down
        // arrow
        context.translate(x, ypix);
        context.moveTo(0, arrowHeight);
        context.lineTo(arrowWidth, 0);
        context.lineTo(-arrowWidth, 0);
      } else { // diamond
        context.translate(x, ypix - arrowHeight / 2);
        context.moveTo(0, 0);
        context.lineTo(arrowWidth, arrowHeight / 2);
        context.lineTo(0, arrowHeight);
        context.lineTo(-arrowWidth, arrowHeight / 2);
      }
      context.fill();
      morpheus.CanvasUtil.resetTransform(context);
      context.textAlign = 'left';
      if (unlockableSortKeys.length > 1) {
        context.font = '8px ' + morpheus.CanvasUtil.getFontFamily(context);
        var sortIndex = '' + (existingSortKeyIndex.number);
        context.fillText(sortIndex, x + 4,
          ypix - 2);
        x += context.measureText(sortIndex).width;
      }
      if (sortKeys[existingSortKeyIndex.index].getLockOrder() !== 0) {
        context.font = fontHeight + 'px FontAwesome';
        context.fillText('\uf023', x + arrowWidth + 2, ypix);
      }

    }
  }
};
morpheus.Util.extend(morpheus.VectorTrackHeader, morpheus.AbstractCanvas);

morpheus.VectorTrack = function (project, name, positions, isColumns, heatmap) {
  morpheus.AbstractCanvas.call(this, true);
  this.preferredSize = {
    width: 0,
    height: 0
  };
  this.project = project;
  this.positions = positions;
  this.isColumns = isColumns;
  this.name = name;
  this.visible = true;
  this.heatmap = heatmap;

  // this.highlightColor = 'rgb(255,255,0)';
  this.id = _.uniqueId();
  var _this = this;
  this.updateSpanMapFunction = function () {
    _this.spanMap = morpheus.VectorUtil.createSpanMap(_this.getVector());
  };

  this.lastPosition = {
    start: -1,
    end: -1
  };
  // for molecule span
  this.events = 'rowSortOrderChanged rowFilterChanged datasetChanged';
  var mouseMoved = function (event) {
    var index = -1;
    if (event.type !== 'mouseout') {
      var position = morpheus.CanvasUtil.getMousePosWithScroll(
        event.target, event, heatmap.scrollLeft(), heatmap
          .scrollTop());
      if (_this.settings.squished) {
        var total = positions.getPosition(positions.getLength() - 1)
          + positions.getItemSize(positions.getLength() - 1);
        var squishFactor = total
          / (isColumns ? _this.getUnscaledWidth() : _this
            .getUnscaledHeight());
        position[isColumns ? 'x' : 'y'] *= squishFactor;
      }
      index = !isColumns ? _this.positions.getIndex(position.y, false)
        : _this.positions.getIndex(position.x, false);

    }

    if (isColumns) {
      heatmap.setMousePosition(-1, index, {
        name: _this.name,
        event: event
      });
    } else {
      heatmap.setMousePosition(index, -1, {
        name: _this.name,
        event: event

      });
    }
  };

  $(this.canvas).on('contextmenu.morpheus', function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    heatmap.setSelectedTrack(_this.name, isColumns);
    _this.showPopup(e);
    return false;

  });
  // display options:
  // - text and color, shape, bar (stacked or not), highlight matching (any
  // except arrays)
  // - color and bar-discrete or contin
  // - color by for bar plots
  this.settings = {
    maxTextWidth: undefined,
    squished: false,
    inlineTooltip: false,
    tooltip: true,
    highlightMatchingValues: false,
    colorBarSize: 12,
    stackedBar: false,
    display: [],
    selectionColor: 'rgb(182,213,253)',
    colorByField: null, // color this vector by another vector, used in bar plot and text
    fontField: null, // use a different field for determining font
    barColor: '#bdbdbd',
    barSize: 40,
    min: undefined,
    mid: undefined,
    max: undefined,
    autoscaleAlways: false, // autoscale on every repaint
    minMaxReversed: false
    // whether to reverse min and max when auto-setting min and max
  };
  $(this.canvas).on('mousemove.morpheus mouseout.morpheus', mouseMoved);
};
morpheus.VectorTrack.RENDER = {
  TEXT: 'text',
  COLOR: 'color',
  BAR: 'bar',
  MOLECULE: 'molecule',
  TEXT_AND_COLOR: 'text_and_color',
  TEXT_AND_FONT: 'text_and_font',
  SHAPE: 'shape',
  ARC: 'arc',
  BOX_PLOT: 'box_plot',
  HEAT_MAP: 'heat_map'
};
morpheus.VectorTrack.vectorToString = function (vector) {
  var dataType = morpheus.VectorUtil.getDataType(vector);
  var formatter = vector.getProperties().get(morpheus.VectorKeys.FORMATTER);
  if (formatter != null) {
    if (typeof formatter === 'object') { // convert to function
      formatter = morpheus.Util.createNumberFormat(formatter.pattern);
      if (dataType === '[number]') {
        var nf = formatter;
        formatter = function (v) {
          var s = [];
          if (v != null) {
            for (var i = 0, arrayLength = v.length; i < arrayLength; i++) {
              s.push(nf(v[i]));
            }
          }
          return s.join(', ');
        };
      }
      vector.getProperties().set(morpheus.VectorKeys.FORMATTER, formatter);
    }
  } else if (dataType === 'number') {
    formatter = morpheus.Util.nf;
  } else if (dataType === '[number]') {
    formatter = function (v) {
      var s = [];
      if (v != null) {
        for (var i = 0, arrayLength = v.length; i < arrayLength; i++) {
          s.push(morpheus.Util.nf(v[i]));
        }
      }
      return s.join(', ');
    };
  } else if (dataType === '[string]') {
    formatter = function (v) {
      var s = [];
      if (v != null) {
        for (var i = 0, arrayLength = v.length; i < arrayLength; i++) {
          s.push(v[i]);
        }
      }
      return s.join(', ');
    };
  } else {
    formatter = function (v) {
      return '' + v;
    };
  }
  return formatter;
};

morpheus.VectorTrack.prototype = {
  settingFromConfig: function (conf) {
    var _this = this;
    var settings = this.settings;
    // new style= rows:[{field: 'test', display:['text']}]
    // old style= rows:[{field: 'test', display:'text,color'}]
    var fromString = function (s) {
      settings.display = [];
      var tokens = s.split(',');
      for (var i = 0, length = tokens.length; i < length; i++) {
        var method = $.trim(tokens[i]);
        method = method.toUpperCase();
        var mapped = morpheus.VectorTrack.RENDER[method];
        if (mapped !== undefined) {
          settings.display.push(mapped);
        } else if (method === 'DISCRETE') {
          _this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE, true);
        } else if (method === 'CONTINUOUS') {
          _this.getFullVector().getProperties().set(morpheus.VectorKeys.DISCRETE, false);
        } else if (method === 'HIGHLIGHT') {
          settings.highlightMatchingValues = true;
        } else if (method === 'STACKED_BAR') {
          settings.stackedBar = true;
          settings.display.push(morpheus.VectorTrack.RENDER.BAR);
        } else if (method === 'TOOLTIP') {
          settings.inlineTooltip = true;
        } else {
          console.log(method + ' not found.');
        }
      }
    };
    var fromArray = function (array) {
      settings.display = [];
      for (var i = 0; i < array.length; i++) {
        var method = array[i].toUpperCase();
        var mapped = morpheus.VectorTrack.RENDER[method];
        if (mapped !== undefined) {
          settings.display.push(mapped);
        } else {
          console.log(method + ' not found.');
        }
      }
    };
    var fromObject = function (obj) {
      settings.display = [];
      for (var key in obj) {
        if (obj[key]) {
          var method = key.toUpperCase();
          var mapped = morpheus.VectorTrack.RENDER[method];
          if (mapped !== undefined) {
            settings.display.push(mapped);
          }
        }
      }
    };

    if (conf != null) {
      if (_.isString(conf)) { // deprecated, comma separated list of text, color, etc
        fromString(conf);
      } else if (_.isArray(conf)) {
        fromArray(conf);
      } else {
        var userSuppliedSettings = conf;
        if (!_.isArray(conf.display) && _.isObject(conf.display)) { // deprecated
          userSuppliedSettings = conf.display;
        }
        settings = $.extend({}, settings, userSuppliedSettings);
        settings.maxTextWidth = undefined;
        if (userSuppliedSettings.discrete != null) {
          _this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE, userSuppliedSettings.discrete);
        }

        if (_.isArray(userSuppliedSettings.display)) {
          settings.display = userSuppliedSettings.display;
        } else if (_.isString(userSuppliedSettings.display)) {
          fromString(userSuppliedSettings.display);
        }
        if (!_.isArray(settings.render) && _.isObject(settings.render)) {// deprecated
          fromObject(settings.render);
          delete settings.render;
        }
      }
      this.settings = settings;
    }
    if (!this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) &&
      (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR) || this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT))) {
      settings.display.push(morpheus.VectorTrack.RENDER.TEXT);
    }
    this._update();

  },
  setShowTooltip: function (value) {
    this.settings.tooltip = value;
  },
  isShowTooltip: function () {
    return this.settings.tooltip;
  },
  isRenderAs: function (value) {
    return this.settings.display.indexOf(value) !== -1;
  },
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    $(this.canvas).off();
    this._selection.dispose();
    this.project.off(this.events, this.updateSpanMapFunction);
  },
  getName: function () {
    return this.name;
  },
  getVector: function (name) {
    name = name == null ? this.name : name;
    var vector = this.isColumns ? this.project.getSortedFilteredDataset()
      .getColumnMetadata().getByName(name) : this.project
      .getSortedFilteredDataset().getRowMetadata().getByName(name);
    return !vector ? new morpheus.Vector(name, 0) : vector;
  },
  getFullVector: function () {
    var vector = this.isColumns ? this.project.getFullDataset()
      .getColumnMetadata().getByName(this.name) : this.project
      .getFullDataset().getRowMetadata().getByName(this.name);
    return !vector ? new morpheus.Vector(this.name, 0) : vector;
  },
  _updatePreferredSize: function () {
    var size = this._computePreferredSize();
    this.preferredSize.width = size.width;
    this.preferredSize.height = size.height;

  },
  _computePreferredSize: function (forPrint) {
    var width = 0;
    var height = 0;
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT)) {
      if (this.positions.getSize() >= 6) {
        var context = this.canvas.getContext('2d');
        var textWidth = morpheus.CanvasUtil.getVectorStringWidth(
          context, this.getVector(), this.positions,
          forPrint ? -1 : (this.isColumns ? 120 : 100));
        if (!forPrint) {
          this.settings.maxTextWidth = textWidth;
        }
        width += textWidth;
      } else if (!forPrint) {
        this.settings.maxTextWidth = 0; // text not drawn
      }
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)) {
      width += this.settings.barSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
      width += this.settings.colorBarSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      width += this.settings.colorBarSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      width += 300;
    }
    // if (!forPrint && !this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
    //   width = Math.min(300, width);
    // }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.ARC)) {
      width += this.settings.arcSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      width += 100;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.HEAT_MAP)) {
      width += 100;
    }
    // 2 pixel spacing between display types
    var nkeys = this.settings.display.length;

    if (nkeys > 0) {
      width += (nkeys - 1) * 2;
    }
    width = Math.max(0, width);
    return this.isColumns ? {
      width: height,
      height: width
    } : {
      width: width,
      height: height
    };

  },
  getPreferredSize: function () {
    return this.preferredSize;
  },
  getPrintSize: function () {
    return this._computePreferredSize(true);
  },
  _createDiscreteValueMap: function () {
    var values = morpheus.VectorUtil.getValues(this.getFullVector());
    values.sort(morpheus.SortKey.ASCENDING_COMPARATOR);
    this.discreteValueMap = new morpheus.Map();
    for (var i = 0, length = values.length; i < length; i++) {
      this.discreteValueMap.set(values[i], i + 1);
    }
    this.settings.min = 0;
    this.settings.mid = 0;
    this.settings.max = values.length;
  },
  _setChartMinMax: function () {
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      if (!this.settings.stackedBar && this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE)
        && !this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
        if (!this.discreteValueMap) {
          this._createDiscreteValueMap();
        }
      } else {
        if (this.settings.autoscaleAlways || this.settings.min == null || this.settings.max == null
          || this.settings.mid == null) {
          var vector = this.getFullVector();

          var minMax = morpheus.VectorUtil.getMinMax(vector);
          var min = minMax.min;
          var max = minMax.max;
          if (this.settings.minMaxReversed) {
            var tmp = max;
            max = min;
            min = tmp;
          }
          if (this.settings.autoscaleAlways || this.settings.min == null) {
            this.settings.min = Math.min(0, min);
          }
          if (this.settings.autoscaleAlways || this.settings.max == null) {
            this.settings.max = Math.max(0, max);
          }
          if (this.settings.autoscaleAlways || this.settings.mid == null) {
            this.settings.mid = this.settings.min < 0 ? 0
              : this.settings.min;
          }
        }

      }
    }
  },

  _update: function () {
    if (this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE) == null
      && (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
        || this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || this
          .isRenderAs(morpheus.VectorTrack.RENDER.BAR))) {
      if ((this.isColumns ? this.project.getColumnColorModel() : this.project.getRowColorModel()).getContinuousColorScheme(this.getFullVector()) != null) {
        this.getFullVector().getProperties().set(morpheus.VectorKeys.DISCRETE, false);
        this.settings.highlightMatchingValues = false;
      } else if ((this.isColumns ? this.project.getColumnColorModel() : this.project.getRowColorModel()).getDiscreteColorScheme(this.getFullVector()) != null) {
        this.getFullVector().getProperties().set(morpheus.VectorKeys.DISCRETE, true);
        this.settings.highlightMatchingValues = true;
      } else if (this.getFullVector().getProperties().has(
          morpheus.VectorKeys.FIELDS)
        || morpheus.VectorUtil.getDataType(this.getFullVector()) === 'number' || morpheus.VectorUtil.getDataType(this.getFullVector()) === '[number]') {
        this.getFullVector().getProperties().set(morpheus.VectorKeys.DISCRETE, false);
        this.settings.highlightMatchingValues = false;
      }
    }
    if (this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE) == null) {
      this.getFullVector().getProperties().set(morpheus.VectorKeys.DISCRETE, true);
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      this.project.off(this.events, this.updateSpanMapFunction);
    }
    this._setChartMinMax();
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      this.project.on(this.events, this.updateSpanMapFunction);
      if (!this.moleculeCache) {
        this.moleculeCache = {};
        var _this = this;

        var valueToModelIndices = this.getFullVector().getProperties()
          .get(morpheus.VectorKeys.VALUE_TO_INDICES);
        if (!valueToModelIndices) {
          var fullVector = this.getFullVector();
          valueToModelIndices = morpheus.VectorUtil
            .createValueToIndicesMap(fullVector);
          fullVector.getProperties().set(
            morpheus.VectorKeys.VALUE_TO_INDICES,
            valueToModelIndices);

        }

        if (_this.heatmap.options.structureUrlProvider !== undefined) {
          valueToModelIndices.forEach(function (indices, value) {
            var url = _this.heatmap.options
              .structureUrlProvider(value);
            var image = new Image();
            image.src = url;
            _this.moleculeCache[value] = image;
          });

          setTimeout(function () {
            _this.setInvalid(true);
            _this.repaint();
          }, 2000);
        } else {
          var values = valueToModelIndices.keys();
          var doRequest = function (smile) {
            $
              .ajax(
                {
                  contentType: 'text/plain',
                  context: {
                    smile: smile
                  },
                  data: {
                    'string': smile,
                    'representation': 'sdf'
                  },
                  url: 'http://cactus.nci.nih.gov/chemical/structure'
                }).done(function (text) {
              _this.moleculeCache[this.smile] = text;
              if (values.length > 0) {
                doRequest(values.pop());
              }
              _this.invalid = true;
              _this.repaint();
            });
          };
          for (var i = 0; i < 6; i++) {
            doRequest(values.pop());
          }
        }
        this.updateSpanMapFunction();
      }
    }
    this._updatePreferredSize();
  }
  ,
  postPaint: function (clip, context) {
    // draw hover, matching values
    context.lineWidth = 1;
    context.strokeStyle = 'Grey';
    var project = this.project;
    var setup = this._setup(context, clip);
    var vector = setup.vector;
    var start = setup.start;
    var end = setup.end;

    // hover
    if (this.isColumns) {
      if (project.getHoverColumnIndex() !== -1) {
        this.drawColumnBorder(context, this.positions, project
          .getHoverColumnIndex(), this.getUnscaledHeight());

      }
    } else {
      if (project.getHoverRowIndex() !== -1) {
        this.drawRowBorder(context, this.positions, project
          .getHoverRowIndex(), this.getUnscaledWidth());
      }
    }
    this._highlightMatchingValues(context, vector, start, end);
  }
  ,
  _highlightMatchingValues: function (context, viewVector, start, end) {
    var project = this.project;
    var positions = this.positions;
    context.strokeStyle = 'black';
    context.lineWidth = 3;
    var hoverIndex = this.isColumns ? project.getHoverColumnIndex()
      : project.getHoverRowIndex();
    var value = viewVector.getValue(hoverIndex);

    if (this.settings.highlightMatchingValues
      && hoverIndex !== -1
      && this.heatmap.mousePositionOptions
      && this.heatmap.mousePositionOptions.name === viewVector
        .getName()) {
      var valueToModelIndices = this.getFullVector().getProperties().get(
        morpheus.VectorKeys.VALUE_TO_INDICES);
      if (!valueToModelIndices) {
        var fullVector = this.getFullVector();
        valueToModelIndices = morpheus.VectorUtil
          .createValueToIndicesMap(fullVector);
        fullVector.getProperties().set(
          morpheus.VectorKeys.VALUE_TO_INDICES,
          valueToModelIndices);

      }
      var indices = valueToModelIndices.get(value);
      if (indices == null) {
        console.log('valueToModelIndices error');
        return;
      }
      if (indices.length <= 1) {
        return;
      }
      if (this.isColumns) {
        if (project.getHoverColumnIndex() !== -1) {
          var height = this.getUnscaledHeight();
          // context.fillStyle = '#ffffb3';
          context.beginPath();
          for (var i = 0, nindices = indices.length; i < nindices; i++) {
            var viewIndex = project
              .convertModelColumnIndexToView(indices[i]);
            if (viewIndex >= start && viewIndex < end) {
              var size = positions.getItemSize(viewIndex);
              var pix = positions.getPosition(viewIndex);
              context.rect(pix, 0, size, height);
            }
          }
          context.stroke();

        }
      } else {
        context.beginPath();
        var width = this.getUnscaledWidth();
        var indices = valueToModelIndices.get(value);
        for (var i = 0, nindices = indices.length; i < nindices; i++) {
          var viewIndex = project
            .convertModelRowIndexToView(indices[i]);
          if (viewIndex >= start && viewIndex < end) {
            var size = positions.getItemSize(viewIndex);
            var pix = positions.getPosition(viewIndex);
            context.rect(0, pix, width, size);
          }
        }
        context.stroke();
      }

    }

  }
  ,
  drawSelection: function (options) {
    var project = this.project;
    var positions = this.positions;
    var context = options.context;
    var start = options.start;
    var end = options.end;
    context.lineWidth = 1;
    context.fillStyle = this.settings.selectionColor;
    if (this.isColumns) {
      var height = this.getUnscaledHeight();
      var viewIndices = project.getColumnSelectionModel()
        .getViewIndices();
      viewIndices.forEach(function (i) {
        if (i >= start && i <= end) {
          var size = positions.getItemSize(i);
          var pix = positions.getPosition(i);
          context.fillRect(pix, 0, size, height);
        }
      });
    } else {
      var width = this.getUnscaledWidth();
      if (!this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
        var viewIndices = project.getRowSelectionModel()
          .getViewIndices();
        viewIndices.forEach(function (i) {
          if (i >= start && i <= end) {
            var size = positions.getItemSize(i);
            var pix = positions.getPosition(i);
            context.fillRect(0, pix, width, size);
          }
        });
      }
    }

  }
  ,
  prePaint: function (clip, context) {
    // draw selection
    var project = this.project;
    var positions = this.positions;
    var setup = this._setup(context, clip);
    var start = setup.start;
    var end = setup.end;
    this.drawSelection({
      context: context,
      start: start,
      end: end
    });
    if (this.invalid || start !== this.lastPosition.start
      || end !== this.lastPosition.end) {
      this.lastPosition.start = start;
      this.lastPosition.end = end;
      this.invalid = true;
    }
  }
  ,
  drawRowBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(0, pix + size);
    context.lineTo(gridSize, pix + size);
    context.stroke();
    context.beginPath();
    context.moveTo(0, pix);
    context.lineTo(gridSize, pix);
    context.stroke();
  }
  ,
  drawColumnBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(pix + size, 0);
    context.lineTo(pix + size, gridSize);
    context.stroke();
    context.beginPath();
    context.moveTo(pix, 0);
    context.lineTo(pix, gridSize);
    context.stroke();
  }
  ,
  isSquished: function () {
    return this.settings.squished;
  }
  ,
  _setup: function (context, clip) {
    var start = 0;
    var vector = this.getVector();
    var end = vector.size();
    var settings = this.settings;
    var positions = this.positions;
    var width = clip.width;
    var height = clip.height;
    if (!settings.squished) {
      if (this.isColumns) {
        start = morpheus.Positions.getLeft(clip, positions);
        end = morpheus.Positions.getRight(clip, positions);
      } else {
        start = morpheus.Positions.getTop(clip, positions);
        end = morpheus.Positions.getBottom(clip, positions);
      }
    }
    if (settings.squished) {

      var total = positions.getPosition(positions.getLength() - 1)
        + positions.getItemSize(positions.getLength() - 1);
      if (!this.isColumns) {
        var squishFactor = height / total;
        context.scale(1, squishFactor);
      } else {
        var squishFactor = width / total;
        context.scale(squishFactor, 1);
      }

    } else {
      context.translate(-clip.x, -clip.y);
    }
    return {
      start: start,
      end: end,
      vector: vector
    };
  }
  ,
  draw: function (clip, context) {
    var setup = this._setup(context, clip);
    this._draw({
      start: setup.start,
      end: setup.end,
      vector: setup.vector,
      context: context,
      availableSpace: this.isColumns ? this.getUnscaledHeight()
        : this.getUnscaledWidth(),
      clip: clip
    });
  }
  ,
  print: function (clip, context) {
    var vector = this.getVector();
    this._draw({
      start: 0,
      end: vector.size(),
      vector: vector,
      context: context,
      availableSpace: this.isColumns ? clip.height
        : clip.width,
      clip: clip
    });
  }
  ,
  /**
   * @param options.vector
   * @param options.context
   * @param options.start
   * @param options.end
   * @param options.availableSpace
   */
  _draw: function (options) {
    var _this = this;
    var context = options.context;
    var vector = options.vector;
    var availableSpace = options.availableSpace;
    var fullAvailableSpace = options.availableSpace;
    var start = options.start;
    var end = options.end;
    var clip = options.clip;
    var positions = this.positions;
    if (this.settings.autoscaleAlways) {
      this._setChartMinMax();
    }
    context.textAlign = 'left';
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;

    var fontSize = Math.min(morpheus.VectorTrack.MAX_FONT_SIZE, positions.getSize() - 2);
    var size = 0;
    context.font = fontSize + 'px ' + morpheus.CanvasUtil.getFontFamily(context);
    context.strokeStyle = morpheus.HeatMapElementCanvas.GRID_COLOR;
    context.lineWidth = 0.1;
    // grid lines
    if (this.heatmap.heatmap.isDrawGrid() && !this.settings.squished) {
      if (this.isColumns) {
        var gridSize = availableSpace;
        context.beginPath();
        for (var i = start; i < end; i++) {
          var size = positions.getItemSize(i);
          var pix = positions.getPosition(i);
          if (size > 7) {
            context.moveTo(pix + size, 0);
            context.lineTo(pix + size, gridSize);
          }
        }
        context.stroke();
      } else {
        if (!this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
          var gridSize = availableSpace;
          context.beginPath();
          for (var i = start; i < end; i++) {
            var size = positions.getItemSize(i);
            var pix = positions.getPosition(i);
            if (size > 7) {

              context.moveTo(0, pix + size);
              context.lineTo(gridSize, pix + size);

            }
          }
          context.stroke();
        }
      }
    }
    context.lineWidth = 1;
    var offset = 1;

    if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
      this.renderColor(context, vector, start, end, clip,
        this.isColumns ? availableSpace : 0,
        !this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE));
      offset += this.settings.colorBarSize + 2;
      availableSpace -= offset;
    }
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      this.renderShape(context, vector, start, end, clip,
        this.isColumns ? availableSpace - offset : offset);
      offset += this.settings.colorBarSize + 2;
      availableSpace -= offset;
    }

    if (this.isRenderAs(morpheus.VectorTrack.RENDER.ARC)) {
      this.renderArc(context, vector, start, end, clip,
        this.settings.arcSize);
      offset += this.settings.arcSize + 2;
      availableSpace -= offset;
    }
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      this.renderMolecule(context, vector, start, end, clip, offset,
        availableSpace);
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      var barSize = !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) ? (availableSpace - 2)
        : this.settings.barSize;
      offset++;
      this.renderBoxPlot(context, vector, start, end, clip, offset,
        barSize);
      offset += barSize + 2;
      availableSpace -= offset;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.HEAT_MAP)) {
      var barSize = !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) ? (availableSpace - 2)
        : this.settings.barSize;
      offset++;
      this.renderHeatMap(context, vector, start, end, clip,
        barSize);
      offset += barSize + 2;
      availableSpace -= offset;
    }

    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)) {
      var barSize = !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) ? (availableSpace - 5)
        : this.settings.barSize;
      if (this.settings.stackedBar) {
        this.renderStackedBar(context, vector, start, end, clip,
          offset, barSize);
      } else {
        var fields = vector.getProperties().get(
          morpheus.VectorKeys.FIELDS);
        var visibleFieldIndices = vector.getProperties().get(
          morpheus.VectorKeys.VISIBLE_FIELDS);
        if (fields != null && visibleFieldIndices == null) {
          visibleFieldIndices = morpheus.Util.seq(fields.length);
        }

        if (fields != null) {
          this.renderUnstackedBar(context, vector, start, end, clip,
            offset, barSize, visibleFieldIndices);
        } else {
          this.renderBar(context, vector, start, end, clip, this.isColumns ? (fullAvailableSpace - offset - barSize) : offset,
            barSize);
        }
      }

      offset += barSize + 2;
      availableSpace -= offset;

    }
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) &&
      (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR) || this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT))) {
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      this.renderText(context, vector, this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR), this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT),
        start, end, clip, this.isColumns ? (fullAvailableSpace - offset) : offset);
      offset += this.settings.maxTextWidth + 2;
      availableSpace -= offset;
    }
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) && !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
      && !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT)) {
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      var dataType = morpheus.VectorUtil.getDataType(vector);
      if (dataType === 'url') {
        context.fillStyle = 'blue';
        this.canvas.style.cursor = 'pointer';
      }
      this.renderText(context, vector, false, false, start, end, clip, this.isColumns ? (fullAvailableSpace - offset) : offset);

    }
  }
  ,
  showPopup: function (e, isHeader) {
    var _this = this;
    var project = this.project;
    var isColumns = this.isColumns;
    var hasSelection = isColumns ? project.getColumnSelectionModel()
      .count() > 0 : project.getRowSelectionModel().count() > 0;
    var ANNOTATE_SELECTION = 'Annotate Selection';
    var INVERT_SELECTION = 'Invert Selection';
    var SELECT_ALL = 'Select All';
    var SHOW_SELECTION_ONLY = 'Show Selection Only';
    var CLEAR_SELECTION = 'Clear Selection';
    var HIGHLIGHT_MATCHING_VALUES = 'Highlight Matching Values';
    var FIELDS = 'Choose Fields...';
    var DELETE = 'Delete...';
    var TOOLTIP = 'Show In Tooltip';
    var HIDE = 'Hide';
    var HIDE_OTHERS = 'Hide Others';
    var REMOVE_SHOW_SELECTION_ONLY = 'Show All';
    var SORT_ASC = 'Sort Ascending';
    var SORT_DESC = 'Sort Descending';
    var MOVE_TO_TOP = 'Move To Top';
    var SORT_SEL_ASC = 'Sort Heat Map Ascending \u2191';
    var SORT_SEL_DESC = 'Sort Heat Map Descending \u2193';
    var SORT_SEL_TOP_N = 'Sort Heat Map Descending/Ascending';
    var DISPLAY_BAR = 'Show Bar Chart';
    var NUMBER_FORMAT = 'Format';
    var DISPLAY_STACKED_BAR = 'Show Stacked Bar Chart';
    var DISPLAY_BOX_PLOT = 'Show Box Plot';
    var DISPLAY_COLOR = 'Show Color';
    var COLOR_BAR_SIZE = 'Color Bar Size...';
    var DISPLAY_TEXT = 'Show Text';
    var DISPLAY_SHAPE = 'Show Shape';
    var DISPLAY_ARC = 'Show Arc';
    var DISPLAY_TEXT_AND_COLOR = 'Encode Text Using Color';
    var DISPLAY_TEXT_AND_FONT = 'Encode Text Using Font';
    var DISPLAY_STRUCTURE = 'Show Chemical Structure';
    var DISPLAY_CONTINUOUS = 'Continuous';
    var positions = this.positions;
    var heatmap = this.heatmap;

    var sectionToItems = {
      'Sort': [],
      'Selection': [],
      'Display': []
    };

    var customItems = this.heatmap.getPopupItems();
    if (customItems && customItems.length > 0) {
      customItems.forEach(function (item) {
        if (item.columns === isColumns) {
          sectionToItems[item.section].push(item);
        }
      });
    }
    if (sectionToItems.Selection.length > 0) {
      sectionToItems.Selection.push({
        separator: true
      });
    }
    sectionToItems.Selection.push({
      name: MOVE_TO_TOP
    });
    if (this.heatmap.options.menu.Edit && this.heatmap.options.menu.Edit.indexOf('Annotate' +
        ' Selected Rows') !== -1) {
      sectionToItems.Selection.push({
        name: ANNOTATE_SELECTION
      });
    }
    sectionToItems.Selection.push({
      name: 'Copy',
      class: 'copy'
    });

    sectionToItems.Selection.push({
      name: INVERT_SELECTION
    });
    sectionToItems.Selection.push({
      name: SELECT_ALL
    });
    sectionToItems.Selection.push({
      name: CLEAR_SELECTION
    });
    // sectionToItems.Selection.push({
    // name : SHOW_SELECTION_ONLY
    // });
    var combinedFilter = isColumns ? project.getColumnFilter() : project
      .getRowFilter();
    var showSelectionOnlyIndex = combinedFilter
      .indexOf(SHOW_SELECTION_ONLY);
    if (showSelectionOnlyIndex !== -1) {
      sectionToItems.Selection.push({
        name: REMOVE_SHOW_SELECTION_ONLY
      });
    }

    if (!isHeader) {
      sectionToItems['Sort'].push({
        name: SORT_SEL_ASC,
        disabled: !hasSelection
      });
      sectionToItems['Sort'].push({
        name: SORT_SEL_DESC,
        disabled: !hasSelection
      });

      sectionToItems['Sort'].push({
        name: SORT_SEL_TOP_N,
        disabled: !hasSelection
      });
    }
    var dataType = morpheus.VectorUtil.getDataType(this.getFullVector());
    var arrayFields = this.getFullVector().getProperties().get(
      morpheus.VectorKeys.FIELDS);
    var isArray = arrayFields !== undefined;
    var isNumber = dataType === 'number' || dataType === '[number]';
    if (isNumber || isArray) {
      sectionToItems.Display.push({
        name: NUMBER_FORMAT
      });
      sectionToItems.Display.push({
        separator: true
      });

      sectionToItems.Display.push({
        name: DISPLAY_BAR,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      });
    }
    if (isArray) {
      sectionToItems.Display.push({
        name: DISPLAY_STACKED_BAR,
        checked: this.settings.stackedBar
      });
      sectionToItems.Display.push({
        name: DISPLAY_BOX_PLOT,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)
      });
      sectionToItems.Display.push({
        name: FIELDS
      });
    }

    if (dataType !== 'url') {
      // text and text_and_color are mutually exclusive
      sectionToItems.Display.push({
        name: DISPLAY_TEXT,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT)
      });
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT)) {
        sectionToItems.Display.push({
          name: DISPLAY_TEXT_AND_COLOR,
          checked: this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
        });
        sectionToItems.Display.push({
          name: DISPLAY_TEXT_AND_FONT,
          checked: this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT)
        });
      }
      sectionToItems.Display.push({
        separator: true
      });

      sectionToItems.Display.push({
        name: DISPLAY_COLOR,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
      });
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
        sectionToItems.Display.push({
          name: COLOR_BAR_SIZE
        });
      }
    }
    if (!isArray && dataType !== 'url') {
      sectionToItems.Display.push({
        name: DISPLAY_SHAPE,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)
      });
      // sectionToItems.Display.push({
      // name : DISPLAY_ARC,
      // checked : this.isRenderAs(morpheus.VectorTrack.RENDER.ARC)
      // });

    }

    if (!isArray && !isNumber && !this.isColumns
      && name.toLowerCase().indexOf('smile') !== -1) {
      sectionToItems.Display.push({
        name: DISPLAY_STRUCTURE,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)
      });
    }

    sectionToItems.Display.push({
      name: TOOLTIP,
      checked: this.settings.inlineTooltip
    });
    if (!isArray && dataType !== 'url') {
      sectionToItems.Display.push({
        name: HIGHLIGHT_MATCHING_VALUES,
        checked: this.settings.highlightMatchingValues
      });
    }
    if (dataType !== 'url') {
      // sectionToItems.Display.push({
      //   name: 'Squished',
      //   checked: this.settings.squished
      // });
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      sectionToItems.Display.push({
        separator: true
      });
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)) {
        sectionToItems.Display.push({
          name: 'Edit Bar Color...'
        });
      }
      sectionToItems.Display.push({
        name: 'Auto Range'
      });
      sectionToItems.Display.push({
        name: 'Custom Range...'
      });
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR) || this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      sectionToItems.Display.push({
        separator: true
      });
      if (isNumber) {
        sectionToItems.Display.push({
          name: DISPLAY_CONTINUOUS,
          checked: !this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE)
        });
      }
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
        || this
          .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
        || (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR) && isArray)) {
        sectionToItems.Display.push({
          name: 'Edit Colors...'
        });

      }
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
        sectionToItems.Display.push({
          name: 'Edit Shapes...'
        });

      }
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT)) {
        sectionToItems.Display.push({
          name: 'Edit Fonts...'
        });

      }

      if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
        || this
          .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
        || (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR) && isArray)) {
        sectionToItems.Display.push({
          name: 'Color Key',
          icon: 'fa fa-key'
        });
      }

    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      sectionToItems.Display.push({
        name: 'Shape Key',
        icon: 'fa fa-key'
      });
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_FONT)) {
      sectionToItems.Display.push({
        name: 'Font Key',
        icon: 'fa fa-key'
      });
    }

    sectionToItems.Display.push({
      separator: true
    });
    sectionToItems.Display.push({
      name: HIDE
    });
    sectionToItems.Display.push({
      name: HIDE_OTHERS,
      disabled: heatmap.getVisibleTrackNames(this.isColumns).length <= 1

    });
    sectionToItems.Display.push({
      separator: true
    });
    sectionToItems.Display.push({
      name: DELETE
    });

    var items = [];

    function addSection(name) {
      if (items.length > 0) {
        items.push({
          separator: true
        });
      }
      items = items.concat(sectionToItems[name]);
    }

    addSection('Sort');
    _.each(sectionToItems.Selection, function (item) {
      if (item.name !== REMOVE_SHOW_SELECTION_ONLY
        && item.name !== SELECT_ALL) {
        item.disabled = !hasSelection;
      }
    });
    if (!isHeader) {
      addSection('Selection');
    } else if (this.heatmap.options.toolbar.options) {
      addSection('Display');
    }

    if (e.preventDefault) {
      e.preventDefault();
    }
    if (items.length === 0) {
      return;
    }
    morpheus.Popup
      .showPopup(
        items,
        {
          x: e.pageX,
          y: e.pageY
        },
        e.target,
        function (event, item) {
          var customItem;
          if (item === NUMBER_FORMAT) {
            var vector = _this.getFullVector();
            var formatter = vector
              .getProperties().get(morpheus.VectorKeys.FORMATTER);
            if (formatter != null) {
              if (typeof formatter === 'object') { // convert to function
                formatter = morpheus.Util.createNumberFormat(formatter.pattern);
                vector.getProperties().set(morpheus.VectorKeys.FORMATTER, formatter);
              }
            }
            var pattern = formatter != null ? formatter.toJSON().pattern : '.2f';
            var formBuilder = new morpheus.FormBuilder();
            formBuilder.append({
              name: 'number_of_fraction_digits',
              type: 'number',
              value: morpheus.Util.getNumberFormatPatternFractionDigits(pattern),
              required: true,
              style: 'max-width:60px;'
            });
            formBuilder.find('number_of_fraction_digits').on(
              'keyup input', _.debounce(
                function () {
                  var n = parseInt($(this)
                    .val());
                  if (n >= 0) {
                    vector.getProperties().set(morpheus.VectorKeys.FORMATTER, {pattern: '.' + n + 'f'});
                    _this.setInvalid(true);
                    _this.repaint();
                  }
                }, 100));
            morpheus.FormBuilder.showInModal({
              title: 'Format',
              close: 'Close',
              html: formBuilder.$form,
              focus: heatmap.getFocusEl()
            });
          } else if (item === 'Copy') {
            heatmap.getActionManager().execute(isColumns ? 'Copy Selected Columns' : 'Copy' +
              ' Selected Rows');
          } else if (item === FIELDS) {
            var visibleFieldIndices = _this
              .getFullVector()
              .getProperties()
              .get(morpheus.VectorKeys.VISIBLE_FIELDS);
            var visibleFields;
            if (visibleFieldIndices == null) {
              visibleFields = arrayFields.slice(0);
            } else {
              visibleFields = [];
              for (var i = 0; i < visibleFieldIndices.length; i++) {
                visibleFields
                  .push(arrayFields[visibleFieldIndices[i]]);
              }

            }
            var availableFields = [];
            for (var i = 0; i < arrayFields.length; i++) {
              if (visibleFields.indexOf(arrayFields[i]) === -1) {
                availableFields.push(arrayFields[i]);
              }
            }

            var leftOptions = [];
            var rightOptions = [];
            for (var i = 0; i < availableFields.length; i++) {
              leftOptions.push(new Option(
                availableFields[i],
                availableFields[i]));
            }
            for (var i = 0; i < visibleFields.length; i++) {
              rightOptions
                .push(new Option(visibleFields[i],
                  visibleFields[i]));
            }

            var list = new morpheus.DualList(leftOptions,
              rightOptions);

            morpheus.FormBuilder
              .showOkCancel({
                title: 'Fields',
                okCallback: function () {
                  var visibleFields = list
                    .getOptions(false);
                  var visibleFieldIndices = [];
                  for (var i = 0; i < visibleFields.length; i++) {
                    visibleFieldIndices
                      .push(arrayFields
                        .indexOf(visibleFields[i]));
                  }
                  var fullVector = _this
                    .getFullVector();
                  fullVector
                    .getProperties()
                    .set(
                      morpheus.VectorKeys.VISIBLE_FIELDS,
                      visibleFieldIndices);

                  var summaryFunction = fullVector
                    .getProperties()
                    .get(
                      morpheus.VectorKeys.ARRAY_SUMMARY_FUNCTION);
                  if (summaryFunction) {
                    summaryFunction.indices = visibleFieldIndices;
                  }
                  var updatedVector = _this.isColumns ? _this.project
                      .getFullDataset()
                      .getColumnMetadata()
                      .add(_this.name)
                    : _this.project
                      .getFullDataset()
                      .getRowMetadata()
                      .add(_this.name);
                  // remove cached summary field
                  for (var i = 0; i < updatedVector
                    .size(); i++) {
                    var array = fullVector
                      .getValue(i);
                    if (array != null) {
                      array.summary = undefined;
                    }

                  }

                  _this.setInvalid(true);
                  _this.repaint();
                },
                content: list.$el
              });
          } else if (item === 'Edit Bar Color...') {
            var formBuilder = new morpheus.FormBuilder();
            formBuilder.append({
              name: 'bar_color',
              type: 'color',
              value: _this.settings.barColor,
              required: true,
              style: 'max-width:50px;'
            });
            formBuilder.find('bar_color').on(
              'change',
              function () {
                _this.settings.barColor = $(this)
                  .val();
                _this.setInvalid(true);
                _this.repaint();
              });
            morpheus.FormBuilder.showInModal({
              title: 'Bar Color',
              close: 'Close',
              html: formBuilder.$form,
              focus: heatmap.getFocusEl()
            });
          } else if (item === COLOR_BAR_SIZE) {
            var formBuilder = new morpheus.FormBuilder();
            formBuilder.append({
              name: 'size',
              type: 'text',
              value: _this.settings.colorBarSize,
              required: true,
              style: 'max-width:50px;'
            });
            formBuilder.find('size').on(
              'change',
              function () {
                var val = parseFloat($(this)
                  .val());
                if (val > 0) {
                  _this.settings.colorBarSize = val;
                  _this.setInvalid(true);
                  _this.repaint();
                }
              });
            morpheus.FormBuilder.showInModal({
              title: 'Color Bar Size',
              close: 'Close',
              html: formBuilder.$form,
              focus: heatmap.getFocusEl()
            });
          } else if (item === ANNOTATE_SELECTION) {
            heatmap.getActionManager().execute(isColumns ? 'Annotate Selected Columns' : 'Annotate' +
              ' Selected Rows');
          } else if (item === DELETE) {
            morpheus.FormBuilder
              .showOkCancel({
                title: 'Delete',
                content: 'Are you sure you want to delete '
                + _this.name + '?',
                okCallback: function () {
                  var metadata = isColumns ? project
                      .getFullDataset()
                      .getColumnMetadata()
                    : project
                      .getFullDataset()
                      .getRowMetadata();
                  metadata
                    .remove(morpheus.MetadataUtil
                      .indexOf(
                        metadata,
                        _this.name));
                  var sortKeys = isColumns ? project
                      .getColumnSortKeys()
                    : project
                      .getRowSortKeys();
                  var sortKeyIndex = _.indexOf(
                    sortKeys.map(function (key) {
                      return key.field;
                    }), _this.name);
                  if (sortKeyIndex !== -1) {
                    sortKeys.splice(
                      sortKeyIndex, 1);
                    if (isColumns) {
                      project
                        .setColumnSortKeys(
                          sortKeys,
                          true);
                    } else {
                      project.setRowSortKeys(
                        sortKeys, true);
                    }
                  }
                  var groupByKeys = isColumns ? project
                      .getGroupColumns()
                    : project
                      .getGroupRows();
                  var groupByKeyIndex = _
                    .indexOf(
                      groupByKeys
                        .map(function (key) {
                          return key.field;
                        }),
                      _this.name);
                  if (groupByKeyIndex !== -1) {
                    groupByKeys.splice(
                      groupByKeyIndex, 1);
                    if (isColumns) {
                      project
                        .setGroupColumns(
                          groupByKeys,
                          true);
                    } else {
                      project.setGroupRows(
                        groupByKeys,
                        true);
                    }
                  }
                  if (!isColumns) {
                    // remove from any group
                    // by or sort by
                    project
                      .trigger(
                        'rowTrackRemoved',
                        {
                          vector: _this
                            .getFullVector()
                        });
                  } else {
                    project
                      .trigger(
                        'columnTrackRemoved',
                        {
                          vector: _this
                            .getFullVector()
                        });
                  }
                }
              });
          } else if (item === CLEAR_SELECTION) {
            heatmap.getActionManager().execute(isColumns ? 'Clear Selected Columns' : 'Clear' +
              ' Selected Rows');
          } else if (item === INVERT_SELECTION) {
            heatmap.getActionManager().execute(isColumns ? 'Invert Selected Columns' : 'Invert' +
              ' Selected Rows');
          } else if (item === MOVE_TO_TOP) {
            heatmap.getActionManager().execute(isColumns ? 'Move Selected Columns To Top' : 'Move' +
              ' Selected Rows To Top');
          } else if (item === SORT_ASC || item === SORT_DESC) {
            var sortKey = new morpheus.SortKey(
              _this.name,
              item === SORT_ASC ? morpheus.SortKey.SortOrder.ASCENDING
                : morpheus.SortKey.SortOrder.DESCENDING);
            if (_this.isColumns) {
              _this.project
                .setColumnSortKeys(
                  morpheus.SortKey
                    .keepExistingSortKeys(
                      [sortKey],
                      project
                        .getColumnSortKeys()),
                  true);
            } else {
              _this.project
                .setRowSortKeys(
                  morpheus.SortKey
                    .keepExistingSortKeys(
                      [sortKey],
                      project
                        .getRowSortKeys()),
                  true);
            }
          } else if (item == SORT_SEL_ASC
            || item == SORT_SEL_DESC
            || item === SORT_SEL_TOP_N) {
            var sortOrder;
            if (item === SORT_SEL_ASC) {
              sortOrder = morpheus.SortKey.SortOrder.ASCENDING;
            } else if (item === SORT_SEL_DESC) {
              sortOrder = morpheus.SortKey.SortOrder.DESCENDING;
            } else {
              sortOrder = morpheus.SortKey.SortOrder.TOP_N;
            }
            heatmap.sortBasedOnSelection(sortOrder,
              isColumns, e && e.shiftKey);
          } else if (item === SELECT_ALL) {
            heatmap.getActionManager().execute(isColumns ? 'Select All Columns' : 'Select All Rows');
          } else if (item === 'Auto Range') {
            delete _this.settings.min;
            delete _this.settings.max;
            delete _this.settings.mid;
            _this._update();
            heatmap.revalidate();
          } else if (item === 'Custom Range...') {
            var formBuilder = new morpheus.FormBuilder();
            var items = [
              {
                name: 'min',
                required: true,
                type: 'number',
                value: _this.settings.min
              }, {
                name: 'mid',
                required: true,
                type: 'number',
                value: _this.settings.mid
              }, {
                name: 'max',
                required: true,
                type: 'number',
                value: _this.settings.max
              }];
            _.each(items, function (item) {
              formBuilder.append(item);
            });
            morpheus.FormBuilder
              .showOkCancel({
                title: 'Range',
                content: formBuilder.$form,
                okCallback: function () {
                  _this.settings.min = parseFloat(formBuilder
                    .getValue('min'));
                  _this.settings.mid = parseFloat(formBuilder
                    .getValue('mid'));
                  _this.settings.max = parseFloat(formBuilder
                    .getValue('max'));
                  _this._update();
                  heatmap.revalidate();
                }
              });
          } else if (item === 'Squished') {
            _this.settings.squished = !_this.settings.squished;
            heatmap.revalidate();
          } else if (item === 'Color Key') {
            var legend = new morpheus.HeatMapTrackColorLegend(
              [_this], isColumns ? _this.project
                  .getColumnColorModel()
                : _this.project
                  .getRowColorModel());
            var size = legend.getPreferredSize();
            legend.setBounds(size);
            legend.repaint();

            morpheus.FormBuilder.showInModal({
              title: 'Color Key',
              html: legend.canvas,
              focus: heatmap.getFocusEl()
            });
          } else if (item === 'Shape Key') {
            var legend = new morpheus.HeatMapTrackShapeLegend(
              [_this], isColumns ? _this.project
                  .getColumnShapeModel()
                : _this.project
                  .getRowShapeModel());
            var size = legend.getPreferredSize();
            legend.setBounds(size);
            legend.repaint();

            morpheus.FormBuilder.showInModal({
              title: 'Shape Key',
              html: legend.canvas,
              focus: heatmap.getFocusEl()
            });
          } else if (item === 'Font Key') {
            var legend = new morpheus.HeatMapTrackFontLegend(
              [_this], isColumns ? _this.project
                  .getColumnFontModel()
                : _this.project
                  .getRowFontModel());
            var size = legend.getPreferredSize();
            legend.setBounds(size);
            legend.repaint();
            morpheus.FormBuilder.showInModal({
              title: 'Font Key',
              html: legend.canvas,
              focus: heatmap.getFocusEl()
            });
          } else if (item === 'Edit Fonts...') {
            heatmap.getActionManager().execute('Edit Fonts');
          } else if (item === 'Edit Shapes...') {
            var shapeFormBuilder = new morpheus.FormBuilder();
            var shapeModel = isColumns ? _this.project
              .getColumnShapeModel() : _this.project
              .getRowShapeModel();
            var chooser = new morpheus.ShapeChooser({
              map: shapeModel.getMap(_this.name)
            });

            chooser.on('change', function (event) {
              shapeModel.setMappedValue(_this
                  .getFullVector(), event.value,
                event.shape);
              _this.setInvalid(true);
              _this.repaint();
            });
            morpheus.FormBuilder.showInModal({
              title: 'Edit Shapes',
              html: chooser.$div,
              close: 'Close',
              focus: heatmap.getFocusEl()
            });
          } else if (item === 'Edit Colors...') {
            var colorModel = isColumns ? _this.project
              .getColumnColorModel() : _this.project
              .getRowColorModel();
            var colorSchemeChooser = new morpheus.ColorSchemeChooser({track: _this, heatMap: _this.heatmap, colorModel: colorModel});
            morpheus.FormBuilder.showInModal({
              title: 'Edit Colors',
              html: colorSchemeChooser.$div,
              close: 'Close',
              focus: heatmap.getFocusEl()
            });
          } else if (item === TOOLTIP) {
            _this.settings.inlineTooltip = !_this.settings.inlineTooltip;
          } else if (item === HIGHLIGHT_MATCHING_VALUES) {
            _this.settings.highlightMatchingValues = !_this.settings.highlightMatchingValues;
          } else if ((customItem = _
              .find(
                customItems,
                function (customItem) {
                  return customItem.name === item
                    && customItem.columns === isColumns;
                }))) {
            if (customItem.task) {
              // add task
              var task = {
                tabId: _this.heatmap.getTabManager()
                  .getActiveTabId()
              };

              _this.heatmap.getTabManager().addTask(task);
              setTimeout(function () {
                customItem.callback(heatmap);
                _this.heatmap.getTabManager()
                  .removeTask(task);
              }, 1);
            } else {
              customItem.callback(heatmap);
            }

          } else if (item === DISPLAY_CONTINUOUS) {
            var discrete = _this.getFullVector().getProperties().get(morpheus.VectorKeys.DISCRETE) || false;
            _this.getFullVector().getProperties().set(morpheus.VectorKeys.DISCRETE, !discrete);
            _this._setChartMinMax();
            _this.setInvalid(true);
            _this.repaint();
          } else if (item === HIDE) {
            heatmap.setTrackVisible(_this.name, false,
              _this.isColumns);
            heatmap.revalidate();
          } else if (item === HIDE_OTHERS) {
            var names = heatmap.getVisibleTrackNames(_this.isColumns);
            for (var i = 0; i < names.length; i++) {
              if (names[i] !== _this.name) {
                heatmap.setTrackVisible(names[i], false,
                  _this.isColumns);
              }
            }

            heatmap.revalidate();

          } else if (item === DISPLAY_STACKED_BAR) {
            _this.settings.stackedBar = !_this.settings.stackedBar;
            _this._update();
            heatmap.revalidate();
          } else {
            if (item === DISPLAY_BAR) {
              item = morpheus.VectorTrack.RENDER.BAR;
            } else if (item === DISPLAY_COLOR) {
              item = morpheus.VectorTrack.RENDER.COLOR;
            } else if (item === DISPLAY_TEXT) {
              item = morpheus.VectorTrack.RENDER.TEXT;
            } else if (item === DISPLAY_TEXT_AND_COLOR) {
              item = morpheus.VectorTrack.RENDER.TEXT_AND_COLOR;
            } else if (item === DISPLAY_TEXT_AND_FONT) {
              item = morpheus.VectorTrack.RENDER.TEXT_AND_FONT;
            } else if (item === DISPLAY_STRUCTURE) {
              item = morpheus.VectorTrack.RENDER.MOLECULE;
            } else if (item === DISPLAY_SHAPE) {
              item = morpheus.VectorTrack.RENDER.SHAPE;
            } else if (item === DISPLAY_ARC) {
              item = morpheus.VectorTrack.RENDER.ARC;
            } else if (item === DISPLAY_BOX_PLOT) {
              item = morpheus.VectorTrack.RENDER.BOX_PLOT;
            } else {
              console.log('Unknown item ' + item);
            }
            var show = !_this.isRenderAs(item);
            var remove;
            if (!show) {
              _this.settings.display.splice(_this.settings.display.indexOf(item), 1);
              // if no longer rendering as text, remove TEXT_AND_COLOR and TEXT_AND_FONT
              if (item === morpheus.VectorTrack.RENDER.TEXT) {
                remove = [morpheus.VectorTrack.RENDER.TEXT_AND_FONT, morpheus.VectorTrack.RENDER.TEXT_AND_COLOR];
              }
            } else {
              if (item === morpheus.VectorTrack.RENDER.COLOR) {
                remove = [morpheus.VectorTrack.RENDER.TEXT_AND_COLOR];
              } else if (item === morpheus.VectorTrack.RENDER.TEXT_AND_COLOR) {
                remove = [morpheus.VectorTrack.RENDER.COLOR];
              }
              _this.settings.display.push(item);
            }
            if (remove) {
              remove.forEach(function (key) {
                var index = _this.settings.display.indexOf(key);
                if (index !== -1) {
                  _this.settings.display.splice(index, 1);
                }
              });
            }
            _this._update();
            heatmap.revalidate();
            if (show && item === morpheus.VectorTrack.RENDER.TEXT_AND_FONT) {
              heatmap.getActionManager().execute('Edit Fonts');
            }
          }
        });
  }
  ,
  renderColor: function (context, vector, start, end, clip, offset, continuous) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var colorModel = isColumns ? this.project.getColumnColorModel() : this.project.getRowColorModel();
    var settings = this.settings;
    var canvasSize = isColumns ? this.getUnscaledHeight() : this.getUnscaledWidth();
    var colorBarSize = settings.colorBarSize;
    if (colorBarSize > canvasSize) {
      colorBarSize = canvasSize >= 5 ? (canvasSize - 1)
        : canvasSize;
    }
    var getColor;
    if (!continuous) {
      getColor = _.bind(colorModel.getMappedValue, colorModel);
    } else {
      getColor = _.bind(colorModel.getContinuousMappedValue, colorModel);
    }

    if (vector.getProperties().get(
        morpheus.VectorKeys.FIELDS) != null) {
      var visibleFieldIndices = vector.getProperties().get(
        morpheus.VectorKeys.VISIBLE_FIELDS);
      if (visibleFieldIndices == null) {
        visibleFieldIndices = morpheus.Util.seq(vector.getProperties().get(
          morpheus.VectorKeys.FIELDS).length);
      }
      colorBarSize /= visibleFieldIndices.length;
      var nvisibleFieldIndices = visibleFieldIndices.length;

      for (var i = start; i < end; i++) {
        var array = vector.getValue(i);
        var position = positions.getPosition(i);
        var size = positions.getItemSize(i);
        var _offset = offset;
        if (array != null) {
          for (var j = 0; j < nvisibleFieldIndices; j++) {
            var value = array[visibleFieldIndices[j]];
            var color = getColor(vector, value);
            context.fillStyle = color;
            if (isColumns) {
              context.beginPath();
              context.rect(position, _offset - colorBarSize, size,
                colorBarSize);
              context.fill();
            } else {
              context.beginPath();
              context.rect(_offset, position, colorBarSize, size);
              context.fill();
            }
            _offset += colorBarSize;
          }
        }

      }

    } else {
      for (var i = start; i < end; i++) {
        var value = vector.getValue(i);
        var position = positions.getPosition(i);
        var size = positions.getItemSize(i);
        var color = getColor(vector, value);
        context.fillStyle = color;
        if (isColumns) {
          context.beginPath();
          context.rect(position, offset - colorBarSize, size,
            settings.colorBarSize);
          context.fill();
        } else {
          context.beginPath();
          context.rect(offset, position, colorBarSize, size);
          context.fill();
        }
      }
    }
  }
  ,
  renderShape: function (context, vector, start, end, clip, offset) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var shapeModel = isColumns ? this.project.getColumnShapeModel()
      : this.project.getRowShapeModel();
    var settings = this.settings;
    var canvasSize = isColumns ? this.getUnscaledHeight() : this
      .getUnscaledWidth();
    var colorBarSize = settings.colorBarSize;
    if (colorBarSize > canvasSize) {
      colorBarSize = canvasSize >= 5 ? (canvasSize - 1)
        : canvasSize;
    }
    context.fillStyle = 'black';
    context.strokeStyle = 'black';

    var lineWidth = context.lineWidth;
    context.lineWidth = 1;
    for (var i = start; i < end; i++) {

      var value = vector.getValue(i);
      var position = positions.getPosition(i);
      var itemSize = positions.getItemSize(i);
      var minSize = Math.min(colorBarSize, itemSize);
      var size2 = minSize / 2;
      var shape = shapeModel.getMappedValue(vector, value);
      // x and y are at center
      var x = isColumns ? position + itemSize / 2 : offset + size2;
      var y = isColumns ? offset - size2 : position + itemSize / 2;
      size2 -= 0.5; // small border between cells
      morpheus.CanvasUtil.drawShape(context, shape, x, y, size2);
    }
    context.lineWidth = lineWidth;
  }
  ,
  renderHeatMap: function (context, vector, start, end, clip, size) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var project = this.project;
    context.save();
    context.lineWidth = 1;
    //	context.translate(clip.x, clip.y);
    var width = clip.width;
    var height = clip.height;
    var colorScheme = this.heatmap.getHeatMapElementComponent().getColorScheme();
    var drawGrid = this.heatmap.getHeatMapElementComponent().isDrawGrid();
    var gridColor = this.heatmap.getHeatMapElementComponent().getGridColor();
    var gridThickness = this.heatmap.getHeatMapElementComponent().getGridThickness();
    for (var i = start; i < end; i++) {
      var value = vector.getValue(i); // value is an array of values to display as a heat map
      if (value != null) {
        var pix = positions.getPosition(i);
        var itemSize = positions.getItemSize(i);
        var currentPix = 0;
        var nvalues = value.length;
        var pixPer = size / nvalues;
        for (var j = 0; j < nvalues; j++) {
          var val = value[j];
          context.fillStyle = colorScheme.getColor(i, -1, val);
          context.fillRect(j * pixPer, pix, pixPer, itemSize);
        }
        if (drawGrid && itemSize > 10) {
          context.strokeStyle = gridColor;
          context.lineWidth = gridThickness;
          context.beginPath();
          for (var j = 0; j < nvalues; j++) {
            var val = value[j];
            context.rect(j * pixPer, pix, pixPer, itemSize);
          }
          context.stroke();

        }
      }

    }

    context.restore();
  }
  ,
  renderArc: function (context, vector, start, end, clip, size) {

    var isColumns = this.isColumns;
    var positions = this.positions;
    var project = this.project;
    context.save();
    context.lineWidth = 1;
    // var scale = d3.scale.linear().domain([1, size]).range([0.8, 1])
    // .clamp(true);
    // var fill = d3.scale.category20b();

    var total = positions.getPosition(positions.getLength() - 1)
      + positions.getItemSize(positions.getLength() - 1);
    context.translate(clip.x, clip.y);
    var width = clip.width;
    var height = clip.height;
    // if (!isColumns) {
    // 	var squishFactor = height / total;
    // 	context.scale(1, squishFactor);
    // } else {
    // 	var squishFactor = width / total;
    // 	context.scale(squishFactor, 1);
    // }

    for (var i = start; i < end; i++) {
      var value = vector.getValue(i); // value is an array of other indices to link to
      if (value != null) {
        var startPix = positions.getPosition(i) + positions.getItemSize(i)
          / 2;
        for (var j = 0, nindices = value.length; j < nindices; j++) {
          var viewIndex = value[j];
          var endPix = positions.getPosition(viewIndex)
            + positions.getItemSize(viewIndex) / 2;
          var midPix = (endPix + startPix) / 2;
          var distance = Math.abs(i - viewIndex);
          var arcRadius = size; // scale(distance) * size;
          if (isColumns) {
            context.beginPath();
            context.moveTo(startPix, arcRadius);
            context.quadraticCurveTo(midPix, 1, endPix, arcRadius);
          } else {
            console.log(i, viewIndex, startPix, endPix);
            context.beginPath();
            context.moveTo(1, startPix);
            context.quadraticCurveTo(arcRadius, midPix, 1, endPix);
          }

          context.stroke();

        }
      }

    }
    context.restore();
  }
  ,
  sdfToSvg: function (sdf, width, height) {
    if (!this.jsme && typeof JSApplet !== 'undefined') {
      this.jsmeId = _.uniqueId('m');
      this.$jsmeDiv = $(
        '<div id="'
        + this.jsmeId
        + '" style="position:absolute;left:-10000px;top:-10000px;"></div>')
        .appendTo($(document.body));
      this.jsme = new JSApplet.JSME(this.jsmeId, '380px', '340px', {});
    }
    // this.$jsmeDiv.css('width', width + 'px').css('height', height +
    // 'px');
    // this.jsme.setSize(width + 'px', height + 'px');
    this.jsme.readMolFile(sdf);
    var svg = $('#' + this.jsmeId + ' > div > div > div:nth-child(2) > svg');
    var svgWidth = svg.width.baseVal.value;
    var svgHeight = svg.height.baseVal.value;
    var scale = Math.min(width / svgWidth, height / svgHeight);
    var text = '<svg><g transform="scale(' + scale + ')">' + svg.innerHTML
      + '</g></svg>';
    return text;
  }
  ,
  renderMolecule: function (context, vector, start, end, clip, offset) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.strokeStyle = 'black';
    var width = this.getUnscaledWidth();
    var customUrlProvider = this.heatmap.options.structureUrlProvider !== undefined;
    var dummyTarget = {
      childNodes: [],
      getContext: function () {
        return context;
      }
    };
    for (var i = start; i < end; i++) {
      var spanEnd = this.spanMap.get(i);
      if (spanEnd !== undefined) {
        var startPix = positions.getPosition(i);
        var endPix = positions.getPosition(spanEnd - 1)
          + positions.getSize();
        var size = endPix - startPix;
        var value = vector.getValue(i);
        var cache = this.moleculeCache[value];
        if (cache) {
          if (customUrlProvider) {
            if (cache.complete) {
              // 800 x 400
              var scaleFactor = Math.min(size / cache.height,
                width / cache.width);
              var scaledWidth = cache.width * scaleFactor;
              var scaledHeight = cache.height * scaleFactor;
              var diff = cache.height - scaledHeight;
              startPix += diff / 2;
              try {
                context.drawImage(cache, offset, startPix,
                  scaledWidth, scaledHeight);
              }
              catch (x) {

              }
            }
          } else {
            var text = this.sdfToSvg(cache, width, size);
            canvg(dummyTarget, text, {
              ignoreMouse: true,
              ignoreAnimation: true,
              offsetY: startPix,
              ignoreClear: true,
              ignoreDimensions: true
            });
          }
        }
      }
    }
  }
  ,
  createChartScale: function (availableSpace) {
    var domain;
    var range;
    if (this.settings.mid !== this.settings.min
      && this.settings.mid !== this.settings.max) {
      domain = [this.settings.min, this.settings.mid, this.settings.max];
      range = this.isColumns ? [availableSpace, availableSpace / 2, 0]
        : [0, availableSpace / 2, availableSpace];
    } else {
      domain = [this.settings.min, this.settings.max];
      range = this.isColumns ? [availableSpace, 0] : [
        0,
        availableSpace];
    }
    var scale = d3.scale.linear().domain(domain).range(range).clamp(true);
    return scale;
  }
  ,
  renderBar: function (context, vector, start, end, clip, offset, availableSpace) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    context.fillStyle = this.settings.barColor;
    var scale = this.createChartScale(availableSpace);
    var midPix = scale(this.settings.mid);
    var settings = this.settings;
    var discrete = vector.getProperties().get(morpheus.VectorKeys.DISCRETE) && this.discreteValueMap != null;
    var colorByVector = this.settings.colorByField != null ? this
      .getVector(this.settings.colorByField) : null;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();

    for (var i = start; i < end; i++) {
      var value = vector.getValue(i);
      if (discrete) {
        value = this.discreteValueMap.get(value);
      }
      var position = positions.getPosition(i);
      var size = positions.getItemSize(i);
      var scaledValue = scale(value);
      if (colorByVector !== null) {
        context.fillStyle = colorModel.getMappedValue(colorByVector, colorByVector.getValue(i));
      }
      if (isColumns) {
        context.beginPath();
        context.rect(position, Math.min(midPix, scaledValue) + offset, size,
          Math.abs(midPix - scaledValue));
        context.fill();
      } else {
        context.beginPath();
        context.rect(offset + Math.min(midPix, scaledValue), position,
          Math.abs(midPix - scaledValue), size);
        context.fill();
      }
    }
  }
  ,
  renderBoxPlot: function (context, vector, start, end, clip, offset, availableSpace) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    context.strokeStyle = 'black';
    context.save();
    context.translate(offset, 0);
    var scale = this.createChartScale(availableSpace);
    var visibleFieldIndices = vector.getProperties().get(
      morpheus.VectorKeys.VISIBLE_FIELDS);

    var colorByVector = this.settings.colorByField != null ? this
      .getVector(this.settings.colorByField) : null;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();
    for (var i = start; i < end; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        var itemSize = positions.getItemSize(i);
        if (itemSize <= 3) {
          continue;
        }
        var radius = 2;
        var pix = positions.getPosition(i);
        var start = pix + 1;
        var end = pix + itemSize - 1;
        var center = (start + end) / 2;
        var _itemSize = itemSize - 2;
        var lineHeight = Math.max(2, _itemSize - 8);
        var box = array.summary;
        if (box == null) {
          var v = morpheus.VectorUtil.arrayAsVector(array);
          box = morpheus
            .BoxPlotItem(visibleFieldIndices != null ? new morpheus.SlicedVector(
              v, visibleFieldIndices)
              : v);
          array.summary = box;
        }
        context.fillStyle = '#bdbdbd';

        if (!isColumns) {
          // box from q1 (25th q) to q3
          context.fillRect(Math.min(scale(box.q1), scale(box.q3)),
            start, Math.abs(scale(box.q1) - scale(box.q3)),
            _itemSize);
          // draw line from q1 to lav
          context.fillRect(Math.min(scale(box.q1),
            scale(box.lowerAdjacentValue)), center - lineHeight
            / 2, Math.abs(scale(box.q1)
            - scale(box.lowerAdjacentValue)), lineHeight);
          // draw line from q3 to uav
          context.fillRect(Math.min(scale(box.q3),
            scale(box.upperAdjacentValue)), center - lineHeight
            / 2, Math.abs(scale(box.q3)
            - scale(box.upperAdjacentValue)), lineHeight);
          context.fillStyle = '#31a354';
          // highlight median
          context.fillRect(scale(box.median) - 3, start, 3, end - start);
          context.fillStyle = '#636363';

          // draw individual points
          // for (var j = 0, length = visibleFieldIndices == null ? array.length : visibleFieldIndices.length; j < length; j++) {
          // 	var index = visibleFieldIndices == null ? j : visibleFieldIndices[j];
          // 	var value = array[index];
          // 	if (value != null) {
          // 		if (colorByVector != null) {
          // 			var colorByArray = colorByVector.getValue(i);
          // 			if (colorByArray != null) {
          // 				var color = colorModel
          // 				.getMappedValue(
          // 					colorByVector,
          // 					colorByArray[index]);
          // 				context.fillStyle = color;
          // 			} else {
          // 				context.fillStyle = '#636363';
          // 			}
          //
          // 		}
          // 		var pix = scale(value);
          // 		context.beginPath();
          // 		context
          // 		.arc(pix, center, radius, Math.PI * 2,
          // 			false);
          // 		context.fill();
          // 	}
          // }

        } else { // TOD implement for columns

        }

      }
    }
    context.restore();
  }
  ,
  renderStackedBar: function (context, vector, start, end, clip, offset, availableSpace) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var scale = this.createChartScale(availableSpace);
    var midPix = scale(this.settings.mid);
    var settings = this.settings;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();
    context.strokeStyle = 'black';
    context.lineWidth = 2;
    for (var i = start; i < end; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        var position = positions.getPosition(i);
        var size = positions.getItemSize(i);
        var positivePairs = [];
        var negativePairs = [];
        for (var j = 0, length = array.length; j < length; j++) {
          var value = array[j];
          if (value >= this.settings.mid) {
            positivePairs.push({
              value: value,
              index: j
            });
          } else if (value < 0) {
            negativePairs.push({
              value: value,
              index: j
            });
          }
        }

        // array.sort(function (a, b) {
        // 	return (a.value < b.value ? 1 : (a.value === b.value ? 0 : -1));
        // });
        // var positiveIndices = [];
        // positivePairs.forEach(function (item) {
        // 	positiveIndices.push(item.index);
        // });
        //
        var positiveIndices = morpheus.Util.indexSortPairs(
          positivePairs, false);
        for (var j = 0, length = positiveIndices.length; j < length; j++) {
          var index = positiveIndices[j];
          var value = array[index];
          var color = colorModel.getMappedValue(vector, index);
          context.fillStyle = color;
          var scaledValue = scale(value);
          var nextScaledValue = j === (length - 1) ? midPix
            : scale(array[positiveIndices[j + 1]]);
          if (isColumns) {
            context.beginPath();
            context.rect(position, Math.min(nextScaledValue,
              scaledValue), size, Math.abs(nextScaledValue
              - scaledValue));
            context.fill();
          } else {
            context.beginPath();
            context.rect(offset
              + Math.min(nextScaledValue, scaledValue),
              position, Math.abs(nextScaledValue
                - scaledValue), size);
            context.fill();
          }
        }
        var negativeIndices = morpheus.Util.indexSortPairs(
          negativePairs, true); // draw smaller (more negative)
        // values 1st
        for (var j = 0, length = negativeIndices.length; j < length; j++) {
          var index = negativeIndices[j];
          var value = array[index];
          var color = colorModel.getMappedValue(vector, index);
          context.fillStyle = color;
          var scaledValue = scale(value);
          var nextScaledValue = j === (length - 1) ? midPix
            : scale(array[negativeIndices[j + 1]]);
          if (isColumns) {
            context.beginPath();
            context.rect(position, Math.min(nextScaledValue,
              scaledValue), size, Math.abs(nextScaledValue
              - scaledValue));
            context.fill();
          } else {
            context.beginPath();
            context.rect(offset
              + Math.min(nextScaledValue, scaledValue),
              position, Math.abs(nextScaledValue
                - scaledValue), size);
            context.fill();
          }

        }
      }
    }
    context.lineWidth = 1;
  }
  ,
  renderUnstackedBar: function (context, vector, start, end, clip, offset, availableSpace, fieldIndices) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var nvalues = fieldIndices.length;
    var settings = this.settings;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();
    context.fillStyle = this.settings.barColor;
    // context.strokeStyle = '0000f0';
    var barSpacer = 0;
    var barWidth = (availableSpace - (nvalues - 1) * barSpacer) / nvalues;
    var colorByVector = this.settings.colorByField != null ? this
      .getVector(this.settings.colorByField) : null;
    context.strokeStyle = 'white';
    for (var i = start; i < end; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        var position = positions.getPosition(i);
        var itemSize = positions.getItemSize(i);
        var scale = this.createChartScale(itemSize - 1);
        var midPix = scale(this.settings.mid); // need to set mid pix
        // for each item
        var xpix = 0;
        for (var j = 0; j < nvalues; j++) {
          var value = array[fieldIndices[j]];
          if (colorByVector != null) {
            var colorByArray = colorByVector.getValue(i);
            var color = colorModel
              .getMappedValue(
                colorByVector,
                colorByArray != null ? colorByArray[fieldIndices[j]]
                  : null);
            context.fillStyle = color;
          }

          var scaledValue = scale(value);

          if (isColumns) {
            context.beginPath();
            context.rect(Math.min(midPix, scaledValue), offset
              + xpix, Math.abs(midPix - scaledValue),
              barWidth);
            context.fill();
          } else {
            // bar always goes to midpix
            context.beginPath();
            var barHeight = Math.abs(midPix - scaledValue);
            var ypix = position + itemSize
              - Math.max(midPix, scaledValue);
            context.rect(offset + xpix, ypix, barWidth, barHeight);
            context.fill();

          }

          xpix += barWidth + barSpacer;
        }

      }

    }
  }
  ,
  renderText: function (context, vector, isColor, isFont, start, end, clip, offset,
                        canvasSize) {

    context.textBaseline = 'middle';
    if (typeof C2S !== 'undefined' && context instanceof C2S) { // FIXME hack for svg text alignment
      context.translate(this.isColumns ? 2 : 0, this.isColumns ? 0 : 2);
    }
    var positions = this.positions;
    var isColumns = this.isColumns;

    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();

    var fontModel = isColumns ? this.project.getColumnFontModel()
      : this.project.getRowFontModel();

    if (isColumns) {
      context.translate(clip.x, clip.y); // reset transform, needed for export to svg
    }
    var colorByVector = this.settings.colorByField != null ? this
      .getVector(this.settings.colorByField) : vector;
    var getColor;
    if (colorByVector.getProperties().get(morpheus.VectorKeys.DISCRETE)) {
      getColor = _.bind(colorModel.getMappedValue, colorModel);
    } else {
      getColor = _.bind(colorModel.getContinuousMappedValue, colorModel);
    }
    var fontVector = this.settings.fontField != null ? this
      .getVector(this.settings.fontField) : vector;
    var toStringFunction = morpheus.VectorTrack.vectorToString(vector);
    var font = context.font;
    for (var i = start; i < end; i++) {
      var size = this.positions.getItemSize(i);
      if (size < 6) {
        continue;
      }
      var value = vector.getValue(i);
      if (value != null) {
        var stringValue = toStringFunction(value);
        var position = positions.getPosition(i);
        if (isColor) {
          context.fillStyle = getColor(colorByVector, colorByVector.getValue(i));
        }
        if (isFont) {
          context.font = fontModel.getMappedValue(fontVector, fontVector.getValue(i)).weight + ' ' + font;
        }
        if (isColumns) {
          context.save();
          context.translate(position + size / 2 - clip.x,
            offset - clip.y);
          context.rotate(-Math.PI / 2);
          context.fillText(stringValue, 0, 0);
          context.restore();
        } else {
          context.fillText(stringValue, offset, position + size / 2);
        }
      }
    }
    context.font = font;
  }
};
morpheus.Util.extend(morpheus.VectorTrack, morpheus.AbstractCanvas);
morpheus.VectorTrack.MAX_FONT_SIZE = 18;

/**
 * Performs clustering using pairwise average linking on the given distance
 * matrix.
 *
 * @return array of nodes. Each node object contains a left, right, and
 *         distance.
 */
morpheus.AverageLinkage = function (nelements, distmatrix) {
  var j;
  var n;
  var clusterid;
  var number;
  var result;
  clusterid = []; // nelements;
  number = []; // nelements;
  result = []; // nelements - 1;
  for (var i = 0; i < nelements - 1; i++) {
    result[i] = {
      left: 0,
      right: 0,
      distance: 0
    };
  }
  /*
   * Setup a list specifying to which cluster an element belongs, and keep
   * track of the number of elements in each cluster (needed to calculate the
   * average).
   */
  for (j = 0; j < nelements; j++) {
    number[j] = 1;
    clusterid[j] = j;
  }
  // ip, jp, and distance;
  var r = {};
  // result array contains array of int left, int right, float distance;
  for (n = nelements; n > 1; n--) {
    morpheus.HCluster.findClosestPair(n, distmatrix, r);
    result[nelements - n] = {};
    result[nelements - n].distance = r.distance;
    var is = r.ip;
    var js = r.jp;
    /* Save result */
    result[nelements - n].left = clusterid[is];
    result[nelements - n].right = clusterid[js];
    /* Fix the distances */
    var sum = number[is] + number[js];
    for (j = 0; j < js; j++) {
      distmatrix[js][j] = distmatrix[is][j] * number[is]
        + distmatrix[js][j] * number[js];
      distmatrix[js][j] /= sum;
    }
    for (j = js + 1; j < is; j++) {
      distmatrix[j][js] = distmatrix[is][j] * number[is]
        + distmatrix[j][js] * number[js];
      distmatrix[j][js] /= sum;
    }
    for (j = is + 1; j < n; j++) {
      distmatrix[j][js] = distmatrix[j][is] * number[is]
        + distmatrix[j][js] * number[js];
      distmatrix[j][js] /= sum;
    }
    for (j = 0; j < is; j++) {
      distmatrix[is][j] = distmatrix[n - 1][j];
    }
    for (j = is + 1; j < n - 1; j++) {
      distmatrix[j][is] = distmatrix[n - 1][j];
    }
    /* Update number of elements in the clusters */
    number[js] = sum;
    number[is] = number[n - 1];
    /* Update clusterids */
    clusterid[js] = n - nelements - 1;
    clusterid[is] = clusterid[n - 1];
  }
  return result;
};

morpheus.CollapseDataset = function (dataset, collapseToFields,
                                     summarizeFunction, shallowCopy) {
  var vectors = [];
  for (var i = 0; i < collapseToFields.length; i++) {
    var v = dataset.getRowMetadata().getByName(collapseToFields[i]);
    if (!v) {
      throw collapseToFields[i]
      + ' not found. Available fields are '
      + morpheus.MetadataUtil.getMetadataNames(dataset
      .getRowMetadata());
    }
    vectors.push(v);
  }
  var idToIndices = morpheus.VectorUtil.createValuesToIndicesMap(vectors);
  var collapsedDataset = new morpheus.Dataset({
    name: dataset.getName(),
    rows: idToIndices.size(),
    columns: dataset.getColumnCount(),
    dataType: 'Float32'
  });
  var nseries = dataset.getSeriesCount();
  for (var series = 1; series < nseries; series++) {
    collapsedDataset.addSeries({
      name: dataset.getName(i),
      dataType: 'Float32'
    });
  }
  if (shallowCopy) {
    collapsedDataset.setColumnMetadata(dataset.getColumnMetadata());
  } else {
    morpheus.MetadataUtil.copy(dataset.getColumnMetadata(),
      collapsedDataset.getColumnMetadata());
  }
  var nfields = collapseToFields.length;
  var collapseToVectors = [];
  for (var i = 0; i < nfields; i++) {
    collapseToVectors.push(collapsedDataset.getRowMetadata().add(
      collapseToFields[i]));
  }
  var counter = 0;
  idToIndices
  .forEach(function (rowIndices, key) {
    // collapse each column separately
    var slice = morpheus.DatasetUtil.slicedView(dataset,
      rowIndices, null);
    var view = new morpheus.DatasetColumnView(slice);
    for (var series = 0; series < nseries; series++) {
      view.setSeriesIndex(series);
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        view.setIndex(j);
        collapsedDataset.setValue(counter, j,
          summarizeFunction(view), series);
      }
    }
    for (var i = 0; i < nfields; i++) {
      var collapsedToVector = collapseToVectors[i];
      var vector = vectors[i];
      collapsedToVector.setValue(counter, vector
      .getValue(rowIndices[0]));
    }
    counter++;
  });
  if (nfields === 1) {
    var newVector = collapseToVectors[0];
    vectors[0].getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        newVector.properties.set(key, val);
      }
    });
  }
  return collapsedDataset;
};

morpheus.CompleteLinkage = function (nelements, distmatrix) {
  var j;
  var n;
  var clusterid = []; // new var[nelements];
  var result = [];// new Node[nelements - 1];
  for (var i = 0; i < nelements - 1; i++) {
    result[i] = {
      left: 0,
      right: 0,
      distance: 0
    };
  }
  /* Setup a list specifying to which cluster a gene belongs */
  for (j = 0; j < nelements; j++) {
    clusterid[j] = j;
  }
  var r = {};
  for (n = nelements; n > 1; n--) {
    morpheus.HCluster.findClosestPair(n, distmatrix, r);
    result[nelements - n].distance = r.distance;
    var is = r.ip;
    var js = r.jp;
    /* Fix the distances */
    for (j = 0; j < js; j++) {
      distmatrix[js][j] = Math.max(distmatrix[is][j], distmatrix[js][j]);
    }
    for (j = js + 1; j < is; j++) {
      distmatrix[j][js] = Math.max(distmatrix[is][j], distmatrix[j][js]);
    }
    for (j = is + 1; j < n; j++) {
      distmatrix[j][js] = Math.max(distmatrix[j][is], distmatrix[j][js]);
    }
    for (j = 0; j < is; j++) {
      distmatrix[is][j] = distmatrix[n - 1][j];
    }
    for (j = is + 1; j < n - 1; j++) {
      distmatrix[j][is] = distmatrix[n - 1][j];
    }
    /* Update clusterids */
    result[nelements - n].left = clusterid[is];
    result[nelements - n].right = clusterid[js];
    clusterid[js] = n - nelements - 1;
    clusterid[is] = clusterid[n - 1];
  }
  return result;
};

morpheus.HClusterGroupBy = function (dataset, groupByFieldNames, distanceFunction, linkageMethod) {
  var model = dataset.getRowMetadata();
  var vectors = morpheus.MetadataUtil.getVectors(dataset.getRowMetadata(),
    groupByFieldNames);
  var idToIndices = morpheus.VectorUtil.createValuesToIndicesMap(vectors);
  var reorderedIndices = [];
  var offset = 0;
  var root = {
    id: -1,
    children: [],
    height: 0
  };
  var tree = {
    maxHeight: 0,
    rootNode: root,
    leafNodes: [],
    nLeafNodes: 0
  };
  idToIndices
  .forEach(function (rowIndices, id) {
    var originalIndicesForGroup = idToIndices.get(id);
    var subset = morpheus.DatasetUtil.slicedView(dataset,
      originalIndicesForGroup, null);
    var hcl;
    var distanceMatrix = morpheus.HCluster.computeDistanceMatrix(
      subset, distanceFunction);
    hcl = new morpheus.HCluster(distanceMatrix, linkageMethod);
    var reorderedGroupIndices = hcl.reorderedIndices;
    for (var i = 0, rows = subset.getRowCount(); i < rows; i++) {
      var originalIndex = originalIndicesForGroup[reorderedGroupIndices[i]];
      reorderedIndices.push(originalIndex);
    }

    morpheus.DendrogramUtil.dfs(hcl.tree.rootNode, function (node) {
      node.index += offset;
      node.minIndex += offset;
      node.maxIndex += offset;
      node.id += offset;
      return true;
    });
    if (hcl.tree.leafNodes.length === 0) {
      tree.leafNodes = tree.leafNodes
      .concat([hcl.tree.rootNode]);
    } else {
      tree.leafNodes = tree.leafNodes.concat(hcl.tree.leafNodes);

    }

    root.children.push(hcl.tree.rootNode);
    if (!isNaN(hcl.tree.maxHeight)) {
      tree.maxHeight = Math.max(tree.maxHeight,
        hcl.tree.maxHeight);
    }
    offset += subset.getRowCount();
  });
  tree.nLeafNodes = tree.leafNodes.length;
  tree.rootNode.height = tree.maxHeight;
  this.tree = tree;
  this.reorderedIndices = reorderedIndices;
};

/**
 *
 * @param distmatrix
 * @param linkageAlgorithm {Function}
 * @constructor
 */
morpheus.HCluster = function (distmatrix, linkageAlgorithm) {
  var nelements = distmatrix.length;
  var nNodes = nelements - 1;
  if (nNodes === -1) {

    var root = {
      id: 0,
      height: 0,
      index: 0,
      minIndex: 0,
      maxIndex: 0,
      depth: 0
    };

    this.tree = {
      maxHeight: 0,
      rootNode: root,
      leafNodes: [],
      nLeafNodes: 0
    };
    this.reorderedIndices = [0];
    return;
  }
  // tree array contains array of int left, int right, float distance;
  var tree = linkageAlgorithm(nelements, distmatrix);
  var nodeorder = []; // nNodes;
  var nodecounts = [];// nNodes;
  var order = []; // nelements;
  var nodeID = []; // nNodes;
  for (var i = 0; i < nelements; i++) {
    order[i] = i;
  }
  var leftIds = []; // nNodes
  var rightIds = []; // nNodes
  for (var i = 0; i < nNodes; i++) {
    var min1 = tree[i].left;
    var min2 = tree[i].right;
    /* min1 and min2 are the elements that are to be joined */
    var order1;
    var order2;
    var counts1;
    var counts2;
    var ID1;
    var ID2;
    nodeID[i] = nNodes + (i + 2);
    if (min1 < 0) {
      var index1 = -min1 - 1;
      order1 = nodeorder[index1];
      counts1 = nodecounts[index1];
      ID1 = nodeID[index1];
      tree[i].distance = Math
      .max(tree[i].distance, tree[index1].distance);
    } else {
      order1 = order[min1];
      counts1 = 1;
      ID1 = min1;
    }
    if (min2 < 0) {
      var index2 = -min2 - 1;
      order2 = nodeorder[index2];
      counts2 = nodecounts[index2];
      ID2 = nodeID[index2];
      tree[i].distance = Math
      .max(tree[i].distance, tree[index2].distance);
    } else {
      order2 = order[min2];
      counts2 = 1;
      ID2 = min2;
    }
    leftIds[i] = ID1;
    rightIds[i] = ID2;
    nodecounts[i] = counts1 + counts2;
    nodeorder[i] = (counts1 * order1 + counts2 * order2)
      / (counts1 + counts2);
  }
  var reorderedIndices = morpheus.HCluster.treeSort(nNodes, order, nodeorder,
    nodecounts, tree);
  var idToIndex = {};
  for (var i = 0, length = reorderedIndices.length; i < length; i++) {
    var index = reorderedIndices[i];
    idToIndex[index] = i;
  }
  var nodeIdToNode = {};
  var node;
  for (var i = 0, length = nodeID.length; i < length; i++) {
    var id = nodeID[i];
    var leftId = leftIds[i];
    var lnode = nodeIdToNode[leftId];
    if (lnode === undefined) {
      lnode = {
        id: leftId
      };
      var index = idToIndex[leftId];
      lnode.index = index;
      lnode.minIndex = index;
      lnode.maxIndex = index;
      nodeIdToNode[lnode.id] = lnode;
    }
    var rightId = rightIds[i];
    var rnode = nodeIdToNode[rightId];
    if (rnode === undefined) {
      rnode = {
        id: rightId
      };
      var index = idToIndex[rightId];
      rnode.index = index;
      rnode.minIndex = index;
      rnode.maxIndex = index;
      nodeIdToNode[rnode.id] = rnode;
    }
    node = {
      id: id,
      children: lnode.index < rnode.index ? [lnode, rnode] : [rnode, lnode],
      height: tree[i].distance,
      index: (rnode.index + lnode.index) / 2.0
    };

    node.minIndex = Math.min(rnode.minIndex, lnode.minIndex);
    node.maxIndex = Math.max(rnode.maxIndex, lnode.maxIndex);
    lnode.parent = node;
    rnode.parent = node;
    nodeIdToNode[node.id] = node;
  }
  this.reorderedIndices = reorderedIndices;
  var leafNodes = [];
  for (var i = 0, length = reorderedIndices.length; i < length; i++) {
    var leaf = nodeIdToNode[reorderedIndices[i]];
    leaf.height = 0;
    leafNodes.push(leaf);
  }

  morpheus.DendrogramUtil.setNodeDepths(node);

  this.tree = {
    maxHeight: node.height,
    rootNode: node,
    leafNodes: leafNodes,
    nLeafNodes: leafNodes.length
  };
};
/*
 * Searches the distance matrix to find the pair with the shortest distance
 * between them. The indices of the pair are returned in ip and jp; the distance
 * itself is returned by the function.
 * 
 * @param n The number of elements in the distance matrix.
 * 
 * @param distmatrix. A ragged array containing the distance matrix. The number
 * of columns in each row is one less than the row index.
 * 
 * @return The first and second indices of the pair with the shortest distance.
 */
morpheus.HCluster.findClosestPair = function (n, distmatrix, r) {
  var i, j;
  var temp;
  var distance = distmatrix[1][0];
  var ip = 1;
  var jp = 0;
  for (i = 1; i < n; i++) {
    for (j = 0; j < i; j++) {
      temp = distmatrix[i][j];
      if (temp < distance) {
        distance = temp;
        ip = i;
        jp = j;
      }
    }
  }
  r.distance = distance;
  r.ip = ip;
  r.jp = jp;
};
/**
 * Creates a ragged array with the number of rows equal to the number of rows in
 * the dataset. Each row in the array has n columns where n is the row index.
 *
 * @param dataset
 * @param distanceFunction
 *            The distance function. Use 0 to assume dataset is already a
 *            distance matrix, 1 to assume dataset is already a similarity
 *            matrix.
 * @return the distance matrix
 */
morpheus.HCluster.computeDistanceMatrix = function (dataset, distanceFunction) {
  /* Set up the ragged array */
  var matrix = [];
  var n = dataset.getRowCount();
  for (var i = 1; i < n; i++) {
    matrix[i] = new Float32Array(i);
  }
  // assume dataset is already a distance matrix
  if (distanceFunction === 0) {
    for (var i = 1; i < n; i++) {
      for (var j = 0; j < i; j++) {
        matrix[i][j] = dataset.getValue(i, j);
      }
    }
  } else if (distanceFunction === 1) { // already a similarity matrix
    var max = -Number.MAX_VALUE;
    for (var i = 1; i < n; i++) {
      for (var j = 0; j < i; j++) {
        var value = dataset.getValue(i, j);
        if (!isNaN(value)) {
          max = Math.max(value, max);
        }
      }
    }
    for (var i = 1; i < n; i++) {
      for (var j = 0; j < i; j++) {
        matrix[i][j] = max - dataset.getValue(i, j);
      }
    }
  } else {
    var list1 = new morpheus.DatasetRowView(dataset);
    var list2 = new morpheus.DatasetRowView(dataset);
    /* Calculate the distances and save them in the ragged array */
    for (var i = 1; i < n; i++) {
      list1.setIndex(i);
      for (var j = 0; j < i; j++) {
        matrix[i][j] = distanceFunction(list1, list2.setIndex(j));
      }
    }
  }

  return matrix;
};
morpheus.HCluster.treeSort = function (nNodes, order, nodeorder, nodecounts,
                                       tree) {
  var nElements = nNodes + 1;
  var i;
  var neworder = []; // nElements;
  var clusterids = []; // nElements;
  for (i = 0; i < nElements; i++) {
    clusterids[i] = i;
    neworder[i] = 0;
  }
  for (i = 0; i < nNodes; i++) {
    var i1 = tree[i].left;
    var i2 = tree[i].right;
    var order1 = (i1 < 0) ? nodeorder[-i1 - 1] : order[i1];
    var order2 = (i2 < 0) ? nodeorder[-i2 - 1] : order[i2];
    var count1 = (i1 < 0) ? nodecounts[-i1 - 1] : 1;
    var count2 = (i2 < 0) ? nodecounts[-i2 - 1] : 1;
    /*
     * If order1 and order2 are equal, their order is determined by the
     * order in which they were clustered
     */
    if (i1 < i2) {
      var increase = (order1 < order2) ? count1 : count2;
      var j;
      for (j = 0; j < nElements; j++) {
        var clusterid = clusterids[j];
        if ((clusterid == i1) && (order1 >= order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i2) && (order1 < order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i1) || (clusterid == i2)) {
          clusterids[j] = -i - 1;
        }
      }
    } else {
      var increase = (order1 <= order2) ? count1 : count2;
      var j;
      for (j = 0; j < nElements; j++) {
        var clusterid = clusterids[j];
        if ((clusterid == i1) && (order1 > order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i2) && (order1 <= order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i1) || (clusterid == i2)) {
          clusterids[j] = -i - 1;
        }
      }
    }
  }
  return morpheus.Util.indexSort(neworder, true);
};

/**
 * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.
 * @param <T> type of the points to cluster
 * @see <a href="http://en.wikipedia.org/wiki/K-means%2B%2B">K-means++ (wikipedia)</a>
 * @since 3.2
 */

/**
 * @param dataset The dataset to cluster the rows of
 * @param distance
 * @param k The number of clusters
 * @param maxIterations The maximum number of iterations
 * @constructor
 */
morpheus.KMeansPlusPlusClusterer = function (k, maxIterations, distanceFunction) {

  var distance = function (points1, points2) {
    return distanceFunction(points1.getPoint(), points2.getPoint());
  };

  function nextInt(upperBound) {
    return (Math.floor(Math.random() * upperBound)) | 0;
  }

  function nextDouble() {
    return Math.random();
  }

  function PointWrapper(point) {
    this.getPoint = function () {
      return point;
    };
  }

  function CentroidCluster(center) {
    var centroidPoints = [];
    this.addPoint = function (p) {
      centroidPoints.push(p);
    };
    this.getPoints = function () {
      return centroidPoints;
    };
    this.getCenter = function () {
      return center;
    };
  }

  /**
   * Runs the K-means++ clustering algorithm.
   *
   * @param points the points to cluster
   * @return a list of clusters containing the points
   */
  function cluster(points) {
    // number of clusters has to be smaller or equal the number of data points
    if (points.length < k) {
      throw 'Too many clusters';
    }

    // create the initial clusters
    var clusters = chooseInitialCenters(points);

    // create an array containing the latest assignment of a point to a cluster
    // no need to initialize the array, as it will be filled with the first assignment
    var assignments = new Int32Array(points.length);
    assignPointsToClusters(clusters, points, assignments);
    // iterate through updating the centers until we're done
    var max = (maxIterations < 0) ? Number.MAX_VALUE : maxIterations;
    for (var count = 0; count < max; count++) {
      var emptyCluster = false;
      var newClusters = [];
      for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
        var cluster = clusters[clusterIndex];
        var newCenter;
        if (cluster.getPoints().length === 0) {
          newCenter = getPointFromLargestVarianceCluster(clusters);
          emptyCluster = true;
        } else {
          newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().size());
        }
        newClusters.push(new CentroidCluster(newCenter));
      }
      var changes = assignPointsToClusters(newClusters, points, assignments);
      clusters = newClusters;

      // if there were no more changes in the point-to-cluster assignment
      // and there are no empty clusters left, return the current clusters
      if (changes === 0 && !emptyCluster) {
        return clusters;
      }
    }
    return clusters;
  }

  /**
   * Adds the given points to the closest {@link Cluster}.
   *
   * @param clusters the {@link Cluster}s to add the points to
   * @param points the points to add to the given {@link Cluster}s
   * @param assignments points assignments to clusters
   * @return the number of points assigned to different clusters as the iteration before
   */
  function assignPointsToClusters(clusters, points, assignments) {
    var assignedDifferently = 0;
    var pointIndex = 0;
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var clusterIndex = getNearestCluster(clusters, p);
      if (clusterIndex != assignments[pointIndex]) {
        assignedDifferently++;
      }

      var cluster = clusters[clusterIndex];
      cluster.addPoint(p);
      assignments[pointIndex++] = clusterIndex;
    }

    return assignedDifferently;
  }

  /**
   * Use K-means++ to choose the initial centers.
   *
   * @param points the points to choose the initial centers from
   * @return the initial centers
   */
  function chooseInitialCenters(points) {

    // Convert to list for indexed access. Make it unmodifiable, since removal of items
    // would screw up the logic of this method.
    var pointList = points;
    // The number of points in the list.
    var numPoints = pointList.length;

    // Set the corresponding element in this array to indicate when
    // elements of pointList are no longer available.
    var taken = new Array(numPoints);
    for (var i = 0; i < taken.length; i++) {
      taken[i] = false;
    }

    // The resulting list of initial centers.
    var resultSet = [];

    // Choose one center uniformly at random from among the data points.
    var firstPointIndex = nextInt(numPoints);
    var firstPoint = pointList[firstPointIndex];
    resultSet.push(new CentroidCluster(firstPoint));
    // Must mark it as taken
    taken[firstPointIndex] = true;

    // To keep track of the minimum distance squared of elements of
    // pointList to elements of resultSet.

    var minDistSquared = new Float32Array(numPoints);

    // Initialize the elements.  Since the only point in resultSet is firstPoint,
    // this is very easy.
    for (var i = 0; i < numPoints; i++) {
      if (i !== firstPointIndex) { // That point isn't considered
        var d = distance(firstPoint, pointList[i]);
        minDistSquared[i] = d * d;
      }
    }

    while (resultSet.length < k) {
      // Sum up the squared distances for the points in pointList not
      // already taken.
      var distSqSum = 0.0;

      for (var i = 0; i < numPoints; i++) {
        if (!taken[i]) {
          distSqSum += minDistSquared[i];
        }
      }

      // Add one new data point as a center. Each point x is chosen with
      // probability proportional to D(x)2
      var r = nextDouble() * distSqSum;

      // The index of the next point to be added to the resultSet.
      var nextPointIndex = -1;

      // Sum through the squared min distances again, stopping when
      // sum >= r.
      var sum = 0.0;
      for (var i = 0; i < numPoints; i++) {
        if (!taken[i]) {
          sum += minDistSquared[i];
          if (sum >= r) {
            nextPointIndex = i;
            break;
          }
        }
      }

      // If it's not set to >= 0, the point wasn't found in the previous
      // for loop, probably because distances are extremely small.  Just pick
      // the last available point.
      if (nextPointIndex === -1) {
        for (var i = numPoints - 1; i >= 0; i--) {
          if (!taken[i]) {
            nextPointIndex = i;
            break;
          }
        }
      }

      // We found one.
      if (nextPointIndex >= 0) {

        var p = pointList[nextPointIndex];

        resultSet.push(new CentroidCluster(p));

        // Mark it as taken.
        taken[nextPointIndex] = true;

        if (resultSet.length < k) {
          // Now update elements of minDistSquared.  We only have to compute
          // the distance to the new center to do this.
          for (var j = 0; j < numPoints; j++) {
            // Only have to worry about the points still not taken.
            if (!taken[j]) {
              var d = distance(p, pointList[j]);
              var d2 = d * d;
              if (d2 < minDistSquared[j]) {
                minDistSquared[j] = d2;
              }
            }
          }
        }

      } else {
        // None found --
        // Break from the while loop to prevent
        // an infinite loop.
        break;
      }
    }
    return resultSet;
  }

  /**
   * Get a random point from the {@link Cluster} with the largest distance variance.
   *
   * @param clusters the {@link Cluster}s to search
   * @return a random point from the selected cluster
   * @throws ConvergenceException if clusters are all empty
   */
  function getPointFromLargestVarianceCluster(clusters) {
    var maxVariance = -Number.MAX_VALUE;
    var selected = null;
    for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
      var cluster = clusters[clusterIndex];

      if (cluster.getPoints().length > 0) {

        // compute the distance variance of the current cluster
        var center = cluster.getCenter();
        var points = cluster.getPoints();
        var distances = new Float32Array(points.length);
        for (var i = 0; i < points.length; i++) {
          distances[i] = distance(points[i], center);
        }
        var variance = morpheus.Variance(morpheus.VectorUtil.arrayAsVector(distances));

        // select the cluster with the largest variance
        if (variance > maxVariance) {
          maxVariance = variance;
          selected = cluster;
        }
      }
    }

    // did we find at least one non-empty cluster ?
    if (selected == null) {
      throw 'All clusters are empty';
    }

    // extract a random point from the cluster
    var selectedPoints = selected.getPoints();
    return selectedPoints.splice(nextInt(selectedPoints.length), 1);

  }

  // /**
  //  * Get the point farthest to its cluster center
  //  *
  //  * @param clusters the {@link Cluster}s to search
  //  * @return point farthest to its cluster center
  //  * @throws ConvergenceException if clusters are all empty
  //  */
  // function getFarthestPoint(clusters) {
  //
  //   var maxDistance = Number.NEGATIVE_INFINITY;
  //   var selectedCluster = null;
  //   var selectedPoint = -1;
  //   for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
  //     var c = clusters[clusterIndex];
  //     // get the farthest point
  //     var center = cluster.getCenter();
  //     var points = cluster.getPoints();
  //     for (var i = 0; i < points.length; ++i) {
  //       var d = distance(points[i], center);
  //       if (d > maxDistance) {
  //         maxDistance = d;
  //         selectedCluster = cluster;
  //         selectedPoint = i;
  //       }
  //     }
  //
  //   }
  //
  //   // did we find at least one non-empty cluster ?
  //   if (selectedCluster == null) {
  //     throw 'Empty cluster';
  //   }
  //
  //   return selectedCluster.getPoints().splice(selectedPoint, 1);
  //
  // }

  /**
   * Returns the nearest {@link Cluster} to the given point
   *
   * @param clusters the {@link Cluster}s to search
   * @param point the point to find the nearest {@link Cluster} for
   * @return the index of the nearest {@link Cluster} to the given point
   */
  function getNearestCluster(clusters, point) {
    var minDistance = Number.MAX_VALUE;
    var clusterIndex = 0;
    var minCluster = 0;
    for (var i = 0; i < clusters.length; i++) {
      var c = clusters[i];
      var d = distance(point, c.getCenter());
      if (d < minDistance) {
        minDistance = d;
        minCluster = clusterIndex;
      }
      clusterIndex++;
    }
    return minCluster;
  }

  /**
   * Computes the centroid for a set of points.
   *
   * @param points the set of points
   * @param dimension the point dimension
   * @return the computed centroid for the set of points
   */
  function centroidOf(points, dimension) {
    var centroid = new Float32Array(dimension);
    for (var i = 0; i < centroid.length; i++) {
      var sum = 0;
      var count = 0;
      for (var pointIndex = 0; pointIndex < points.length; pointIndex++) {
        var p = points[pointIndex];
        var point = p.getPoint();
        var val = point.getValue(i);
        if (!isNaN(val)) {
          sum += val;
          count++;
        }
      }
      centroid[i] = (sum / count);
    }
    return new PointWrapper(morpheus.VectorUtil.arrayAsVector(centroid));
  }

  this.execute = function (vectors) {
    var points = [];
    // cluster rows
    var npoints = vectors.length;
    for (var i = 0; i < npoints; i++) {
      var p = new PointWrapper(vectors[i]);
      p.i = i;
      points.push(p);
    }
    return cluster(points);
  };
  this.cluster = cluster;
};

morpheus.PermutationPValues = function (dataset, aIndices, bIndices,
                                        numPermutations, f, continuousList) {
  var numRows = dataset.getRowCount();
  /** unpermuted scores */
  var scores = new Float32Array(numRows);
  /** Whether to smooth p values */
  var smoothPValues = true;
  var permuter;
  var permutationScore;
  if (aIndices != null) {
    var list1 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
      dataset, null, aIndices));
    var list2 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
      dataset, null, bIndices));
    dataset = new morpheus.SlicedDatasetView(dataset, null, aIndices
    .concat(bIndices));
    permuter = new morpheus.UnbalancedPermuter(aIndices.length,
      bIndices.length);
    permutationScore = new morpheus.TwoClassPermutationScore();
    permutationScore.init(dataset, f);
    for (var i = 0; i < numRows; i++) {
      scores[i] = f(list1.setIndex(i), list2.setIndex(i));
    }
  } else { // continuous
    permuter = new morpheus.UnbalancedContinuousPermuter(continuousList.size());
    permutationScore = new morpheus.ContinuousPermutationScore(continuousList);
    permutationScore.init(dataset, f);
    var list = new morpheus.DatasetRowView(dataset);
    for (var i = 0; i < numRows; i++) {
      scores[i] = f(continuousList, list.setIndex(i));
    }
  }

  var rowSpecificPValues = new Float32Array(numRows);

  for (var permutationIndex = 0; permutationIndex < numPermutations; permutationIndex++) {
    permutationScore.setPermutation(permuter.next());
    for (var i = 0; i < numRows; i++) {
      var permutedScore = permutationScore.getScore(i);
      var score = scores[i];
      if (permutedScore >= score) {
        rowSpecificPValues[i]++;
      }
    }
  }
  var N = numPermutations;
  var kArray = new Uint32Array(numRows);
  for (var i = 0; i < numRows; i++) {
    var k = rowSpecificPValues[i];
    kArray[i] = k;
    var p;
    if (smoothPValues) {
      p = (k + 1) / (N + 2);
    } else {
      p = k / N;

    }
    // 2-sided p-value
    var oneMinusP = 1 - p;
    if (oneMinusP < p) {
      p = oneMinusP;
    }
    p *= 2;
    if (p === 0) {
      // ensure not degenerate case where profile is
      // completely
      // flat
      // TODO handle cases where profile is flat (but not
      // completely)

      var val = dataset.getValue(i, 0);
      var flat = true;
      for (var j = 1, cols = dataset.getColumnCount(); j < cols && flat; j++) {
        if (dataset.getValue(i, j) != val) {
          flat = false;
        }
      }
      if (flat) {
        p = 1;
      }
    }
    rowSpecificPValues[i] = p;

  }
  this.rowSpecificPValues = rowSpecificPValues;
  this.k = kArray;
  this.fdr = morpheus.FDR_BH(rowSpecificPValues);
  this.scores = scores;
};
morpheus.PermutationPValues.prototype = {
  getBonferroni: function (index) {
    return Math.min(this.rowSpecificPValues[index] * this.numRows, 1);
  }
};

morpheus.UnbalancedContinuousPermuter = function (size) {
  var indices = new Uint32Array(size);
  for (var i = 0; i < indices.length; i++) {
    indices[i] = i;
  }
  var n = indices.length;
  // Returns a random integer between min (included) and max (included)
  // Using Math.round() will give you a non-uniform distribution!
  function getRandomIntInclusive(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  this.next = function () {
    // shuffle indices array
    for (var i = n - 1; i >= 1; i--) {
      var j = getRandomIntInclusive(0, i); // random integer such that
      // 0  j  i
      // exchange a[j] and a[i]
      var tmp = indices[j];
      indices[j] = indices[i];
      indices[i] = tmp;
    }

    return indices;
  };
};

morpheus.UnbalancedPermuter = function (numClassZero, numClassOne) {
  var assignments = new Uint32Array(numClassZero + numClassOne);
  var indices = new Uint32Array(numClassZero + numClassOne);
  for (var i = 0; i < indices.length; i++) {
    indices[i] = i;
  }
  var n = indices.length;
  // Returns a random integer between min (included) and max (included)
  // Using Math.round() will give you a non-uniform distribution!
  function getRandomIntInclusive(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  this.next = function () {
    // shuffle indices array
    for (var i = n - 1; i >= 1; i--) {
      var j = getRandomIntInclusive(0, i); // random integer such that
      // 0  j  i
      // exchange a[j] and a[i]
      var tmp = indices[j];
      indices[j] = indices[i];
      indices[i] = tmp;
    }

    // pick 1st numClassOne indices to be class one
    for (var i = 0; i < n; i++) {
      assignments[i] = 0;
    }
    for (var i = 0; i < numClassOne; i++) {
      assignments[indices[i]] = 1;
    }

    return assignments;
  };
};

morpheus.TwoClassPermutationScore = function () {
  this.classZeroView = null;
  this.classOneView = null;

};
morpheus.TwoClassPermutationScore.prototype = {
  getScore: function (index) {
    this.classZeroView.setIndex(index);
    this.classOneView.setIndex(index);
    return this.f(this.classZeroView, this.classOneView);
  },
  init: function (dataset, f) {
    this.dataset = dataset;
    this.classZeroView = new morpheus.DatasetRowView(dataset);
    this.classOneView = new morpheus.DatasetRowView(dataset);
    this.f = f;
  },
  setPermutation: function (permutedAssignments) {
    var zeroIndices = [];
    var oneIndices = [];
    for (var i = 0, length = permutedAssignments.length; i < length; i++) {
      if (permutedAssignments[i] === 0) {
        zeroIndices.push(i);
      } else {
        oneIndices.push(i);
      }
    }

    this.classZeroView.setDataset(new morpheus.SlicedDatasetView(
      this.dataset, null, zeroIndices));
    this.classOneView.setDataset(new morpheus.SlicedDatasetView(
      this.dataset, null, oneIndices));

  }

};

morpheus.ContinuousPermutationScore = function (referenceList) {
  this.referenceList = referenceList;
};
morpheus.ContinuousPermutationScore.prototype = {
  getScore: function (index) {
    this.datasetRowView.setIndex(index);
    return this.f(this.referenceListView, this.datasetRowView);
  },
  init: function (dataset, f) {
    this.dataset = dataset;
    this.referenceListView = null;
    this.datasetRowView = new morpheus.DatasetRowView(dataset);
    this.f = f;
  },
  setPermutation: function (indices) {
    this.referenceListView = new morpheus.SlicedVector(this.referenceList, indices);
  }

};

morpheus.Ranking = function (values) {
  var ranks = [];
  for (var i = 0, length = values.length; i < length; i++) {
    ranks.push({
      value: values[i],
      position: i
    });
  }
  if (ranks.length === 0) {
    return [];
  }
  ranks.sort(function (a, b) {
    return (a.value < b.value ? -1 : (a.value === b.value ? 0 : 1));
  });

  var out = [];
  var pos = 1; // position in sorted array
  out[ranks[0].position] = pos;
  var tiesTrace = [];
  tiesTrace.push(ranks[0].position);
  for (var i = 1; i < ranks.length; i++) {
    if (ranks[i].value > ranks[i - 1].value) {
      // tie sequence has ended (or had length 1)
      pos = i + 1;
      if (tiesTrace.length > 1) { // if seq is nontrivial, resolve
        morpheus.Ranking.fillAverage(out, tiesTrace);
      }
      tiesTrace = [];
      tiesTrace.push(ranks[i].position);
    } else {
      // tie sequence continues
      tiesTrace.push(ranks[i].position);
    }
    out[ranks[i].position] = pos;
  }
  if (tiesTrace.length > 1) { // handle tie sequence at end
    morpheus.Ranking.fillAverage(out, tiesTrace);
  }
  return out;
};
morpheus.Ranking.fill = function (data, tiesTrace, value) {
  for (var i = 0, length = tiesTrace.length; i < length; i++) {
    data[tiesTrace[i]] = value;
  }
};
morpheus.Ranking.fillAverage = function (ranks, tiesTrace) {
  var c = ranks[tiesTrace[0]];
  // length of sequence of tied ranks
  var length = tiesTrace.length;
  morpheus.Ranking.fill(ranks, tiesTrace, (2 * c + length - 1) / 2);
};

morpheus.SingleLinkage = function (nelements, distmatrix) {
  var i, j, k;
  var nnodes = nelements - 1;
  var temp = []; // var[nnodes];
  var index = []; // new var[nelements];
  var vector = []; // var[nnodes];
  var result = []; // new Node[nelements];
  for (i = 0; i < nelements; i++) {
    result[i] = {
      left: 0,
      right: 0,
      distance: 0
    };
  }
  for (i = 0; i < nnodes; i++) {
    vector[i] = i;
  }
  for (i = 0; i < nelements; i++) {
    result[i].distance = Number.MAX_VALUE;
    for (j = 0; j < i; j++) {
      temp[j] = distmatrix[i][j];
    }
    for (j = 0; j < i; j++) {
      k = vector[j];
      if (result[j].distance >= temp[j]) {
        if (result[j].distance < temp[k]) {
          temp[k] = result[j].distance;
        }
        result[j].distance = temp[j];
        vector[j] = i;
      } else if (temp[j] < temp[k]) {
        temp[k] = temp[j];
      }
    }
    for (j = 0; j < i; j++) {
      if (result[j].distance >= result[vector[j]].distance) {
        vector[j] = i;
      }
    }
  }
  for (i = 0; i < nnodes; i++) {
    result[i].left = i;
  }
  result.sort(function (node1, node2) {
    var term1 = node1.distance;
    var term2 = node2.distance;
    if (term1 < term2)
      return -1;
    if (term1 > term2)
      return +1;
    return 0;
  });
  for (i = 0; i < nelements; i++) {
    index[i] = i;
  }
  for (i = 0; i < nnodes; i++) {
    j = result[i].left;
    k = vector[j];
    result[i].left = index[j];
    result[i].right = index[k];
    index[k] = -i - 1;
  }
  var result2 = []; // new Node[nelements - 1];
  for (i = 0; i < nelements - 1; i++) {
    result2[i] = result[i];
  }
  return result2;
};

})(typeof window !== 'undefined' ? window : this);

/*!
 * JavaScript Cookie v2.1.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	if (typeof define === 'function' && define.amd) {
		define(factory);
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function init (converter) {
		function api (key, value, attributes) {
			var result;
			if (typeof document === 'undefined') {
				return;
			}

			// Write

			if (arguments.length > 1) {
				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					var expires = new Date();
					expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
					attributes.expires = expires;
				}

				try {
					result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				if (!converter.write) {
					value = encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
				} else {
					value = converter.write(value, key);
				}

				key = encodeURIComponent(String(key));
				key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
				key = key.replace(/[\(\)]/g, escape);

				return (document.cookie = [
					key, '=', value,
					attributes.expires && '; expires=' + attributes.expires.toUTCString(), // use expires attribute, max-age is not supported by IE
					attributes.path    && '; path=' + attributes.path,
					attributes.domain  && '; domain=' + attributes.domain,
					attributes.secure ? '; secure' : ''
				].join(''));
			}

			// Read

			if (!key) {
				result = {};
			}

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling "get()"
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var rdecode = /(%[0-9A-Z]{2})+/g;
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var name = parts[0].replace(rdecode, decodeURIComponent);
				var cookie = parts.slice(1).join('=');

				if (cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					cookie = converter.read ?
						converter.read(cookie, name) : converter(cookie, name) ||
						cookie.replace(rdecode, decodeURIComponent);

					if (this.json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					if (key === name) {
						result = cookie;
						break;
					}

					if (!key) {
						result[name] = cookie;
					}
				} catch (e) {}
			}

			return result;
		}

		api.set = api;
		api.get = function (key) {
			return api(key);
		};
		api.getJSON = function () {
			return api.apply({
				json: true
			}, [].slice.call(arguments));
		};
		api.defaults = {};

		api.remove = function (key, attributes) {
			api(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));

/*!
 * typeahead.js 0.9.3
 * https://github.com/twitter/typeahead
 * Copyright 2013 Twitter, Inc. and other contributors; Licensed MIT
 */

!function(a){var b="0.9.3",c={isMsie:function(){var a=/(msie) ([\w.]+)/i.exec(navigator.userAgent);return a?parseInt(a[2],10):!1},isBlankString:function(a){return!a||/^\s*$/.test(a)},escapeRegExChars:function(a){return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},isString:function(a){return"string"==typeof a},isNumber:function(a){return"number"==typeof a},isArray:a.isArray,isFunction:a.isFunction,isObject:a.isPlainObject,isUndefined:function(a){return"undefined"==typeof a},bind:a.proxy,bindAll:function(b){var c;for(var d in b)a.isFunction(c=b[d])&&(b[d]=a.proxy(c,b))},indexOf:function(a,b){for(var c=0;c<a.length;c++)if(a[c]===b)return c;return-1},each:a.each,map:a.map,filter:a.grep,every:function(b,c){var d=!0;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?void 0:!1}),!!d):d},some:function(b,c){var d=!1;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?!1:void 0}),!!d):d},mixin:a.extend,getUniqueId:function(){var a=0;return function(){return a++}}(),defer:function(a){setTimeout(a,0)},debounce:function(a,b,c){var d,e;return function(){var f,g,h=this,i=arguments;return f=function(){d=null,c||(e=a.apply(h,i))},g=c&&!d,clearTimeout(d),d=setTimeout(f,b),g&&(e=a.apply(h,i)),e}},throttle:function(a,b){var c,d,e,f,g,h;return g=0,h=function(){g=new Date,e=null,f=a.apply(c,d)},function(){var i=new Date,j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(e),e=null,g=i,f=a.apply(c,d)):e||(e=setTimeout(h,j)),f}},tokenizeQuery:function(b){return a.trim(b).toLowerCase().split(/[\s]+/)},tokenizeText:function(b){return a.trim(b).toLowerCase().split(/[\s\-_]+/)},getProtocol:function(){return location.protocol},noop:function(){}},d=function(){var a=/\s+/;return{on:function(b,c){var d;if(!c)return this;for(this._callbacks=this._callbacks||{},b=b.split(a);d=b.shift();)this._callbacks[d]=this._callbacks[d]||[],this._callbacks[d].push(c);return this},trigger:function(b,c){var d,e;if(!this._callbacks)return this;for(b=b.split(a);d=b.shift();)if(e=this._callbacks[d])for(var f=0;f<e.length;f+=1)e[f].call(this,{type:d,data:c});return this}}}(),e=function(){function b(b){b&&b.el||a.error("EventBus initialized without el"),this.$el=a(b.el)}var d="typeahead:";return c.mixin(b.prototype,{trigger:function(a){var b=[].slice.call(arguments,1);this.$el.trigger(d+a,b)}}),b}(),f=function(){function a(a){this.prefix=["__",a,"__"].join(""),this.ttlKey="__ttl__",this.keyMatcher=new RegExp("^"+this.prefix)}function b(){return(new Date).getTime()}function d(a){return JSON.stringify(c.isUndefined(a)?null:a)}function e(a){return JSON.parse(a)}var f,g;try{f=window.localStorage,f.setItem("~~~","!"),f.removeItem("~~~")}catch(h){f=null}return g=f&&window.JSON?{_prefix:function(a){return this.prefix+a},_ttlKey:function(a){return this._prefix(a)+this.ttlKey},get:function(a){return this.isExpired(a)&&this.remove(a),e(f.getItem(this._prefix(a)))},set:function(a,e,g){return c.isNumber(g)?f.setItem(this._ttlKey(a),d(b()+g)):f.removeItem(this._ttlKey(a)),f.setItem(this._prefix(a),d(e))},remove:function(a){return f.removeItem(this._ttlKey(a)),f.removeItem(this._prefix(a)),this},clear:function(){var a,b,c=[],d=f.length;for(a=0;d>a;a++)(b=f.key(a)).match(this.keyMatcher)&&c.push(b.replace(this.keyMatcher,""));for(a=c.length;a--;)this.remove(c[a]);return this},isExpired:function(a){var d=e(f.getItem(this._ttlKey(a)));return c.isNumber(d)&&b()>d?!0:!1}}:{get:c.noop,set:c.noop,remove:c.noop,clear:c.noop,isExpired:c.noop},c.mixin(a.prototype,g),a}(),g=function(){function a(a){c.bindAll(this),a=a||{},this.sizeLimit=a.sizeLimit||10,this.cache={},this.cachedKeysByAge=[]}return c.mixin(a.prototype,{get:function(a){return this.cache[a]},set:function(a,b){var c;this.cachedKeysByAge.length===this.sizeLimit&&(c=this.cachedKeysByAge.shift(),delete this.cache[c]),this.cache[a]=b,this.cachedKeysByAge.push(a)}}),a}(),h=function(){function b(a){c.bindAll(this),a=c.isString(a)?{url:a}:a,i=i||new g,h=c.isNumber(a.maxParallelRequests)?a.maxParallelRequests:h||6,this.url=a.url,this.wildcard=a.wildcard||"%QUERY",this.filter=a.filter,this.replace=a.replace,this.ajaxSettings={type:"get",cache:a.cache,timeout:a.timeout,dataType:a.dataType||"json",beforeSend:a.beforeSend},this._get=(/^throttle$/i.test(a.rateLimitFn)?c.throttle:c.debounce)(this._get,a.rateLimitWait||300)}function d(){j++}function e(){j--}function f(){return h>j}var h,i,j=0,k={};return c.mixin(b.prototype,{_get:function(a,b){function c(c){var e=d.filter?d.filter(c):c;b&&b(e),i.set(a,c)}var d=this;f()?this._sendRequest(a).done(c):this.onDeckRequestArgs=[].slice.call(arguments,0)},_sendRequest:function(b){function c(){e(),k[b]=null,f.onDeckRequestArgs&&(f._get.apply(f,f.onDeckRequestArgs),f.onDeckRequestArgs=null)}var f=this,g=k[b];return g||(d(),g=k[b]=a.ajax(b,this.ajaxSettings).always(c)),g},get:function(a,b){var d,e,f=this,g=encodeURIComponent(a||"");return b=b||c.noop,d=this.replace?this.replace(this.url,g):this.url.replace(this.wildcard,g),(e=i.get(d))?c.defer(function(){b(f.filter?f.filter(e):e)}):this._get(d,b),!!e}}),b}(),i=function(){function d(b){c.bindAll(this),c.isString(b.template)&&!b.engine&&a.error("no template engine specified"),b.local||b.prefetch||b.remote||a.error("one of local, prefetch, or remote is required"),this.name=b.name||c.getUniqueId(),this.limit=b.limit||5,this.minLength=b.minLength||1,this.header=b.header,this.footer=b.footer,this.valueKey=b.valueKey||"value",this.template=e(b.template,b.engine,this.valueKey),this.local=b.local,this.prefetch=b.prefetch,this.remote=b.remote,this.itemHash={},this.adjacencyList={},this.storage=b.name?new f(b.name):null}function e(a,b,d){var e,f;return c.isFunction(a)?e=a:c.isString(a)?(f=b.compile(a),e=c.bind(f.render,f)):e=function(a){return"<p>"+a[d]+"</p>"},e}var g={thumbprint:"thumbprint",protocol:"protocol",itemHash:"itemHash",adjacencyList:"adjacencyList"};return c.mixin(d.prototype,{_processLocalData:function(a){this._mergeProcessedData(this._processData(a))},_loadPrefetchData:function(d){function e(a){var b=d.filter?d.filter(a):a,e=m._processData(b),f=e.itemHash,h=e.adjacencyList;m.storage&&(m.storage.set(g.itemHash,f,d.ttl),m.storage.set(g.adjacencyList,h,d.ttl),m.storage.set(g.thumbprint,n,d.ttl),m.storage.set(g.protocol,c.getProtocol(),d.ttl)),m._mergeProcessedData(e)}var f,h,i,j,k,l,m=this,n=b+(d.thumbprint||"");return this.storage&&(f=this.storage.get(g.thumbprint),h=this.storage.get(g.protocol),i=this.storage.get(g.itemHash),j=this.storage.get(g.adjacencyList)),k=f!==n||h!==c.getProtocol(),d=c.isString(d)?{url:d}:d,d.ttl=c.isNumber(d.ttl)?d.ttl:864e5,i&&j&&!k?(this._mergeProcessedData({itemHash:i,adjacencyList:j}),l=a.Deferred().resolve()):l=a.getJSON(d.url).done(e),l},_transformDatum:function(a){var b=c.isString(a)?a:a[this.valueKey],d=a.tokens||c.tokenizeText(b),e={value:b,tokens:d};return c.isString(a)?(e.datum={},e.datum[this.valueKey]=a):e.datum=a,e.tokens=c.filter(e.tokens,function(a){return!c.isBlankString(a)}),e.tokens=c.map(e.tokens,function(a){return a.toLowerCase()}),e},_processData:function(a){var b=this,d={},e={};return c.each(a,function(a,f){var g=b._transformDatum(f),h=c.getUniqueId(g.value);d[h]=g,c.each(g.tokens,function(a,b){var d=b.charAt(0),f=e[d]||(e[d]=[h]);!~c.indexOf(f,h)&&f.push(h)})}),{itemHash:d,adjacencyList:e}},_mergeProcessedData:function(a){var b=this;c.mixin(this.itemHash,a.itemHash),c.each(a.adjacencyList,function(a,c){var d=b.adjacencyList[a];b.adjacencyList[a]=d?d.concat(c):c})},_getLocalSuggestions:function(a){var b,d=this,e=[],f=[],g=[];return c.each(a,function(a,b){var d=b.charAt(0);!~c.indexOf(e,d)&&e.push(d)}),c.each(e,function(a,c){var e=d.adjacencyList[c];return e?(f.push(e),(!b||e.length<b.length)&&(b=e),void 0):!1}),f.length<e.length?[]:(c.each(b,function(b,e){var h,i,j=d.itemHash[e];h=c.every(f,function(a){return~c.indexOf(a,e)}),i=h&&c.every(a,function(a){return c.some(j.tokens,function(b){return 0===b.indexOf(a)})}),i&&g.push(j)}),g)},initialize:function(){var b;return this.local&&this._processLocalData(this.local),this.transport=this.remote?new h(this.remote):null,b=this.prefetch?this._loadPrefetchData(this.prefetch):a.Deferred().resolve(),this.local=this.prefetch=this.remote=null,this.initialize=function(){return b},b},getSuggestions:function(a,b){function d(a){f=f.slice(0),c.each(a,function(a,b){var d,e=g._transformDatum(b);return d=c.some(f,function(a){return e.value===a.value}),!d&&f.push(e),f.length<g.limit}),b&&b(f)}var e,f,g=this,h=!1;a.length<this.minLength||(e=c.tokenizeQuery(a),f=this._getLocalSuggestions(e).slice(0,this.limit),f.length<this.limit&&this.transport&&(h=this.transport.get(a,d)),!h&&b&&b(f))}}),d}(),j=function(){function b(b){var d=this;c.bindAll(this),this.specialKeyCodeMap={9:"tab",27:"esc",37:"left",39:"right",13:"enter",38:"up",40:"down"},this.$hint=a(b.hint),this.$input=a(b.input).on("blur.tt",this._handleBlur).on("focus.tt",this._handleFocus).on("keydown.tt",this._handleSpecialKeyEvent),c.isMsie()?this.$input.on("keydown.tt keypress.tt cut.tt paste.tt",function(a){d.specialKeyCodeMap[a.which||a.keyCode]||c.defer(d._compareQueryToInputValue)}):this.$input.on("input.tt",this._compareQueryToInputValue),this.query=this.$input.val(),this.$overflowHelper=e(this.$input)}function e(b){return a("<span></span>").css({position:"absolute",left:"-9999px",visibility:"hidden",whiteSpace:"nowrap",fontFamily:b.css("font-family"),fontSize:b.css("font-size"),fontStyle:b.css("font-style"),fontVariant:b.css("font-variant"),fontWeight:b.css("font-weight"),wordSpacing:b.css("word-spacing"),letterSpacing:b.css("letter-spacing"),textIndent:b.css("text-indent"),textRendering:b.css("text-rendering"),textTransform:b.css("text-transform")}).insertAfter(b)}function f(a,b){return a=(a||"").replace(/^\s*/g,"").replace(/\s{2,}/g," "),b=(b||"").replace(/^\s*/g,"").replace(/\s{2,}/g," "),a===b}return c.mixin(b.prototype,d,{_handleFocus:function(){this.trigger("focused")},_handleBlur:function(){this.trigger("blured")},_handleSpecialKeyEvent:function(a){var b=this.specialKeyCodeMap[a.which||a.keyCode];b&&this.trigger(b+"Keyed",a)},_compareQueryToInputValue:function(){var a=this.getInputValue(),b=f(this.query,a),c=b?this.query.length!==a.length:!1;c?this.trigger("whitespaceChanged",{value:this.query}):b||this.trigger("queryChanged",{value:this.query=a})},destroy:function(){this.$hint.off(".tt"),this.$input.off(".tt"),this.$hint=this.$input=this.$overflowHelper=null},focus:function(){this.$input.focus()},blur:function(){this.$input.blur()},getQuery:function(){return this.query},setQuery:function(a){this.query=a},getInputValue:function(){return this.$input.val()},setInputValue:function(a,b){this.$input.val(a),!b&&this._compareQueryToInputValue()},getHintValue:function(){return this.$hint.val()},setHintValue:function(a){this.$hint.val(a)},getLanguageDirection:function(){return(this.$input.css("direction")||"ltr").toLowerCase()},isOverflow:function(){return this.$overflowHelper.text(this.getInputValue()),this.$overflowHelper.width()>this.$input.width()},isCursorAtEnd:function(){var a,b=this.$input.val().length,d=this.$input[0].selectionStart;return c.isNumber(d)?d===b:document.selection?(a=document.selection.createRange(),a.moveStart("character",-b),b===a.text.length):!0}}),b}(),k=function(){function b(b){c.bindAll(this),this.isOpen=!1,this.isEmpty=!0,this.isMouseOverDropdown=!1,this.$menu=a(b.menu).on("mouseenter.tt",this._handleMouseenter).on("mouseleave.tt",this._handleMouseleave).on("click.tt",".tt-suggestion",this._handleSelection).on("mouseover.tt",".tt-suggestion",this._handleMouseover)}function e(a){return a.data("suggestion")}var f={suggestionsList:'<span class="tt-suggestions"></span>'},g={suggestionsList:{display:"block"},suggestion:{whiteSpace:"nowrap",cursor:"pointer"},suggestionChild:{whiteSpace:"normal"}};return c.mixin(b.prototype,d,{_handleMouseenter:function(){this.isMouseOverDropdown=!0},_handleMouseleave:function(){this.isMouseOverDropdown=!1},_handleMouseover:function(b){var c=a(b.currentTarget);this._getSuggestions().removeClass("tt-is-under-cursor"),c.addClass("tt-is-under-cursor")},_handleSelection:function(b){var c=a(b.currentTarget);this.trigger("suggestionSelected",e(c))},_show:function(){this.$menu.css("display","block")},_hide:function(){this.$menu.hide()},_moveCursor:function(a){var b,c,d,f;if(this.isVisible()){if(b=this._getSuggestions(),c=b.filter(".tt-is-under-cursor"),c.removeClass("tt-is-under-cursor"),d=b.index(c)+a,d=(d+1)%(b.length+1)-1,-1===d)return this.trigger("cursorRemoved"),void 0;-1>d&&(d=b.length-1),f=b.eq(d).addClass("tt-is-under-cursor"),this._ensureVisibility(f),this.trigger("cursorMoved",e(f))}},_getSuggestions:function(){return this.$menu.find(".tt-suggestions > .tt-suggestion")},_ensureVisibility:function(a){var b=this.$menu.height()+parseInt(this.$menu.css("paddingTop"),10)+parseInt(this.$menu.css("paddingBottom"),10),c=this.$menu.scrollTop(),d=a.position().top,e=d+a.outerHeight(!0);0>d?this.$menu.scrollTop(c+d):e>b&&this.$menu.scrollTop(c+(e-b))},destroy:function(){this.$menu.off(".tt"),this.$menu=null},isVisible:function(){return this.isOpen&&!this.isEmpty},closeUnlessMouseIsOverDropdown:function(){this.isMouseOverDropdown||this.close()},close:function(){this.isOpen&&(this.isOpen=!1,this.isMouseOverDropdown=!1,this._hide(),this.$menu.find(".tt-suggestions > .tt-suggestion").removeClass("tt-is-under-cursor"),this.trigger("closed"))},open:function(){this.isOpen||(this.isOpen=!0,!this.isEmpty&&this._show(),this.trigger("opened"))},setLanguageDirection:function(a){var b={left:"0",right:"auto"},c={left:"auto",right:" 0"};"ltr"===a?this.$menu.css(b):this.$menu.css(c)},moveCursorUp:function(){this._moveCursor(-1)},moveCursorDown:function(){this._moveCursor(1)},getSuggestionUnderCursor:function(){var a=this._getSuggestions().filter(".tt-is-under-cursor").first();return a.length>0?e(a):null},getFirstSuggestion:function(){var a=this._getSuggestions().first();return a.length>0?e(a):null},renderSuggestions:function(b,d){var e,h,i,j,k,l="tt-dataset-"+b.name,m='<div class="tt-suggestion">%body</div>',n=this.$menu.find("."+l);0===n.length&&(h=a(f.suggestionsList).css(g.suggestionsList),n=a("<div></div>").addClass(l).append(b.header).append(h).append(b.footer).appendTo(this.$menu)),d.length>0?(this.isEmpty=!1,this.isOpen&&this._show(),i=document.createElement("div"),j=document.createDocumentFragment(),c.each(d,function(c,d){d.dataset=b.name,e=b.template(d.datum),i.innerHTML=m.replace("%body",e),k=a(i.firstChild).css(g.suggestion).data("suggestion",d),k.children().each(function(){a(this).css(g.suggestionChild)}),j.appendChild(k[0])}),n.show().find(".tt-suggestions").html(j)):this.clearSuggestions(b.name),this.trigger("suggestionsRendered")},clearSuggestions:function(a){var b=a?this.$menu.find(".tt-dataset-"+a):this.$menu.find('[class^="tt-dataset-"]'),c=b.find(".tt-suggestions");b.hide(),c.empty(),0===this._getSuggestions().length&&(this.isEmpty=!0,this._hide())}}),b}(),l=function(){function b(a){var b,d,f;c.bindAll(this),this.$node=e(a.input),this.datasets=a.datasets,this.dir=null,this.eventBus=a.eventBus,b=this.$node.find(".tt-dropdown-menu"),d=this.$node.find(".tt-query"),f=this.$node.find(".tt-hint"),this.dropdownView=new k({menu:b}).on("suggestionSelected",this._handleSelection).on("cursorMoved",this._clearHint).on("cursorMoved",this._setInputValueToSuggestionUnderCursor).on("cursorRemoved",this._setInputValueToQuery).on("cursorRemoved",this._updateHint).on("suggestionsRendered",this._updateHint).on("opened",this._updateHint).on("closed",this._clearHint).on("opened closed",this._propagateEvent),this.inputView=new j({input:d,hint:f}).on("focused",this._openDropdown).on("blured",this._closeDropdown).on("blured",this._setInputValueToQuery).on("enterKeyed tabKeyed",this._handleSelection).on("queryChanged",this._clearHint).on("queryChanged",this._clearSuggestions).on("queryChanged",this._getSuggestions).on("whitespaceChanged",this._updateHint).on("queryChanged whitespaceChanged",this._openDropdown).on("queryChanged whitespaceChanged",this._setLanguageDirection).on("escKeyed",this._closeDropdown).on("escKeyed",this._setInputValueToQuery).on("tabKeyed upKeyed downKeyed",this._managePreventDefault).on("upKeyed downKeyed",this._moveDropdownCursor).on("upKeyed downKeyed",this._openDropdown).on("tabKeyed leftKeyed rightKeyed",this._autocomplete)}function e(b){var c=a(g.wrapper),d=a(g.dropdown),e=a(b),f=a(g.hint);c=c.css(h.wrapper),d=d.css(h.dropdown),f.css(h.hint).css({backgroundAttachment:e.css("background-attachment"),backgroundClip:e.css("background-clip"),backgroundColor:e.css("background-color"),backgroundImage:e.css("background-image"),backgroundOrigin:e.css("background-origin"),backgroundPosition:e.css("background-position"),backgroundRepeat:e.css("background-repeat"),backgroundSize:e.css("background-size")}),e.data("ttAttrs",{dir:e.attr("dir"),autocomplete:e.attr("autocomplete"),spellcheck:e.attr("spellcheck"),style:e.attr("style")}),e.addClass("tt-query").attr({autocomplete:"off",spellcheck:!1}).css(h.query);try{!e.attr("dir")&&e.attr("dir","auto")}catch(i){}return e.wrap(c).parent().prepend(f).append(d)}function f(a){var b=a.find(".tt-query");c.each(b.data("ttAttrs"),function(a,d){c.isUndefined(d)?b.removeAttr(a):b.attr(a,d)}),b.detach().removeData("ttAttrs").removeClass("tt-query").insertAfter(a),a.remove()}var g={wrapper:'<span class="twitter-typeahead"></span>',hint:'<input class="tt-hint" type="text" autocomplete="off" spellcheck="off" disabled>',dropdown:'<span class="tt-dropdown-menu"></span>'},h={wrapper:{position:"relative",display:"inline-block"},hint:{position:"absolute",top:"0",left:"0",borderColor:"transparent",boxShadow:"none"},query:{position:"relative",verticalAlign:"top",backgroundColor:"transparent"},dropdown:{position:"absolute",top:"100%",left:"0",zIndex:"100",display:"none"}};return c.isMsie()&&c.mixin(h.query,{backgroundImage:"url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"}),c.isMsie()&&c.isMsie()<=7&&(c.mixin(h.wrapper,{display:"inline",zoom:"1"}),c.mixin(h.query,{marginTop:"-1px"})),c.mixin(b.prototype,d,{_managePreventDefault:function(a){var b,c,d=a.data,e=!1;switch(a.type){case"tabKeyed":b=this.inputView.getHintValue(),c=this.inputView.getInputValue(),e=b&&b!==c;break;case"upKeyed":case"downKeyed":e=!d.shiftKey&&!d.ctrlKey&&!d.metaKey}e&&d.preventDefault()},_setLanguageDirection:function(){var a=this.inputView.getLanguageDirection();a!==this.dir&&(this.dir=a,this.$node.css("direction",a),this.dropdownView.setLanguageDirection(a))},_updateHint:function(){var a,b,d,e,f,g=this.dropdownView.getFirstSuggestion(),h=g?g.value:null,i=this.dropdownView.isVisible(),j=this.inputView.isOverflow();h&&i&&!j&&(a=this.inputView.getInputValue(),b=a.replace(/\s{2,}/g," ").replace(/^\s+/g,""),d=c.escapeRegExChars(b),e=new RegExp("^(?:"+d+")(.*$)","i"),f=e.exec(h),this.inputView.setHintValue(a+(f?f[1]:"")))},_clearHint:function(){this.inputView.setHintValue("")},_clearSuggestions:function(){this.dropdownView.clearSuggestions()},_setInputValueToQuery:function(){this.inputView.setInputValue(this.inputView.getQuery())},_setInputValueToSuggestionUnderCursor:function(a){var b=a.data;this.inputView.setInputValue(b.value,!0)},_openDropdown:function(){this.dropdownView.open()},_closeDropdown:function(a){this.dropdownView["blured"===a.type?"closeUnlessMouseIsOverDropdown":"close"]()},_moveDropdownCursor:function(a){var b=a.data;b.shiftKey||b.ctrlKey||b.metaKey||this.dropdownView["upKeyed"===a.type?"moveCursorUp":"moveCursorDown"]()},_handleSelection:function(a){var b="suggestionSelected"===a.type,d=b?a.data:this.dropdownView.getSuggestionUnderCursor();d&&(this.inputView.setInputValue(d.value),b?this.inputView.focus():a.data.preventDefault(),b&&c.isMsie()?c.defer(this.dropdownView.close):this.dropdownView.close(),this.eventBus.trigger("selected",d.datum,d.dataset))},_getSuggestions:function(){var a=this,b=this.inputView.getQuery();c.isBlankString(b)||c.each(this.datasets,function(c,d){d.getSuggestions(b,function(c){b===a.inputView.getQuery()&&a.dropdownView.renderSuggestions(d,c)})})},_autocomplete:function(a){var b,c,d,e,f;("rightKeyed"!==a.type&&"leftKeyed"!==a.type||(b=this.inputView.isCursorAtEnd(),c="ltr"===this.inputView.getLanguageDirection()?"leftKeyed"===a.type:"rightKeyed"===a.type,b&&!c))&&(d=this.inputView.getQuery(),e=this.inputView.getHintValue(),""!==e&&d!==e&&(f=this.dropdownView.getFirstSuggestion(),this.inputView.setInputValue(f.value),this.eventBus.trigger("autocompleted",f.datum,f.dataset)))},_propagateEvent:function(a){this.eventBus.trigger(a.type)},destroy:function(){this.inputView.destroy(),this.dropdownView.destroy(),f(this.$node),this.$node=null},setQuery:function(a){this.inputView.setQuery(a),this.inputView.setInputValue(a),this._clearHint(),this._clearSuggestions(),this._getSuggestions()}}),b}();!function(){var b,d={},f="ttView";b={initialize:function(b){function g(){var b,d=a(this),g=new e({el:d});b=c.map(h,function(a){return a.initialize()}),d.data(f,new l({input:d,eventBus:g=new e({el:d}),datasets:h})),a.when.apply(a,b).always(function(){c.defer(function(){g.trigger("initialized")})})}var h;return b=c.isArray(b)?b:[b],0===b.length&&a.error("no datasets provided"),h=c.map(b,function(a){var b=d[a.name]?d[a.name]:new i(a);return a.name&&(d[a.name]=b),b}),this.each(g)},destroy:function(){function b(){var b=a(this),c=b.data(f);c&&(c.destroy(),b.removeData(f))}return this.each(b)},setQuery:function(b){function c(){var c=a(this).data(f);c&&c.setQuery(b)}return this.each(c)}},jQuery.fn.typeahead=function(a){return b[a]?b[a].apply(this,[].slice.call(arguments,1)):b.initialize.apply(this,arguments)}}()}(window.jQuery);
if (typeof clue === 'undefined') {
    clue = {};
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = clue; // Node
}
clue.USER_KEY = null;

clue.CORE_CELL_LINES = [
    'A375', 'A549', 'HA1E', 'HCC515', 'HEPG2', 'HT29',
    'MCF7', 'PC3', 'VCAP'];

clue.CORE_CELL_LINES_CCLE = ['A375_SKIN', 'A549_LUNG', 'HA1E_KIDNEY', 'HCC515_LUNG', 'HEPG2_LIVER', 'HT29_LARGE_INTESTINE', 'MCF7_BREAST', 'PC3_PROSTATE', 'VCAP_PROSTATE'];

$.ajaxPrefilter(function (options, originalOptions, jqXHR) {
    if (clue.USER_KEY != null && options.url.indexOf(clue.API_URL) === 0) {
        //	jqXHR.setRequestHeader('user_id', clue.getUserName());
        jqXHR.setRequestHeader('user_key', clue.USER_KEY);
    }
});
clue.analytics = function () {
    if (window.location.hostname === 'clue.io') {
        if (typeof ga === 'undefined') {
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments);
                }, i[r].l = 1 * new Date();
                a = s.createElement(o), m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m);
            })(window, document, 'script', '//www.google-analytics.com/analytics.js',
                'ga');
        }
        ga('create', 'UA-62656334-1', 'auto', 'clue');
        if (clue.getUserName() != null) {
            ga('clue.set', 'clue_user', clue.getUserName());
        }
        ga('clue.send', 'pageview');
    }
};
clue.cachedFetch = function (url, options, callback) {
    //TODO: If local storage is not present then make query without storage
    try {
        var expiry = 5 * 60; // 5 min default
        if (typeof options === 'number') {
            expiry = options;
            options = undefined;
        } else if (typeof options === 'object') {
            // I hope you didn't set it to 0 seconds
            expiry = options.seconds || expiry;
        }
        // Use the URL as the cache key to sessionStorage
        var cacheKey = clue.hashstr(url + clue.USER_KEY);
        if (options.ignoreApiKey) {
            cacheKey = clue.hashstr(url);
        }
        var cached = localStorage.getItem(cacheKey);
        var whenCached = localStorage.getItem(cacheKey + ':ts');
        if (cached !== null && whenCached !== null) {
            // it was in sessionStorage! Yay!
            // Even though 'whenCached' is a string, this operation
            // works because the minus sign tries to convert the
            // string to an integer and it will work.
            var age = (Date.now() - whenCached) / 1000;
            if (age < expiry) {
                return callback(null, JSON.parse(cached));
            } else {
                // We need to clean up this old key
                localStorage.removeItem(cacheKey);
                localStorage.removeItem(cacheKey + ':ts');
            }
        }
    } catch (ex) {
        //local storage not supported?
        console.log(ex);
    }
    var clueHeaders = new Headers({
        'user_key': clue.USER_KEY
    });

    var myInit = {
        method: 'GET',
        headers: clueHeaders
    };
    if (options.ajax) {
        var ajx = $.ajax({
            url: url,
            type: 'GET',
            cache: true
        });
        ajx.done(function (result) {
            localStorage.setItem(cacheKey, JSON.stringify(result));
            localStorage.setItem(cacheKey + ':ts', Date.now())
            return callback(null, result);
        }).fail(function (err) {
            return callback(err);
        });
    } else {
        fetch(url, myInit).then(function (response) {
            return response.json().then(function (data) {
                if (response.ok) {
                    return data;
                } else {
                    return Promise.reject({status: response.status, data: data});
                }
            });
        }).then(function (result) {
            localStorage.setItem(cacheKey, JSON.stringify(result));
            localStorage.setItem(cacheKey + ':ts', Date.now());

            return callback(null, result);
        }).catch(function (error) {
            console.log('error:', error);
            return callback(error, null);
        });
    }
}
clue.hashstr = function hashstr(s) {
    var hash = 0;
    if (s.length === 0) return hash;
    for (var i = 0; i < s.length; i++) {
        var char = s.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
};
/**
 *  Parses URL and returns the version (e.g. &version=1.1 should return 1.1)
 * @param url The base URL to get the version from
 * @returns The api version, as a string
 */
clue.getVersionFromUrl = function (url) {
    var result = null;
    // skips the '?' character at the beginning of the URL
    if (url) {
        var query = url.substr(1);
        query.split("&").forEach(function (part) {
            var item = part.split("=");
            if (item[0] === 'version') {
                result = decodeURIComponent(item[1]);
            }
        });
    }
    return result;
}

/**
 * List all the directories at the specified url, and load all gcts inside these directories
 * @param url The base URL to load gct files from
 * @return {*}
 */
clue.parseApacheListing = function (url) {
    var d = $.Deferred();
    $.ajax({
        url: url
    }).done(function (html) {
        var a = $(html).find('td > a');
        var files = [];
        for (var i = 1; i < a.length; i++) {
            var text = $(a[i]).text();
            files.push(text);
        }
        files.sort();
        d.resolve(files.map(function (file) {
            return url + file;
        }));
    }).fail(function (err) {
        d.reject(err);
    });
    return d;

};
clue.getUserName = function () {
    return Cookies.get('user_id');
};

clue.showLoginModal = function () {
    $loginModal.modal('show');
};

clue.hideAccountDropDown = function () {
    $('#header-drop-down').hide();
};

clue.getUserInfo = function () {
    var userInfo;
    var userInfoCookie = Cookies.get('user_info');
    if (userInfoCookie) {
        userInfo = JSON.parse(Cookies.get('user_info'));
    }
    return userInfo;
};

// set up clue config, borrowed from
// https://github.com/HenrikJoreteg/clientconfig
var config = Cookies.get('clue_config') || {};
if (config) {
    var co = JSON.parse(config);
    Object.freeze(co);
}
// wipe it out
//document.cookie = 'clue_config=;expires=Thu, 01 Jan 1970 00:00:00 GMT';

clue.ENV = JSON.parse(config).env;
clue.API_URL = JSON.parse(config).url;
clue.whitelist_key = JSON.parse(config).whitelist_key;

clue.isDomainOnWhitelist = function (email) {
    return $.ajax({
        url: clue.API_URL + '/api/whitelists/' + clue.whitelist_key + '/domain/' + email + '/exists',
        type: 'GET'
    });
};

clue.getSettings = function (callback) {

    var url = '/settings';
    var init = {
        seconds: 30 * 60, // 30 minutes
        ajax: true
    };
    clue.cachedFetch(url, init, callback);
};
clue.getAllEvents = function (callback) {

    var url = '/allEvents';

    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
};
clue.getRoles = function (callback) {
    var init = {
        seconds: 24 * 60 * 60 // 1 day
    };
    clue.cachedFetch(clue.API_URL + '/api/roles', init, callback);
};
clue.getServerInfo = function (callback) {
    var url = '/server_info';
    var init = {
        // mode: 'same-origin',
        ignoreApiKey: true,
        seconds: 7 * 24 * 60 * 60 // 1 week
    }
    clue.cachedFetch(url, init, callback);
};
clue.getApiRepurposingDefinitions = function (callback) {
    var url = clue.API_URL + '/public/repurposing-definition';

    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
}
clue.getApiPublicDefinitions = function (callback) {
    var url = clue.API_URL + '/public/definitions';

    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
};
clue.getConnectopediaGlossary = function (callback) {
    var url = clue.API_URL + '/api/glossary/distinct?field=index';
    var init = {
        ignoreApiKey: true,
        seconds: 24 * 60 * 60 // 1 day
    };
    clue.cachedFetch(url, init, callback);

};
clue.getConnectopediaTags = function (callback) {
    var url = '/connectopedia/tags.json';
    var init = {
        ignoreApiKey: true,
        seconds: 24 * 60 * 60 // 1 day

    };
    clue.cachedFetch(url, init, callback);
};
clue.getTranscriptionalImpactForAllTouchstonePerts = function (callback) {

    var url = clue.API_URL +
        '/api/perts?filter={"include":{"pcls":true},"where": {"pert_icollection" : "TS"},"fields" : ["tas","pert_type","pert_id","pert_iname"],"order":"tas DESC"}';

    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
};
clue.getGitInfo = function (callback) {
    var url = '/build-info';
    var init = {
        ignoreApiKey: true,
        seconds: 7 * 24 * 60 * 60 // 7 days
    }
    clue.cachedFetch(url, init, callback);
};
clue.getApps = function (callback) {

    var init = {
        // mode: 'same-origin',
        seconds: 10 * 60 // 10 minutes
    }
    clue.cachedFetch(clue.API_URL + '/api/app_list/getApps?server_env=' + clue.ENV, init, callback);
};
clue.nominate = function (callback) {
    var url = clue.API_URL + '/api/nominate';
    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
};
clue.getAcademicTraining = function (callback) {
    var url = clue.API_URL + '/api/academic_training';
    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
};

clue.getResearchRoles = function (callback) {
    var url = clue.API_URL + '/api/research_roles';
    return $.ajax({
        url: url,
        type: 'GET',
        cache: true
    });
};


clue.autoCompleteInstituteUrl = function (callback) {
    return clue.API_URL + '/api/institutions/autocomplete';
};
clue.touchStoneVersion = function (callback) {
    var init = {
        // mode: 'same-origin',
        ignoreApiKey: true,
        seconds: 24 * 60 * 60 // 1 day
    }
    clue.cachedFetch(clue.API_URL + '/api/touchstone-version', init, callback);
};
clue.nominatePerts = function (type, name) {
    return $.ajax({
        url: clue.API_URL + '/api/nominate_entity?type=' + type + '&name=' + name,
        type: 'GET'
    });
};
clue.generateShortUrl = function (url) {
    return $.ajax({
        data: {
            url: url
        },
        method: 'POST',
        url: clue.API_URL + '/api/shortUrl/generate'
    });
};

/**
 * Autocomplete for a list of documents.
 *
 * @param options.$el
 *            Element to autocomplete
 * @param options.max
 *            max number of suggestions (defaults to 3).
 * @param options.fieldNames
 *            array of document fields to search.
 * @param options.nitems
 *            Nummber of documents to search
 * @param options.next
 *            Function callback to advance to next document.
 * @param options.getValue(field)
 *            Function callback to get the value for the current document at the
 *            specified field.
 */
clue.autocomplete = function (options) {
    var f = function (q, cb) {
        var matches = [];
        // an array that will be populated with substring matches
        // regex used to determine if a string starts with substring `q`
        var regex = new RegExp('^' + q, 'i');
        // iterate through the pool of strings and for any string that
        // contains the substring `q`, add it to the `matches` array
        var max = options.max || 3;
        var values = {};
        var count = 0;
        var fieldNames = options.fieldNames;
        var nfields = fieldNames.length;
        for (var i = 0, nitems = options.nitems; i < nitems && count < max; i++) {
            options.next();
            for (var j = 0; j < nfields; j++) {
                var str = options.getValue(fieldNames[j]);
                if (!values[str] && regex.test(str)) {
                    values[str] = true;
                    count++;
                    if (count === max) {
                        break;
                    }
                }
            }
        }
        for (var val in values) {
            matches.push({
                value: val
            });
        }
        cb(matches);
    };
    morpheus.Util.autocomplete(options.$el, f, null, false);

};

/**
 * Search a list of documents.
 *
 * @param options.fieldNames
 *            array of document fields to search.
 * @param options.nitems
 *            Nummber of documents to search
 * @param options.next
 *            Function callback to advance to next document.
 * @param options.getValue(field)
 *            Function callback to get the value for the current document at the
 *            specified field.
 * @return A list of matching indices or null if no search text was provided.
 */
clue.search = function (text, options) {
    text = $.trim(text);
    if (text === '') {
        return null;
    }
    var tokens = morpheus.Util.getAutocompleteTokens(text);
    if (tokens.length == 0) {
        return null;
    }
    var fieldNames = options.fieldNames;
    var predicates = morpheus.Util.createSearchPredicates({
        tokens: tokens,
        fields: fieldNames
    });
    var indices = [];
    var npredicates = predicates.length;
    var nfields = model.getMetadataCount();
    for (var i = 0, nitems = options.nitems; i < nitems; i++) {
        var matches = false;
        options.next();
        for (var p = 0; p < npredicates && !matches; p++) {
            var predicate = predicates[p];
            var filterColumnName = predicate.getField();
            if (filterColumnName != null) {
                var value = options.getValue(filterColumnName);
                // TODO handle arrays
                if (value != null && predicate.accept(value)) {
                    matches = true;
                    break;
                }
            } else { // try all fields
                for (var j = 0; j < nfields; j++) {
                    var value = options.getValue(fieldNames[j]);
                    if (value != null && predicate.accept(value)) {
                        matches = true;
                        break;
                    }
                }
            }
        }
        if (matches) {
            indices.push(i);
        }
    }
    return indices;
};


clue.getCell = function (cell_id) {
    return $.ajax({
        url: clue.API_URL + '/api/cells?filter={"where":{"cell_id":"'
        + encodeURIComponent(cell_id) + '"}}',
        type: 'GET'
    });
};
clue.getPertInfo = function (pert_id) {
    return $.ajax({
        url: clue.API_URL + '/api/perts?filter={"include":{"pcls":true},"where":{"pert_id":"'
        + encodeURIComponent(pert_id) + '"}}',
        type: 'GET'
    });
};

clue.getGeneBySymbol = function (gene_symbol) {
    return $.ajax({
        url: clue.API_URL + '/api/genes/findOne?filter={"where":{"gene_symbol":"' + encodeURIComponent(gene_symbol) + '"}}',
        type: 'GET'
    });
};


clue.getPert = function (pert_iname) {
    return $.ajax({
        url: clue.API_URL + '/api/pert-card/' + pert_iname,
        type: 'GET'
    });
};

clue.getMissingCities = function () {
    var filter = {
        'fields': ['institute', 'country'],
        'where': {'city': '-666'}
    };
    return $.ajax({
        url: clue.API_URL + '/api/institutions?filter={"fields": ["id","institute", "country"], "where": {"city": "-666"}}',
        type: 'GET'
    });
};

clue.userExists = function (email) {
    return $.ajax({
        url: clue.API_URL
        + '/api/admin/users/exists?filter={"where":{"email":"'
        + encodeURIComponent(email) + '"}}',
        type: 'GET'
    });
};

clue.guessInstitutionFromEmail = function (email) {
    return $.ajax({
        'url': clue.API_URL + '/api/institutions/domain/' + encodeURIComponent(email),
        'type': 'GET'
    });
};

clue.getTouchStone = function () {
    return $.ajax({
        url: clue.API_URL + '/touchstone',
        type: 'GET'
    });
};

clue.getDosePoints = function (pert_iname) {
    return $.ajax({
        url: clue.API_URL + '/api/sigs/doseByCoreCellLines/' + pert_iname,
        type: 'GET'
    });
};

clue.searchPerts = function (search) {
    return $.ajax({
        url: clue.API_URL + '/api/search/perts/' + search,
        type: 'GET'
    });
};

clue.getHistory = function () {

    return $
        .ajax({
            url: clue.API_URL
            + '/api/jobs?filter={"where":{"user_id":"'
            + clue.getUserName()
            + '","status":{"inq":["pending","processing","submitted","completed"]}},"limit":10,"order":"created DESC"}',
            type: 'GET'
        });
};

clue.autoCompleteInstitute = function (inst) {
    return $.ajax({
        url: clue.autoCompleteInstituteUrl() + '?q=' + inst,
        type: 'GET'
    });
};


clue.loadScriptsWhenReady = function (scripts) {
    $(document).one('clueReady', function () {
        for (var i = 0; i < scripts.length; i++) {
            var script = document.createElement('script');
            script.setAttribute('type', 'text/javascript');
            script.setAttribute('src', scripts[i]);
            document.head.appendChild(script);
        }
    });
};

clue.setup = function (callback) {
    return callback();
};

clue.getTempApiKey = function () {

};
clue.getUserKey = function (callback, errorCallback) {

    if (clue.USER_KEY != null) {
        callback(clue.USER_KEY);
    } else {
        $.ajax({
            url: '/api_config',
            cache: true,
            success: function (config) {
                if (config.api_key != null) {
                    clue.USER_KEY = config.api_key;
                }
                callback(clue.USER_KEY);
                $(document).trigger('clueReady');
            },
            error: function () {
                if (errorCallback) {
                    errorCallback();
                }
            }
        });
    }
};

clue.fixUrl = function (url) {
    if (url.indexOf('data.clue.io') === 0 || url.indexOf('macchiato.clue.io') === 0) {
        url = 'https://s3.amazonaws.com/' + url;
    }
    return url;
};

clue.BASE_GUTC_DIGESTS_URL = '//s3.amazonaws.com/data.clue.io/tsv2/digests/';
/**
 *
 * @param options.id BRD id of pert
 * @param options.top Number of top results to return
 * @param options.bottom Number of bottom results to return
 * @return A Deferred that resolves to an array of results
 */
clue.gutcTopResults = function (options) {
    var deferred = $.Deferred();
    var d = morpheus.DatasetUtil.read(clue.BASE_GUTC_DIGESTS_URL + options.id + '/pert_id_summary.gct');
    d.done(function (dataset) {
        var array = [];
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
            array.push({
                index: i,
                value: dataset.getValue(i, 0)
            });
        }
        array.sort(function (a, b) {
            return (a.value < b.value ? 1 : (a.value === b.value ? 0 : -1));
        });
        var idVector = dataset.getRowMetadata().get(0);
        var results = [];
        for (var i = 0, n = Math.min(array.length, options.top); i < n; i++) {
            var index = array[i];
            results.push({
                id: idVector.getValue(index.index),
                score: dataset.getValue(index.index, 0),
                rank: i + 1
            });
        }
        for (var i = 0, j = array.length - 1,
                 n = Math.min(options.bottom, array.length); i < n; i++, j--) {
            var index = array[j];
            results.push({
                id: idVector.getValue(index.index),
                score: dataset.getValue(index.index, 0),
                rank: 8796 - i
            });
        }
        var filter = {
            where: {
                pert_id: {
                    inq: results.map(function (r) {
                        return r.id;
                    })
                }
            },
            fields: {
                description: true,
                pert_id: true,
                pert_iname: true,
                pert_type: true
            }
        };
        $.ajax(clue.API_URL + '/api/perts?filter=' + JSON.stringify(filter)).fail(function (err) {
            deferred.reject(err);
        }).done(function (items) {
            var idToItem = {};
            for (var i = 0, nitems = results.length; i < nitems; i++) {
                idToItem[results[i].id] = results[i];
            }
            for (var i = 0, nitems = items.length; i < nitems; i++) {
                var item = items[i];
                var result = idToItem[item.pert_id];
                if (result !== undefined) {
                    result.description = item.description;
                    result.pert_iname = item.pert_iname;
                    result.pert_type = item.pert_type;
                }
            }
            deferred.resolve(results);
        });

    });
    d.fail(function (err) {
        deferred.reject(err);
    });
    return deferred;

};
/**
 *
 * @param gutcOptions.url Base GUTC output URL
 * @return jQuery Deferred
 */
clue.getGutcResult = function (gutcOptions) {
    var gutcUrl = gutcOptions.url;
    if (gutcUrl[gutcUrl.length - 1] !== '/') {
        gutcUrl += '/';
    }
    // data.clue.io/api/jgould+1@broadinstitute.org/results/
    if (gutcUrl.indexOf('https://s3.amazonaws.com/data.clue.io/api/') === 0) {
        // encode email address
        var remainder = gutcUrl.substring('https://s3.amazonaws.com/data.clue.io/api/'.length);
        var resultsIndex = remainder.indexOf('/results');
        if (resultsIndex !== -1) {
            var email = remainder.substring(0, resultsIndex);
            gutcUrl = 'https://s3.amazonaws.com/data.clue.io/api/' + encodeURIComponent(email) + remainder.substring(resultsIndex);
        }
    }
    var d = $.Deferred();
    var signedPromise = clue.getSignedFolder(gutcUrl); // 1st sign the folder
    signedPromise.done(function (nameToUrl) {
        var options = {};
        if (gutcOptions.gutcSummary) {
            options.pert_id_summary = nameToUrl['pert_id_summary.gct'];
            if (options.pert_id_summary == null) {
                options.pert_id_summary = nameToUrl['ps_pert_summary.gct'];
            }
        }
        if (gutcOptions.gutcCell) {
            options.pert_id_cell = nameToUrl['pert_id_cell.gct'];
        }
        if (gutcOptions.pclCell) {
            options.pcl_cell = nameToUrl['pcl_cell.gct'];
        }
        if (gutcOptions.pclSummary) {
            options.pcl_summary = nameToUrl['pcl_summary.gct'];
            if (options.pcl_summary == null) {
                options.pcl_summary = nameToUrl['ps_pcl_summary.gct'];
            }
        }

        // try to get query name
        options.config = nameToUrl['config.yaml'];
        if (options.config == null && gutcUrl.lastIndexOf('UPTAG/') === gutcUrl.length - 6) {
            options.config = gutcUrl.substring(0, gutcUrl.length - 6)
                + 'config.yaml';
        }
        if (options.config != null && options.config.indexOf('/arfs/') > -1) {
            options.config = options.config.replace('/arfs/', '/');
        }
        options.columnInfo = nameToUrl['column_meta.txt'];
        options.rowInfo = gutcOptions.rowMeta ? nameToUrl['row_meta.txt'] : null;

        var gutcPromise = clue.getGutcResultByUrl(options);
        gutcPromise.done(function (result) {
            d.resolve(result);
        });
        gutcPromise.fail(function (result) {
            d.reject(result);
        });
    });

    function unsignedResults() {
        var options = {};
        if (gutcOptions.gutcSummary) {
            options.pert_id_summary = gutcUrl + 'pert_id_summary.gct';

        }
        if (gutcOptions.gutcCell) {
            options.pert_id_cell = gutcUrl + 'pert_id_cell.gct';
        }

        if (gutcOptions.pclCell) {
            options.pcl_cell = gutcUrl + 'pcl_cell.gct';
        }
        if (gutcOptions.pclSummary) {
            options.pcl_summary = gutcUrl + 'pcl_summary.gct';
        }

        // try to get query name
        if (gutcUrl.lastIndexOf('UPTAG/') === gutcUrl.length - 6) {
            options.config = gutcUrl.substring(0, gutcUrl.length - 6)
                + 'config.yaml';
        }
        var gutcPromise = clue.getGutcResultByUrl(options);
        gutcPromise.done(function (result) {
            d.resolve(result);
        });
        gutcPromise.fail(function (result) {
            d.reject(result);
        });
    }

    signedPromise.fail(function (nameToUrl) {
        unsignedResults();
    });
    return d;
};

/**
 * Gets one or more GUTC results as a morpheus.Dataset.
 *
 * @param {string[]}
 *            options.urls The GUTC output URLS
 * @param {Boolean}
 *            [options.pclSummary=true] Whether to retrieve pcl level data
 * @param {Boolean}
 *            [options.pclCell=true] - Whether to retrieve pcl level data
 * @param {Boolean}
 *            [options.gutcSummary=true] - Whether to gutc summary level data
 * @param {Boolean}
 *            [options.gutcCell=true] - Whether to gutc cell level data
 * @param {string} options.index Path to index file to annotate results with.
 * @return A jQuery deferred object that resolves to a morpheus.Dataset.
 *
 */
clue.getGutcResults = function (options) {
    var deferred = $.Deferred();
    var promises = [];
    var datasets = [];

    options = $.extend({}, {
        pclCell: true,
        gutcCell: true,
        pclSummary: true,
        gutcSummary: true
    }, options);
    options.urls.forEach(function (url) {
        url = clue.fixUrl(url);
        var promise = clue.getGutcResult({
            url: url,
            rowMeta: options.urls.length === 1,
            pclCell: options.pclCell,
            gutcCell: options.gutcCell,
            pclSummary: options.pclSummary,
            gutcSummary: options.gutcSummary
        });
        promises.push(promise);
        promise.done(function (dataset) {
            datasets.push(dataset);
        });
    });
    var indexLines = null;
    if (options.index) {
        options.index = clue.fixUrl(options.index);
        var indexPromise = $.Deferred();
        var indexSignedUrl = clue.getSignedUrl(options.index);
        indexSignedUrl.done(function (url) {
            var p = morpheus.Util.readLines(url);
            p.done(function (result) {
                indexLines = result;
                indexPromise.resolve();
            });
            p.fail(function () {
                indexPromise.resolve();
            });

        });
        indexSignedUrl.fail(function () {
            indexPromise.resolve();
        });
        promises.push(indexPromise);
    }
    $.when.apply($, promises).then(
        function () {
            var dataset;
            for (var i = 0; i < datasets.length; i++) {
                var pclSeriesData = [];
                for (var j = 0, ncols = datasets[i].getRowCount(); j < ncols; j++) {
                    pclSeriesData.push({});
                }
                var pclSeriesIndex = datasets[i].addSeries({
                    name: 'PCL',
                    dataType: 'number',
                    array: pclSeriesData
                });
            }
            if (datasets.length === 1) {
                dataset = datasets[0];
            } else {
                // join rows by pert_id
                for (var i = 0; i < datasets.length; i++) {
                    datasets[i] = new morpheus.TransposedDatasetView(
                        datasets[i]);
                }
                dataset = new morpheus.JoinedDataset(datasets[0],
                    datasets[1], 'id', 'id', 'query');
                for (var i = 2; i < datasets.length; i++) {
                    dataset = new morpheus.JoinedDataset(dataset,
                        datasets[i], 'id', 'id', 'query');
                }
                dataset = new morpheus.TransposedDatasetView(dataset);
            }
            // id and pert_type on rows
            // cell_id, id, and query on columns

            dataset.setName(options.name);
            if (indexLines) {

                new morpheus.OpenFileTool().annotate(
                    indexLines, dataset, true, null, '_id',
                    indexLines[0].split(/\t/)[0], null);
            }
            deferred.resolve(dataset);
        }, function () {
            deferred.reject('Unable to read results.');
        });
    var promise = deferred.promise();
    promise.toString = function () {
        return 'results';
    };
    return promise;
};

clue.createGutcColorScheme = function () {
    return {
        name: '(-100, -95, -90, 90, 95, 100)',
        scalingMode: 'fixed',
        map: [
            {
                value: -100,
                color: '#0000ff'
            }, {
                value: -95,
                color: '#abdda4'
            }, {
                value: -90,
                color: '#ffffff'
            }, {
                value: 90,
                color: '#ffffff'
            }, {
                value: 95,
                color: '#fdae61'
            }, {
                value: 100,
                color: '#ff0000'
            }]
    };
};

clue.createLoadingEl = function () {
    return $(
        '<div id="loading-spinner" class="loading-box"><div class="loading"><div class="fa fa-spinner fa-spin fa-3x"></div><p class="load-message">&nbsp;Loading&#8230;</p></div></div>');
};
clue.getSignedFolder = function (folder) {
    var d = $.Deferred();
    var p = $.ajax({
        context: folder,
        url: clue.API_URL + '/api/s3_resources/signFolder?s3_folder=' + folder
    });
    p.done(function (urls) {
        var fileNameToUrl = {};
        urls.forEach(function (url) {
            // e.g.
            // https://s3.amazonaws.com/appdata.cmap.org/icv/dosval/BRD-A13084692_10_UM_24_H/column_info.txt?AWSAccessKeyId=AKIAJZQISWLUKFS3VUKA&Expires=1455749092&Signature=OHTVTyy%2Fk0BAT83YfyT90ZsWUa8%3D",
            var questionMarkIndex = url.indexOf('?');
            if (questionMarkIndex !== -1) {
                var name = url.substring(0, questionMarkIndex);
                var slashIndex = name.lastIndexOf('/');
                name = name.substring(slashIndex + 1);
                fileNameToUrl[name] = url;
            } else {
                d.reject('No file name found for ' + url);
            }

        });
        d.resolve(fileNameToUrl);
    });
    p.fail(function () {
        d.reject();
    });
    return d;
};

clue.getSignedUrl = function (url) {
    return $.ajax(clue.API_URL + '/api/s3_resources/signFile?s3_file=' + url);
};

clue.getJobConfig = function (url) {
    var nameDeferred = $.Deferred();
    var p = $.ajax({
        url: url,
        dataType: 'text'
    });
    var config = {};
    p.done(function (text) {
        var lines = text.split('\n');
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            var index = line.indexOf(':');
            if (index !== -1) {
                var key = line.substring(0, index).trim();
                var value = line.substring(index + 1).trim();
                config[key] = value;
            }
        }
        nameDeferred.resolve(config);
    });
    p.fail(function () {
        nameDeferred.resolve(config);
    });
    return nameDeferred;
};
/**
 *
 * @param options.urls
 *            Array of base urls to retrieve query results from
 * @param options.tool Either sig_query_tool or sig_prot_query_tool
 *
 */
clue.getQueryResults = function (options) {
    var datasetPromises = [];
    var connectivityDatasets = [];
    var introspectDatasets = [];
    options.urls.forEach(function (url) {
        url = clue.fixUrl(url);
        var p;
        if (options.tool === 'sig_prot_query_tool') {
            p = clue.getQueryResultByUrl({
                baseUrl: url,
                gct: 'CONCATED_CONN.gct'
            });
        } else {
            p = clue.getQueryResultByUrl({
                baseUrl: url,
                gct: 'result_WTCS.CUSTOM.COMBINED_n1x4160.gct' // FIXME
            });
        }
        p.done(function (result) {
            connectivityDatasets.push(result.conn);
            if (result.introspect != null) {
                introspectDatasets.push(result.introspect);
            }
        });
        datasetPromises.push(p);
    });
    var d = $.Deferred();
    $.when
        .apply($, datasetPromises)
        .then(
            function () {
                if (connectivityDatasets.length === 1) {
                    d.resolve({
                        conn: connectivityDatasets[0],
                        introspectDatasets: introspectDatasets
                    });
                } else {
                    var joined = new morpheus.JoinedDataset(
                        new morpheus.TransposedDatasetView(
                            connectivityDatasets[0]),
                        new morpheus.TransposedDatasetView(
                            connectivityDatasets[1]));
                    for (var i = 2; i < connectivityDatasets.length; i++) {
                        joined = new morpheus.JoinedDataset(joined,
                            new morpheus.TransposedDatasetView(
                                connectivityDatasets[i]));
                    }
                    d
                        .resolve({
                            conn: new morpheus.TransposedDatasetView(
                                joined),
                            introspectDatasets: introspectDatasets
                        });
                }

            });
    return d;

};

/**
 *
 * @param options.gct
 * @param options.baseUrl
 * @return {*}
 */
clue.getQueryResultByUrl = function (options) {
    var dataset = null;
    var introspectDataset = null;
    var deferred = $.Deferred();
    var config = {};
    var promises = [];
    var introspectPromise = $.Deferred();
    promises.push(introspectPromise);
    promises.push(clue.getJobConfig(options.baseUrl + '/config.yaml').done(function (conf) {
        config = conf;
        if (conf.introspect === 'true') {

            var p = morpheus.DatasetUtil.read(options.baseUrl + '/INTROSPECT_CONN.gct');
            p.done(function (d) {
                introspectDataset = d;
            });
            p.always(function () {
                introspectPromise.resolve();
            });
        } else {
            introspectPromise.resolve();
        }
    }));

    var p = morpheus.DatasetUtil.read(options.baseUrl + '/' + options.gct);
    p.done(function (d) {
        dataset = d;
    });
    promises.push(p);
    $.when.apply($, promises).then(function () {
        if (config.rpt != null) {
            if (introspectDataset != null) {
                introspectDataset.setName(0, 'Introspect - ' + config.rpt);
            }
            var v = dataset.getColumnMetadata().getByName('name');

            if (v == null) {
                v = dataset.getColumnMetadata()
                    .add('name');
            }
            for (var j = 0, size = v.size(); j < size; j++) {
                v.setValue(j, config.rpt);
            }
        }
        if (config.data_type != null) {
            var v = dataset.getColumnMetadata().getByName('data_type');
            if (v == null) {
                v = dataset.getColumnMetadata()
                    .add('data_type');
            }
            for (var j = 0, size = v.size(); j < size; j++) {
                v.setValue(j, config.data_type);
            }
        }

        deferred.resolve({
            conn: dataset,
            introspect: introspectDataset
        });
    });
    return deferred;
};

var pertTypesTasCache = null;
var pertTypesTasConfig = {
    'trt_oe': {
        xaxisTitle: 'All Gene OE',
        color: '#27AAE0',
        lineColor: '#8fc7de'
    },
    'trt_sh.cgs': {
        xaxisTitle: 'All Gene KD',
        color: '#B438BE',
        lineColor: '#c692ca'
    },
    'trt_cp': {
        xaxisTitle: 'All Compounds',
        color: '#F5A623',
        lineColor: '#edca91'
    }
};

/**
 *
 * @param options.multiple Multiple files?
 * @return jQuery Deferred
 */
clue.promptForFile = function (options) {
    var d = $.Deferred();
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
        name: 'file',
        value: '',
        type: 'file',
        required: true,
        multiple: options.multiple
    });
    var $modal;
    formBuilder.on('change', function (e) {
        var value = e.value;
        if (value !== '' && value != null) {
            $modal.modal('hide');
            $modal.remove();
            d.resolve(value);
        }
    });
    $modal = morpheus.FormBuilder.showInModal({
        title: 'File',
        html: formBuilder.$form,
        close: false
    });
    return d;
};
clue.loadTasChart = function (pertId, pertType, tasChartId) {
    $(tasChartElt).empty();
    var tasPointHoverId = '#tas_point_info';

    var showTasChart = function (pertId, tasChartElt) {
        // convert hover info params into an object
        var getTasHoverData = function (pertName, tas, pertsAbove, pertsBelow) {
            var totalPerts = pertsAbove + pertsBelow + 1;
            var percentBelow = (pertsBelow / totalPerts) * 100;
            var percentAbove = 100 - pertsBelow;
            return {
                'pert': pertName,
                'tas': tas,
                'pertsAbove': pertsAbove,
                'pertsBelow': pertsBelow,
                'percentBelow': percentBelow,
                'percentAbove': percentAbove,
                'percentile': Math.floor(percentBelow)
            };
        };

        // convert hover data into % breakdown table
        var getHoverPercentTable = function (tasHoverInfo, pertTypeConfig) {
            return '<div class="metadata-line"></div><table style="font-size:4pt;width:100%;"><tr><td style="width:' + tasHoverInfo.percentBelow + '%;background-color:' +
                pertTypeConfig.color + '">&nbsp;</td><td style="background-color:lightgrey;width:' + tasHoverInfo.percentAbove + '%">&nbsp;</tr></table></div>';
        };

        // convert hover data into a div
        var getHoverScoreText = function (tasHoverInfo) {
            if (tasHoverInfo) {
                return '<div>' +
                    '<div class="metadata-line">' +
                    '<span class="label">Score:</span><span class="value">' + tasHoverInfo.tas + '</span>' +
                    '</div>' +
                    '<div class="metadata-line">' +
                    '<span class="label">Percentile:</span><span class="value">' + tasHoverInfo.percentile + '</span>' + '' +
                    '</div>' +
                    '</div>';
            }
            else {
                return '';
            }
        };

        var makeHoverDiv = function (tasHoverInfo, pertTypeConfig) {
            var percentTable = getHoverPercentTable(tasHoverInfo, pertTypeConfig);
            var scoreText = getHoverScoreText(tasHoverInfo);
            return '<div class="graph-title">' + tasHoverInfo.pert + '<br/>' + percentTable + scoreText + '</div>';
        };

        // add hover behavior, initializing hover detail to the given params
        var addHoverBehavior = function (x, y, pertName, pertsAbove, pertsBelow) {
            var pertTypeConfig = pertTypesTasConfig[pertType];

            $(tasChartElt).find(tasPointHoverId).remove();
            $(tasChartElt).append('<div id="tas_point_info" style="width:40%;position:relative;top:-90%;right:-50%;"></div>');

            Plotly.addTraces(tasChartElt, {
                mode: 'lines+markers',
                x: [x],
                y: [y],
                hoverinfo: 'none',
                name: pertName,
                marker: {
                    color: pertTypeConfig.color,
                    size: 10
                },
                hovermode: 'closest'
            }).then(function () {

                var tasHoverInfoElt = $(tasChartElt).find(tasPointHoverId);
                tasChartElt.on('plotly_hover', function (data) {
                    tasHoverInfoElt.empty();
                    var infotext = data.points.map(function (d) {
                        var tasHoverInfo = undefined;
                        if (d.data.text) {
                            tasHoverInfo = getTasHoverData(d.data.text[d.x], d.y, d.x, (d.data.x.length - d.x) - 1);
                            return makeHoverDiv(tasHoverInfo, pertTypeConfig);
                        }
                        return '';
                    });
                    tasHoverInfoElt.append(infotext);
                })
                    .on('plotly_unhover', function (data) {
                        tasHoverInfoElt.empty();
                        var tasHoverInfo = getTasHoverData(pertName, y, pertsAbove, pertsBelow);
                        tasHoverInfoElt.append(makeHoverDiv(tasHoverInfo, pertTypeConfig));
                    });

                tasHoverInfoElt.empty();
                var tasHoverInfo = getTasHoverData(pertName, y, pertsAbove, pertsBelow);
                tasHoverInfoElt.append(makeHoverDiv(tasHoverInfo, pertTypeConfig));
            });
        };

        if (pertTypesTasCache[pertType]) {
            var tasForPert = pertTypesTasCache[pertType].tasForPertId[pertId];

            var xAxisTitle = pertTypesTasConfig[pertType].xaxisTitle + ' (' + pertTypesTasCache[pertType].tasX.length + ')';
            var tasChartElt = document.getElementById(tasChartId);
            var lineColor = pertTypesTasConfig[pertType].lineColor;

            Plotly.newPlot(tasChartElt, [
                    {
                        x: pertTypesTasCache[pertType].tasX,
                        y: pertTypesTasCache[pertType].tasY,
                        text: pertTypesTasCache[pertType].pert_iname,
                        hoverinfo: 'none',
                        mode: 'lines',
                        type: 'scatter',
                        marker: {color: lineColor}
                    }],
                {
                    margin: {
                        t: 10,
                        b: 20,
                        l: 30,
                        r: 0
                    },
                    hovermode: 'closest',
                    showlegend: false,
                    xaxis: {
                        showline: true,
                        zeroline: false,
                        showticklabels: false,
                        ticks: '',
                        fixedrange: true,
                        range: [0, pertTypesTasCache[pertType].tasX.length],
                        title: xAxisTitle,
                        showgrid: false,
                        titlefont: {
                            family: 'Roboto Condensed, sans-serif'
                        }
                    },
                    yaxis: {
                        range: [0, 1.0],
                        dtick: 0.25,
                        showline: true,
                        zeroline: false,
                        fixedrange: true,
                        ticksuffix: ' ',
                        titlefont: {
                            family: 'Roboto Condensed, sans-serif'
                        }
                    }
                },
                {displayModeBar: false}
            ).then(function () {
                if (tasForPert) {

                    var pertsAbove = pertTypesTasCache[pertType].tasX.length;
                    addHoverBehavior(tasForPert.tasX, tasForPert.tasY, tasForPert.pert_iname, tasForPert.tasX, (pertsAbove - tasForPert.tasX) - 1);
                }
                else {
                    console.log('No tas data available for ' + pertId);
                }
            });
        }
        else {
            console.log('unknown pert type ' + pertType + '.  Cannot show tas curve.');
        }
    };

    var tasChartElt = document.getElementById(tasChartId);

    if (!pertTypesTasCache) {
        var impact = clue.getTranscriptionalImpactForAllTouchstonePerts(function (error, tasScores) {
        });
        impact.done(function (tasScores) {
            tasCache = {};
            // cache of chart points for each pert type
            pertTypesTasCache = {};
            for (var pertType in pertTypesTasConfig) {
                pertTypesTasCache[pertType] = {
                    tasX: [],
                    tasY: [],
                    pert_id: [],
                    pert_iname: [],
                    tasForPertId: {},
                    xIndex: 0
                };
            }

            tasScores.forEach(function (tas, index) {
                tasCache[tas.pert_id] = tas.pert_type;

                if (!pertTypesTasCache[tas.pert_type]) {
                    console.log('No tas cache for ' + tas.pert_type);
                }
                else {
                    var tasForPertType = pertTypesTasCache[tas.pert_type];
                    tasForPertType.tasX.push(tasForPertType.xIndex);
                    tasForPertType.tasY.push(tas.tas);
                    tasForPertType.pert_id.push(tas.pert_id);
                    tasForPertType.pert_iname.push(tas.pert_iname);
                    tasForPertType.tasForPertId[tas.pert_id] = {
                        tasX: tasForPertType.xIndex,
                        tasY: tas.tas,
                        pert_iname: tas.pert_iname,
                        pert_type: tas.pert_type
                    };
                    tasForPertType.xIndex++;
                }
            });
            showTasChart(pertId, tasChartElt);
        })
    }
    else {
        showTasChart(pertId, tasChartElt);
    }
};

clue.getGutcResultByUrl = function (options) {
    var deferred = $.Deferred();
    var idSummary;
    var idCellSummary;
    var pclCell;
    var pclSummary;
    var promises = [];
    var p;
    if (options.pert_id_summary != null) {
        p = morpheus.DatasetUtil.read(options.pert_id_summary);
        promises.push(p);
        p.done(function (d) {
            idSummary = d;
        });
    }
    if (options.pert_id_cell != null) {
        p = morpheus.DatasetUtil.read(options.pert_id_cell);
        promises.push(p);
        p.done(function (d) {
            idCellSummary = d;
        });
    }
    if (options.pcl_cell != null) {
        p = morpheus.DatasetUtil.read(options.pcl_cell);
        promises.push(p);
        p.done(function (d) {
            pclCell = d;

        });
        p.fail(function (d) {
            console.log('Error reading PCL cell at ' + options.pcl_cell);
        });
    }
    if (options.pcl_summary != null) {
        p = morpheus.DatasetUtil.read(options.pcl_summary);
        promises.push(p);
        p.done(function (d) {
            pclSummary = d;
        });
        p.fail(function (d) {
            console.log('Error reading PCL summary at ' + options.pcl_summary);
        });
    }
    var annotationLines = null;
    if (options.columnInfo != null) {
        p = morpheus.Util.readLines(options.columnInfo);
        p.done(function (lines) {
            annotationLines = lines;
        });
    }
    var rowAnnotationLines = null;
    if (options.rowInfo != null) {
        p = morpheus.Util.readLines(options.rowInfo);
        p.done(function (lines) {
            rowAnnotationLines = lines;
        });
    }

    var queryName = null;
    if (options.config != null) {
        var nameDeferred = $.Deferred();
        p = $.ajax({
            url: options.config
        });
        p.done(function (text) {
            var lines = text.split('\n');
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (line.indexOf('rpt:') === 0) {
                    queryName = $.trim(line.substring(4));
                    break;
                }
            }
        });
        p.always(function () {
            nameDeferred.resolve();
        });
        promises.push(nameDeferred);
    }

    function addUniqueId(d) {
        var uniqueIdVector = d.getColumnMetadata()
            .add('_id');
        var idVector = d.getColumnMetadata()
            .getByName('id');
        var cellVector = d.getColumnMetadata()
            .getByName('cell_id');
        for (var i = 0, size = idVector.size(); i < size; i++) {
            uniqueIdVector.setValue(i, idVector.getValue(i) + '-' + cellVector.getValue(i));
        }
        return uniqueIdVector;
    }

    $.when
        .apply($, promises)
        .then(
            function () {
                var counter = 0;
                var cellDataset = null;

                if (idCellSummary) { // pert cell is in long form
                    var queryIdVectorLong = idCellSummary
                        .getColumnMetadata().getByName('id');
                    var pertIdVectorLong = idCellSummary
                        .getRowMetadata().getByName('id');
                    var cellIdVectorLong = idCellSummary
                        .getRowMetadata().add('cell_id');
                    var uniqueCells = new morpheus.Set();
                    var uniquePerts = new morpheus.Set();
                    for (var i = 0, nrows = idCellSummary.getRowCount(); i < nrows; i++) {
                        var id = pertIdVectorLong.getValue(i);
                        var index = id.lastIndexOf(':');
                        var cell = id.substring(index + 1);
                        id = id.substring(0, index);
                        pertIdVectorLong.setValue(i, id);
                        cellIdVectorLong.setValue(i, cell);
                        uniquePerts.add(id);
                        uniqueCells.add(cell);
                    }

                    if (idSummary) {
                        uniqueCells.add('summary');
                    }

                    cellDataset = new morpheus.Dataset({
                        name: '',
                        rows: uniquePerts.size(),
                        columns: uniqueCells.size()
                        * idCellSummary.getColumnCount()
                    });
                    var pertIdVector = cellDataset.getRowMetadata().add('id');
                    counter = 0;
                    uniquePerts.forEach(function (id) {
                        pertIdVector.setValue(counter++, id);
                    });

                    var cellVector = cellDataset.getColumnMetadata()
                        .add('cell_id');
                    var queryIdVector = cellDataset.getColumnMetadata()
                        .add('id');
                    var nqueries = idCellSummary.getColumnCount();
                    var cells = uniqueCells.values();
                    var ncells = cells.length;
                    for (var j = 0; j < nqueries; j++) {
                        var queryId = queryIdVectorLong
                            .getValue(j);
                        for (var i = 0, size = cellVector.size(); i < size; i++) {
                            cellVector.setValue(j * ncells + i,
                                cells[i]);
                            queryIdVector.setValue(j * ncells + i,
                                queryId);

                        }
                    }

                    var pertIdToIndex = morpheus.VectorUtil.createValueToIndexMap(pertIdVector);
                    var uniqueIdToIndex = morpheus.VectorUtil.createValueToIndexMap(addUniqueId(cellDataset));
                    morpheus.DatasetUtil.fill(cellDataset, NaN);
                    for (var j = 0; j < nqueries; j++) {
                        var queryId = queryIdVectorLong.getValue(j);
                        for (var i = 0, nrows = idCellSummary.getRowCount(); i < nrows; i++) {
                            var cellId = cellIdVectorLong.getValue(i);
                            var pertId = pertIdVectorLong.getValue(i);
                            var rowIndex = pertIdToIndex.get(pertId);
                            var columnIndex = uniqueIdToIndex.get(queryId + '-' + cellId);
                            cellDataset.setValue(rowIndex, columnIndex, idCellSummary.getValue(i, j));
                        }
                    }

                    if (idSummary) {
                        // query on columns, perts on rows
                        var cellIdVectorLong = idSummary.getRowMetadata().add('cell_id');
                        for (var i = 0, size = cellIdVectorLong.size(); i < size; i++) {
                            cellIdVectorLong.setValue(i, 'summary');
                        }
                        queryIdVectorLong = idSummary
                            .getColumnMetadata().getByName('id');
                        pertIdVectorLong = idSummary
                            .getRowMetadata().getByName('id');

                        for (var j = 0; j < nqueries; j++) {
                            var queryId = queryIdVectorLong.getValue(j);
                            for (var i = 0, nrows = idSummary.getRowCount(); i < nrows; i++) {
                                var cellId = cellIdVectorLong.getValue(i);
                                var pertId = pertIdVectorLong.getValue(i);
                                var rowIndex = pertIdToIndex.get(pertId);
                                var columnIndex = uniqueIdToIndex.get(queryId + '-' + cellId);
                                if (rowIndex === undefined) {
                                    throw 'error';
                                }
                                if (columnIndex === undefined) {
                                    throw 'error';
                                }
                                cellDataset.setValue(rowIndex, columnIndex, idSummary.getValue(i, j));
                            }
                        }
                    }
                } else if (idSummary) {
                    cellDataset = idSummary;
                    var cellVector = cellDataset.getColumnMetadata()
                        .add('cell_id');
                    for (var j = 0, size = cellVector.size(); j < size; j++) {
                        cellVector.setValue(j, 'summary');
                    }
                    addUniqueId(cellDataset);
                }

                // make sure pclSummary has pcls on rows
                if (pclSummary) {
                    if (pclSummary.getRowCount() === 1) {
                        pclSummary = new morpheus.TransposedDatasetView(
                            pclSummary);
                    }
                    var pclSummaryRowIds = pclSummary.getRowMetadata().getByName('id');
                    for (var i = 0; i < pclSummaryRowIds.size(); i++) {
                        var id = pclSummaryRowIds.getValue(i);
                        var index = id.lastIndexOf(':');
                        if (index !== -1) {
                            // e.g. CP_BETA_ADRENERGIC_RECEPTOR_AGONIST:SUMMLY
                            pclSummaryRowIds.setValue(i, id.substring(0, index));
                        }
                    }
                    var cellVector = pclSummary.getColumnMetadata().add('cell_id');
                    for (var j = 0, size = cellVector.size(); j < size; j++) {
                        cellVector.setValue(j, 'summary');
                    }

                    addUniqueId(pclSummary);
                }
                if (pclCell != null) {
                    // we want cell and query id on columns, pcl ids on rows, output currently is queries on
                    // columns, pcl:cell on rows
                    var pclIdVector = pclCell.getRowMetadata()
                        .getByName('id');
                    var pclCellVector = pclCell.getRowMetadata().add(
                        'cell_id');
                    // add cell_id
                    for (var i = 0, size = pclCellVector.size(); i < size; i++) {
                        var id = pclIdVector.getValue(i);
                        var index = id.lastIndexOf(':');
                        pclIdVector.setValue(i, id.substring(0, index));
                        pclCellVector.setValue(i, id
                            .substring(index + 1));
                    }
                    var doPivot = pclCell.getColumnCount() == 1 || pclCell.getColumnMetadata().getByName('id').getValue(0) !== 'CP_ATPASE_INHIBITOR';
                    if (doPivot) { // it's in
                        // long form
                        var uniquePcls = new morpheus.Set();
                        var uniqueCells = new morpheus.Set();
                        for (var i = 0, size = pclCellVector.size(); i < size; i++) {
                            var cell = pclCellVector.getValue(i);
                            var id = pclIdVector.getValue(i);
                            uniqueCells.add(cell);
                            var pcl = pclIdVector.getValue(i);
                            uniquePcls.add(pcl);
                        }
                        var nqueries = pclCell.getColumnCount();
                        var pivotedDataset = new morpheus.Dataset({
                            name: '',
                            rows: uniquePcls.size(),
                            columns: uniqueCells.size() * nqueries
                        });
                        morpheus.DatasetUtil.fill(pivotedDataset, NaN);
                        // pcl ids on rows
                        var pivotedRowIdVector = pivotedDataset
                            .getRowMetadata().add('id');
                        counter = 0;
                        uniquePcls.forEach(function (pcl) {
                            pivotedRowIdVector.setValue(counter++, pcl);
                        });
                        var pclIdToIndex = morpheus.VectorUtil.createValueToIndexMap(pivotedRowIdVector);
                        var pivotedColumnIdVector = pivotedDataset
                            .getColumnMetadata().add('id'); // query id
                        var pivotedColumnCellIdVector = pivotedDataset
                            .getColumnMetadata().add('cell_id');

                        var queryIdVector = pclCell.getColumnMetadata().getByName('id');
                        var cellArray = uniqueCells.values();
                        counter = 0;
                        for (var j = 0; j < nqueries; j++) {
                            var queryId = queryIdVector.getValue(j);
                            for (var i = 0; i < cellArray.length; i++) {
                                var cellId = cellArray[i];
                                pivotedColumnIdVector.setValue(counter, queryId);
                                pivotedColumnCellIdVector.setValue(counter, cellId);
                                counter++;
                            }
                        }

                        var uniqueIdToIndex = morpheus.VectorUtil.createValueToIndexMap(addUniqueId(pivotedDataset));
                        for (var j = 0; j < nqueries; j++) {
                            var queryId = queryIdVector.getValue(j);
                            for (var i = 0, size = pclCellVector.size(); i < size; i++) {
                                var cell = pclCellVector.getValue(i);
                                var columnIndex = uniqueIdToIndex.get(queryId + '-' + cell);
                                var rowIndex = pclIdToIndex.get(pclIdVector
                                    .getValue(i));
                                pivotedDataset
                                    .setValue(rowIndex, columnIndex,
                                        pclCell.getValue(i, j));
                            }
                        }
                        pclCell = pivotedDataset;
                    } else {
                        pclCell = new morpheus.TransposedDatasetView(
                            pclCell);
                        addUniqueId(pclCell);
                    }
                    if (pclSummary != null) {
                        // add summary column to PCL cell by joining by pert id
                        pclCell = new morpheus.TransposedDatasetView(
                            new morpheus.JoinedDataset(
                                new morpheus.TransposedDatasetView(
                                    pclCell),
                                new morpheus.TransposedDatasetView(
                                    pclSummary), 'id', 'id'));
                    }
                    var pclPertTypeVector = pclCell.getRowMetadata()
                        .add('type');
                    for (var i = 0, size = pclPertTypeVector.size(); i < size; i++) {
                        pclPertTypeVector.setValue(i, 'PCL');
                    }

                    // merge gutc and PCL results
                    cellDataset = cellDataset ? new morpheus.JoinedDataset(
                        cellDataset, pclCell, '_id', '_id')
                        : pclCell;
                } else if (pclSummary != null) {
                    cellDataset = cellDataset ? new morpheus.JoinedDataset(
                        cellDataset, pclSummary, 'id', 'id')
                        : pclSummary;
                }

                var sourceIndex = morpheus.MetadataUtil.indexOf(
                    cellDataset.getRowMetadata(), 'Source');
                if (sourceIndex !== -1) {
                    cellDataset.getRowMetadata().remove(sourceIndex);
                }

                var mergedDataset = cellDataset;
                var pertDoseVector = mergedDataset.getColumnMetadata()
                    .getByName('pert_idose');
                if (pertDoseVector) {
                    var regex = /um/;
                    for (var i = 0, size = pertDoseVector.size(); i < size; i++) {
                        var value = '' + pertDoseVector.getValue(i);
                        pertDoseVector.setValue(i, value.replace('um',
                            '\u00B5m'));
                    }
                }
                if (annotationLines) {
                    new morpheus.OpenFileTool().annotate(
                        annotationLines, mergedDataset, true, null,
                        'id', annotationLines[0].split(/\t/)[0], null);
                }
                if (rowAnnotationLines) {
                    new morpheus.OpenFileTool().annotate(
                        rowAnnotationLines, mergedDataset, false, null,
                        'id', rowAnnotationLines[0].split(/\t/)[0], null);
                }

                if (queryName != null) {
                    var nameVector = mergedDataset.getColumnMetadata()
                        .getByName('name');

                    if (!nameVector) {
                        nameVector = mergedDataset.getColumnMetadata()
                            .add('name');
                    }

                    for (var j = 0; j < nameVector.size(); j++) {
                        nameVector.setValue(j, queryName);
                    }

                }
                // remove columns that contain missing values only
                var columns = [];
                for (var j = 0, ncols = mergedDataset.getColumnCount(); j < ncols; j++) {
                    for (var i = 0, nrows = mergedDataset.getRowCount(); i < nrows; i++) {
                        if (!isNaN(mergedDataset.getValue(i, j))) {
                            columns.push(j);
                            break;
                        }
                    }
                }
                mergedDataset = columns.length !== mergedDataset
                    .getColumnCount() ? new morpheus.SlicedDatasetView(
                    mergedDataset, null, columns)
                    : mergedDataset;
                var tmp = mergedDataset.getColumnMetadata().getByName('_id');
                if (tmp) {
                    tmp.setName('id');
                }
                var tmp = mergedDataset.getColumnMetadata().getByName('id');
                if (tmp) {
                    tmp.setName('_id');
                }
                deferred.resolve(mergedDataset);

            },
            function (err) {
                console.log('Unable to read GUTC results. Error: '
                    + err);
                deferred.reject('Unable to read GUTC results.');
            }
        );
    return deferred.promise();
};

clue.newPlot = function (myPlot, traces, layout, config) {
    Plotly.newPlot(myPlot, traces, layout, config);
    var $a = $('<a data-toggle="tooltip" title="Toggle mode bar" href="#" style="fill: rgb(68,' +
        ' 122,' +
        ' 219);position:' +
        ' absolute;top:' +
        ' -2px;right:-6px;z-index:' +
        ' 1002;"><svg height="1em" width="1em" viewBox="0 0 1542 1000"><path d="m0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a>');
    var $myPlot = $(myPlot);
    $a.appendTo($myPlot);
    var $modeBar = $(myPlot).find('.modebar');
    $modeBar.css('display', 'none');
    $a.on('click', function (e) {
        e.preventDefault();
        $modeBar.toggle();
    });
};

clue.getPlotlyDefaults2 = function () {
    var plotly = clue.getPlotlyDefaults();
    plotly.layout.width = 600;
    plotly.layout.height = 600;
    plotly.layout.margin = {
        l: 40,
        r: 10,
        t: 40,
        b: 40,
        autoexpand: true
    };
    delete plotly.config.displayModeBar;
    return plotly;
};

clue.BUTTONS_TO_REMOVE_FOR_STATIC_CHART = ['select2d', 'lasso2d']; // ['zoom2d', 'pan2d', 'select2d', 'lasso2d', 'autoScale2d', 'resetScale2d'];
clue.getPlotlyDefaults = function () {
    var layout = {
        hovermode: 'closest',
        autosize: true,
        // paper_bgcolor: 'rgb(255,255,255)',
        // plot_bgcolor: 'rgb(229,229,229)',
        showlegend: false,
        margin: {
            l: 80,
            r: 10,
            t: 8, // leave space for modebar
            b: 14,
            autoexpand: true
        },
        titlefont: {
            size: 12
        },
        xaxis: {
            zeroline: false,
            titlefont: {
                size: 12
            },
            // gridcolor: 'rgb(255,255,255)',
            showgrid: true,
            //   showline: true,
            showticklabels: true,
            tickcolor: 'rgb(127,127,127)',
            ticks: 'outside'
        },
        yaxis: {
            zeroline: false,
            titlefont: {
                size: 12
            },
            // gridcolor: 'rgb(255,255,255)',
            showgrid: true,
            //   showline: true,
            showticklabels: true,
            tickcolor: 'rgb(127,127,127)',
            ticks: 'outside'
        }
    };

    // var toImage = {
    //   name: 'toImage',
    //   title: 'Download plot as a svg',
    //   icon: Icons.camera,
    //   click: function (gd) {
    //     var format = 'svg';
    //     Lib.notifier('Taking snapshot - this may take a few seconds', 'long');
    //     downloadImage(gd, {'format': format})
    //     .then(function (filename) {
    //       Lib.notifier('Snapshot succeeded - ' + filename, 'long');
    //     })
    //     .catch(function () {
    //       Lib.notifier('Sorry there was a problem downloading your snapshot!', 'long');
    //     });
    //   }
    // };
    var config = {
        modeBarButtonsToAdd: [],
        showLink: false,
        displayModeBar: true, // always show modebar
        displaylogo: false,
        staticPlot: false,
        showHints: true,
        modeBarButtonsToRemove: ['sendDataToCloud', 'zoomIn2d', 'zoomOut2d', 'hoverCompareCartesian', 'hoverClosestCartesian']
    };
    return {
        layout: layout,
        config: config
    };
};

/* ========================================================================
 * Bootstrap (plugin): validator.js v0.9.0
 * ========================================================================
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Cina Saffary.
 * Made by @1000hz in the style of Bootstrap 3 era @fat
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * ======================================================================== */


+function ($) {
    'use strict';

    // VALIDATOR CLASS DEFINITION
    // ==========================

    var Validator = function (element, options) {
        this.$element = $(element)
        this.options  = options

        options.errors = $.extend({}, Validator.DEFAULTS.errors, options.errors)

        for (var custom in options.custom) {
            if (!options.errors[custom]) throw new Error('Missing default error message for custom validator: ' + custom)
        }

        $.extend(Validator.VALIDATORS, options.custom)

        this.$element.attr('novalidate', true) // disable automatic native validation
        this.toggleSubmit()

        this.$element.on('input.bs.validator change.bs.validator focusout.bs.validator', $.proxy(this.validateInput, this))
        this.$element.on('submit.bs.validator', $.proxy(this.onSubmit, this))

        this.$element.find('[data-match]').each(function () {
            var $this  = $(this)
            var target = $this.data('match')

            $(target).on('input.bs.validator', function (e) {
                $this.val() && $this.trigger('input.bs.validator')
            })
        })
    }

    Validator.INPUT_SELECTOR = ':input:not([type="submit"], button):enabled:visible'

    Validator.DEFAULTS = {
        delay: 500,
        html: false,
        disable: true,
        custom: {},
        errors: {
            match: 'Does not match',
            minlength: 'Not long enough'
        },
        feedback: {
            success: 'glyphicon-ok',
            error: 'glyphicon-remove'
        }
    }

    Validator.VALIDATORS = {
        'native': function ($el) {
            var el = $el[0]
            return el.checkValidity ? el.checkValidity() : true
        },
        'match': function ($el) {
            var target = $el.data('match')
            return !$el.val() || $el.val() === $(target).val()
        },
        'minlength': function ($el) {
            var minlength = $el.data('minlength')
            return !$el.val() || $el.val().length >= minlength
        }
    }

    Validator.prototype.validateInput = function (e) {
        var $el        = $(e.target)
        var prevErrors = $el.data('bs.validator.errors')
        var errors

        if ($el.is('[type="radio"]')) $el = this.$element.find('input[name="' + $el.attr('name') + '"]')

        this.$element.trigger(e = $.Event('validate.bs.validator', {relatedTarget: $el[0]}))

        if (e.isDefaultPrevented()) return

        var self = this

        this.runValidators($el).done(function (errors) {
            $el.data('bs.validator.errors', errors)

            errors.length ? self.showErrors($el) : self.clearErrors($el)

            if (!prevErrors || errors.toString() !== prevErrors.toString()) {
                e = errors.length
                    ? $.Event('invalid.bs.validator', {relatedTarget: $el[0], detail: errors})
                    : $.Event('valid.bs.validator', {relatedTarget: $el[0], detail: prevErrors})

                self.$element.trigger(e)
            }

            self.toggleSubmit()

            self.$element.trigger($.Event('validated.bs.validator', {relatedTarget: $el[0]}))
        })
    }


    Validator.prototype.runValidators = function ($el) {
        var errors   = []
        var deferred = $.Deferred()
        var options  = this.options

        $el.data('bs.validator.deferred') && $el.data('bs.validator.deferred').reject()
        $el.data('bs.validator.deferred', deferred)

        function getErrorMessage(key) {
            return $el.data(key + '-error')
                || $el.data('error')
                || key == 'native' && $el[0].validationMessage
                || options.errors[key]
        }

        $.each(Validator.VALIDATORS, $.proxy(function (key, validator) {
            if (($el.data(key) || key == 'native') && !validator.call(this, $el)) {
                var error = getErrorMessage(key)
                !~errors.indexOf(error) && errors.push(error)
            }
        }, this))

        if (!errors.length && $el.val() && $el.data('remote')) {
            this.defer($el, function () {
                var data = {}
                data[$el.attr('name')] = $el.val()
                $.get($el.data('remote'), data)
                    .fail(function (jqXHR, textStatus, error) { errors.push(getErrorMessage('remote') || error) })
                    .always(function () { deferred.resolve(errors)})
            })
        } else deferred.resolve(errors)

        return deferred.promise()
    }

    Validator.prototype.validate = function () {
        var delay = this.options.delay

        this.options.delay = 0
        this.$element.find(Validator.INPUT_SELECTOR).trigger('input.bs.validator')
        this.options.delay = delay

        return this
    }

    Validator.prototype.showErrors = function ($el) {
        var method = this.options.html ? 'html' : 'text'

        this.defer($el, function () {
            var $group = $el.closest('.form-group')
            var $block = $group.find('.help-block.with-errors')
            var $feedback = $group.find('.form-control-feedback')
            var errors = $el.data('bs.validator.errors')

            if (!errors.length) return

            errors = $('<ul/>')
                .addClass('list-unstyled')
                .append($.map(errors, function (error) { return $('<li/>')[method](error) }))

            $block.data('bs.validator.originalContent') === undefined && $block.data('bs.validator.originalContent', $block.html())
            $block.empty().append(errors)
            $group.addClass('has-error')

            $feedback.length
            && $feedback.removeClass(this.options.feedback.success)
            && $feedback.addClass(this.options.feedback.error)
            && $group.removeClass('has-success')
        })
    }

    Validator.prototype.clearErrors = function ($el) {
        var $group = $el.closest('.form-group')
        var $block = $group.find('.help-block.with-errors')
        var $feedback = $group.find('.form-control-feedback')

        $block.html($block.data('bs.validator.originalContent'))
        $group.removeClass('has-error')

        $feedback.length
        && $feedback.removeClass(this.options.feedback.error)
        && $feedback.addClass(this.options.feedback.success)
        && $group.addClass('has-success')
    }

    Validator.prototype.hasErrors = function () {
        function fieldErrors() {
            return !!($(this).data('bs.validator.errors') || []).length
        }

        return !!this.$element.find(Validator.INPUT_SELECTOR).filter(fieldErrors).length
    }

    Validator.prototype.isIncomplete = function () {
        function fieldIncomplete() {
            return this.type === 'checkbox' ? !this.checked                                   :
                this.type === 'radio'    ? !$('[name="' + this.name + '"]:checked').length :
                $.trim(this.value) === ''
        }

        return !!this.$element.find(Validator.INPUT_SELECTOR).filter('[required]').filter(fieldIncomplete).length
    }

    Validator.prototype.onSubmit = function (e) {
        this.validate()
        if (this.isIncomplete() || this.hasErrors()) e.preventDefault()
    }

    Validator.prototype.toggleSubmit = function () {
        if(!this.options.disable) return

        var $btn = $('button[type="submit"], input[type="submit"]')
            .filter('[form="' + this.$element.attr('id') + '"]')
            .add(this.$element.find('input[type="submit"], button[type="submit"]'))

        $btn.toggleClass('disabled', this.isIncomplete() || this.hasErrors())
    }

    Validator.prototype.defer = function ($el, callback) {
        callback = $.proxy(callback, this)
        if (!this.options.delay) return callback()
        window.clearTimeout($el.data('bs.validator.timeout'))
        $el.data('bs.validator.timeout', window.setTimeout(callback, this.options.delay))
    }

    Validator.prototype.destroy = function () {
        this.$element
            .removeAttr('novalidate')
            .removeData('bs.validator')
            .off('.bs.validator')

        this.$element.find(Validator.INPUT_SELECTOR)
            .off('.bs.validator')
            .removeData(['bs.validator.errors', 'bs.validator.deferred'])
            .each(function () {
                var $this = $(this)
                var timeout = $this.data('bs.validator.timeout')
                window.clearTimeout(timeout) && $this.removeData('bs.validator.timeout')
            })

        this.$element.find('.help-block.with-errors').each(function () {
            var $this = $(this)
            var originalContent = $this.data('bs.validator.originalContent')

            $this
                .removeData('bs.validator.originalContent')
                .html(originalContent)
        })

        this.$element.find('input[type="submit"], button[type="submit"]').removeClass('disabled')

        this.$element.find('.has-error').removeClass('has-error')

        return this
    }

    // VALIDATOR PLUGIN DEFINITION
    // ===========================


    function Plugin(option) {
        return this.each(function () {
            var $this   = $(this)
            var options = $.extend({}, Validator.DEFAULTS, $this.data(), typeof option == 'object' && option)
            var data    = $this.data('bs.validator')

            if (!data && option == 'destroy') return
            if (!data) $this.data('bs.validator', (data = new Validator(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.validator

    $.fn.validator             = Plugin
    $.fn.validator.Constructor = Validator


    // VALIDATOR NO CONFLICT
    // =====================

    $.fn.validator.noConflict = function () {
        $.fn.validator = old
        return this
    }


    // VALIDATOR DATA-API
    // ==================

    $(window).on('load', function () {
        $('form[data-toggle="validator"]').each(function () {
            var $form = $(this)
            Plugin.call($form, $form.data())
        })
    })

}(jQuery);
/**
 * Created by andrew on 1/27/16.
 */

/**
 * Created by turner on 9/9/15.
 */
var scarpa = (function (scarpa) {
    scarpa.initializeAppMenu = function(webAppCards, scientificProjectCards) {

        var $appMenuModal,
            $app_menu_section_labels,
            $app_menu_sections,
            webAppCardsPresentationList;

        webAppCardsPresentationList = _.sortBy(webAppCards, 'abbreviation');

        //_.each(webAppCardsPresentationList, function(card){
        //    console.log(card.title + ' ' + card.abbreviation + ' icon ' + card.icon_url);
        //});

        $app_menu_section_labels = $('.app-menu-section-label');

        $app_menu_sections = $( "div[id^='app_menu_title_']" );

        $appMenuModal = $('#appMenuModal');

        scarpa.hideAppMenuSections = function () {
            $app_menu_sections.hide();
        };

        scarpa.showAppMenuSectionWithName = function (name) {

            var str = '#' + name,
                $menuSection = $(str);

            scarpa.hideAppMenuSections();

            if ($menuSection.length > 0) {
                $menuSection.show();
            }

        };

        scarpa.hideAppMenuSections();

        buildWebAppsSubMenu($('#app_menu_title_web_apps_items'), webAppCardsPresentationList);

        function isFlagshipTier(tierNumber) {
            return tierNumber == 1;
        }

        function isLowestTier(tierNumber) {
            return tierNumber == 0 || tierNumber > 2;
        }

        function buildCardDiv(card,tierNumber) {
            var imageWidth,containerColumnClass;
            var isFlagship = isFlagshipTier(tierNumber);
            var isBottomTier = isLowestTier(tierNumber);

            if (isFlagship) {
                imageWidth = "72px";
                containerColumnClass = "flagship-card";
            }
            else {
                imageWidth = "42px";
                containerColumnClass = "launchedapp-card";
            }

            var appLink = $('<a class="app-card" >');
            appLink.attr('href',card.url);
            var appName = $('<div class="text-center">');
            var appText = $('<div class="text-center appText">');


            if (isFlagship) {
                appName.addClass("flagship-app-name");
            }
            else {
                appName.addClass("launched-app-name");
            }
            if (isBottomTier) {
                appName.css('padding-top','0');
                appName.css('width','300px');
            }
            appName.html(card.title);
            var appContainer = $('<div class="flex-center app-container">');

            if (isFlagship) {
                appContainer.addClass(containerColumnClass);
            }
            if (isBottomTier) {
                appContainer.css('padding','0');
            }
            var appIcon = $('<img class="flex-center">');
            appIcon.css("width",imageWidth);
            appIcon.css("height",imageWidth);
            appIcon.attr('src',card.icon_url);

            if (card.icon_hover_url) {
                appLink.hover(function () {
                        appIcon.attr('src', card.icon_hover_url);
                    },
                    function () {
                        appIcon.attr('src', card.icon_url);
                    });
            }

            var isQuery = $(appName).text().indexOf('QUERY') > -1;
            var isTouchstone = $(appName).text().indexOf('Touchstone') > -1;

            if (isQuery){
                appText.append( "Find perturbagens <br/>that give rise to expression signatures similar to yours" );
            }
            if (isTouchstone) {
                appText.append( "Explore the Touchstone <br/>reference dataset of 8,870 expression signatures" );
            }

            if (!isLowestTier(tierNumber)) {
                appLink.append(appIcon);
                appLink.append(appName).append(appText);
            }
            if (isLowestTier(tierNumber)) {
                appLink.append(appName);
            }
            appContainer.append(appLink);

            return appContainer;
        }

        function buildAppTier(appCards,tierNumber) {
            var isFlagship = isFlagshipTier(tierNumber);
            var isBottomTier = isLowestTier(tierNumber);
            var numAppsPerRow = 3;
            if (isBottomTier) {
                numAppsPerRow = 1;
            }
            var appsSection = $('<div class="appTier">');
            var appRow = $('<div class="appRow">');
            var isPartialRow = false;
            appCards.forEach(function(card,index) {
                if (!isFlagship) {
                    if (index % numAppsPerRow == 0) {
                        appsSection.append($('<div class="flex-even">').append(appRow));
                        appRow = $('<div class="appRow">');
                        isPartialRow = false;
                    }
                }
                appRow.append(buildCardDiv(card,tierNumber));
                isPartialRow = true;
            });
            if (isPartialRow) {
                appsSection.append($('<div class="flex-center">').append(appRow));
            }
            return appsSection;
        }

        function buildWebAppsSubMenu($column_container, cards) {
            if (cards.length > 0) {
                // three tiers: flagship, tier2, and other
                var flagshipCards = cards.filter(function(card) {
                    return card.app_tier == 1;
                });
                var tier2Cards = cards.filter(function(card) {
                    return card.app_tier == 2;
                });
                var lowerTierCards = cards.filter(function(card) {
                    return (card.app_tier != 1 && card.app_tier != 2);
                });

                var flagshipTier = buildAppTier(flagshipCards,1);
                var row2Tier = buildAppTier(tier2Cards,2);
                var bottomTier = buildAppTier(lowerTierCards,3);




                if (flagshipCards.length > 0) {
                    $column_container.append(flagshipTier);

                }

                if (tier2Cards.length > 0) {
                    var hr = $("<hr>").addClass("app-menu-hr2")
                    $column_container.append(row2Tier);
                    $column_container.append(hr);
                }
                if (lowerTierCards.length > 0) {
                    $column_container.append(bottomTier);
                }

            }
        }

        function resetMenuSectionSelection() {
            _.each($app_menu_section_labels,function(appElt,index,appLabel) {
                $(appElt).removeClass('app-menu-section-label-selected');
            });
        }

        function buildNotLoggedInMenuContent() {
            var notLoggedInOverlayClass = "notLoggedInOverlay";
            var appsContent = $('#app_menu_title_web_apps_items');
            if (!scarpa.isLoggedIn()) {
                if ($('#app_menu_title_web_apps_items .' + notLoggedInOverlayClass).length == 0) {

                    var notLoggedInDiv =
                        '<div class="' + notLoggedInOverlayClass +'">' +
                        '<div style="font-size:34px; font-weight:100; margin-top:60px;">' +
                        'Please Login' +
                        '</div>' +
                        '<div style="font-size:14px;font-weight: 300;line-height: 22px;margin-top:12px;"> <a class="loginFromMenuModal">Login with your clue.io account<br/>to access the apps</a></div>' +
                        '</div>';
                    appsContent.addClass('col-xs-12');
                    appsContent.append(notLoggedInDiv);
                }
            }
            else {
                appsContent.removeClass('col-xs-12');
                $('.' + notLoggedInOverlayClass).remove();
            }

            // todo arz rip this out if/when we deploy menu modal v3
            $('.loginFromMenuModal').on('click',function(evt) {
                evt.preventDefault();
                $('#appMenuModal').modal('hide');
                $('#loginModal').modal('show');
            });
        }

        function buildScientificProjectsSubMenu($column_container, cards) {

            _.each(cards, function(card) {

                var $row = $('<div>');

                var $col_xs_12,
                    $a_container,
                    $link_label_container,
                    $a;

                $link_label_container = $('<div>');
                $link_label_container.html(card.title);

                $a = $('<a>');
                $a.attr("href", card.url);
                $a.append($link_label_container[ 0 ]);

                $a_container = $('<div>');
                $a_container.append($a[ 0 ]);

                // .col-xs-12
                $col_xs_12 = $('<div class="col-xs-12">');
                $col_xs_12.append($a_container[ 0 ]);

                $row.append($col_xs_12[ 0 ]);

                $column_container.append($row[ 0 ]);

            });

        }

        $appMenuModal.on('shown.bs.modal', function (e) {
            resetMenuSectionSelection();

            var name,
                $webAppMenuSection;

            $webAppMenuSection = $app_menu_section_labels.filter(function(){

                var value = $(this).attr('data-app-menu-section');

                return value === 'app_menu_title_web_apps_items';
            });

            $webAppMenuSection.addClass('app-menu-section-label-selected');
            name = $webAppMenuSection.attr('data-app-menu-section');
            scarpa.showAppMenuSectionWithName(name);
            buildNotLoggedInMenuContent();
        });

        $appMenuModal.on('hidden.bs.modal', function (e) {
            resetMenuSectionSelection();
            scarpa.hideAppMenuSections();
        });


        // attach 'show menu' mouse handlers to each app menu section
        $app_menu_section_labels.on('click', function(){

            $app_menu_section_labels.removeClass('app-menu-section-label-selected');

            $(this).removeClass('app-menu-section-label-unselected');
            $(this).addClass('app-menu-section-label-selected');

            scarpa.showAppMenuSectionWithName( $(this).data('appMenuSection') );
        });

        //$app_menu_section_labels.on('mouseout', function(){
        //    $(this).removeClass('app-menu-section-label-selected');
        //    $(this).addClass('app-menu-section-label-unselected');
        //});

    };

    scarpa.clueAppLaunch = function (success, failure) {

        clue.getUserKey(function() {

            if(scarpa.isLoggedIn())
            {
                clue.getApps(function(err, appResults){

                    if(err)
                    {
                        failure('getApps - error');
                    }
                    else
                    {
                        if (!appResults.cards) {
                            appResults.cards = [];
                        }
                        appResults.cards.sort(sort_by('title', false, function(a){return a.toUpperCase()}));
                    }
                });
            }

        }, function() {
            redirectToSignout();
            failure('getUserKey - error');
        });
    };

    scarpa.appLaunch = function (continuation) {

        var user_id = clue.getUserName() || 'Login';
        $('#login').html(user_id);

        scarpa.clueAppLaunch(function (appsAndScientificProjects) {

            scarpa.apps = appsAndScientificProjects.ap;

            scarpa.initializeAppMenu(appsAndScientificProjects.ap.cards, appsAndScientificProjects.sc);

            if (continuation) {
                continuation();
            }

        }, function(errorMessage) {
            console.log('clueAppLaunch - ' + errorMessage);
        });


        if (scarpa.isLoggedIn()) {
            var logoutIfCookieExpired = function() {
                if (!scarpa.isLoggedIn()) {
                    redirectToSignout();
                    clearInterval(logoutJob);
                }
            };
            var logoutJob = setInterval(logoutIfCookieExpired,5 * 1000);
        }

    };

    scarpa.isLoggedIn = function() {
        return clue.getUserName() !== undefined && clue.getUserInfo() !== undefined;
    };

    // Rajiv Narayan's data
    scarpa.touchstone_root_directory = "data.clue.io/tsv2/digests";
    scarpa.s3_root = "//s3.amazonaws.com/";

    scarpa.transcriptionalImpactScoreBins =
    {
        high:
        {
            low: 0.66,
            high: 1.00
        },
        medium:
        {
            low: 0.33,
            high: 0.66
        },
        low:
        {
            low: 0.00,
            high: 0.33
        }
    };

    scarpa.perturbagenTypeList = [ "oe", "kd", "cp" ];

    scarpa.perturbagenTypes =
    {
        "trt_oe":"oe",
        "trt_sh.cgs":"kd",
        "trt_cp":"cp"
    };

    scarpa.perturbagenTypeLabels = _.invert(scarpa.perturbagenTypes);

    scarpa.perturbagenIdentifierColors =
    {
        combined:"#aaaaaa",

        trt_oe:"#2AB9E6",
        oe:"#2AB9E6",
        OE:"#2AB9E6",

        "trt_sh.cgs":"#C355CA",
        kd:"#C355CA",
        KD:"#C355CA",

        trt_cp:"#F5A623",
        cp:"#F5A623",
        CP:"#F5A623"
    };

    scarpa.cellLineIdentifiers = [ "A375", "A549", "HCC515", "HEPG2", "HT29", "MCF7", "PC3" , "HA1E", "VCAP" ];

    scarpa.isCompoundPerturbagen = function (type) {
        return type === 'cp' || type === 'trt_cp';
    };

    scarpa.isOverExpressionPerturbagen = function (type) {
        return type === 'oe' || type === 'trt_oe';
    };

    scarpa.isKnockDownPerturbagen = function (type) {
        return type === 'kd' || type === 'trt_sh.cgs';
    };

    scarpa.capitalizeFirstLetter = function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };

    scarpa.prettyNumber = function (rawNumber) {

        var dec = String(rawNumber).split(/[.,]/),
            sep = ',',
            decsep = '.';

        return dec[0].split('').reverse().reduce(function (prev, now, i) {
                return i % 3 === 0 ? prev + sep + now : prev + now;
            }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');
    };

    scarpa.ellipsisStringWithLength = function(str, length) {
        return (str.length > length) ? str.substr(0, length - 1) + " ..." : str;
    };

    scarpa.regularExpressionsWithSearchQuery = function (query){

        var REs = [],
            commas = [],
            parts = [],
            quotedRE,
            disassembled;

        quotedRE = new RegExp('"[^"]*"');

        // single quoted query is the RE. Return that.
        if (quotedRE.test(query)) {
            disassembled = query.split('"');
            return [ new RegExp(disassembled[ 1 ], 'i') ];
        }

        // list of comma separated terms
        _.each(query.split(','), function(q){
            commas.push( $.trim(q) );
        });

        // include white space separated terms
        _.each(commas, function(c){
            var cc = [];

            _.each(c.split(' '), function(piece) {
                cc.push($.trim(piece));
            });

            Array.prototype.push.apply(parts, cc);
        });

        // build RE for each term
        _.each(parts, function(p){
            REs.push( new RegExp(p, 'i') );
        });

        return REs;
    };

    // get the property from any css class that is UNASSIGNED to an element.
    scarpa.cssPropertyWithPropertyNameAndClassName = function (property, cssClassName) {

        var $inspector = $("<div>").css('display', 'none').addClass(cssClassName);

        $("body").append($inspector);

        try {
            return $inspector.css(property);
        } finally {
            $inspector.remove();
        }
    };

    return scarpa;
})(scarpa || {});

var sort_by = function(field, reverse, primer){

    var key = primer ?
        function(x) {return primer(x[field])} :
        function(x) {return x[field]};

    reverse = !reverse ? 1 : -1;

    return function (a, b) {
        return a = key(a), b = key(b), reverse * ((a > b) - (b > a));
    }
};

var redirectToSignout = function() {
    window.location= location.protocol+'//'+location.hostname+(location.port ? ':'+location.port: '') + "/signout";
};

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.async=e.async||{})}(this,function(exports){"use strict";function apply(e,t,r){switch(r.length){case 0:return e.call(t);case 1:return e.call(t,r[0]);case 2:return e.call(t,r[0],r[1]);case 3:return e.call(t,r[0],r[1],r[2])}return e.apply(t,r)}function overRest$1(e,t,r){return t=nativeMax(void 0===t?e.length-1:t,0),function(){for(var n=arguments,o=-1,i=nativeMax(n.length-t,0),a=Array(i);++o<i;)a[o]=n[t+o];o=-1;for(var s=Array(t+1);++o<t;)s[o]=n[o];return s[t]=r(a),apply(e,this,s)}}function identity(e){return e}function rest(e,t){return overRest$1(e,t,identity)}function isObject(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}function asyncify(e){return initialParams(function(t,r){var n;try{n=e.apply(this,t)}catch(e){return r(e)}isObject(n)&&"function"==typeof n.then?n.then(function(e){r(null,e)},function(e){r(e.message?e:new Error(e))}):r(null,n)})}function supportsAsync(){var supported;try{supported=isAsync(eval("(async function () {})"))}catch(e){supported=!1}return supported}function isAsync(e){return supportsSymbol&&"AsyncFunction"===e[Symbol.toStringTag]}function wrapAsync(e){return isAsync(e)?asyncify(e):e}function applyEach$1(e){return rest(function(t,r){var n=initialParams(function(r,n){var o=this;return e(t,function(e,t){wrapAsync$1(e).apply(o,r.concat(t))},n)});return r.length?n.apply(this,r):n})}function getRawTag(e){var t=hasOwnProperty.call(e,symToStringTag$1),r=e[symToStringTag$1];try{e[symToStringTag$1]=void 0;var n=!0}catch(e){}var o=nativeObjectToString.call(e);return n&&(t?e[symToStringTag$1]=r:delete e[symToStringTag$1]),o}function objectToString(e){return nativeObjectToString$1.call(e)}function baseGetTag(e){return null==e?void 0===e?undefinedTag:nullTag:(e=Object(e),symToStringTag&&symToStringTag in e?getRawTag(e):objectToString(e))}function isFunction(e){if(!isObject(e))return!1;var t=baseGetTag(e);return t==funcTag||t==genTag||t==asyncTag||t==proxyTag}function isLength(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=MAX_SAFE_INTEGER}function isArrayLike(e){return null!=e&&isLength(e.length)&&!isFunction(e)}function noop(){}function once(e){return function(){if(null!==e){var t=e;e=null,t.apply(this,arguments)}}}function baseTimes(e,t){for(var r=-1,n=Array(e);++r<e;)n[r]=t(r);return n}function isObjectLike(e){return null!=e&&"object"==typeof e}function baseIsArguments(e){return isObjectLike(e)&&baseGetTag(e)==argsTag}function stubFalse(){return!1}function isIndex(e,t){return t=null==t?MAX_SAFE_INTEGER$1:t,!!t&&("number"==typeof e||reIsUint.test(e))&&e>-1&&e%1==0&&e<t}function baseIsTypedArray(e){return isObjectLike(e)&&isLength(e.length)&&!!typedArrayTags[baseGetTag(e)]}function baseUnary(e){return function(t){return e(t)}}function arrayLikeKeys(e,t){var r=isArray(e),n=!r&&isArguments(e),o=!r&&!n&&isBuffer(e),i=!r&&!n&&!o&&isTypedArray(e),a=r||n||o||i,s=a?baseTimes(e.length,String):[],c=s.length;for(var u in e)!t&&!hasOwnProperty$1.call(e,u)||a&&("length"==u||o&&("offset"==u||"parent"==u)||i&&("buffer"==u||"byteLength"==u||"byteOffset"==u)||isIndex(u,c))||s.push(u);return s}function isPrototype(e){var t=e&&e.constructor,r="function"==typeof t&&t.prototype||objectProto$5;return e===r}function overArg(e,t){return function(r){return e(t(r))}}function baseKeys(e){if(!isPrototype(e))return nativeKeys(e);var t=[];for(var r in Object(e))hasOwnProperty$3.call(e,r)&&"constructor"!=r&&t.push(r);return t}function keys(e){return isArrayLike(e)?arrayLikeKeys(e):baseKeys(e)}function createArrayIterator(e){var t=-1,r=e.length;return function(){return++t<r?{value:e[t],key:t}:null}}function createES2015Iterator(e){var t=-1;return function(){var r=e.next();return r.done?null:(t++,{value:r.value,key:t})}}function createObjectIterator(e){var t=keys(e),r=-1,n=t.length;return function(){var o=t[++r];return r<n?{value:e[o],key:o}:null}}function iterator(e){if(isArrayLike(e))return createArrayIterator(e);var t=getIterator(e);return t?createES2015Iterator(t):createObjectIterator(e)}function onlyOnce(e){return function(){if(null===e)throw new Error("Callback was already called.");var t=e;e=null,t.apply(this,arguments)}}function _eachOfLimit(e){return function(t,r,n){function o(e,t){if(c-=1,e)s=!0,n(e);else{if(t===breakLoop||s&&c<=0)return s=!0,n(null);i()}}function i(){for(;c<e&&!s;){var t=a();if(null===t)return s=!0,void(c<=0&&n(null));c+=1,r(t.value,t.key,onlyOnce(o))}}if(n=once(n||noop),e<=0||!t)return n(null);var a=iterator(t),s=!1,c=0;i()}}function eachOfLimit(e,t,r,n){_eachOfLimit(t)(e,wrapAsync$1(r),n)}function doLimit(e,t){return function(r,n,o){return e(r,t,n,o)}}function eachOfArrayLike(e,t,r){function n(e,t){e?r(e):++i!==a&&t!==breakLoop||r(null)}r=once(r||noop);var o=0,i=0,a=e.length;for(0===a&&r(null);o<a;o++)t(e[o],o,onlyOnce(n))}function doParallel(e){return function(t,r,n){return e(eachOf,t,wrapAsync$1(r),n)}}function _asyncMap(e,t,r,n){n=n||noop,t=t||[];var o=[],i=0,a=wrapAsync$1(r);e(t,function(e,t,r){var n=i++;a(e,function(e,t){o[n]=t,r(e)})},function(e){n(e,o)})}function doParallelLimit(e){return function(t,r,n,o){return e(_eachOfLimit(r),t,wrapAsync$1(n),o)}}function arrayEach(e,t){for(var r=-1,n=null==e?0:e.length;++r<n&&t(e[r],r,e)!==!1;);return e}function createBaseFor(e){return function(t,r,n){for(var o=-1,i=Object(t),a=n(t),s=a.length;s--;){var c=a[e?s:++o];if(r(i[c],c,i)===!1)break}return t}}function baseForOwn(e,t){return e&&baseFor(e,t,keys)}function baseFindIndex(e,t,r,n){for(var o=e.length,i=r+(n?1:-1);n?i--:++i<o;)if(t(e[i],i,e))return i;return-1}function baseIsNaN(e){return e!==e}function strictIndexOf(e,t,r){for(var n=r-1,o=e.length;++n<o;)if(e[n]===t)return n;return-1}function baseIndexOf(e,t,r){return t===t?strictIndexOf(e,t,r):baseFindIndex(e,baseIsNaN,r)}function arrayMap(e,t){for(var r=-1,n=null==e?0:e.length,o=Array(n);++r<n;)o[r]=t(e[r],r,e);return o}function isSymbol(e){return"symbol"==typeof e||isObjectLike(e)&&baseGetTag(e)==symbolTag}function baseToString(e){if("string"==typeof e)return e;if(isArray(e))return arrayMap(e,baseToString)+"";if(isSymbol(e))return symbolToString?symbolToString.call(e):"";var t=e+"";return"0"==t&&1/e==-INFINITY?"-0":t}function baseSlice(e,t,r){var n=-1,o=e.length;t<0&&(t=-t>o?0:o+t),r=r>o?o:r,r<0&&(r+=o),o=t>r?0:r-t>>>0,t>>>=0;for(var i=Array(o);++n<o;)i[n]=e[n+t];return i}function castSlice(e,t,r){var n=e.length;return r=void 0===r?n:r,!t&&r>=n?e:baseSlice(e,t,r)}function charsEndIndex(e,t){for(var r=e.length;r--&&baseIndexOf(t,e[r],0)>-1;);return r}function charsStartIndex(e,t){for(var r=-1,n=e.length;++r<n&&baseIndexOf(t,e[r],0)>-1;);return r}function asciiToArray(e){return e.split("")}function hasUnicode(e){return reHasUnicode.test(e)}function unicodeToArray(e){return e.match(reUnicode)||[]}function stringToArray(e){return hasUnicode(e)?unicodeToArray(e):asciiToArray(e)}function toString(e){return null==e?"":baseToString(e)}function trim(e,t,r){if(e=toString(e),e&&(r||void 0===t))return e.replace(reTrim,"");if(!e||!(t=baseToString(t)))return e;var n=stringToArray(e),o=stringToArray(t),i=charsStartIndex(n,o),a=charsEndIndex(n,o)+1;return castSlice(n,i,a).join("")}function parseParams(e){return e=e.toString().replace(STRIP_COMMENTS,""),e=e.match(FN_ARGS)[2].replace(" ",""),e=e?e.split(FN_ARG_SPLIT):[],e=e.map(function(e){return trim(e.replace(FN_ARG,""))})}function autoInject(e,t){var r={};baseForOwn(e,function(e,t){function n(t,r){var n=arrayMap(o,function(e){return t[e]});n.push(r),wrapAsync$1(e).apply(null,n)}var o,i=isAsync(e),a=!i&&1===e.length||i&&0===e.length;if(isArray(e))o=e.slice(0,-1),e=e[e.length-1],r[t]=o.concat(o.length>0?n:e);else if(a)r[t]=e;else{if(o=parseParams(e),0===e.length&&!i&&0===o.length)throw new Error("autoInject task functions require explicit parameters.");i||o.pop(),r[t]=o.concat(n)}}),auto(r,t)}function fallback(e){setTimeout(e,0)}function wrap(e){return rest(function(t,r){e(function(){t.apply(null,r)})})}function DLL(){this.head=this.tail=null,this.length=0}function setInitial(e,t){e.length=1,e.head=e.tail=t}function queue(e,t,r){function n(e,t,r){if(null!=r&&"function"!=typeof r)throw new Error("task callback must be a function");if(u.started=!0,isArray(e)||(e=[e]),0===e.length&&u.idle())return setImmediate$1(function(){u.drain()});for(var n=0,o=e.length;n<o;n++){var i={data:e[n],callback:r||noop};t?u._tasks.unshift(i):u._tasks.push(i)}setImmediate$1(u.process)}function o(e){return rest(function(t){a-=1;for(var r=0,n=e.length;r<n;r++){var o=e[r],i=baseIndexOf(s,o,0);i>=0&&s.splice(i),o.callback.apply(o,t),null!=t[0]&&u.error(t[0],o.data)}a<=u.concurrency-u.buffer&&u.unsaturated(),u.idle()&&u.drain(),u.process()})}if(null==t)t=1;else if(0===t)throw new Error("Concurrency must not be zero");var i=wrapAsync$1(e),a=0,s=[],c=!1,u={_tasks:new DLL,concurrency:t,payload:r,saturated:noop,unsaturated:noop,buffer:t/4,empty:noop,drain:noop,error:noop,started:!1,paused:!1,push:function(e,t){n(e,!1,t)},kill:function(){u.drain=noop,u._tasks.empty()},unshift:function(e,t){n(e,!0,t)},process:function(){if(!c){for(c=!0;!u.paused&&a<u.concurrency&&u._tasks.length;){var e=[],t=[],r=u._tasks.length;u.payload&&(r=Math.min(r,u.payload));for(var n=0;n<r;n++){var l=u._tasks.shift();e.push(l),t.push(l.data)}0===u._tasks.length&&u.empty(),a+=1,s.push(e[0]),a===u.concurrency&&u.saturated();var f=onlyOnce(o(e));i(t,f)}c=!1}},length:function(){return u._tasks.length},running:function(){return a},workersList:function(){return s},idle:function(){return u._tasks.length+a===0},pause:function(){u.paused=!0},resume:function(){u.paused!==!1&&(u.paused=!1,setImmediate$1(u.process))}};return u}function cargo(e,t){return queue(e,1,t)}function reduce(e,t,r,n){n=once(n||noop);var o=wrapAsync$1(r);eachOfSeries(e,function(e,r,n){o(t,e,function(e,r){t=r,n(e)})},function(e){n(e,t)})}function concat$1(e,t,r,n){var o=[];e(t,function(e,t,n){r(e,function(e,t){o=o.concat(t||[]),n(e)})},function(e){n(e,o)})}function doSeries(e){return function(t,r,n){return e(eachOfSeries,t,wrapAsync$1(r),n)}}function _createTester(e,t){return function(r,n,o,i){i=i||noop;var a,s=!1;r(n,function(r,n,i){o(r,function(n,o){n?i(n):e(o)&&!a?(s=!0,a=t(!0,r),i(null,breakLoop)):i()})},function(e){e?i(e):i(null,s?a:t(!1))})}}function _findGetResult(e,t){return t}function consoleFunc(e){return rest(function(t,r){wrapAsync$1(t).apply(null,r.concat(rest(function(t,r){"object"==typeof console&&(t?console.error&&console.error(t):console[e]&&arrayEach(r,function(t){console[e](t)}))})))})}function doDuring(e,t,r){function n(e,t){return e?r(e):t?void o(a):r(null)}r=onlyOnce(r||noop);var o=wrapAsync$1(e),i=wrapAsync$1(t),a=rest(function(e,t){return e?r(e):(t.push(n),void i.apply(this,t))});n(null,!0)}function doWhilst(e,t,r){r=onlyOnce(r||noop);var n=wrapAsync$1(e),o=rest(function(e,i){return e?r(e):t.apply(this,i)?n(o):void r.apply(null,[null].concat(i))});n(o)}function doUntil(e,t,r){doWhilst(e,function(){return!t.apply(this,arguments)},r)}function during(e,t,r){function n(e){return e?r(e):void a(o)}function o(e,t){return e?r(e):t?void i(n):r(null)}r=onlyOnce(r||noop);var i=wrapAsync$1(t),a=wrapAsync$1(e);a(o)}function _withoutIndex(e){return function(t,r,n){return e(t,n)}}function eachLimit(e,t,r){eachOf(e,_withoutIndex(wrapAsync$1(t)),r)}function eachLimit$1(e,t,r,n){_eachOfLimit(t)(e,_withoutIndex(wrapAsync$1(r)),n)}function ensureAsync(e){return isAsync(e)?e:initialParams(function(t,r){var n=!0;t.push(function(){var e=arguments;n?setImmediate$1(function(){r.apply(null,e)}):r.apply(null,e)}),e.apply(this,t),n=!1})}function notId(e){return!e}function baseProperty(e){return function(t){return null==t?void 0:t[e]}}function filterArray(e,t,r,n){var o=new Array(t.length);e(t,function(e,t,n){r(e,function(e,r){o[t]=!!r,n(e)})},function(e){if(e)return n(e);for(var r=[],i=0;i<t.length;i++)o[i]&&r.push(t[i]);n(null,r)})}function filterGeneric(e,t,r,n){var o=[];e(t,function(e,t,n){r(e,function(r,i){r?n(r):(i&&o.push({index:t,value:e}),n())})},function(e){e?n(e):n(null,arrayMap(o.sort(function(e,t){return e.index-t.index}),baseProperty("value")))})}function _filter(e,t,r,n){var o=isArrayLike(t)?filterArray:filterGeneric;o(e,t,wrapAsync$1(r),n||noop)}function forever(e,t){function r(e){return e?n(e):void o(r)}var n=onlyOnce(t||noop),o=wrapAsync$1(ensureAsync(e));r()}function mapValuesLimit(e,t,r,n){n=once(n||noop);var o={},i=wrapAsync$1(r);eachOfLimit(e,t,function(e,t,r){i(e,t,function(e,n){return e?r(e):(o[t]=n,void r())})},function(e){n(e,o)})}function has(e,t){return t in e}function memoize(e,t){var r=Object.create(null),n=Object.create(null);t=t||identity;var o=wrapAsync$1(e),i=initialParams(function(e,i){var a=t.apply(null,e);has(r,a)?setImmediate$1(function(){i.apply(null,r[a])}):has(n,a)?n[a].push(i):(n[a]=[i],o.apply(null,e.concat(rest(function(e){r[a]=e;var t=n[a];delete n[a];for(var o=0,i=t.length;o<i;o++)t[o].apply(null,e)}))))});return i.memo=r,i.unmemoized=e,i}function _parallel(e,t,r){r=r||noop;var n=isArrayLike(t)?[]:{};e(t,function(e,t,r){wrapAsync$1(e)(rest(function(e,o){o.length<=1&&(o=o[0]),n[t]=o,r(e)}))},function(e){r(e,n)})}function parallelLimit(e,t){_parallel(eachOf,e,t)}function parallelLimit$1(e,t,r){_parallel(_eachOfLimit(t),e,r)}function race(e,t){if(t=once(t||noop),!isArray(e))return t(new TypeError("First argument to race must be an array of functions"));if(!e.length)return t();for(var r=0,n=e.length;r<n;r++)wrapAsync$1(e[r])(t)}function reduceRight(e,t,r,n){var o=slice.call(e).reverse();reduce(o,t,r,n)}function reflect(e){var t=wrapAsync$1(e);return initialParams(function(e,r){return e.push(rest(function(e,t){if(e)r(null,{error:e});else{var n=null;1===t.length?n=t[0]:t.length>1&&(n=t),r(null,{value:n})}})),t.apply(this,e)})}function reject$1(e,t,r,n){_filter(e,t,function(e,t){r(e,function(e,r){t(e,!r)})},n)}function reflectAll(e){var t;return isArray(e)?t=arrayMap(e,reflect):(t={},baseForOwn(e,function(e,r){t[r]=reflect.call(this,e)})),t}function constant$1(e){return function(){return e}}function retry(e,t,r){function n(e,t){if("object"==typeof t)e.times=+t.times||i,e.intervalFunc="function"==typeof t.interval?t.interval:constant$1(+t.interval||a),e.errorFilter=t.errorFilter;else{if("number"!=typeof t&&"string"!=typeof t)throw new Error("Invalid arguments for async.retry");e.times=+t||i}}function o(){c(function(e){e&&u++<s.times&&("function"!=typeof s.errorFilter||s.errorFilter(e))?setTimeout(o,s.intervalFunc(u)):r.apply(null,arguments)})}var i=5,a=0,s={times:i,intervalFunc:constant$1(a)};if(arguments.length<3&&"function"==typeof e?(r=t||noop,t=e):(n(s,e),r=r||noop),"function"!=typeof t)throw new Error("Invalid arguments for async.retry");var c=wrapAsync$1(t),u=1;o()}function series(e,t){_parallel(eachOfSeries,e,t)}function sortBy(e,t,r){function n(e,t){var r=e.criteria,n=t.criteria;return r<n?-1:r>n?1:0}var o=wrapAsync$1(t);map(e,function(e,t){o(e,function(r,n){return r?t(r):void t(null,{value:e,criteria:n})})},function(e,t){return e?r(e):void r(null,arrayMap(t.sort(n),baseProperty("value")))})}function timeout(e,t,r){function n(){s||(i.apply(null,arguments),clearTimeout(a))}function o(){var t=e.name||"anonymous",n=new Error('Callback function "'+t+'" timed out.');n.code="ETIMEDOUT",r&&(n.info=r),s=!0,i(n)}var i,a,s=!1,c=wrapAsync$1(e);return initialParams(function(e,r){i=r,a=setTimeout(o,t),c.apply(null,e.concat(n))})}function baseRange(e,t,r,n){for(var o=-1,i=nativeMax$1(nativeCeil((t-e)/(r||1)),0),a=Array(i);i--;)a[n?i:++o]=e,e+=r;return a}function timeLimit(e,t,r,n){var o=wrapAsync$1(r);mapLimit(baseRange(0,e,1),t,o,n)}function transform(e,t,r,n){arguments.length<=3&&(n=r,r=t,t=isArray(e)?[]:{}),n=once(n||noop);var o=wrapAsync$1(r);eachOf(e,function(e,r,n){o(t,e,r,n)},function(e){n(e,t)})}function unmemoize(e){return function(){return(e.unmemoized||e).apply(null,arguments)}}function whilst(e,t,r){r=onlyOnce(r||noop);var n=wrapAsync$1(t);if(!e())return r(null);var o=rest(function(t,i){return t?r(t):e()?n(o):void r.apply(null,[null].concat(i))});n(o)}function until(e,t,r){whilst(function(){return!e.apply(this,arguments)},t,r)}var nativeMax=Math.max,initialParams=function(e){return rest(function(t){var r=t.pop();e.call(this,t,r)})},supportsSymbol="function"==typeof Symbol,wrapAsync$1=supportsAsync()?wrapAsync:identity,freeGlobal="object"==typeof global&&global&&global.Object===Object&&global,freeSelf="object"==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function("return this")(),Symbol$1=root.Symbol,objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty,nativeObjectToString=objectProto.toString,symToStringTag$1=Symbol$1?Symbol$1.toStringTag:void 0,objectProto$1=Object.prototype,nativeObjectToString$1=objectProto$1.toString,nullTag="[object Null]",undefinedTag="[object Undefined]",symToStringTag=Symbol$1?Symbol$1.toStringTag:void 0,asyncTag="[object AsyncFunction]",funcTag="[object Function]",genTag="[object GeneratorFunction]",proxyTag="[object Proxy]",MAX_SAFE_INTEGER=9007199254740991,breakLoop={},iteratorSymbol="function"==typeof Symbol&&Symbol.iterator,getIterator=function(e){return iteratorSymbol&&e[iteratorSymbol]&&e[iteratorSymbol]()},argsTag="[object Arguments]",objectProto$3=Object.prototype,hasOwnProperty$2=objectProto$3.hasOwnProperty,propertyIsEnumerable=objectProto$3.propertyIsEnumerable,isArguments=baseIsArguments(function(){return arguments}())?baseIsArguments:function(e){return isObjectLike(e)&&hasOwnProperty$2.call(e,"callee")&&!propertyIsEnumerable.call(e,"callee")},isArray=Array.isArray,freeExports="object"==typeof exports&&exports&&!exports.nodeType&&exports,freeModule=freeExports&&"object"==typeof module&&module&&!module.nodeType&&module,moduleExports=freeModule&&freeModule.exports===freeExports,Buffer=moduleExports?root.Buffer:void 0,nativeIsBuffer=Buffer?Buffer.isBuffer:void 0,isBuffer=nativeIsBuffer||stubFalse,MAX_SAFE_INTEGER$1=9007199254740991,reIsUint=/^(?:0|[1-9]\d*)$/,argsTag$1="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",funcTag$1="[object Function]",mapTag="[object Map]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",setTag="[object Set]",stringTag="[object String]",weakMapTag="[object WeakMap]",arrayBufferTag="[object ArrayBuffer]",dataViewTag="[object DataView]",float32Tag="[object Float32Array]",float64Tag="[object Float64Array]",int8Tag="[object Int8Array]",int16Tag="[object Int16Array]",int32Tag="[object Int32Array]",uint8Tag="[object Uint8Array]",uint8ClampedTag="[object Uint8ClampedArray]",uint16Tag="[object Uint16Array]",uint32Tag="[object Uint32Array]",typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=!0,typedArrayTags[argsTag$1]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag$1]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=!1;var freeExports$1="object"==typeof exports&&exports&&!exports.nodeType&&exports,freeModule$1=freeExports$1&&"object"==typeof module&&module&&!module.nodeType&&module,moduleExports$1=freeModule$1&&freeModule$1.exports===freeExports$1,freeProcess=moduleExports$1&&freeGlobal.process,nodeUtil=function(){try{return freeProcess&&freeProcess.binding("util")}catch(e){}}(),nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray,isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray,objectProto$2=Object.prototype,hasOwnProperty$1=objectProto$2.hasOwnProperty,objectProto$5=Object.prototype,nativeKeys=overArg(Object.keys,Object),objectProto$4=Object.prototype,hasOwnProperty$3=objectProto$4.hasOwnProperty,eachOfGeneric=doLimit(eachOfLimit,1/0),eachOf=function(e,t,r){var n=isArrayLike(e)?eachOfArrayLike:eachOfGeneric;n(e,wrapAsync$1(t),r)},map=doParallel(_asyncMap),applyEach=applyEach$1(map),mapLimit=doParallelLimit(_asyncMap),mapSeries=doLimit(mapLimit,1),applyEachSeries=applyEach$1(mapSeries),apply$2=rest(function(e,t){return rest(function(r){return e.apply(null,t.concat(r))})}),baseFor=createBaseFor(),auto=function(e,t,r){function n(e,t){g.push(function(){s(e,t)})}function o(){if(0===g.length&&0===y)return r(null,p);for(;g.length&&y<t;){var e=g.shift();e()}}function i(e,t){var r=d[e];r||(r=d[e]=[]),r.push(t)}function a(e){var t=d[e]||[];arrayEach(t,function(e){e()}),o()}function s(e,t){if(!m){var n=onlyOnce(rest(function(t,n){if(y--,n.length<=1&&(n=n[0]),t){var o={};baseForOwn(p,function(e,t){o[t]=e}),o[e]=n,m=!0,d=Object.create(null),r(t,o)}else p[e]=n,a(e)}));y++;var o=wrapAsync$1(t[t.length-1]);t.length>1?o(p,n):o(n)}}function c(){for(var e,t=0;h.length;)e=h.pop(),t++,arrayEach(u(e),function(e){0===--b[e]&&h.push(e)});if(t!==f)throw new Error("async.auto cannot execute tasks due to a recursive dependency")}function u(t){var r=[];return baseForOwn(e,function(e,n){isArray(e)&&baseIndexOf(e,t,0)>=0&&r.push(n)}),r}"function"==typeof t&&(r=t,t=null),r=once(r||noop);var l=keys(e),f=l.length;if(!f)return r(null);t||(t=f);var p={},y=0,m=!1,d=Object.create(null),g=[],h=[],b={};baseForOwn(e,function(t,r){if(!isArray(t))return n(r,[t]),void h.push(r);var o=t.slice(0,t.length-1),a=o.length;return 0===a?(n(r,t),void h.push(r)):(b[r]=a,void arrayEach(o,function(s){if(!e[s])throw new Error("async.auto task `"+r+"` has a non-existent dependency `"+s+"` in "+o.join(", "));i(s,function(){a--,0===a&&n(r,t)})}))}),c(),o()},symbolTag="[object Symbol]",INFINITY=1/0,symbolProto=Symbol$1?Symbol$1.prototype:void 0,symbolToString=symbolProto?symbolProto.toString:void 0,rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f\\ufe20-\\ufe23",rsComboSymbolsRange="\\u20d0-\\u20f0",rsVarRange="\\ufe0e\\ufe0f",rsZWJ="\\u200d",reHasUnicode=RegExp("["+rsZWJ+rsAstralRange+rsComboMarksRange+rsComboSymbolsRange+rsVarRange+"]"),rsAstralRange$1="\\ud800-\\udfff",rsComboMarksRange$1="\\u0300-\\u036f\\ufe20-\\ufe23",rsComboSymbolsRange$1="\\u20d0-\\u20f0",rsVarRange$1="\\ufe0e\\ufe0f",rsAstral="["+rsAstralRange$1+"]",rsCombo="["+rsComboMarksRange$1+rsComboSymbolsRange$1+"]",rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier="(?:"+rsCombo+"|"+rsFitz+")",rsNonAstral="[^"+rsAstralRange$1+"]",rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsZWJ$1="\\u200d",reOptMod=rsModifier+"?",rsOptVar="["+rsVarRange$1+"]?",rsOptJoin="(?:"+rsZWJ$1+"(?:"+[rsNonAstral,rsRegional,rsSurrPair].join("|")+")"+rsOptVar+reOptMod+")*",rsSeq=rsOptVar+reOptMod+rsOptJoin,rsSymbol="(?:"+[rsNonAstral+rsCombo+"?",rsCombo,rsRegional,rsSurrPair,rsAstral].join("|")+")",reUnicode=RegExp(rsFitz+"(?="+rsFitz+")|"+rsSymbol+rsSeq,"g"),reTrim=/^\s+|\s+$/g,FN_ARGS=/^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m,FN_ARG_SPLIT=/,/,FN_ARG=/(=.+)?(\s*)$/,STRIP_COMMENTS=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,hasSetImmediate="function"==typeof setImmediate&&setImmediate,hasNextTick="object"==typeof process&&"function"==typeof process.nextTick,_defer;_defer=hasSetImmediate?setImmediate:hasNextTick?process.nextTick:fallback;var setImmediate$1=wrap(_defer);DLL.prototype.removeLink=function(e){return e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev,e.prev=e.next=null,this.length-=1,e},DLL.prototype.empty=DLL,DLL.prototype.insertAfter=function(e,t){t.prev=e,t.next=e.next,e.next?e.next.prev=t:this.tail=t,e.next=t,this.length+=1},DLL.prototype.insertBefore=function(e,t){t.prev=e.prev,t.next=e,e.prev?e.prev.next=t:this.head=t,e.prev=t,this.length+=1},DLL.prototype.unshift=function(e){this.head?this.insertBefore(this.head,e):setInitial(this,e)},DLL.prototype.push=function(e){this.tail?this.insertAfter(this.tail,e):setInitial(this,e)},DLL.prototype.shift=function(){return this.head&&this.removeLink(this.head)},DLL.prototype.pop=function(){return this.tail&&this.removeLink(this.tail)};var eachOfSeries=doLimit(eachOfLimit,1),seq$1=rest(function(e){var t=arrayMap(e,wrapAsync$1);return rest(function(e){var r=this,n=e[e.length-1];"function"==typeof n?e.pop():n=noop,reduce(t,e,function(e,t,n){t.apply(r,e.concat(rest(function(e,t){n(e,t)})))},function(e,t){n.apply(r,[e].concat(t))})})}),compose=rest(function(e){return seq$1.apply(null,e.reverse())}),concat=doParallel(concat$1),concatSeries=doSeries(concat$1),constant=rest(function(e){var t=[null].concat(e);return initialParams(function(e,r){return r.apply(this,t)})}),detect=doParallel(_createTester(identity,_findGetResult)),detectLimit=doParallelLimit(_createTester(identity,_findGetResult)),detectSeries=doLimit(detectLimit,1),dir=consoleFunc("dir"),eachSeries=doLimit(eachLimit$1,1),every=doParallel(_createTester(notId,notId)),everyLimit=doParallelLimit(_createTester(notId,notId)),everySeries=doLimit(everyLimit,1),filter=doParallel(_filter),filterLimit=doParallelLimit(_filter),filterSeries=doLimit(filterLimit,1),groupByLimit=function(e,t,r,n){n=n||noop;var o=wrapAsync$1(r);mapLimit(e,t,function(e,t){o(e,function(r,n){return r?t(r):t(null,{key:n,val:e})})},function(e,t){for(var r={},o=Object.prototype.hasOwnProperty,i=0;i<t.length;i++)if(t[i]){var a=t[i].key,s=t[i].val;o.call(r,a)?r[a].push(s):r[a]=[s]}return n(e,r)})},groupBy=doLimit(groupByLimit,1/0),groupBySeries=doLimit(groupByLimit,1),log=consoleFunc("log"),mapValues=doLimit(mapValuesLimit,1/0),mapValuesSeries=doLimit(mapValuesLimit,1),_defer$1;_defer$1=hasNextTick?process.nextTick:hasSetImmediate?setImmediate:fallback;var nextTick=wrap(_defer$1),queue$1=function(e,t){var r=wrapAsync$1(e);return queue(function(e,t){r(e[0],t)},t,1)},priorityQueue=function(e,t){var r=queue$1(e,t);return r.push=function(e,t,n){if(null==n&&(n=noop),"function"!=typeof n)throw new Error("task callback must be a function");if(r.started=!0,isArray(e)||(e=[e]),0===e.length)return setImmediate$1(function(){r.drain()});t=t||0;for(var o=r._tasks.head;o&&t>=o.priority;)o=o.next;for(var i=0,a=e.length;i<a;i++){var s={data:e[i],priority:t,callback:n};o?r._tasks.insertBefore(o,s):r._tasks.push(s)}setImmediate$1(r.process)},delete r.unshift,r},slice=Array.prototype.slice,reject=doParallel(reject$1),rejectLimit=doParallelLimit(reject$1),rejectSeries=doLimit(rejectLimit,1),retryable=function(e,t){t||(t=e,e=null);var r=wrapAsync$1(t);return initialParams(function(t,n){function o(e){r.apply(null,t.concat(e))}e?retry(e,o,n):retry(o,n)})},some=doParallel(_createTester(Boolean,identity)),someLimit=doParallelLimit(_createTester(Boolean,identity)),someSeries=doLimit(someLimit,1),nativeCeil=Math.ceil,nativeMax$1=Math.max,times=doLimit(timeLimit,1/0),timesSeries=doLimit(timeLimit,1),waterfall=function(e,t){function r(o){if(n===e.length)return t.apply(null,[null].concat(o));var i=onlyOnce(rest(function(e,n){return e?t.apply(null,[e].concat(n)):void r(n)}));o.push(i);var a=wrapAsync$1(e[n++]);a.apply(null,o)}if(t=once(t||noop),!isArray(e))return t(new Error("First argument to waterfall must be an array of functions"));if(!e.length)return t();var n=0;r([])},index={applyEach:applyEach,applyEachSeries:applyEachSeries,apply:apply$2,asyncify:asyncify,auto:auto,autoInject:autoInject,cargo:cargo,compose:compose,concat:concat,concatSeries:concatSeries,constant:constant,detect:detect,detectLimit:detectLimit,detectSeries:detectSeries,dir:dir,doDuring:doDuring,doUntil:doUntil,doWhilst:doWhilst,during:during,each:eachLimit,eachLimit:eachLimit$1,eachOf:eachOf,eachOfLimit:eachOfLimit,eachOfSeries:eachOfSeries,eachSeries:eachSeries,ensureAsync:ensureAsync,every:every,everyLimit:everyLimit,everySeries:everySeries,filter:filter,filterLimit:filterLimit,filterSeries:filterSeries,forever:forever,groupBy:groupBy,groupByLimit:groupByLimit,groupBySeries:groupBySeries,log:log,map:map,mapLimit:mapLimit,mapSeries:mapSeries,mapValues:mapValues,mapValuesLimit:mapValuesLimit,mapValuesSeries:mapValuesSeries,memoize:memoize,nextTick:nextTick,parallel:parallelLimit,parallelLimit:parallelLimit$1,priorityQueue:priorityQueue,queue:queue$1,race:race,reduce:reduce,reduceRight:reduceRight,reflect:reflect,reflectAll:reflectAll,reject:reject,rejectLimit:rejectLimit,rejectSeries:rejectSeries,retry:retry,retryable:retryable,seq:seq$1,series:series,setImmediate:setImmediate$1,some:some,someLimit:someLimit,someSeries:someSeries,sortBy:sortBy,timeout:timeout,times:times,timesLimit:timeLimit,timesSeries:timesSeries,transform:transform,unmemoize:unmemoize,until:until,waterfall:waterfall,whilst:whilst,all:every,any:some,forEach:eachLimit,forEachSeries:eachSeries,forEachLimit:eachLimit$1,forEachOf:eachOf,forEachOfSeries:eachOfSeries,forEachOfLimit:eachOfLimit,inject:reduce,foldl:reduce,foldr:reduceRight,select:filter,selectLimit:filterLimit,selectSeries:filterSeries,wrapSync:asyncify};exports.default=index,exports.applyEach=applyEach,exports.applyEachSeries=applyEachSeries,exports.apply=apply$2,exports.asyncify=asyncify,exports.auto=auto,exports.autoInject=autoInject,exports.cargo=cargo,exports.compose=compose,exports.concat=concat,exports.concatSeries=concatSeries,exports.constant=constant,exports.detect=detect,exports.detectLimit=detectLimit,exports.detectSeries=detectSeries,exports.dir=dir,exports.doDuring=doDuring,exports.doUntil=doUntil,exports.doWhilst=doWhilst,exports.during=during,exports.each=eachLimit,exports.eachLimit=eachLimit$1,exports.eachOf=eachOf,exports.eachOfLimit=eachOfLimit,exports.eachOfSeries=eachOfSeries,exports.eachSeries=eachSeries,exports.ensureAsync=ensureAsync,exports.every=every,exports.everyLimit=everyLimit,exports.everySeries=everySeries,exports.filter=filter,exports.filterLimit=filterLimit,exports.filterSeries=filterSeries,exports.forever=forever,exports.groupBy=groupBy,exports.groupByLimit=groupByLimit,exports.groupBySeries=groupBySeries,exports.log=log,exports.map=map,exports.mapLimit=mapLimit,exports.mapSeries=mapSeries,exports.mapValues=mapValues,exports.mapValuesLimit=mapValuesLimit,exports.mapValuesSeries=mapValuesSeries,exports.memoize=memoize,exports.nextTick=nextTick,exports.parallel=parallelLimit,exports.parallelLimit=parallelLimit$1,exports.priorityQueue=priorityQueue,exports.queue=queue$1,exports.race=race,exports.reduce=reduce,exports.reduceRight=reduceRight,exports.reflect=reflect,exports.reflectAll=reflectAll,exports.reject=reject,exports.rejectLimit=rejectLimit,exports.rejectSeries=rejectSeries,exports.retry=retry,exports.retryable=retryable,exports.seq=seq$1,exports.series=series,exports.setImmediate=setImmediate$1,exports.some=some,exports.someLimit=someLimit,exports.someSeries=someSeries,exports.sortBy=sortBy,exports.timeout=timeout,exports.times=times,exports.timesLimit=timeLimit,exports.timesSeries=timesSeries,exports.transform=transform,exports.unmemoize=unmemoize,exports.until=until,exports.waterfall=waterfall,exports.whilst=whilst,exports.all=every,exports.allLimit=everyLimit,exports.allSeries=everySeries,exports.any=some,exports.anyLimit=someLimit,exports.anySeries=someSeries,exports.find=detect,exports.findLimit=detectLimit,exports.findSeries=detectSeries,exports.forEach=eachLimit,exports.forEachSeries=eachSeries,exports.forEachLimit=eachLimit$1,exports.forEachOf=eachOf,exports.forEachOfSeries=eachOfSeries,exports.forEachOfLimit=eachOfLimit,exports.inject=reduce,exports.foldl=reduce,exports.foldr=reduceRight,exports.select=filter,exports.selectLimit=filterLimit,exports.selectSeries=filterSeries,exports.wrapSync=asyncify,Object.defineProperty(exports,"__esModule",{value:!0})});
//# sourceMappingURL=async.min.map
var NavBar = function (appTitle, path, category, color) {
    this.displayName = appTitle;
    this.user = null;
    this.category = category;
    if (this.category) {
        this.category = this.category.toUpperCase();
    }
    var loginBox = $('#header-login');

    if (scarpa.isLoggedIn()) {
        this.user = clue.getUserInfo().shortName;
        loginBox.addClass('header-pop-down');
        loginBox.css('color', '');

        loginBox.text(this.user);
        $('#header-pop-down').show();
    }
    else {
        loginBox.css('color', 'white');

        loginBox.text('Log in');
        loginBox.css('background-color', '#F15A22');
    }

    var headerAppTitle = $('#header-app-title');
    headerAppTitle.text(this.displayName);
    headerAppTitle.on("click", function () {
        window.location = path;
    });
    //refactor this, have color in database and use it here
    $("#header-app-title").css("color", color);
    headerAppTitle.attr('data-app-title', this.displayName);
};

//toggles visibility of popover tooltips
$(document).on('click', ".tooltip_trigger", function (e) {
    if ($('[aria-describedby]').length) {
        $('[aria-describedby]').each(function (i, el) {
            $(this).popover('hide');
        });
    }
    var target_elem = $(this);
    var event_id = "#" + target_elem.attr("id");
    var popover_config = $(event_id).data("popover-config");

    if (0 === _.size(popover_config)) {
        return;
    }
    //TODO convert popover_config to JSON
    _.each(popover_config, function (config) {

        var target_id = "#" + config.target_id;
        if ($(target_id).attr("aria-describedby")) {
            console.log("POP 2");
            $(target_id).popover("hide");
        }
        else {
            console.log("POP 3 " + config.content_id);
            var content = $("#" + config.content_id).html();
            var placement = config.placement;
            var viewport = config.viewport || "body";
            var data = {
                html: true,
                content: content,
                placement: placement,
                trigger: 'manual',
                viewport: viewport
            };

            var add_class = null;

            if ($(event_id).data("tooltip-class") === "coaching_tips" || $(event_id).data("tooltip-class") === "header_announcements") {
                var css_class = $(event_id).data("tooltip-class");
                var template = '<div class="popover ' + css_class + '" role="tooltip"><div class="arrow"></div><div class="popover-content ' + css_class + '_text"></div></div>';
                data.template = template;
            }
            else if($(event_id).data("tooltip-class"))
            {
                add_class = $(event_id).data("tooltip-class");
            }
            $(target_id).popover(data);
            $(target_id).popover('show');
            if(add_class)
            {
                $(".popover").addClass(add_class);
            }
        }

    });
});
/**
 * Created by turner on 5/6/16.
 */
var scarpa = (function (scarpa) {

    scarpa.dispatch = d3.dispatch(

        // TSTable notifications
        "tstable_did_show_all_rows",
        "tstable_did_update_checkbox",
        "tstable_did_update_row_counter",
        "tstable_did_click_row",

        // Facet notifications
        "did_change_cmap_class_facet",
        "did_change_perturbagen_facet",
        "did_disable_data_lens_facet",
        "did_select_oe_kd_facet",
        "did_select_cell_line_specificity_facet",

        // FilterChain evaluation notification
        "do_evaluate_filter_chain"

    );

    return scarpa;
})(scarpa || {});

var APP_TOOLS_TYPE = "Tools";
var APP_UTILITY_TYPE = "Utility";
var APP_WORKBENCH_TYPE = "Workbench";
var APP_REFERENCE_TYPE = "Reference";
var APP_DEVELOPER_TYPE = "For Developers";

var addAppTo = function(appsElt,appUrl,appTitle,hoverText) {
    appsElt.append($('<div/>', { 'class' : 'row'}));
    var appLink = $('<a/>',{
        'class' : "col-xs-6 app-link-text",
        'href' : appUrl,
        'text' : appTitle
    });
    if (hoverText) {
        appLink.attr('title',hoverText);
    }
    var icon;
    if (appTitle === 'API') {
        appLink.prepend('<i class="fa fa-cogs" aria-hidden="true">&nbsp;</i>');
    }
    else if (appTitle === 'Code') {
        appLink.prepend('<i class="fa fa-code" aria-hidden="true">&nbsp;</i>');
    }
    appsElt.children().last().append(appLink);
};

var isMenuVisible = function() {
    return $('#hero-menu-modal').is(":visible");
};

var compare = function (a,b) {
    var at = a.display_order;
    var bt = b.display_order;
    if((at && !bt) || (!at && bt))
    {
        return 1;
    }
    if(!at && !bt)
    {
        return 0;
    }
    if (at < bt)
        return -1;
    if (at > bt)
        return 1;
    return 0;
}

var showMenu = function(focusOnApps) {
    var menuModal = $('#hero-menu-modal');
    var appsElt = $('#Apps');
    var appsArea = $('#AppsList');
    var utilAppsElt = $('#UtilityApps');
    var referenceApsElt = $('#ReferenceApps');
    var developerAppsElt = $('#DeveloperApps');
    var elementToFocusOn;
    var hotkeyHint =  ' to open menu';
    if (morpheus.Util.IS_MAC) {
        hotkeyHint = 'command-k' + hotkeyHint;
    }
    else {
        hotkeyHint = 'ctrl-k' + hotkeyHint;
    }
    $('#menu-hotkey-hint').text(hotkeyHint);

    var isLoggedIn = scarpa.isLoggedIn();
    if (isLoggedIn) {
        $('.login-section').hide();
        clue.getUserKey(function (key,err) {

            clue.getApps(function(err, result){

                if (err) {
                    console.log('getApps - error');
                }

                else
                {
                    developerAppsElt.empty();
                    referenceApsElt.empty();
                    appsElt.empty();
                    utilAppsElt.empty();
                    appsElt.append($('<div/>',{'text' : 'Analysis'}));
                    var analysisAppsElt = $('<div/>',{'class' : 'row'},{'class' : 'analysis-apps'});
                    analysisAppsElt.empty();
                    appsElt.children().last().append(analysisAppsElt);

                    var cards = [];
                    if (result.cards) {
                        cards = result.cards;
                        cards.sort(compare);
                    }

                    async.each(cards, function(card, callback) {
                        //var card = cards[appIndex];
                        var tagLine = card['tag-line'] || "-";
                        var hoverText = card.description;
                        var appTitle = card.title;
                        var appUrl = card.url;
                        var iconUrl = '/' + card.icon_url;
                        var appCategory = card.category;

                        if (appCategory === APP_TOOLS_TYPE) {
                            var appIcon = $('<img/>', {
                                'src': iconUrl
                            });

                            var appElt = $('<div/>', {'class': 'col-xs-12 hero-menu-app-with-icon'});

                            var appLink = $('<a/>', {
                                'href': appUrl,
                                'class': "click-me"
                            });

                            appLink.append(appIcon);
                            var appText = $('<div/>', {
                                'class': 'app-title col-xs-11 app-link-text',
                                'text': appTitle,
                                'style': 'padding-right:0;'
                            });
                            appText.append('<br/><div class="modal-form-copy" style="color:#8c8c8c;">' + tagLine + '</div>');
                            appLink.append(appText);
                            var appInfoCircle = '<i class="fa fa-info-circle col-xs-1" data-toggle="tooltip" data-placement="left" title="' + hoverText + '" aria-hidden="true" style="align-content: flex-end;color:#2c8fae;padding-left:0;"></i>';

                            appLink.append(appInfoCircle);

                            appElt.append(appLink);


                            analysisAppsElt.append(appElt);

                            if (!elementToFocusOn) {
                                elementToFocusOn = appLink;
                            }
                            callback();
                        }
                        else if (appCategory === APP_UTILITY_TYPE) {
                            addAppTo(utilAppsElt, appUrl, appTitle, hoverText);
                            callback();
                        }
                        else if (appCategory === APP_REFERENCE_TYPE) {
                            addAppTo(referenceApsElt, appUrl, appTitle, hoverText);
                            callback();
                        }
                        else if (appCategory === APP_DEVELOPER_TYPE) {
                            addAppTo(developerAppsElt, appUrl, appTitle, hoverText);
                            callback();
                        }
                        else{
                            callback();
                        }
                    }, function(err) {
                        // if any of the file processing produced an error, err would equal that error
                        if( err ) {
                            // One of the iterations produced an error.
                            // All processing will now stop.
                            console.error('Issue found with an APP List: ' + err);
                        }
                        $('[data-toggle="tooltip"]').tooltip({'delay':1});

                        appsArea.show();
                        menuModal.modal('show');

                        var tabIndexOfApp = 1;
                        var tabIndexOrderedAppLinks = [analysisAppsElt,referenceApsElt,utilAppsElt,developerAppsElt];
                        $.each(tabIndexOrderedAppLinks,(function(index,appsBlock) {
                            $(appsBlock).children().each(function() {
                                var appLink = $(this);
                                appLink.attr('tabindex',tabIndexOfApp++);
                            });
                        }));

                        if (focusOnApps) {
                            if (elementToFocusOn) {
                                elementToFocusOn.focus();
                            }
                        }
                    });
                }
            });
        });
    }
    else {
        appsArea.hide();
        $('.login-section').show();
        $('.loginFromMenuModal').on('click',function(evt) {
            evt.preventDefault();
            // close modal, pop up login, then have login return to here
            menuModal.modal('hide');
            loadMenuAfterLogin = true;
            $loginModal.modal('show');

        });
        menuModal.modal('show');
    }
};

$(window).keydown(function (e){
    var commandKey = morpheus.Util.IS_MAC ? e.metaKey : e.ctrlKey;
    if (commandKey && e.which === 75) {
        if (!isMenuVisible() && $('body.modal-open').length === 0) {
            showMenu(true);
        }
    }
});


var $loginModal = $('#loginModal');

var $logoutForm = $('#logout-form');
var $logoutTitle = $('#logout-title');

var $loginForm = $('#login-form');
var $loginTitle = $('#login-title');

var $settingsTitle = $('#settings-title');
var $settingsForm = $('#settings-form');

var $forgotPasswordTitle = $('#forgot-password-title');
var $forgotPasswordForm = $('#forgot-password-form');
var $accountActivatedTitle = $('#account-activated-title');

var $signUpTitle = $('#signup-title');
var $signUpForm = $('#signup-form');

var $accountCreationTitle = $('#account-creation-success-title');
var $otherAcademicTrainingCheckbox = $('#other');

var academicTrainingErrorsElt = $('#academicTrainingErrors');

var $otherAcademicTrainingTextInput = $('#other-academicTraining');

var $researchRoles = $('#researchRoles');
var $academicTraining = $('#academicTraining');
var hasLoadedResearchRoles = false;
var hasDeterminedAttestationRequirements = false;
var hasLoadedAcademicTraining = false;

var forms = [$logoutForm, $loginForm, $forgotPasswordForm, $signUpForm, $settingsForm];
var titles = [$logoutTitle, $loginTitle, $forgotPasswordTitle, $signUpTitle, $accountActivatedTitle, $settingsTitle, $accountCreationTitle];

var next;
var loadMenuAfterLogin = false;

var validatorOptions = {'disable': false};

var hideAllFormsAndTitles = function () {
    _.each(forms, function ($form) {
        $form.hide();
    });
    _.each(titles, function ($title) {
        $title.hide();
    });
};

$loginModal.on('show.bs.modal', function (e) {
    _.each(forms, function ($form) {
        $form.hide();
    });
    _.each(titles, function ($title) {
        $title.hide();
    });

    $loginTitle.show();
    $loginForm.show();

    if (!hasDeterminedAttestationRequirements) {
        determineNonProfitAttestionRequirements();
    }
    if (!hasLoadedResearchRoles) {
        loadResearchRoles();
    }
    if (!hasLoadedAcademicTraining) {
        loadAcademicTraining();
    }
});

var loadAcademicTraining = function () {
    hasLoadedAcademicTraining = true;
    hasLoadedResearchRoles = true;
    var at = clue.getAcademicTraining(function (error, data) {});
    at.done(function(data){
        $academicTraining.empty();
        data.forEach(function (role, index) {
            var roleId = 'AcademicTraining' + index;
            var roleValue = role.name;
            var roleName = role.name;
            var checkbox = '<input id="' + roleId + '" type="checkbox" value="' + roleValue + '" name="academicTraining">&nbsp;' + roleName;
            var option = '<div class="modal-form-copy"><label for="' + roleId + '" class="light-text">' + checkbox + '</label></div>';
            $academicTraining.append(option);
        });
        $academicTraining.find('input[type="checkbox"]').on('click', function (evt) {
            validateAcademicTraining();
        });
    }).fail(function(error){
        console.error('Could not find research roles due to: ' + error);
    });
};

var loadResearchRoles = function () {
    hasLoadedResearchRoles = true;
    var rr = clue.getResearchRoles(function (error, data) {});
    rr.done(function(data){
        $researchRoles.empty();
        data.forEach(function (role, index) {
            var roleId = 'ResearchRole' + index;
            var roleValue = role.name;
            var roleName = role.name;
            var checkbox = '<input id="' + roleId + '" type="radio" value="' + roleValue + '" name="research-role-group" data-error="Please select one" required="">&nbsp;' + roleName;
            var option = '<div class="modal-form-copy"><label for="' + roleId + '" class="light-text">' + checkbox + '</label></div>';
            $researchRoles.append(option);
        });
    }).fail(function(error){
        console.error('Could not find research roles due to: ' + error);
    });
};

var determineNonProfitAttestionRequirements = function () {
    hasDeterminedAttestationRequirements = true;
    //TODO: cache

    clue.getServerInfo(function(error,data){
        if(error){
            console.error('Could not determine installation type due to: ' + error);
            return;
        }
        var requireAttestation = ('public' === data.organization);
        var nonProfitAttestationElt = $('#nonProfitAttestation');
        if (requireAttestation) {
            nonProfitAttestationElt.prop('required', true);
            nonProfitAttestationElt.show();
        }
        else {
            nonProfitAttestationElt.prop('required', false);
            nonProfitAttestationElt.hide();
        }
    });
};

$('#institution').typeahead({
    name: 'institutions',
    limit: 10,
    remote: {
        'url': clue.autoCompleteInstituteUrl() + '?q=%QUERY',
        'filter': function (parsedResponse) {
            var datums = [];
            parsedResponse.forEach(function (o) {
                var institute = o.institute;
                datums.push({
                    'value': institute,
                    'tokens': institute
                })
            });
            return datums;
        }
    }
});

$loginForm.find('[name=forgot]').on('click', function (e) {
    e.preventDefault();
    _.each(forms, function ($form) {
        $form.hide();
    });
    _.each(titles, function ($title) {
        $title.hide();
    });
    $forgotPasswordTitle.show();
    $forgotPasswordForm.show();

});

$loginForm.find('[name=create-account]').on('click', function (e) {
    e.preventDefault();
    _.each(forms, function ($form) {
        $form.hide();
    });
    _.each(titles, function ($title) {
        $title.hide();
    });
    $signUpTitle.show();
    $signUpForm.show();
});

hideLoginModal = function () {
    $loginForm.find('[name=messageText]').text('');
    $loginForm.find('[name=messageGroup]').hide();
    $loginModal.modal('hide');
    $loginTitle.hide();
    $loginForm.hide();
};

$loginForm.validator(validatorOptions).on('submit', function (e) {
    var returnTo = $('#returnTo').val();

    if (e.isDefaultPrevented()) {
        // handle the invalid form...
    } else {
        e.preventDefault();
        // everything looks good!
        $.ajax({
            url: '/signin',
            method: 'POST',
            data: {
                email: $loginForm.find('[name=email]').val().toLowerCase(),
                password: $loginForm.find('[name=password]').val(),
                returnTo: returnTo
            }
        })
            .done(
                function (r) {
                    if (r.api_key) {
                        clue.USER_KEY = r.api_key;
                    }
                    if (r.returnTo && r.user_id) {
                        $('#header-login').trigger('clue-login', [r.user_name]);
                        document.location.href = r.returnTo;
                        hideLoginModal();
                    }
                    else if (r.user_id) {
                        $('#header-login').trigger('clue-login', [r.user_name]);
                        // see if 2 factor auth is required
                        scarpa.appLaunch();

                        if (r.twofactorRequired) {
                            document.location.href = '/login-otp';
                        }
                        else {

                            if (typeof CLUE_ORIGINAL_URL !== 'undefined' && '/api_config' !== CLUE_ORIGINAL_URL && '/settings' !== CLUE_ORIGINAL_URL) {
                                document.location.href = CLUE_ORIGINAL_URL;
                            }
                            else if (next != null) {
                                document.location.href = next;
                            }
                            else if (loadMenuAfterLogin) {
                                showMenu();
                            }
                            hideLoginModal();
                        }

                    } else {
                        $loginForm.find('[name=messageText]').text('The email address or password you entered is incorrect. Please try again or create an account.');
                        $loginForm.find('[name=messageGroup]').show();
                    }
                    populateToolsAndMainMenu();

                })
            .fail(
                function (err) {
                    $loginForm.find('[name=messageText]').text("We are unable to process your request at this time. If you are still unable to perform this action after a few tries please contact clue@broadinstitute.org");
                    $loginForm.find('[name=messageGroup]').show();
                });

    }
});

var clearAcademicTrainingErrors = function () {
    academicTrainingErrorsElt.text('');
    academicTrainingErrorsElt.hide();
};

var showAcademicTrainingError = function (errorText) {
    academicTrainingErrorsElt.text(errorText);
    academicTrainingErrorsElt.show();
};

$otherAcademicTrainingCheckbox.change(function () {
    if (this.checked) {
        $otherAcademicTrainingTextInput.show();
    }
    else {
        $otherAcademicTrainingTextInput.hide();
        clearAcademicTrainingErrors();
    }
});

var validateAcademicTraining = function () {
    clearAcademicTrainingErrors();
    var academicTraining = $('input[name="academicTraining"]:checked').map(function () {
        return $(this).val();
    }).get();

    var hasOtherAcademicTraining = academicTraining.indexOf('other') > -1;
    if (hasOtherAcademicTraining) {
        var academicTrainingText = $('#other-academicTraining').val();
        if (academicTrainingText.trim().length == 0) {
            showAcademicTrainingError('Please specify your academic training');
            return false;
        }
    }
    if (academicTraining.length == 0) {
        showAcademicTrainingError('Please choose one or more options');
        return false;
    }
    return true;
};

var getAcademicTraining = function () {
    var academicTraining = [];

    $('input[name="academicTraining"]:checked').map(function () {
        academicTraining.push($(this).val());
    });

    var customAcademicTraining = $otherAcademicTrainingTextInput.val();
    if (customAcademicTraining) {
        if (customAcademicTraining.trim().length > 0) {
            academicTraining.push(customAcademicTraining);
        }
    }
    return academicTraining;
};

returnToLoginModal = function (evt) {
    evt.preventDefault();
    $signUpForm.hide();
    $loginForm.show();
};

showEmailAlreadyUsed = function (inputField) {
    var parent = inputField.parent();
    parent.addClass('has-error');
    if ($('#emailErrors').children().length === 0) {
        $('#emailErrors').append('<ul class="list-unstyled"><li>Email address already in use.  <a id="login_from_email">Login with existing account</a></li></ul>');
        $('#login_from_email').on('click', function (evt) {
            returnToLoginModal(evt);
        });
    }
};

showEmailNotRecognized = function (emailField) {
    var emailAddress = emailField.val().toLowerCase().split("@")[1];
    var parent = emailField.parent();
    parent.addClass('has-error');
    if ($('#emailErrors').children().length === 0) {
        $('#emailErrors').append('<ul class="list-unstyled"><li>' + emailAddress + ' is not from a recognized academic or non-profit organization, please try again or email clue@broadinstitute.org for help.</li></ul>');
        $('#login_from_email').on('click', function (evt) {
            returnToLoginModal(evt);
        });
    }
};

removeEmailAlreadyUsed = function (inputField) {
    $('#emailErrors').children().remove();
    inputField.parent().removeClass('has-error');
};

removeEmailNotRecognized = function (callback) {
    $('#messageText').text("");
    return callback();
};

disableInstitutionEntry = function () {
    var institutionElt = $('#institution');
    institutionElt.css('background-color', '#f5f5f5');
    institutionElt.attr('disabled', 'disabled');
    var attestationElt = $('#nonProfitAttestation');
    attestationElt.prop('required', false);
    attestationElt.hide();
};

enableInstitutionEntry = function () {
    var institutionElt = $('#institution');
    institutionElt.css('background-color', '');
    institutionElt.removeAttr('disabled');
    var attestationElt = $('#nonProfitAttestation');
    attestationElt.prop('required', true);
    attestationElt.show();
};

clearInstitutionSelection = function () {
    $('#institution').val('');
};

setInstitution = function (institutionText) {
    $('#institution').val(institutionText);
    $('#institutionErrors').children().remove();
    $('#instituteEntry').removeClass('has-error');
};

checkEmail = function (callback) {
    var emailInput = $("#email");
    var emailAddress = emailInput.val().toLowerCase();
    clue.userExists(emailAddress)
        .done(function (data) {
            if (data.exists) {
                showEmailAlreadyUsed(emailInput);
                return callback("User already exists");
            }
            else {
                removeEmailAlreadyUsed(emailInput);
                if (emailAddress) {
                    var output = clue.isDomainOnWhitelist(emailInput.val());
                    output.done(function (results) {
                        if (!(results.exists)) {
                            showEmailNotRecognized(emailInput);
                            return callback("Email not recognized");
                        }
                        else {
                            return callback();
                        }
                    })
                }
                else {
                    return callback();
                }
            }
        })
        .fail(function (jqXHR, textStatus, errorThrown) {
            var error = 'Could not lookup email due to ' + JSON.stringify(errorThrown);
            console.error(error);
            return callback(error);
        });
};

// $signUpForm.on('validated.bs.validator',function(evt) {
//     //console.log("TRIGGERED");
//     if ('email'===evt.relatedTarget.id) {
//         checkEmail();
//         removeEmailNotRecognized();
//     }
// });

function guessInstitution(emailAddress, callback) {
    var guessedInstitution;
    clue.guessInstitutionFromEmail(emailAddress)
        .done(function (data) {
            if (data) {
                if (data.institute) {
                    guessedInstitution = data.institute;
                    setInstitution(guessedInstitution);
                    disableInstitutionEntry();
                }
            }
            if (!guessedInstitution) {
                clearInstitutionSelection();
                enableInstitutionEntry();
            }
            return callback();
        })
        .fail(function (jqXHR, textStatus, errorThrown) {
            clearInstitutionSelection();
            enableInstitutionEntry();
            var error = null;
            if (jqXHR.status !== 200) {
                error = 'Could not infer institute via email due to ' + JSON.stringify(errorThrown);
                console.log(error);
            }
            return callback(error);
        });
}

$signUpForm.find('[id=email]').on('change', function (evt) {
    var target = $(evt.target);
    //callback
    checkEmail(function (error) {
        removeEmailNotRecognized(function (error) {
            var emailAddress = $(evt.target).val();
            guessInstitution(emailAddress, function (error) {
            });
        });
    });
});

$signUpForm.find('[id=return_to_login]').on('click', function (evt) {
    returnToLoginModal(evt);
});

var showSignupSuccess = function (successMessage) {
    $('#success-message-from-server').text(successMessage);
    $accountCreationTitle.show();
};

$signUpForm.validator(validatorOptions).on('submit', function (e) {
    var hasError = e.isDefaultPrevented();
    e.preventDefault();

    var academicTraining,
        inputValues;

    var hasChosenAcademicTraining = validateAcademicTraining();
    var affiliation = $('#institution').val();
    if (hasChosenAcademicTraining) {
        academicTraining = getAcademicTraining();
    }
    else {
        hasError = true;
    }

    if (!affiliation) {
        hasError = true;
    }

    if ($('#emailErrors').children().length > 0) {
        $('#email').parent().addClass('has-error');
    }

    if (!hasError) {
        $signUpForm.find('[name=messageText]').text('');

        inputValues = {
            'email': $signUpForm.find('[name=email]').val().toLowerCase(),
            'password': $signUpForm.find('[name=password]').val(),
            'institution': affiliation,
            'firstName': $signUpForm.find('[name=firstName]').val(),
            'lastName': $signUpForm.find('[name=lastName]').val(),
            'academicTraining': academicTraining,
            'researchRole': $signUpForm.find('[name=research-role-group]:checked').val()
        };

        $.ajax({
            url: '/register',
            method: 'POST',
            data: inputValues
        }).done(function (data) {
            if (data.error) {
                var emailInput = $('#email');
                if (data.errorCode == 'email_already_used') {
                    showEmailAlreadyUsed(emailInput);
                }
                else {
                    removeEmailAlreadyUsed(emailInput);
                    $signUpForm.find('[name=messageText]').text(data.error);
                    $signUpForm.find('[name=messageGroup]').show();
                }
            } else {
                hideAllFormsAndTitles();
                showSignupSuccess(data.message);
                //$signUpForm.find('[name=messageText]').text(data.message);
                //$signUpForm.find('[name=messageGroup]').show();
            }
        }).fail(
            function (err) {
                $signUpForm.find('[name=messageText]').text("We are unable to process your request at this time. If you are still unable to perform this action after a few tries please contact clue@broadinstitute.org");
                $signUpForm.find('[name=messageGroup]').show();
            });

    }
});

$forgotPasswordForm.find('[name=create-account]').on('click', function (e) {
    e.preventDefault();
    _.each(forms, function ($form) {
        $form.hide();
    });
    _.each(titles, function ($title) {
        $title.hide();
    });
    $signUpTitle.show();
    $signUpForm.show();
});

$logoutForm.find('[name=settings]').on('click', function (e) {
    e.preventDefault();
    hideAllFormsAndTitles();
    clue.getSettings(function (err, result) {$('#setting_institution').html('<strong>Institution: </strong>' + result.institution);
        $('#setting_email').html('<strong>Email: </strong>' + result.email);
        $('#apiKey').html('<strong>API KEY: </strong>' + result.apiKey);
        $('#roles').html('<strong>Roles: </strong>' + result.roles);
        $settingsTitle.show();
        $settingsForm.show();});
});

$settingsForm.find('[name=ok]').on('click', function (e) {
    e.preventDefault();
    hideAllFormsAndTitles();
    $settingsForm.hide();
    $logoutTitle.show();
    $logoutForm.show();
});

$forgotPasswordForm.validator(validatorOptions);

$forgotPasswordForm.on('submit', function (e) {
    e.preventDefault();
    var hasValidEmail = !$forgotPasswordForm.find('[name=email]').parent().hasClass('has-error');
    var email = $forgotPasswordForm.find('[name=email]').val().toLowerCase();
    var $this = $(this);

    if (hasValidEmail) {
        $.ajax({
            url: '/password_reset',
            method: 'POST',
            data: {
                'email': email
            }
        })
            .done(function (data) {
                $forgotPasswordForm.find('[name=messageText]').text('');
                if (data.error) {
                    $forgotPasswordForm.find('[name=messageText]').text(data.error);
                    $forgotPasswordForm.find('[name=messageGroup]').show();
                } else {
                    $forgotPasswordForm.find('[id=forgotEmailText]').text(data.message);
                    $forgotPasswordForm.find('[name=passwordEmailSuccess]').show();
                    $forgotPasswordForm.find('[name=messageGroup]').hide();
                    $forgotPasswordForm.find('[id=resetEmail]').hide();
                    $forgotPasswordForm.find('[id=resetEmailSubmit]').hide();
                    $forgotPasswordForm.find('[id=resetPasswordCreateAccount]').hide();
                    $('#forgotPasswordInstructions').hide();
                }
            }).fail(
            function (err) {
                $forgotPasswordForm.find('[name=messageText]').text("We were unable to find your email. If you have an existing account and are still unable to perform this action after a few tries please contact clue@broadinstitute.org");
                $forgotPasswordForm.find('[name=messageGroup]').show();
            }
        );
    }
});
